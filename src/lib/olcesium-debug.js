// Ol-Cesium. See https://github.com/openlayers/ol-cesium/
// License: https://github.com/openlayers/ol-cesium/blob/master/LICENSE
// Version: v1.35-29-g071c090

'use strict';
var $jscomp = $jscomp || {};
$jscomp.scope = {};
$jscomp.ASSUME_ES5 = false;
$jscomp.ASSUME_NO_NATIVE_MAP = false;
$jscomp.ASSUME_NO_NATIVE_SET = false;
$jscomp.defineProperty = $jscomp.ASSUME_ES5 || typeof Object.defineProperties == "function" ? Object.defineProperty : function(target, property, descriptor) {
  descriptor = descriptor;
  if (target == Array.prototype || target == Object.prototype) {
    return;
  }
  target[property] = descriptor.value;
};
$jscomp.getGlobal = function(maybeGlobal) {
  return typeof window != "undefined" && window === maybeGlobal ? maybeGlobal : typeof global != "undefined" && global != null ? global : maybeGlobal;
};
$jscomp.global = $jscomp.getGlobal(this);
$jscomp.polyfill = function(target, polyfill, fromLang, toLang) {
  if (!polyfill) {
    return;
  }
  var obj = $jscomp.global;
  var split = target.split(".");
  for (var i = 0; i < split.length - 1; i++) {
    var key = split[i];
    if (!(key in obj)) {
      obj[key] = {};
    }
    obj = obj[key];
  }
  var property = split[split.length - 1];
  var orig = obj[property];
  var impl = polyfill(orig);
  if (impl == orig || impl == null) {
    return;
  }
  $jscomp.defineProperty(obj, property, {configurable:true, writable:true, value:impl});
};
$jscomp.polyfill("Array.prototype.copyWithin", function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(target, start, opt_end) {
    var len = this.length;
    target = Number(target);
    start = Number(start);
    opt_end = Number(opt_end != null ? opt_end : len);
    if (target < start) {
      opt_end = Math.min(opt_end, len);
      while (start < opt_end) {
        if (start in this) {
          this[target++] = this[start++];
        } else {
          delete this[target++];
          start++;
        }
      }
    } else {
      opt_end = Math.min(opt_end, len + start - target);
      target += opt_end - start;
      while (opt_end > start) {
        if (--opt_end in this) {
          this[--target] = this[opt_end];
        } else {
          delete this[target];
        }
      }
    }
    return this;
  };
  return polyfill;
}, "es6", "es3");
$jscomp.SYMBOL_PREFIX = "jscomp_symbol_";
$jscomp.initSymbol = function() {
  $jscomp.initSymbol = function() {
  };
  if (!$jscomp.global["Symbol"]) {
    $jscomp.global["Symbol"] = $jscomp.Symbol;
  }
};
$jscomp.Symbol = function() {
  var counter = 0;
  function Symbol(opt_description) {
    return $jscomp.SYMBOL_PREFIX + (opt_description || "") + counter++;
  }
  return Symbol;
}();
$jscomp.initSymbolIterator = function() {
  $jscomp.initSymbol();
  var symbolIterator = $jscomp.global["Symbol"].iterator;
  if (!symbolIterator) {
    symbolIterator = $jscomp.global["Symbol"].iterator = $jscomp.global["Symbol"]("iterator");
  }
  if (typeof Array.prototype[symbolIterator] != "function") {
    $jscomp.defineProperty(Array.prototype, symbolIterator, {configurable:true, writable:true, value:function() {
      return $jscomp.arrayIterator(this);
    }});
  }
  $jscomp.initSymbolIterator = function() {
  };
};
$jscomp.arrayIterator = function(array) {
  var index = 0;
  return $jscomp.iteratorPrototype(function() {
    if (index < array.length) {
      return {done:false, value:array[index++]};
    } else {
      return {done:true};
    }
  });
};
$jscomp.iteratorPrototype = function(next) {
  $jscomp.initSymbolIterator();
  var iterator = {next:next};
  iterator[$jscomp.global["Symbol"].iterator] = function() {
    return this;
  };
  return iterator;
};
$jscomp.iteratorFromArray = function(array, transform) {
  $jscomp.initSymbolIterator();
  if (array instanceof String) {
    array = array + "";
  }
  var i = 0;
  var iter = {next:function() {
    if (i < array.length) {
      var index = i++;
      return {value:transform(index, array[index]), done:false};
    }
    iter.next = function() {
      return {done:true, value:void 0};
    };
    return iter.next();
  }};
  iter[Symbol.iterator] = function() {
    return iter;
  };
  return iter;
};
$jscomp.polyfill("Array.prototype.entries", function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function() {
    return $jscomp.iteratorFromArray(this, function(i, v) {
      return [i, v];
    });
  };
  return polyfill;
}, "es6", "es3");
$jscomp.polyfill("Array.prototype.fill", function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(value, opt_start, opt_end) {
    var length = this.length || 0;
    if (opt_start < 0) {
      opt_start = Math.max(0, length + opt_start);
    }
    if (opt_end == null || opt_end > length) {
      opt_end = length;
    }
    opt_end = Number(opt_end);
    if (opt_end < 0) {
      opt_end = Math.max(0, length + opt_end);
    }
    for (var i = Number(opt_start || 0); i < opt_end; i++) {
      this[i] = value;
    }
    return this;
  };
  return polyfill;
}, "es6", "es3");
$jscomp.findInternal = function(array, callback, thisArg) {
  if (array instanceof String) {
    array = String(array);
  }
  var len = array.length;
  for (var i = 0; i < len; i++) {
    var value = array[i];
    if (callback.call(thisArg, value, i, array)) {
      return {i:i, v:value};
    }
  }
  return {i:-1, v:void 0};
};
$jscomp.polyfill("Array.prototype.find", function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(callback, opt_thisArg) {
    return $jscomp.findInternal(this, callback, opt_thisArg).v;
  };
  return polyfill;
}, "es6", "es3");
$jscomp.polyfill("Array.prototype.findIndex", function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(callback, opt_thisArg) {
    return $jscomp.findInternal(this, callback, opt_thisArg).i;
  };
  return polyfill;
}, "es6", "es3");
$jscomp.polyfill("Array.from", function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(arrayLike, opt_mapFn, opt_thisArg) {
    $jscomp.initSymbolIterator();
    opt_mapFn = opt_mapFn != null ? opt_mapFn : function(x) {
      return x;
    };
    var result = [];
    var iteratorFunction = arrayLike[Symbol.iterator];
    if (typeof iteratorFunction == "function") {
      arrayLike = iteratorFunction.call(arrayLike);
      var next;
      while (!(next = arrayLike.next()).done) {
        result.push(opt_mapFn.call(opt_thisArg, next.value));
      }
    } else {
      var len = arrayLike.length;
      for (var i = 0; i < len; i++) {
        result.push(opt_mapFn.call(opt_thisArg, arrayLike[i]));
      }
    }
    return result;
  };
  return polyfill;
}, "es6", "es3");
$jscomp.polyfill("Object.is", function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(left, right) {
    if (left === right) {
      return left !== 0 || 1 / left === 1 / right;
    } else {
      return left !== left && right !== right;
    }
  };
  return polyfill;
}, "es6", "es3");
$jscomp.polyfill("Array.prototype.includes", function(orig) {
  if (orig) {
    return orig;
  }
  var includes = function(searchElement, opt_fromIndex) {
    var array = this;
    if (array instanceof String) {
      array = String(array);
    }
    var len = array.length;
    for (var i = opt_fromIndex || 0; i < len; i++) {
      if (array[i] == searchElement || Object.is(array[i], searchElement)) {
        return true;
      }
    }
    return false;
  };
  return includes;
}, "es7", "es3");
$jscomp.polyfill("Array.prototype.keys", function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function() {
    return $jscomp.iteratorFromArray(this, function(i) {
      return i;
    });
  };
  return polyfill;
}, "es6", "es3");
$jscomp.polyfill("Array.of", function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(var_args) {
    return Array.from(arguments);
  };
  return polyfill;
}, "es6", "es3");
$jscomp.polyfill("Array.prototype.values", function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function() {
    return $jscomp.iteratorFromArray(this, function(k, v) {
      return v;
    });
  };
  return polyfill;
}, "es8", "es3");
$jscomp.makeIterator = function(iterable) {
  $jscomp.initSymbolIterator();
  var iteratorFunction = iterable[Symbol.iterator];
  return iteratorFunction ? iteratorFunction.call(iterable) : $jscomp.arrayIterator(iterable);
};
$jscomp.FORCE_POLYFILL_PROMISE = false;
$jscomp.polyfill("Promise", function(NativePromise) {
  if (NativePromise && !$jscomp.FORCE_POLYFILL_PROMISE) {
    return NativePromise;
  }
  function AsyncExecutor() {
    this.batch_ = null;
  }
  AsyncExecutor.prototype.asyncExecute = function(f) {
    if (this.batch_ == null) {
      this.batch_ = [];
      this.asyncExecuteBatch_();
    }
    this.batch_.push(f);
    return this;
  };
  AsyncExecutor.prototype.asyncExecuteBatch_ = function() {
    var self = this;
    this.asyncExecuteFunction(function() {
      self.executeBatch_();
    });
  };
  var nativeSetTimeout = $jscomp.global["setTimeout"];
  AsyncExecutor.prototype.asyncExecuteFunction = function(f) {
    nativeSetTimeout(f, 0);
  };
  AsyncExecutor.prototype.executeBatch_ = function() {
    while (this.batch_ && this.batch_.length) {
      var executingBatch = this.batch_;
      this.batch_ = [];
      for (var i = 0; i < executingBatch.length; ++i) {
        var f = executingBatch[i];
        delete executingBatch[i];
        try {
          f();
        } catch (error) {
          this.asyncThrow_(error);
        }
      }
    }
    this.batch_ = null;
  };
  AsyncExecutor.prototype.asyncThrow_ = function(exception) {
    this.asyncExecuteFunction(function() {
      throw exception;
    });
  };
  var PromiseState = {PENDING:0, FULFILLED:1, REJECTED:2};
  var PolyfillPromise = function(executor) {
    this.state_ = PromiseState.PENDING;
    this.result_ = undefined;
    this.onSettledCallbacks_ = [];
    var resolveAndReject = this.createResolveAndReject_();
    try {
      executor(resolveAndReject.resolve, resolveAndReject.reject);
    } catch (e) {
      resolveAndReject.reject(e);
    }
  };
  PolyfillPromise.prototype.createResolveAndReject_ = function() {
    var thisPromise = this;
    var alreadyCalled = false;
    function firstCallWins(method) {
      return function(x) {
        if (!alreadyCalled) {
          alreadyCalled = true;
          method.call(thisPromise, x);
        }
      };
    }
    return {resolve:firstCallWins(this.resolveTo_), reject:firstCallWins(this.reject_)};
  };
  PolyfillPromise.prototype.resolveTo_ = function(value) {
    if (value === this) {
      this.reject_(new TypeError("A Promise cannot resolve to itself"));
    } else {
      if (value instanceof PolyfillPromise) {
        this.settleSameAsPromise_(value);
      } else {
        if (isObject(value)) {
          this.resolveToNonPromiseObj_(value);
        } else {
          this.fulfill_(value);
        }
      }
    }
  };
  PolyfillPromise.prototype.resolveToNonPromiseObj_ = function(obj) {
    var thenMethod = undefined;
    try {
      thenMethod = obj.then;
    } catch (error) {
      this.reject_(error);
      return;
    }
    if (typeof thenMethod == "function") {
      this.settleSameAsThenable_(thenMethod, obj);
    } else {
      this.fulfill_(obj);
    }
  };
  function isObject(value) {
    switch(typeof value) {
      case "object":
        return value != null;
      case "function":
        return true;
      default:
        return false;
    }
  }
  PolyfillPromise.prototype.reject_ = function(reason) {
    this.settle_(PromiseState.REJECTED, reason);
  };
  PolyfillPromise.prototype.fulfill_ = function(value) {
    this.settle_(PromiseState.FULFILLED, value);
  };
  PolyfillPromise.prototype.settle_ = function(settledState, valueOrReason) {
    if (this.state_ != PromiseState.PENDING) {
      throw new Error("Cannot settle(" + settledState + ", " + valueOrReason | "): Promise already settled in state" + this.state_);
    }
    this.state_ = settledState;
    this.result_ = valueOrReason;
    this.executeOnSettledCallbacks_();
  };
  PolyfillPromise.prototype.executeOnSettledCallbacks_ = function() {
    if (this.onSettledCallbacks_ != null) {
      var callbacks = this.onSettledCallbacks_;
      for (var i = 0; i < callbacks.length; ++i) {
        callbacks[i].call();
        callbacks[i] = null;
      }
      this.onSettledCallbacks_ = null;
    }
  };
  var asyncExecutor = new AsyncExecutor;
  PolyfillPromise.prototype.settleSameAsPromise_ = function(promise) {
    var methods = this.createResolveAndReject_();
    promise.callWhenSettled_(methods.resolve, methods.reject);
  };
  PolyfillPromise.prototype.settleSameAsThenable_ = function(thenMethod, thenable) {
    var methods = this.createResolveAndReject_();
    try {
      thenMethod.call(thenable, methods.resolve, methods.reject);
    } catch (error) {
      methods.reject(error);
    }
  };
  PolyfillPromise.prototype.then = function(onFulfilled, onRejected) {
    var resolveChild;
    var rejectChild;
    var childPromise = new PolyfillPromise(function(resolve, reject) {
      resolveChild = resolve;
      rejectChild = reject;
    });
    function createCallback(paramF, defaultF) {
      if (typeof paramF == "function") {
        return function(x) {
          try {
            resolveChild(paramF(x));
          } catch (error) {
            rejectChild(error);
          }
        };
      } else {
        return defaultF;
      }
    }
    this.callWhenSettled_(createCallback(onFulfilled, resolveChild), createCallback(onRejected, rejectChild));
    return childPromise;
  };
  PolyfillPromise.prototype.catch = function(onRejected) {
    return this.then(undefined, onRejected);
  };
  PolyfillPromise.prototype.callWhenSettled_ = function(onFulfilled, onRejected) {
    var thisPromise = this;
    function callback() {
      switch(thisPromise.state_) {
        case PromiseState.FULFILLED:
          onFulfilled(thisPromise.result_);
          break;
        case PromiseState.REJECTED:
          onRejected(thisPromise.result_);
          break;
        default:
          throw new Error("Unexpected state: " + thisPromise.state_);
      }
    }
    if (this.onSettledCallbacks_ == null) {
      asyncExecutor.asyncExecute(callback);
    } else {
      this.onSettledCallbacks_.push(function() {
        asyncExecutor.asyncExecute(callback);
      });
    }
  };
  function resolvingPromise(opt_value) {
    if (opt_value instanceof PolyfillPromise) {
      return opt_value;
    } else {
      return new PolyfillPromise(function(resolve, reject) {
        resolve(opt_value);
      });
    }
  }
  PolyfillPromise["resolve"] = resolvingPromise;
  PolyfillPromise["reject"] = function(opt_reason) {
    return new PolyfillPromise(function(resolve, reject) {
      reject(opt_reason);
    });
  };
  PolyfillPromise["race"] = function(thenablesOrValues) {
    return new PolyfillPromise(function(resolve, reject) {
      var iterator = $jscomp.makeIterator(thenablesOrValues);
      for (var iterRec = iterator.next(); !iterRec.done; iterRec = iterator.next()) {
        resolvingPromise(iterRec.value).callWhenSettled_(resolve, reject);
      }
    });
  };
  PolyfillPromise["all"] = function(thenablesOrValues) {
    var iterator = $jscomp.makeIterator(thenablesOrValues);
    var iterRec = iterator.next();
    if (iterRec.done) {
      return resolvingPromise([]);
    } else {
      return new PolyfillPromise(function(resolveAll, rejectAll) {
        var resultsArray = [];
        var unresolvedCount = 0;
        function onFulfilled(i) {
          return function(ithResult) {
            resultsArray[i] = ithResult;
            unresolvedCount--;
            if (unresolvedCount == 0) {
              resolveAll(resultsArray);
            }
          };
        }
        do {
          resultsArray.push(undefined);
          unresolvedCount++;
          resolvingPromise(iterRec.value).callWhenSettled_(onFulfilled(resultsArray.length - 1), rejectAll);
          iterRec = iterator.next();
        } while (!iterRec.done);
      });
    }
  };
  return PolyfillPromise;
}, "es6", "es3");
$jscomp.executeAsyncGenerator = function(generator) {
  function passValueToGenerator(value) {
    return generator.next(value);
  }
  function passErrorToGenerator(error) {
    return generator.throw(error);
  }
  return new Promise(function(resolve, reject) {
    function handleGeneratorRecord(genRec) {
      if (genRec.done) {
        resolve(genRec.value);
      } else {
        Promise.resolve(genRec.value).then(passValueToGenerator, passErrorToGenerator).then(handleGeneratorRecord, reject);
      }
    }
    handleGeneratorRecord(generator.next());
  });
};
$jscomp.owns = function(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
};
$jscomp.polyfill("WeakMap", function(NativeWeakMap) {
  function isConformant() {
    if (!NativeWeakMap || !Object.seal) {
      return false;
    }
    try {
      var x = Object.seal({});
      var y = Object.seal({});
      var map = new NativeWeakMap([[x, 2], [y, 3]]);
      if (map.get(x) != 2 || map.get(y) != 3) {
        return false;
      }
      map.delete(x);
      map.set(y, 4);
      return !map.has(x) && map.get(y) == 4;
    } catch (err) {
      return false;
    }
  }
  if (isConformant()) {
    return NativeWeakMap;
  }
  var prop = "$jscomp_hidden_" + Math.random().toString().substring(2);
  function insert(target) {
    if (!$jscomp.owns(target, prop)) {
      var obj = {};
      $jscomp.defineProperty(target, prop, {value:obj});
    }
  }
  function patch(name) {
    var prev = Object[name];
    if (prev) {
      Object[name] = function(target) {
        insert(target);
        return prev(target);
      };
    }
  }
  patch("freeze");
  patch("preventExtensions");
  patch("seal");
  var index = 0;
  var PolyfillWeakMap = function(opt_iterable) {
    this.id_ = (index += Math.random() + 1).toString();
    if (opt_iterable) {
      $jscomp.initSymbol();
      $jscomp.initSymbolIterator();
      var iter = $jscomp.makeIterator(opt_iterable);
      var entry;
      while (!(entry = iter.next()).done) {
        var item = entry.value;
        this.set(item[0], item[1]);
      }
    }
  };
  PolyfillWeakMap.prototype.set = function(key, value) {
    insert(key);
    if (!$jscomp.owns(key, prop)) {
      throw new Error("WeakMap key fail: " + key);
    }
    key[prop][this.id_] = value;
    return this;
  };
  PolyfillWeakMap.prototype.get = function(key) {
    return $jscomp.owns(key, prop) ? key[prop][this.id_] : undefined;
  };
  PolyfillWeakMap.prototype.has = function(key) {
    return $jscomp.owns(key, prop) && $jscomp.owns(key[prop], this.id_);
  };
  PolyfillWeakMap.prototype.delete = function(key) {
    if (!$jscomp.owns(key, prop) || !$jscomp.owns(key[prop], this.id_)) {
      return false;
    }
    return delete key[prop][this.id_];
  };
  return PolyfillWeakMap;
}, "es6", "es3");
$jscomp.MapEntry = function() {
  this.previous;
  this.next;
  this.head;
  this.key;
  this.value;
};
$jscomp.polyfill("Map", function(NativeMap) {
  var isConformant = !$jscomp.ASSUME_NO_NATIVE_MAP && function() {
    if (!NativeMap || !NativeMap.prototype.entries || typeof Object.seal != "function") {
      return false;
    }
    try {
      NativeMap = NativeMap;
      var key = Object.seal({x:4});
      var map = new NativeMap($jscomp.makeIterator([[key, "s"]]));
      if (map.get(key) != "s" || map.size != 1 || map.get({x:4}) || map.set({x:4}, "t") != map || map.size != 2) {
        return false;
      }
      var iter = map.entries();
      var item = iter.next();
      if (item.done || item.value[0] != key || item.value[1] != "s") {
        return false;
      }
      item = iter.next();
      if (item.done || item.value[0].x != 4 || item.value[1] != "t" || !iter.next().done) {
        return false;
      }
      return true;
    } catch (err) {
      return false;
    }
  }();
  if (isConformant) {
    return NativeMap;
  }
  $jscomp.initSymbol();
  $jscomp.initSymbolIterator();
  var idMap = new WeakMap;
  var PolyfillMap = function(opt_iterable) {
    this.data_ = {};
    this.head_ = createHead();
    this.size = 0;
    if (opt_iterable) {
      var iter = $jscomp.makeIterator(opt_iterable);
      var entry;
      while (!(entry = iter.next()).done) {
        var item = entry.value;
        this.set(item[0], item[1]);
      }
    }
  };
  PolyfillMap.prototype.set = function(key, value) {
    var r = maybeGetEntry(this, key);
    if (!r.list) {
      r.list = this.data_[r.id] = [];
    }
    if (!r.entry) {
      r.entry = {next:this.head_, previous:this.head_.previous, head:this.head_, key:key, value:value};
      r.list.push(r.entry);
      this.head_.previous.next = r.entry;
      this.head_.previous = r.entry;
      this.size++;
    } else {
      r.entry.value = value;
    }
    return this;
  };
  PolyfillMap.prototype.delete = function(key) {
    var r = maybeGetEntry(this, key);
    if (r.entry && r.list) {
      r.list.splice(r.index, 1);
      if (!r.list.length) {
        delete this.data_[r.id];
      }
      r.entry.previous.next = r.entry.next;
      r.entry.next.previous = r.entry.previous;
      r.entry.head = null;
      this.size--;
      return true;
    }
    return false;
  };
  PolyfillMap.prototype.clear = function() {
    this.data_ = {};
    this.head_ = this.head_.previous = createHead();
    this.size = 0;
  };
  PolyfillMap.prototype.has = function(key) {
    return !!maybeGetEntry(this, key).entry;
  };
  PolyfillMap.prototype.get = function(key) {
    var entry = maybeGetEntry(this, key).entry;
    return entry && entry.value;
  };
  PolyfillMap.prototype.entries = function() {
    return makeIterator(this, function(entry) {
      return [entry.key, entry.value];
    });
  };
  PolyfillMap.prototype.keys = function() {
    return makeIterator(this, function(entry) {
      return entry.key;
    });
  };
  PolyfillMap.prototype.values = function() {
    return makeIterator(this, function(entry) {
      return entry.value;
    });
  };
  PolyfillMap.prototype.forEach = function(callback, opt_thisArg) {
    var iter = this.entries();
    var item;
    while (!(item = iter.next()).done) {
      var entry = item.value;
      callback.call(opt_thisArg, entry[1], entry[0], this);
    }
  };
  PolyfillMap.prototype[Symbol.iterator] = PolyfillMap.prototype.entries;
  var maybeGetEntry = function(map, key) {
    var id = getId(key);
    var list = map.data_[id];
    if (list && $jscomp.owns(map.data_, id)) {
      for (var index = 0; index < list.length; index++) {
        var entry = list[index];
        if (key !== key && entry.key !== entry.key || key === entry.key) {
          return {id:id, list:list, index:index, entry:entry};
        }
      }
    }
    return {id:id, list:list, index:-1, entry:undefined};
  };
  var makeIterator = function(map, func) {
    var entry = map.head_;
    return $jscomp.iteratorPrototype(function() {
      if (entry) {
        while (entry.head != map.head_) {
          entry = entry.previous;
        }
        while (entry.next != entry.head) {
          entry = entry.next;
          return {done:false, value:func(entry)};
        }
        entry = null;
      }
      return {done:true, value:void 0};
    });
  };
  var createHead = function() {
    var head = {};
    head.previous = head.next = head.head = head;
    return head;
  };
  var mapIndex = 0;
  var getId = function(obj) {
    var type = obj && typeof obj;
    if (type == "object" || type == "function") {
      obj = obj;
      if (!idMap.has(obj)) {
        var id = "" + ++mapIndex;
        idMap.set(obj, id);
        return id;
      }
      return idMap.get(obj);
    }
    return "p_" + obj;
  };
  return PolyfillMap;
}, "es6", "es3");
$jscomp.polyfill("Math.acosh", function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x);
    return Math.log(x + Math.sqrt(x * x - 1));
  };
  return polyfill;
}, "es6", "es3");
$jscomp.polyfill("Math.asinh", function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x);
    if (x === 0) {
      return x;
    }
    var y = Math.log(Math.abs(x) + Math.sqrt(x * x + 1));
    return x < 0 ? -y : y;
  };
  return polyfill;
}, "es6", "es3");
$jscomp.polyfill("Math.log1p", function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x);
    if (x < 0.25 && x > -0.25) {
      var y = x;
      var d = 1;
      var z = x;
      var zPrev = 0;
      var s = 1;
      while (zPrev != z) {
        y *= x;
        s *= -1;
        z = (zPrev = z) + s * y / ++d;
      }
      return z;
    }
    return Math.log(1 + x);
  };
  return polyfill;
}, "es6", "es3");
$jscomp.polyfill("Math.atanh", function(orig) {
  if (orig) {
    return orig;
  }
  var log1p = Math.log1p;
  var polyfill = function(x) {
    x = Number(x);
    return (log1p(x) - log1p(-x)) / 2;
  };
  return polyfill;
}, "es6", "es3");
$jscomp.polyfill("Math.cbrt", function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    if (x === 0) {
      return x;
    }
    x = Number(x);
    var y = Math.pow(Math.abs(x), 1 / 3);
    return x < 0 ? -y : y;
  };
  return polyfill;
}, "es6", "es3");
$jscomp.polyfill("Math.clz32", function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x) >>> 0;
    if (x === 0) {
      return 32;
    }
    var result = 0;
    if ((x & 4294901760) === 0) {
      x <<= 16;
      result += 16;
    }
    if ((x & 4278190080) === 0) {
      x <<= 8;
      result += 8;
    }
    if ((x & 4026531840) === 0) {
      x <<= 4;
      result += 4;
    }
    if ((x & 3221225472) === 0) {
      x <<= 2;
      result += 2;
    }
    if ((x & 2147483648) === 0) {
      result++;
    }
    return result;
  };
  return polyfill;
}, "es6", "es3");
$jscomp.polyfill("Math.cosh", function(orig) {
  if (orig) {
    return orig;
  }
  var exp = Math.exp;
  var polyfill = function(x) {
    x = Number(x);
    return (exp(x) + exp(-x)) / 2;
  };
  return polyfill;
}, "es6", "es3");
$jscomp.polyfill("Math.expm1", function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x);
    if (x < .25 && x > -.25) {
      var y = x;
      var d = 1;
      var z = x;
      var zPrev = 0;
      while (zPrev != z) {
        y *= x / ++d;
        z = (zPrev = z) + y;
      }
      return z;
    }
    return Math.exp(x) - 1;
  };
  return polyfill;
}, "es6", "es3");
$jscomp.polyfill("Math.hypot", function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x, y, var_args) {
    x = Number(x);
    y = Number(y);
    var i, z, sum;
    var max = Math.max(Math.abs(x), Math.abs(y));
    for (i = 2; i < arguments.length; i++) {
      max = Math.max(max, Math.abs(arguments[i]));
    }
    if (max > 1e100 || max < 1e-100) {
      x = x / max;
      y = y / max;
      sum = x * x + y * y;
      for (i = 2; i < arguments.length; i++) {
        z = Number(arguments[i]) / max;
        sum += z * z;
      }
      return Math.sqrt(sum) * max;
    } else {
      sum = x * x + y * y;
      for (i = 2; i < arguments.length; i++) {
        z = Number(arguments[i]);
        sum += z * z;
      }
      return Math.sqrt(sum);
    }
  };
  return polyfill;
}, "es6", "es3");
$jscomp.polyfill("Math.imul", function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(a, b) {
    a = Number(a);
    b = Number(b);
    var ah = a >>> 16 & 65535;
    var al = a & 65535;
    var bh = b >>> 16 & 65535;
    var bl = b & 65535;
    var lh = ah * bl + al * bh << 16 >>> 0;
    return al * bl + lh | 0;
  };
  return polyfill;
}, "es6", "es3");
$jscomp.polyfill("Math.log10", function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    return Math.log(x) / Math.LN10;
  };
  return polyfill;
}, "es6", "es3");
$jscomp.polyfill("Math.log2", function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    return Math.log(x) / Math.LN2;
  };
  return polyfill;
}, "es6", "es3");
$jscomp.polyfill("Math.sign", function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x);
    return x === 0 || isNaN(x) ? x : x > 0 ? 1 : -1;
  };
  return polyfill;
}, "es6", "es3");
$jscomp.polyfill("Math.sinh", function(orig) {
  if (orig) {
    return orig;
  }
  var exp = Math.exp;
  var polyfill = function(x) {
    x = Number(x);
    if (x === 0) {
      return x;
    }
    return (exp(x) - exp(-x)) / 2;
  };
  return polyfill;
}, "es6", "es3");
$jscomp.polyfill("Math.tanh", function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x);
    if (x === 0) {
      return x;
    }
    var y = Math.exp(-2 * Math.abs(x));
    var z = (1 - y) / (1 + y);
    return x < 0 ? -z : z;
  };
  return polyfill;
}, "es6", "es3");
$jscomp.polyfill("Math.trunc", function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x);
    if (isNaN(x) || x === Infinity || x === -Infinity || x === 0) {
      return x;
    }
    var y = Math.floor(Math.abs(x));
    return x < 0 ? -y : y;
  };
  return polyfill;
}, "es6", "es3");
$jscomp.polyfill("Number.EPSILON", function(orig) {
  return Math.pow(2, -52);
}, "es6", "es3");
$jscomp.polyfill("Number.MAX_SAFE_INTEGER", function() {
  return 9007199254740991;
}, "es6", "es3");
$jscomp.polyfill("Number.MIN_SAFE_INTEGER", function() {
  return -9007199254740991;
}, "es6", "es3");
$jscomp.polyfill("Number.isFinite", function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    if (typeof x !== "number") {
      return false;
    }
    return !isNaN(x) && x !== Infinity && x !== -Infinity;
  };
  return polyfill;
}, "es6", "es3");
$jscomp.polyfill("Number.isInteger", function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    if (!Number.isFinite(x)) {
      return false;
    }
    return x === Math.floor(x);
  };
  return polyfill;
}, "es6", "es3");
$jscomp.polyfill("Number.isNaN", function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    return typeof x === "number" && isNaN(x);
  };
  return polyfill;
}, "es6", "es3");
$jscomp.polyfill("Number.isSafeInteger", function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    return Number.isInteger(x) && Math.abs(x) <= Number.MAX_SAFE_INTEGER;
  };
  return polyfill;
}, "es6", "es3");
$jscomp.polyfill("Number.parseFloat", function(orig) {
  return orig || parseFloat;
}, "es6", "es3");
$jscomp.polyfill("Number.parseInt", function(orig) {
  return orig || parseInt;
}, "es6", "es3");
$jscomp.polyfill("Object.assign", function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(target, var_args) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      if (!source) {
        continue;
      }
      for (var key in source) {
        if ($jscomp.owns(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return polyfill;
}, "es6", "es3");
$jscomp.polyfill("Object.entries", function(orig) {
  if (orig) {
    return orig;
  }
  var entries = function(obj) {
    var result = [];
    for (var key in obj) {
      if ($jscomp.owns(obj, key)) {
        result.push([key, obj[key]]);
      }
    }
    return result;
  };
  return entries;
}, "es8", "es3");
$jscomp.polyfill("Object.getOwnPropertySymbols", function(orig) {
  if (orig) {
    return orig;
  }
  return function() {
    return [];
  };
}, "es6", "es5");
$jscomp.polyfill("Reflect.ownKeys", function(orig) {
  if (orig) {
    return orig;
  }
  var symbolPrefix = "jscomp_symbol_";
  function isSymbol(key) {
    return key.substring(0, symbolPrefix.length) == symbolPrefix;
  }
  var polyfill = function(target) {
    var keys = [];
    var names = Object.getOwnPropertyNames(target);
    var symbols = Object.getOwnPropertySymbols(target);
    for (var i = 0; i < names.length; i++) {
      (isSymbol(names[i]) ? symbols : keys).push(names[i]);
    }
    return keys.concat(symbols);
  };
  return polyfill;
}, "es6", "es5");
$jscomp.polyfill("Object.getOwnPropertyDescriptors", function(orig) {
  if (orig) {
    return orig;
  }
  var getOwnPropertyDescriptors = function(obj) {
    var result = {};
    var keys = Reflect.ownKeys(obj);
    for (var i = 0; i < keys.length; i++) {
      result[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }
    return result;
  };
  return getOwnPropertyDescriptors;
}, "es8", "es5");
$jscomp.underscoreProtoCanBeSet = function() {
  var x = {a:true};
  var y = {};
  try {
    y.__proto__ = x;
    return y.a;
  } catch (e) {
  }
  return false;
};
$jscomp.setPrototypeOf = typeof Object.setPrototypeOf == "function" ? Object.setPrototypeOf : $jscomp.underscoreProtoCanBeSet() ? function(target, proto) {
  target.__proto__ = proto;
  if (target.__proto__ !== proto) {
    throw new TypeError(target + " is not extensible");
  }
  return target;
} : null;
$jscomp.polyfill("Object.setPrototypeOf", function(orig) {
  return orig || $jscomp.setPrototypeOf;
}, "es6", "es5");
$jscomp.polyfill("Object.values", function(orig) {
  if (orig) {
    return orig;
  }
  var values = function(obj) {
    var result = [];
    for (var key in obj) {
      if ($jscomp.owns(obj, key)) {
        result.push(obj[key]);
      }
    }
    return result;
  };
  return values;
}, "es8", "es3");
$jscomp.polyfill("Reflect.apply", function(orig) {
  if (orig) {
    return orig;
  }
  var apply = Function.prototype.apply;
  var polyfill = function(target, thisArg, argList) {
    return apply.call(target, thisArg, argList);
  };
  return polyfill;
}, "es6", "es3");
$jscomp.objectCreate = $jscomp.ASSUME_ES5 || typeof Object.create == "function" ? Object.create : function(prototype) {
  var ctor = function() {
  };
  ctor.prototype = prototype;
  return new ctor;
};
$jscomp.construct = function() {
  function reflectConstructWorks() {
    function Base() {
    }
    function Derived() {
    }
    new Base;
    Reflect.construct(Base, [], Derived);
    return new Base instanceof Base;
  }
  if (typeof Reflect != "undefined" && Reflect.construct) {
    if (reflectConstructWorks()) {
      return Reflect.construct;
    }
    var brokenConstruct = Reflect.construct;
    var patchedConstruct = function(target, argList, opt_newTarget) {
      var out = brokenConstruct(target, argList);
      if (opt_newTarget) {
        Reflect.setPrototypeOf(out, opt_newTarget.prototype);
      }
      return out;
    };
    return patchedConstruct;
  }
  function construct(target, argList, opt_newTarget) {
    if (opt_newTarget === undefined) {
      opt_newTarget = target;
    }
    var proto = opt_newTarget.prototype || Object.prototype;
    var obj = $jscomp.objectCreate(proto);
    var apply = Function.prototype.apply;
    var out = apply.call(target, obj, argList);
    return out || obj;
  }
  return construct;
}();
$jscomp.polyfill("Reflect.construct", function(orig) {
  return $jscomp.construct;
}, "es6", "es3");
$jscomp.polyfill("Reflect.defineProperty", function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(target, propertyKey, attributes) {
    try {
      Object.defineProperty(target, propertyKey, attributes);
      var desc = Object.getOwnPropertyDescriptor(target, propertyKey);
      if (!desc) {
        return false;
      }
      return desc.configurable === (attributes.configurable || false) && desc.enumerable === (attributes.enumerable || false) && ("value" in desc ? desc.value === attributes.value && desc.writable === (attributes.writable || false) : desc.get === attributes.get && desc.set === attributes.set);
    } catch (err) {
      return false;
    }
  };
  return polyfill;
}, "es6", "es5");
$jscomp.polyfill("Reflect.deleteProperty", function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(target, propertyKey) {
    if (!$jscomp.owns(target, propertyKey)) {
      return true;
    }
    try {
      return delete target[propertyKey];
    } catch (err) {
      return false;
    }
  };
  return polyfill;
}, "es6", "es3");
$jscomp.polyfill("Reflect.getOwnPropertyDescriptor", function(orig) {
  return orig || Object.getOwnPropertyDescriptor;
}, "es6", "es5");
$jscomp.polyfill("Reflect.getPrototypeOf", function(orig) {
  return orig || Object.getPrototypeOf;
}, "es6", "es5");
$jscomp.findDescriptor = function(target, propertyKey) {
  var obj = target;
  while (obj) {
    var property = Reflect.getOwnPropertyDescriptor(obj, propertyKey);
    if (property) {
      return property;
    }
    obj = Reflect.getPrototypeOf(obj);
  }
  return undefined;
};
$jscomp.polyfill("Reflect.get", function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(target, propertyKey, opt_receiver) {
    if (arguments.length <= 2) {
      return target[propertyKey];
    }
    var property = $jscomp.findDescriptor(target, propertyKey);
    if (property) {
      return property.get ? property.get.call(opt_receiver) : property.value;
    }
    return undefined;
  };
  return polyfill;
}, "es6", "es5");
$jscomp.polyfill("Reflect.has", function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(target, propertyKey) {
    return propertyKey in target;
  };
  return polyfill;
}, "es6", "es3");
$jscomp.polyfill("Reflect.isExtensible", function(orig) {
  if (orig) {
    return orig;
  }
  if ($jscomp.ASSUME_ES5 || typeof Object.isExtensible == "function") {
    return Object.isExtensible;
  }
  return function() {
    return true;
  };
}, "es6", "es3");
$jscomp.polyfill("Reflect.preventExtensions", function(orig) {
  if (orig) {
    return orig;
  }
  if (!($jscomp.ASSUME_ES5 || typeof Object.preventExtensions == "function")) {
    return function() {
      return false;
    };
  }
  var polyfill = function(target) {
    Object.preventExtensions(target);
    return !Object.isExtensible(target);
  };
  return polyfill;
}, "es6", "es3");
$jscomp.polyfill("Reflect.set", function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(target, propertyKey, value, opt_receiver) {
    var property = $jscomp.findDescriptor(target, propertyKey);
    if (!property) {
      if (Reflect.isExtensible(target)) {
        target[propertyKey] = value;
        return true;
      }
      return false;
    }
    if (property.set) {
      property.set.call(arguments.length > 3 ? opt_receiver : target, value);
      return true;
    } else {
      if (property.writable && !Object.isFrozen(target)) {
        target[propertyKey] = value;
        return true;
      }
    }
    return false;
  };
  return polyfill;
}, "es6", "es5");
$jscomp.polyfill("Reflect.setPrototypeOf", function(orig) {
  if (orig) {
    return orig;
  } else {
    if ($jscomp.setPrototypeOf) {
      var setPrototypeOf = $jscomp.setPrototypeOf;
      var polyfill = function(target, proto) {
        try {
          setPrototypeOf(target, proto);
          return true;
        } catch (e) {
          return false;
        }
      };
      return polyfill;
    } else {
      return null;
    }
  }
}, "es6", "es5");
$jscomp.polyfill("Set", function(NativeSet) {
  var isConformant = !$jscomp.ASSUME_NO_NATIVE_SET && function() {
    if (!NativeSet || !NativeSet.prototype.entries || typeof Object.seal != "function") {
      return false;
    }
    try {
      NativeSet = NativeSet;
      var value = Object.seal({x:4});
      var set = new NativeSet($jscomp.makeIterator([value]));
      if (!set.has(value) || set.size != 1 || set.add(value) != set || set.size != 1 || set.add({x:4}) != set || set.size != 2) {
        return false;
      }
      var iter = set.entries();
      var item = iter.next();
      if (item.done || item.value[0] != value || item.value[1] != value) {
        return false;
      }
      item = iter.next();
      if (item.done || item.value[0] == value || item.value[0].x != 4 || item.value[1] != item.value[0]) {
        return false;
      }
      return iter.next().done;
    } catch (err) {
      return false;
    }
  }();
  if (isConformant) {
    return NativeSet;
  }
  $jscomp.initSymbol();
  $jscomp.initSymbolIterator();
  var PolyfillSet = function(opt_iterable) {
    this.map_ = new Map;
    if (opt_iterable) {
      var iter = $jscomp.makeIterator(opt_iterable);
      var entry;
      while (!(entry = iter.next()).done) {
        var item = entry.value;
        this.add(item);
      }
    }
    this.size = this.map_.size;
  };
  PolyfillSet.prototype.add = function(value) {
    this.map_.set(value, value);
    this.size = this.map_.size;
    return this;
  };
  PolyfillSet.prototype.delete = function(value) {
    var result = this.map_.delete(value);
    this.size = this.map_.size;
    return result;
  };
  PolyfillSet.prototype.clear = function() {
    this.map_.clear();
    this.size = 0;
  };
  PolyfillSet.prototype.has = function(value) {
    return this.map_.has(value);
  };
  PolyfillSet.prototype.entries = function() {
    return this.map_.entries();
  };
  PolyfillSet.prototype.values = function() {
    return this.map_.values();
  };
  PolyfillSet.prototype.keys = PolyfillSet.prototype.values;
  PolyfillSet.prototype[Symbol.iterator] = PolyfillSet.prototype.values;
  PolyfillSet.prototype.forEach = function(callback, opt_thisArg) {
    var set = this;
    this.map_.forEach(function(value) {
      return callback.call(opt_thisArg, value, value, set);
    });
  };
  return PolyfillSet;
}, "es6", "es3");
$jscomp.checkStringArgs = function(thisArg, arg, func) {
  if (thisArg == null) {
    throw new TypeError("The 'this' value for String.prototype." + func + " must not be null or undefined");
  }
  if (arg instanceof RegExp) {
    throw new TypeError("First argument to String.prototype." + func + " must not be a regular expression");
  }
  return thisArg + "";
};
$jscomp.polyfill("String.prototype.codePointAt", function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(position) {
    var string = $jscomp.checkStringArgs(this, null, "codePointAt");
    var size = string.length;
    position = Number(position) || 0;
    if (!(position >= 0 && position < size)) {
      return void 0;
    }
    position = position | 0;
    var first = string.charCodeAt(position);
    if (first < 55296 || first > 56319 || position + 1 === size) {
      return first;
    }
    var second = string.charCodeAt(position + 1);
    if (second < 56320 || second > 57343) {
      return first;
    }
    return (first - 55296) * 1024 + second + 9216;
  };
  return polyfill;
}, "es6", "es3");
$jscomp.polyfill("String.prototype.endsWith", function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(searchString, opt_position) {
    var string = $jscomp.checkStringArgs(this, searchString, "endsWith");
    searchString = searchString + "";
    if (opt_position === void 0) {
      opt_position = string.length;
    }
    var i = Math.max(0, Math.min(opt_position | 0, string.length));
    var j = searchString.length;
    while (j > 0 && i > 0) {
      if (string[--i] != searchString[--j]) {
        return false;
      }
    }
    return j <= 0;
  };
  return polyfill;
}, "es6", "es3");
$jscomp.polyfill("String.fromCodePoint", function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(var_args) {
    var result = "";
    for (var i = 0; i < arguments.length; i++) {
      var code = Number(arguments[i]);
      if (code < 0 || code > 1114111 || code !== Math.floor(code)) {
        throw new RangeError("invalid_code_point " + code);
      }
      if (code <= 65535) {
        result += String.fromCharCode(code);
      } else {
        code -= 65536;
        result += String.fromCharCode(code >>> 10 & 1023 | 55296);
        result += String.fromCharCode(code & 1023 | 56320);
      }
    }
    return result;
  };
  return polyfill;
}, "es6", "es3");
$jscomp.polyfill("String.prototype.includes", function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(searchString, opt_position) {
    var string = $jscomp.checkStringArgs(this, searchString, "includes");
    return string.indexOf(searchString, opt_position || 0) !== -1;
  };
  return polyfill;
}, "es6", "es3");
$jscomp.polyfill("String.prototype.repeat", function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(copies) {
    var string = $jscomp.checkStringArgs(this, null, "repeat");
    if (copies < 0 || copies > 1342177279) {
      throw new RangeError("Invalid count value");
    }
    copies = copies | 0;
    var result = "";
    while (copies) {
      if (copies & 1) {
        result += string;
      }
      if (copies >>>= 1) {
        string += string;
      }
    }
    return result;
  };
  return polyfill;
}, "es6", "es3");
$jscomp.stringPadding = function(padString, padLength) {
  var padding = padString !== undefined ? String(padString) : " ";
  if (!(padLength > 0) || !padding) {
    return "";
  }
  var repeats = Math.ceil(padLength / padding.length);
  return padding.repeat(repeats).substring(0, padLength);
};
$jscomp.polyfill("String.prototype.padEnd", function(orig) {
  if (orig) {
    return orig;
  }
  var padEnd = function(targetLength, opt_padString) {
    var string = $jscomp.checkStringArgs(this, null, "padStart");
    var padLength = targetLength - string.length;
    return string + $jscomp.stringPadding(opt_padString, padLength);
  };
  return padEnd;
}, "es8", "es3");
$jscomp.polyfill("String.prototype.padStart", function(orig) {
  if (orig) {
    return orig;
  }
  var padStart = function(targetLength, opt_padString) {
    var string = $jscomp.checkStringArgs(this, null, "padStart");
    var padLength = targetLength - string.length;
    return $jscomp.stringPadding(opt_padString, padLength) + string;
  };
  return padStart;
}, "es8", "es3");
$jscomp.polyfill("String.prototype.startsWith", function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(searchString, opt_position) {
    var string = $jscomp.checkStringArgs(this, searchString, "startsWith");
    searchString = searchString + "";
    var strLen = string.length;
    var searchLen = searchString.length;
    var i = Math.max(0, Math.min(opt_position | 0, string.length));
    var j = 0;
    while (j < searchLen && i < strLen) {
      if (string[i++] != searchString[j++]) {
        return false;
      }
    }
    return j >= searchLen;
  };
  return polyfill;
}, "es6", "es3");
$jscomp.arrayFromIterator = function(iterator) {
  var i;
  var arr = [];
  while (!(i = iterator.next()).done) {
    arr.push(i.value);
  }
  return arr;
};
$jscomp.arrayFromIterable = function(iterable) {
  if (iterable instanceof Array) {
    return iterable;
  } else {
    return $jscomp.arrayFromIterator($jscomp.makeIterator(iterable));
  }
};
$jscomp.inherits = function(childCtor, parentCtor) {
  childCtor.prototype = $jscomp.objectCreate(parentCtor.prototype);
  childCtor.prototype.constructor = childCtor;
  if ($jscomp.setPrototypeOf) {
    var setPrototypeOf = $jscomp.setPrototypeOf;
    setPrototypeOf(childCtor, parentCtor);
  } else {
    for (var p in parentCtor) {
      if (p == "prototype") {
        continue;
      }
      if (Object.defineProperties) {
        var descriptor = Object.getOwnPropertyDescriptor(parentCtor, p);
        if (descriptor) {
          Object.defineProperty(childCtor, p, descriptor);
        }
      } else {
        childCtor[p] = parentCtor[p];
      }
    }
  }
  childCtor.superClass_ = parentCtor.prototype;
};
$jscomp.polyfill("WeakSet", function(NativeWeakSet) {
  function isConformant() {
    if (!NativeWeakSet || !Object.seal) {
      return false;
    }
    try {
      var x = Object.seal({});
      var y = Object.seal({});
      var set = new NativeWeakSet([x]);
      if (!set.has(x) || set.has(y)) {
        return false;
      }
      set.delete(x);
      set.add(y);
      return !set.has(x) && set.has(y);
    } catch (err) {
      return false;
    }
  }
  if (isConformant()) {
    return NativeWeakSet;
  }
  var PolyfillWeakSet = function(opt_iterable) {
    this.map_ = new WeakMap;
    if (opt_iterable) {
      $jscomp.initSymbol();
      $jscomp.initSymbolIterator();
      var iter = $jscomp.makeIterator(opt_iterable);
      var entry;
      while (!(entry = iter.next()).done) {
        var item = entry.value;
        this.add(item);
      }
    }
  };
  PolyfillWeakSet.prototype.add = function(elem) {
    this.map_.set(elem, true);
    return this;
  };
  PolyfillWeakSet.prototype.has = function(elem) {
    return this.map_.has(elem);
  };
  PolyfillWeakSet.prototype.delete = function(elem) {
    return this.map_.delete(elem);
  };
  return PolyfillWeakSet;
}, "es6", "es3");
var COMPILED = false;
var goog = goog || {};
goog.global = this;
goog.global.CLOSURE_UNCOMPILED_DEFINES;
goog.global.CLOSURE_DEFINES;
goog.isDef = function(val) {
  return val !== void 0;
};
goog.isString = function(val) {
  return typeof val == "string";
};
goog.isBoolean = function(val) {
  return typeof val == "boolean";
};
goog.isNumber = function(val) {
  return typeof val == "number";
};
goog.exportPath_ = function(name, opt_object, opt_objectToExportTo) {
  var parts = name.split(".");
  var cur = opt_objectToExportTo || goog.global;
  if (!(parts[0] in cur) && cur.execScript) {
    cur.execScript("var " + parts[0]);
  }
  for (var part; parts.length && (part = parts.shift());) {
    if (!parts.length && goog.isDef(opt_object)) {
      cur[part] = opt_object;
    } else {
      if (cur[part] && cur[part] !== Object.prototype[part]) {
        cur = cur[part];
      } else {
        cur = cur[part] = {};
      }
    }
  }
};
goog.define = function(name, defaultValue) {
  var value = defaultValue;
  if (!COMPILED) {
    if (goog.global.CLOSURE_UNCOMPILED_DEFINES && goog.global.CLOSURE_UNCOMPILED_DEFINES.nodeType === undefined && Object.prototype.hasOwnProperty.call(goog.global.CLOSURE_UNCOMPILED_DEFINES, name)) {
      value = goog.global.CLOSURE_UNCOMPILED_DEFINES[name];
    } else {
      if (goog.global.CLOSURE_DEFINES && goog.global.CLOSURE_DEFINES.nodeType === undefined && Object.prototype.hasOwnProperty.call(goog.global.CLOSURE_DEFINES, name)) {
        value = goog.global.CLOSURE_DEFINES[name];
      }
    }
  }
  goog.exportPath_(name, value);
};
goog.define("goog.DEBUG", true);
goog.define("goog.LOCALE", "en");
goog.define("goog.TRUSTED_SITE", true);
goog.define("goog.STRICT_MODE_COMPATIBLE", false);
goog.define("goog.DISALLOW_TEST_ONLY_CODE", COMPILED && !goog.DEBUG);
goog.define("goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING", false);
goog.provide = function(name) {
  if (goog.isInModuleLoader_()) {
    throw new Error("goog.provide can not be used within a goog.module.");
  }
  if (!COMPILED) {
    if (goog.isProvided_(name)) {
      throw new Error('Namespace "' + name + '" already declared.');
    }
  }
  goog.constructNamespace_(name);
};
goog.constructNamespace_ = function(name, opt_obj) {
  if (!COMPILED) {
    delete goog.implicitNamespaces_[name];
    var namespace = name;
    while (namespace = namespace.substring(0, namespace.lastIndexOf("."))) {
      if (goog.getObjectByName(namespace)) {
        break;
      }
      goog.implicitNamespaces_[namespace] = true;
    }
  }
  goog.exportPath_(name, opt_obj);
};
goog.VALID_MODULE_RE_ = /^[a-zA-Z_$][a-zA-Z0-9._$]*$/;
goog.module = function(name) {
  if (!goog.isString(name) || !name || name.search(goog.VALID_MODULE_RE_) == -1) {
    throw new Error("Invalid module identifier");
  }
  if (!goog.isInModuleLoader_()) {
    throw new Error("Module " + name + " has been loaded incorrectly. Note, " + "modules cannot be loaded as normal scripts. They require some kind of " + "pre-processing step. You're likely trying to load a module via a " + "script tag or as a part of a concatenated bundle without rewriting the " + "module. For more info see: " + "https://github.com/google/closure-library/wiki/goog.module:-an-ES6-module-like-alternative-to-goog.provide.");
  }
  if (goog.moduleLoaderState_.moduleName) {
    throw new Error("goog.module may only be called once per module.");
  }
  goog.moduleLoaderState_.moduleName = name;
  if (!COMPILED) {
    if (goog.isProvided_(name)) {
      throw new Error('Namespace "' + name + '" already declared.');
    }
    delete goog.implicitNamespaces_[name];
  }
};
goog.module.get = function(name) {
  return goog.module.getInternal_(name);
};
goog.module.getInternal_ = function(name) {
  if (!COMPILED) {
    if (name in goog.loadedModules_) {
      return goog.loadedModules_[name];
    } else {
      if (!goog.implicitNamespaces_[name]) {
        var ns = goog.getObjectByName(name);
        return ns != null ? ns : null;
      }
    }
  }
  return null;
};
goog.moduleLoaderState_ = null;
goog.isInModuleLoader_ = function() {
  return goog.moduleLoaderState_ != null;
};
goog.module.declareLegacyNamespace = function() {
  if (!COMPILED && !goog.isInModuleLoader_()) {
    throw new Error("goog.module.declareLegacyNamespace must be called from " + "within a goog.module");
  }
  if (!COMPILED && !goog.moduleLoaderState_.moduleName) {
    throw new Error("goog.module must be called prior to " + "goog.module.declareLegacyNamespace.");
  }
  goog.moduleLoaderState_.declareLegacyNamespace = true;
};
goog.setTestOnly = function(opt_message) {
  if (goog.DISALLOW_TEST_ONLY_CODE) {
    opt_message = opt_message || "";
    throw new Error("Importing test-only code into non-debug environment" + (opt_message ? ": " + opt_message : "."));
  }
};
goog.forwardDeclare = function(name) {
};
goog.forwardDeclare("Document");
goog.forwardDeclare("HTMLScriptElement");
goog.forwardDeclare("XMLHttpRequest");
if (!COMPILED) {
  goog.isProvided_ = function(name) {
    return name in goog.loadedModules_ || !goog.implicitNamespaces_[name] && goog.isDefAndNotNull(goog.getObjectByName(name));
  };
  goog.implicitNamespaces_ = {"goog.module":true};
}
goog.getObjectByName = function(name, opt_obj) {
  var parts = name.split(".");
  var cur = opt_obj || goog.global;
  for (var i = 0; i < parts.length; i++) {
    cur = cur[parts[i]];
    if (!goog.isDefAndNotNull(cur)) {
      return null;
    }
  }
  return cur;
};
goog.globalize = function(obj, opt_global) {
  var global = opt_global || goog.global;
  for (var x in obj) {
    global[x] = obj[x];
  }
};
goog.addDependency = function(relPath, provides, requires, opt_loadFlags) {
  if (goog.DEPENDENCIES_ENABLED) {
    var provide, require;
    var path = relPath.replace(/\\/g, "/");
    var deps = goog.dependencies_;
    if (!opt_loadFlags || typeof opt_loadFlags === "boolean") {
      opt_loadFlags = opt_loadFlags ? {"module":"goog"} : {};
    }
    for (var i = 0; provide = provides[i]; i++) {
      deps.nameToPath[provide] = path;
      deps.loadFlags[path] = opt_loadFlags;
    }
    for (var j = 0; require = requires[j]; j++) {
      if (!(path in deps.requires)) {
        deps.requires[path] = {};
      }
      deps.requires[path][require] = true;
    }
  }
};
goog.define("goog.ENABLE_DEBUG_LOADER", true);
goog.logToConsole_ = function(msg) {
  if (goog.global.console) {
    goog.global.console["error"](msg);
  }
};
goog.require = function(name) {
  if (!COMPILED) {
    if (goog.ENABLE_DEBUG_LOADER && goog.IS_OLD_IE_) {
      goog.maybeProcessDeferredDep_(name);
    }
    if (goog.isProvided_(name)) {
      if (goog.isInModuleLoader_()) {
        return goog.module.getInternal_(name);
      }
    } else {
      if (goog.ENABLE_DEBUG_LOADER) {
        var path = goog.getPathFromDeps_(name);
        if (path) {
          goog.writeScripts_(path);
        } else {
          var errorMessage = "goog.require could not find: " + name;
          goog.logToConsole_(errorMessage);
          throw new Error(errorMessage);
        }
      }
    }
    return null;
  }
};
goog.basePath = "";
goog.global.CLOSURE_BASE_PATH;
goog.global.CLOSURE_NO_DEPS;
goog.global.CLOSURE_IMPORT_SCRIPT;
goog.nullFunction = function() {
};
goog.abstractMethod = function() {
  throw new Error("unimplemented abstract method");
};
goog.addSingletonGetter = function(ctor) {
  ctor.instance_ = undefined;
  ctor.getInstance = function() {
    if (ctor.instance_) {
      return ctor.instance_;
    }
    if (goog.DEBUG) {
      goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = ctor;
    }
    return ctor.instance_ = new ctor;
  };
};
goog.instantiatedSingletons_ = [];
goog.define("goog.LOAD_MODULE_USING_EVAL", true);
goog.define("goog.SEAL_MODULE_EXPORTS", goog.DEBUG);
goog.loadedModules_ = {};
goog.DEPENDENCIES_ENABLED = !COMPILED && goog.ENABLE_DEBUG_LOADER;
goog.define("goog.TRANSPILE", "detect");
goog.define("goog.TRANSPILER", "transpile.js");
if (goog.DEPENDENCIES_ENABLED) {
  goog.dependencies_ = {loadFlags:{}, nameToPath:{}, requires:{}, visited:{}, written:{}, deferred:{}};
  goog.inHtmlDocument_ = function() {
    var doc = goog.global.document;
    return doc != null && "write" in doc;
  };
  goog.findBasePath_ = function() {
    if (goog.isDef(goog.global.CLOSURE_BASE_PATH) && goog.isString(goog.global.CLOSURE_BASE_PATH)) {
      goog.basePath = goog.global.CLOSURE_BASE_PATH;
      return;
    } else {
      if (!goog.inHtmlDocument_()) {
        return;
      }
    }
    var doc = goog.global.document;
    var currentScript = doc.currentScript;
    if (currentScript) {
      var scripts = [currentScript];
    } else {
      var scripts = doc.getElementsByTagName("SCRIPT");
    }
    for (var i = scripts.length - 1; i >= 0; --i) {
      var script = scripts[i];
      var src = script.src;
      var qmark = src.lastIndexOf("?");
      var l = qmark == -1 ? src.length : qmark;
      if (src.substr(l - 7, 7) == "base.js") {
        goog.basePath = src.substr(0, l - 7);
        return;
      }
    }
  };
  goog.importScript_ = function(src, opt_sourceText) {
    var importScript = goog.global.CLOSURE_IMPORT_SCRIPT || goog.writeScriptTag_;
    if (importScript(src, opt_sourceText)) {
      goog.dependencies_.written[src] = true;
    }
  };
  goog.IS_OLD_IE_ = !!(!goog.global.atob && goog.global.document && goog.global.document.all);
  goog.oldIeWaiting_ = false;
  goog.importProcessedScript_ = function(src, isModule, needsTranspile) {
    var bootstrap = 'goog.retrieveAndExec_("' + src + '", ' + isModule + ", " + needsTranspile + ");";
    goog.importScript_("", bootstrap);
  };
  goog.queuedModules_ = [];
  goog.wrapModule_ = function(srcUrl, scriptText) {
    if (!goog.LOAD_MODULE_USING_EVAL || !goog.isDef(goog.global.JSON)) {
      return "" + "goog.loadModule(function(exports) {" + '"use strict";' + scriptText + "\n" + ";return exports" + "});" + "\n//# sourceURL=" + srcUrl + "\n";
    } else {
      return "" + "goog.loadModule(" + goog.global.JSON.stringify(scriptText + "\n//# sourceURL=" + srcUrl + "\n") + ");";
    }
  };
  goog.loadQueuedModules_ = function() {
    var count = goog.queuedModules_.length;
    if (count > 0) {
      var queue = goog.queuedModules_;
      goog.queuedModules_ = [];
      for (var i = 0; i < count; i++) {
        var path = queue[i];
        goog.maybeProcessDeferredPath_(path);
      }
    }
    goog.oldIeWaiting_ = false;
  };
  goog.maybeProcessDeferredDep_ = function(name) {
    if (goog.isDeferredModule_(name) && goog.allDepsAreAvailable_(name)) {
      var path = goog.getPathFromDeps_(name);
      goog.maybeProcessDeferredPath_(goog.basePath + path);
    }
  };
  goog.isDeferredModule_ = function(name) {
    var path = goog.getPathFromDeps_(name);
    var loadFlags = path && goog.dependencies_.loadFlags[path] || {};
    var languageLevel = loadFlags["lang"] || "es3";
    if (path && (loadFlags["module"] == "goog" || goog.needsTranspile_(languageLevel))) {
      var abspath = goog.basePath + path;
      return abspath in goog.dependencies_.deferred;
    }
    return false;
  };
  goog.allDepsAreAvailable_ = function(name) {
    var path = goog.getPathFromDeps_(name);
    if (path && path in goog.dependencies_.requires) {
      for (var requireName in goog.dependencies_.requires[path]) {
        if (!goog.isProvided_(requireName) && !goog.isDeferredModule_(requireName)) {
          return false;
        }
      }
    }
    return true;
  };
  goog.maybeProcessDeferredPath_ = function(abspath) {
    if (abspath in goog.dependencies_.deferred) {
      var src = goog.dependencies_.deferred[abspath];
      delete goog.dependencies_.deferred[abspath];
      goog.globalEval(src);
    }
  };
  goog.loadModuleFromUrl = function(url) {
    goog.retrieveAndExec_(url, true, false);
  };
  goog.writeScriptSrcNode_ = function(src) {
    goog.global.document.write('<script type="text/javascript" src="' + src + '"></' + "script>");
  };
  goog.appendScriptSrcNode_ = function(src) {
    var doc = goog.global.document;
    var scriptEl = doc.createElement("script");
    scriptEl.type = "text/javascript";
    scriptEl.src = src;
    scriptEl.defer = false;
    scriptEl.async = false;
    doc.head.appendChild(scriptEl);
  };
  goog.writeScriptTag_ = function(src, opt_sourceText) {
    if (goog.inHtmlDocument_()) {
      var doc = goog.global.document;
      if (!goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING && doc.readyState == "complete") {
        var isDeps = /\bdeps.js$/.test(src);
        if (isDeps) {
          return false;
        } else {
          throw new Error('Cannot write "' + src + '" after document load');
        }
      }
      if (opt_sourceText === undefined) {
        if (!goog.IS_OLD_IE_) {
          if (goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING) {
            goog.appendScriptSrcNode_(src);
          } else {
            goog.writeScriptSrcNode_(src);
          }
        } else {
          goog.oldIeWaiting_ = true;
          var state = " onreadystatechange='goog.onScriptLoad_(this, " + ++goog.lastNonModuleScriptIndex_ + ")' ";
          doc.write('<script type="text/javascript" src="' + src + '"' + state + "></" + "script>");
        }
      } else {
        doc.write('<script type="text/javascript">' + goog.protectScriptTag_(opt_sourceText) + "</" + "script>");
      }
      return true;
    } else {
      return false;
    }
  };
  goog.protectScriptTag_ = function(str) {
    return str.replace(/<\/(SCRIPT)/ig, "\\x3c/$1");
  };
  goog.needsTranspile_ = function(lang) {
    if (goog.TRANSPILE == "always") {
      return true;
    } else {
      if (goog.TRANSPILE == "never") {
        return false;
      } else {
        if (!goog.requiresTranspilation_) {
          goog.requiresTranspilation_ = goog.createRequiresTranspilation_();
        }
      }
    }
    if (lang in goog.requiresTranspilation_) {
      return goog.requiresTranspilation_[lang];
    } else {
      throw new Error("Unknown language mode: " + lang);
    }
  };
  goog.requiresTranspilation_ = null;
  goog.lastNonModuleScriptIndex_ = 0;
  goog.onScriptLoad_ = function(script, scriptIndex) {
    if (script.readyState == "complete" && goog.lastNonModuleScriptIndex_ == scriptIndex) {
      goog.loadQueuedModules_();
    }
    return true;
  };
  goog.writeScripts_ = function(pathToLoad) {
    var scripts = [];
    var seenScript = {};
    var deps = goog.dependencies_;
    function visitNode(path) {
      if (path in deps.written) {
        return;
      }
      if (path in deps.visited) {
        return;
      }
      deps.visited[path] = true;
      if (path in deps.requires) {
        for (var requireName in deps.requires[path]) {
          if (!goog.isProvided_(requireName)) {
            if (requireName in deps.nameToPath) {
              visitNode(deps.nameToPath[requireName]);
            } else {
              throw new Error("Undefined nameToPath for " + requireName);
            }
          }
        }
      }
      if (!(path in seenScript)) {
        seenScript[path] = true;
        scripts.push(path);
      }
    }
    visitNode(pathToLoad);
    for (var i = 0; i < scripts.length; i++) {
      var path = scripts[i];
      goog.dependencies_.written[path] = true;
    }
    var moduleState = goog.moduleLoaderState_;
    goog.moduleLoaderState_ = null;
    for (var i = 0; i < scripts.length; i++) {
      var path = scripts[i];
      if (path) {
        var loadFlags = deps.loadFlags[path] || {};
        var languageLevel = loadFlags["lang"] || "es3";
        var needsTranspile = goog.needsTranspile_(languageLevel);
        if (loadFlags["module"] == "goog" || needsTranspile) {
          goog.importProcessedScript_(goog.basePath + path, loadFlags["module"] == "goog", needsTranspile);
        } else {
          goog.importScript_(goog.basePath + path);
        }
      } else {
        goog.moduleLoaderState_ = moduleState;
        throw new Error("Undefined script input");
      }
    }
    goog.moduleLoaderState_ = moduleState;
  };
  goog.getPathFromDeps_ = function(rule) {
    if (rule in goog.dependencies_.nameToPath) {
      return goog.dependencies_.nameToPath[rule];
    } else {
      return null;
    }
  };
  goog.findBasePath_();
  if (!goog.global.CLOSURE_NO_DEPS) {
    goog.importScript_(goog.basePath + "deps.js");
  }
}
goog.hasBadLetScoping = null;
goog.useSafari10Workaround = function() {
  if (goog.hasBadLetScoping == null) {
    var hasBadLetScoping;
    try {
      hasBadLetScoping = !eval('"use strict";' + "let x = 1; function f() { return typeof x; };" + 'f() == "number";');
    } catch (e) {
      hasBadLetScoping = false;
    }
    goog.hasBadLetScoping = hasBadLetScoping;
  }
  return goog.hasBadLetScoping;
};
goog.workaroundSafari10EvalBug = function(moduleDef) {
  return "(function(){" + moduleDef + "\n" + ";" + "})();\n";
};
goog.loadModule = function(moduleDef) {
  var previousState = goog.moduleLoaderState_;
  try {
    goog.moduleLoaderState_ = {moduleName:undefined, declareLegacyNamespace:false};
    var exports;
    if (goog.isFunction(moduleDef)) {
      exports = moduleDef.call(undefined, {});
    } else {
      if (goog.isString(moduleDef)) {
        if (goog.useSafari10Workaround()) {
          moduleDef = goog.workaroundSafari10EvalBug(moduleDef);
        }
        exports = goog.loadModuleFromSource_.call(undefined, moduleDef);
      } else {
        throw new Error("Invalid module definition");
      }
    }
    var moduleName = goog.moduleLoaderState_.moduleName;
    if (!goog.isString(moduleName) || !moduleName) {
      throw new Error('Invalid module name "' + moduleName + '"');
    }
    if (goog.moduleLoaderState_.declareLegacyNamespace) {
      goog.constructNamespace_(moduleName, exports);
    } else {
      if (goog.SEAL_MODULE_EXPORTS && Object.seal && typeof exports == "object" && exports != null) {
        Object.seal(exports);
      }
    }
    goog.loadedModules_[moduleName] = exports;
  } finally {
    goog.moduleLoaderState_ = previousState;
  }
};
goog.loadModuleFromSource_ = function() {
  var exports = {};
  eval(arguments[0]);
  return exports;
};
goog.normalizePath_ = function(path) {
  var components = path.split("/");
  var i = 0;
  while (i < components.length) {
    if (components[i] == ".") {
      components.splice(i, 1);
    } else {
      if (i && components[i] == ".." && components[i - 1] && components[i - 1] != "..") {
        components.splice(--i, 2);
      } else {
        i++;
      }
    }
  }
  return components.join("/");
};
goog.global.CLOSURE_LOAD_FILE_SYNC;
goog.loadFileSync_ = function(src) {
  if (goog.global.CLOSURE_LOAD_FILE_SYNC) {
    return goog.global.CLOSURE_LOAD_FILE_SYNC(src);
  } else {
    try {
      var xhr = new goog.global["XMLHttpRequest"];
      xhr.open("get", src, false);
      xhr.send();
      return xhr.status == 0 || xhr.status == 200 ? xhr.responseText : null;
    } catch (err) {
      return null;
    }
  }
};
goog.retrieveAndExec_ = function(src, isModule, needsTranspile) {
  if (!COMPILED) {
    var originalPath = src;
    src = goog.normalizePath_(src);
    var importScript = goog.global.CLOSURE_IMPORT_SCRIPT || goog.writeScriptTag_;
    var scriptText = goog.loadFileSync_(src);
    if (scriptText == null) {
      throw new Error('Load of "' + src + '" failed');
    }
    if (needsTranspile) {
      scriptText = goog.transpile_.call(goog.global, scriptText, src);
    }
    if (isModule) {
      scriptText = goog.wrapModule_(src, scriptText);
    } else {
      scriptText += "\n//# sourceURL=" + src;
    }
    var isOldIE = goog.IS_OLD_IE_;
    if (isOldIE && goog.oldIeWaiting_) {
      goog.dependencies_.deferred[originalPath] = scriptText;
      goog.queuedModules_.push(originalPath);
    } else {
      importScript(src, scriptText);
    }
  }
};
goog.transpile_ = function(code, path) {
  var jscomp = goog.global["$jscomp"];
  if (!jscomp) {
    goog.global["$jscomp"] = jscomp = {};
  }
  var transpile = jscomp.transpile;
  if (!transpile) {
    var transpilerPath = goog.basePath + goog.TRANSPILER;
    var transpilerCode = goog.loadFileSync_(transpilerPath);
    if (transpilerCode) {
      eval(transpilerCode + "\n//# sourceURL=" + transpilerPath);
      if (goog.global["$gwtExport"] && goog.global["$gwtExport"]["$jscomp"] && !goog.global["$gwtExport"]["$jscomp"]["transpile"]) {
        throw new Error('The transpiler did not properly export the "transpile" ' + "method. $gwtExport: " + JSON.stringify(goog.global["$gwtExport"]));
      }
      goog.global["$jscomp"].transpile = goog.global["$gwtExport"]["$jscomp"]["transpile"];
      jscomp = goog.global["$jscomp"];
      transpile = jscomp.transpile;
    }
  }
  if (!transpile) {
    var suffix = " requires transpilation but no transpiler was found.";
    transpile = jscomp.transpile = function(code, path) {
      goog.logToConsole_(path + suffix);
      return code;
    };
  }
  return transpile(code, path);
};
goog.typeOf = function(value) {
  var s = typeof value;
  if (s == "object") {
    if (value) {
      if (value instanceof Array) {
        return "array";
      } else {
        if (value instanceof Object) {
          return s;
        }
      }
      var className = Object.prototype.toString.call(value);
      if (className == "[object Window]") {
        return "object";
      }
      if (className == "[object Array]" || typeof value.length == "number" && typeof value.splice != "undefined" && typeof value.propertyIsEnumerable != "undefined" && !value.propertyIsEnumerable("splice")) {
        return "array";
      }
      if (className == "[object Function]" || typeof value.call != "undefined" && typeof value.propertyIsEnumerable != "undefined" && !value.propertyIsEnumerable("call")) {
        return "function";
      }
    } else {
      return "null";
    }
  } else {
    if (s == "function" && typeof value.call == "undefined") {
      return "object";
    }
  }
  return s;
};
goog.isNull = function(val) {
  return val === null;
};
goog.isDefAndNotNull = function(val) {
  return val != null;
};
goog.isArray = function(val) {
  return goog.typeOf(val) == "array";
};
goog.isArrayLike = function(val) {
  var type = goog.typeOf(val);
  return type == "array" || type == "object" && typeof val.length == "number";
};
goog.isDateLike = function(val) {
  return goog.isObject(val) && typeof val.getFullYear == "function";
};
goog.isFunction = function(val) {
  return goog.typeOf(val) == "function";
};
goog.isObject = function(val) {
  var type = typeof val;
  return type == "object" && val != null || type == "function";
};
goog.getUid = function(obj) {
  return obj[goog.UID_PROPERTY_] || (obj[goog.UID_PROPERTY_] = ++goog.uidCounter_);
};
goog.hasUid = function(obj) {
  return !!obj[goog.UID_PROPERTY_];
};
goog.removeUid = function(obj) {
  if (obj !== null && "removeAttribute" in obj) {
    obj.removeAttribute(goog.UID_PROPERTY_);
  }
  try {
    delete obj[goog.UID_PROPERTY_];
  } catch (ex) {
  }
};
goog.UID_PROPERTY_ = "closure_uid_" + (Math.random() * 1e9 >>> 0);
goog.uidCounter_ = 0;
goog.getHashCode = goog.getUid;
goog.removeHashCode = goog.removeUid;
goog.cloneObject = function(obj) {
  var type = goog.typeOf(obj);
  if (type == "object" || type == "array") {
    if (obj.clone) {
      return obj.clone();
    }
    var clone = type == "array" ? [] : {};
    for (var key in obj) {
      clone[key] = goog.cloneObject(obj[key]);
    }
    return clone;
  }
  return obj;
};
goog.bindNative_ = function(fn, selfObj, var_args) {
  return fn.call.apply(fn.bind, arguments);
};
goog.bindJs_ = function(fn, selfObj, var_args) {
  if (!fn) {
    throw new Error;
  }
  if (arguments.length > 2) {
    var boundArgs = Array.prototype.slice.call(arguments, 2);
    return function() {
      var newArgs = Array.prototype.slice.call(arguments);
      Array.prototype.unshift.apply(newArgs, boundArgs);
      return fn.apply(selfObj, newArgs);
    };
  } else {
    return function() {
      return fn.apply(selfObj, arguments);
    };
  }
};
goog.bind = function(fn, selfObj, var_args) {
  if (Function.prototype.bind && Function.prototype.bind.toString().indexOf("native code") != -1) {
    goog.bind = goog.bindNative_;
  } else {
    goog.bind = goog.bindJs_;
  }
  return goog.bind.apply(null, arguments);
};
goog.partial = function(fn, var_args) {
  var args = Array.prototype.slice.call(arguments, 1);
  return function() {
    var newArgs = args.slice();
    newArgs.push.apply(newArgs, arguments);
    return fn.apply(this, newArgs);
  };
};
goog.mixin = function(target, source) {
  for (var x in source) {
    target[x] = source[x];
  }
};
goog.now = goog.TRUSTED_SITE && Date.now || function() {
  return +new Date;
};
goog.globalEval = function(script) {
  if (goog.global.execScript) {
    goog.global.execScript(script, "JavaScript");
  } else {
    if (goog.global.eval) {
      if (goog.evalWorksForGlobals_ == null) {
        goog.global.eval("var _evalTest_ = 1;");
        if (typeof goog.global["_evalTest_"] != "undefined") {
          try {
            delete goog.global["_evalTest_"];
          } catch (ignore) {
          }
          goog.evalWorksForGlobals_ = true;
        } else {
          goog.evalWorksForGlobals_ = false;
        }
      }
      if (goog.evalWorksForGlobals_) {
        goog.global.eval(script);
      } else {
        var doc = goog.global.document;
        var scriptElt = doc.createElement("SCRIPT");
        scriptElt.type = "text/javascript";
        scriptElt.defer = false;
        scriptElt.appendChild(doc.createTextNode(script));
        doc.body.appendChild(scriptElt);
        doc.body.removeChild(scriptElt);
      }
    } else {
      throw new Error("goog.globalEval not available");
    }
  }
};
goog.evalWorksForGlobals_ = null;
goog.cssNameMapping_;
goog.cssNameMappingStyle_;
goog.global.CLOSURE_CSS_NAME_MAP_FN;
goog.getCssName = function(className, opt_modifier) {
  if (String(className).charAt(0) == ".") {
    throw new Error('className passed in goog.getCssName must not start with ".".' + " You passed: " + className);
  }
  var getMapping = function(cssName) {
    return goog.cssNameMapping_[cssName] || cssName;
  };
  var renameByParts = function(cssName) {
    var parts = cssName.split("-");
    var mapped = [];
    for (var i = 0; i < parts.length; i++) {
      mapped.push(getMapping(parts[i]));
    }
    return mapped.join("-");
  };
  var rename;
  if (goog.cssNameMapping_) {
    rename = goog.cssNameMappingStyle_ == "BY_WHOLE" ? getMapping : renameByParts;
  } else {
    rename = function(a) {
      return a;
    };
  }
  var result = opt_modifier ? className + "-" + rename(opt_modifier) : rename(className);
  if (goog.global.CLOSURE_CSS_NAME_MAP_FN) {
    return goog.global.CLOSURE_CSS_NAME_MAP_FN(result);
  }
  return result;
};
goog.setCssNameMapping = function(mapping, opt_style) {
  goog.cssNameMapping_ = mapping;
  goog.cssNameMappingStyle_ = opt_style;
};
goog.global.CLOSURE_CSS_NAME_MAPPING;
if (!COMPILED && goog.global.CLOSURE_CSS_NAME_MAPPING) {
  goog.cssNameMapping_ = goog.global.CLOSURE_CSS_NAME_MAPPING;
}
goog.getMsg = function(str, opt_values) {
  if (opt_values) {
    str = str.replace(/\{\$([^}]+)}/g, function(match, key) {
      return opt_values != null && key in opt_values ? opt_values[key] : match;
    });
  }
  return str;
};
goog.getMsgWithFallback = function(a, b) {
  return a;
};
goog.exportSymbol = function(publicPath, object, opt_objectToExportTo) {
  goog.exportPath_(publicPath, object, opt_objectToExportTo);
};
goog.exportProperty = function(object, publicName, symbol) {
  object[publicName] = symbol;
};
goog.inherits = function(childCtor, parentCtor) {
  function tempCtor() {
  }
  tempCtor.prototype = parentCtor.prototype;
  childCtor.superClass_ = parentCtor.prototype;
  childCtor.prototype = new tempCtor;
  childCtor.prototype.constructor = childCtor;
  childCtor.base = function(me, methodName, var_args) {
    var args = new Array(arguments.length - 2);
    for (var i = 2; i < arguments.length; i++) {
      args[i - 2] = arguments[i];
    }
    return parentCtor.prototype[methodName].apply(me, args);
  };
};
goog.base = function(me, opt_methodName, var_args) {
  var caller = arguments.callee.caller;
  if (goog.STRICT_MODE_COMPATIBLE || goog.DEBUG && !caller) {
    throw new Error("arguments.caller not defined.  goog.base() cannot be used " + "with strict mode code. See " + "http://www.ecma-international.org/ecma-262/5.1/#sec-C");
  }
  if (caller.superClass_) {
    var ctorArgs = new Array(arguments.length - 1);
    for (var i = 1; i < arguments.length; i++) {
      ctorArgs[i - 1] = arguments[i];
    }
    return caller.superClass_.constructor.apply(me, ctorArgs);
  }
  var args = new Array(arguments.length - 2);
  for (var i = 2; i < arguments.length; i++) {
    args[i - 2] = arguments[i];
  }
  var foundCaller = false;
  for (var ctor = me.constructor; ctor; ctor = ctor.superClass_ && ctor.superClass_.constructor) {
    if (ctor.prototype[opt_methodName] === caller) {
      foundCaller = true;
    } else {
      if (foundCaller) {
        return ctor.prototype[opt_methodName].apply(me, args);
      }
    }
  }
  if (me[opt_methodName] === caller) {
    return me.constructor.prototype[opt_methodName].apply(me, args);
  } else {
    throw new Error("goog.base called from a method of one name " + "to a method of a different name");
  }
};
goog.scope = function(fn) {
  if (goog.isInModuleLoader_()) {
    throw new Error("goog.scope is not supported within a goog.module.");
  }
  fn.call(goog.global);
};
if (!COMPILED) {
  goog.global["COMPILED"] = COMPILED;
}
goog.defineClass = function(superClass, def) {
  var constructor = def.constructor;
  var statics = def.statics;
  if (!constructor || constructor == Object.prototype.constructor) {
    constructor = function() {
      throw new Error("cannot instantiate an interface (no constructor defined).");
    };
  }
  var cls = goog.defineClass.createSealingConstructor_(constructor, superClass);
  if (superClass) {
    goog.inherits(cls, superClass);
  }
  delete def.constructor;
  delete def.statics;
  goog.defineClass.applyProperties_(cls.prototype, def);
  if (statics != null) {
    if (statics instanceof Function) {
      statics(cls);
    } else {
      goog.defineClass.applyProperties_(cls, statics);
    }
  }
  return cls;
};
goog.defineClass.ClassDescriptor;
goog.define("goog.defineClass.SEAL_CLASS_INSTANCES", goog.DEBUG);
goog.defineClass.createSealingConstructor_ = function(ctr, superClass) {
  if (!goog.defineClass.SEAL_CLASS_INSTANCES) {
    return ctr;
  }
  var superclassSealable = !goog.defineClass.isUnsealable_(superClass);
  var wrappedCtr = function() {
    var instance = ctr.apply(this, arguments) || this;
    instance[goog.UID_PROPERTY_] = instance[goog.UID_PROPERTY_];
    if (this.constructor === wrappedCtr && superclassSealable && Object.seal instanceof Function) {
      Object.seal(instance);
    }
    return instance;
  };
  return wrappedCtr;
};
goog.defineClass.isUnsealable_ = function(ctr) {
  return ctr && ctr.prototype && ctr.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_];
};
goog.defineClass.OBJECT_PROTOTYPE_FIELDS_ = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
goog.defineClass.applyProperties_ = function(target, source) {
  var key;
  for (key in source) {
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      target[key] = source[key];
    }
  }
  for (var i = 0; i < goog.defineClass.OBJECT_PROTOTYPE_FIELDS_.length; i++) {
    key = goog.defineClass.OBJECT_PROTOTYPE_FIELDS_[i];
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      target[key] = source[key];
    }
  }
};
goog.tagUnsealableClass = function(ctr) {
  if (!COMPILED && goog.defineClass.SEAL_CLASS_INSTANCES) {
    ctr.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_] = true;
  }
};
goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_ = "goog_defineClass_legacy_unsealable";
goog.createRequiresTranspilation_ = function() {
  var requiresTranspilation = {"es3":false};
  var transpilationRequiredForAllLaterModes = false;
  function addNewerLanguageTranspilationCheck(modeName, isSupported) {
    if (transpilationRequiredForAllLaterModes) {
      requiresTranspilation[modeName] = true;
    } else {
      if (isSupported()) {
        requiresTranspilation[modeName] = false;
      } else {
        requiresTranspilation[modeName] = true;
        transpilationRequiredForAllLaterModes = true;
      }
    }
  }
  function evalCheck(code) {
    try {
      return !!eval(code);
    } catch (ignored) {
      return false;
    }
  }
  var userAgent = goog.global.navigator && goog.global.navigator.userAgent ? goog.global.navigator.userAgent : "";
  addNewerLanguageTranspilationCheck("es5", function() {
    return evalCheck("[1,].length==1");
  });
  addNewerLanguageTranspilationCheck("es6", function() {
    var re = /Edge\/(\d+)(\.\d)*/i;
    var edgeUserAgent = userAgent.match(re);
    if (edgeUserAgent && Number(edgeUserAgent[1]) < 15) {
      return false;
    }
    var es6fullTest = "class X{constructor(){if(new.target!=String)throw 1;this.x=42}}" + "let q=Reflect.construct(X,[],String);if(q.x!=42||!(q instanceof " + "String))throw 1;for(const a of[2,3]){if(a==2)continue;function " + "f(z={a}){let a=0;return z.a}{function f(){return 0;}}return f()" + "==3}";
    return evalCheck('(()=>{"use strict";' + es6fullTest + "})()");
  });
  addNewerLanguageTranspilationCheck("es6-impl", function() {
    return true;
  });
  addNewerLanguageTranspilationCheck("es7", function() {
    return evalCheck("2 ** 2 == 4");
  });
  addNewerLanguageTranspilationCheck("es8", function() {
    return evalCheck("async () => 1, true");
  });
  return requiresTranspilation;
};
goog.provide("goog.debug.Error");
goog.debug.Error = function(opt_msg) {
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, goog.debug.Error);
  } else {
    var stack = (new Error).stack;
    if (stack) {
      this.stack = stack;
    }
  }
  if (opt_msg) {
    this.message = String(opt_msg);
  }
  this.reportErrorToServer = true;
};
goog.inherits(goog.debug.Error, Error);
goog.debug.Error.prototype.name = "CustomError";
goog.provide("goog.dom.NodeType");
goog.dom.NodeType = {ELEMENT:1, ATTRIBUTE:2, TEXT:3, CDATA_SECTION:4, ENTITY_REFERENCE:5, ENTITY:6, PROCESSING_INSTRUCTION:7, COMMENT:8, DOCUMENT:9, DOCUMENT_TYPE:10, DOCUMENT_FRAGMENT:11, NOTATION:12};
goog.provide("goog.string");
goog.provide("goog.string.Unicode");
goog.define("goog.string.DETECT_DOUBLE_ESCAPING", false);
goog.define("goog.string.FORCE_NON_DOM_HTML_UNESCAPING", false);
goog.string.Unicode = {NBSP:"\u00a0"};
goog.string.startsWith = function(str, prefix) {
  return str.lastIndexOf(prefix, 0) == 0;
};
goog.string.endsWith = function(str, suffix) {
  var l = str.length - suffix.length;
  return l >= 0 && str.indexOf(suffix, l) == l;
};
goog.string.caseInsensitiveStartsWith = function(str, prefix) {
  return goog.string.caseInsensitiveCompare(prefix, str.substr(0, prefix.length)) == 0;
};
goog.string.caseInsensitiveEndsWith = function(str, suffix) {
  return goog.string.caseInsensitiveCompare(suffix, str.substr(str.length - suffix.length, suffix.length)) == 0;
};
goog.string.caseInsensitiveEquals = function(str1, str2) {
  return str1.toLowerCase() == str2.toLowerCase();
};
goog.string.subs = function(str, var_args) {
  var splitParts = str.split("%s");
  var returnString = "";
  var subsArguments = Array.prototype.slice.call(arguments, 1);
  while (subsArguments.length && splitParts.length > 1) {
    returnString += splitParts.shift() + subsArguments.shift();
  }
  return returnString + splitParts.join("%s");
};
goog.string.collapseWhitespace = function(str) {
  return str.replace(/[\s\xa0]+/g, " ").replace(/^\s+|\s+$/g, "");
};
goog.string.isEmptyOrWhitespace = function(str) {
  return /^[\s\xa0]*$/.test(str);
};
goog.string.isEmptyString = function(str) {
  return str.length == 0;
};
goog.string.isEmpty = goog.string.isEmptyOrWhitespace;
goog.string.isEmptyOrWhitespaceSafe = function(str) {
  return goog.string.isEmptyOrWhitespace(goog.string.makeSafe(str));
};
goog.string.isEmptySafe = goog.string.isEmptyOrWhitespaceSafe;
goog.string.isBreakingWhitespace = function(str) {
  return !/[^\t\n\r ]/.test(str);
};
goog.string.isAlpha = function(str) {
  return !/[^a-zA-Z]/.test(str);
};
goog.string.isNumeric = function(str) {
  return !/[^0-9]/.test(str);
};
goog.string.isAlphaNumeric = function(str) {
  return !/[^a-zA-Z0-9]/.test(str);
};
goog.string.isSpace = function(ch) {
  return ch == " ";
};
goog.string.isUnicodeChar = function(ch) {
  return ch.length == 1 && ch >= " " && ch <= "~" || ch >= "\u0080" && ch <= "\ufffd";
};
goog.string.stripNewlines = function(str) {
  return str.replace(/(\r\n|\r|\n)+/g, " ");
};
goog.string.canonicalizeNewlines = function(str) {
  return str.replace(/(\r\n|\r|\n)/g, "\n");
};
goog.string.normalizeWhitespace = function(str) {
  return str.replace(/\xa0|\s/g, " ");
};
goog.string.normalizeSpaces = function(str) {
  return str.replace(/\xa0|[ \t]+/g, " ");
};
goog.string.collapseBreakingSpaces = function(str) {
  return str.replace(/[\t\r\n ]+/g, " ").replace(/^[\t\r\n ]+|[\t\r\n ]+$/g, "");
};
goog.string.trim = goog.TRUSTED_SITE && String.prototype.trim ? function(str) {
  return str.trim();
} : function(str) {
  return str.replace(/^[\s\xa0]+|[\s\xa0]+$/g, "");
};
goog.string.trimLeft = function(str) {
  return str.replace(/^[\s\xa0]+/, "");
};
goog.string.trimRight = function(str) {
  return str.replace(/[\s\xa0]+$/, "");
};
goog.string.caseInsensitiveCompare = function(str1, str2) {
  var test1 = String(str1).toLowerCase();
  var test2 = String(str2).toLowerCase();
  if (test1 < test2) {
    return -1;
  } else {
    if (test1 == test2) {
      return 0;
    } else {
      return 1;
    }
  }
};
goog.string.numberAwareCompare_ = function(str1, str2, tokenizerRegExp) {
  if (str1 == str2) {
    return 0;
  }
  if (!str1) {
    return -1;
  }
  if (!str2) {
    return 1;
  }
  var tokens1 = str1.toLowerCase().match(tokenizerRegExp);
  var tokens2 = str2.toLowerCase().match(tokenizerRegExp);
  var count = Math.min(tokens1.length, tokens2.length);
  for (var i = 0; i < count; i++) {
    var a = tokens1[i];
    var b = tokens2[i];
    if (a != b) {
      var num1 = parseInt(a, 10);
      if (!isNaN(num1)) {
        var num2 = parseInt(b, 10);
        if (!isNaN(num2) && num1 - num2) {
          return num1 - num2;
        }
      }
      return a < b ? -1 : 1;
    }
  }
  if (tokens1.length != tokens2.length) {
    return tokens1.length - tokens2.length;
  }
  return str1 < str2 ? -1 : 1;
};
goog.string.intAwareCompare = function(str1, str2) {
  return goog.string.numberAwareCompare_(str1, str2, /\d+|\D+/g);
};
goog.string.floatAwareCompare = function(str1, str2) {
  return goog.string.numberAwareCompare_(str1, str2, /\d+|\.\d+|\D+/g);
};
goog.string.numerateCompare = goog.string.floatAwareCompare;
goog.string.urlEncode = function(str) {
  return encodeURIComponent(String(str));
};
goog.string.urlDecode = function(str) {
  return decodeURIComponent(str.replace(/\+/g, " "));
};
goog.string.newLineToBr = function(str, opt_xml) {
  return str.replace(/(\r\n|\r|\n)/g, opt_xml ? "<br />" : "<br>");
};
goog.string.htmlEscape = function(str, opt_isLikelyToContainHtmlChars) {
  if (opt_isLikelyToContainHtmlChars) {
    str = str.replace(goog.string.AMP_RE_, "&amp;").replace(goog.string.LT_RE_, "&lt;").replace(goog.string.GT_RE_, "&gt;").replace(goog.string.QUOT_RE_, "&quot;").replace(goog.string.SINGLE_QUOTE_RE_, "&#39;").replace(goog.string.NULL_RE_, "&#0;");
    if (goog.string.DETECT_DOUBLE_ESCAPING) {
      str = str.replace(goog.string.E_RE_, "&#101;");
    }
    return str;
  } else {
    if (!goog.string.ALL_RE_.test(str)) {
      return str;
    }
    if (str.indexOf("&") != -1) {
      str = str.replace(goog.string.AMP_RE_, "&amp;");
    }
    if (str.indexOf("<") != -1) {
      str = str.replace(goog.string.LT_RE_, "&lt;");
    }
    if (str.indexOf(">") != -1) {
      str = str.replace(goog.string.GT_RE_, "&gt;");
    }
    if (str.indexOf('"') != -1) {
      str = str.replace(goog.string.QUOT_RE_, "&quot;");
    }
    if (str.indexOf("'") != -1) {
      str = str.replace(goog.string.SINGLE_QUOTE_RE_, "&#39;");
    }
    if (str.indexOf("\x00") != -1) {
      str = str.replace(goog.string.NULL_RE_, "&#0;");
    }
    if (goog.string.DETECT_DOUBLE_ESCAPING && str.indexOf("e") != -1) {
      str = str.replace(goog.string.E_RE_, "&#101;");
    }
    return str;
  }
};
goog.string.AMP_RE_ = /&/g;
goog.string.LT_RE_ = /</g;
goog.string.GT_RE_ = />/g;
goog.string.QUOT_RE_ = /"/g;
goog.string.SINGLE_QUOTE_RE_ = /'/g;
goog.string.NULL_RE_ = /\x00/g;
goog.string.E_RE_ = /e/g;
goog.string.ALL_RE_ = goog.string.DETECT_DOUBLE_ESCAPING ? /[\x00&<>"'e]/ : /[\x00&<>"']/;
goog.string.unescapeEntities = function(str) {
  if (goog.string.contains(str, "&")) {
    if (!goog.string.FORCE_NON_DOM_HTML_UNESCAPING && "document" in goog.global) {
      return goog.string.unescapeEntitiesUsingDom_(str);
    } else {
      return goog.string.unescapePureXmlEntities_(str);
    }
  }
  return str;
};
goog.string.unescapeEntitiesWithDocument = function(str, document) {
  if (goog.string.contains(str, "&")) {
    return goog.string.unescapeEntitiesUsingDom_(str, document);
  }
  return str;
};
goog.string.unescapeEntitiesUsingDom_ = function(str, opt_document) {
  var seen = {"&amp;":"&", "&lt;":"<", "&gt;":">", "&quot;":'"'};
  var div;
  if (opt_document) {
    div = opt_document.createElement("div");
  } else {
    div = goog.global.document.createElement("div");
  }
  return str.replace(goog.string.HTML_ENTITY_PATTERN_, function(s, entity) {
    var value = seen[s];
    if (value) {
      return value;
    }
    if (entity.charAt(0) == "#") {
      var n = Number("0" + entity.substr(1));
      if (!isNaN(n)) {
        value = String.fromCharCode(n);
      }
    }
    if (!value) {
      div.innerHTML = s + " ";
      value = div.firstChild.nodeValue.slice(0, -1);
    }
    return seen[s] = value;
  });
};
goog.string.unescapePureXmlEntities_ = function(str) {
  return str.replace(/&([^;]+);/g, function(s, entity) {
    switch(entity) {
      case "amp":
        return "&";
      case "lt":
        return "<";
      case "gt":
        return ">";
      case "quot":
        return '"';
      default:
        if (entity.charAt(0) == "#") {
          var n = Number("0" + entity.substr(1));
          if (!isNaN(n)) {
            return String.fromCharCode(n);
          }
        }
        return s;
    }
  });
};
goog.string.HTML_ENTITY_PATTERN_ = /&([^;\s<&]+);?/g;
goog.string.whitespaceEscape = function(str, opt_xml) {
  return goog.string.newLineToBr(str.replace(/  /g, " &#160;"), opt_xml);
};
goog.string.preserveSpaces = function(str) {
  return str.replace(/(^|[\n ]) /g, "$1" + goog.string.Unicode.NBSP);
};
goog.string.stripQuotes = function(str, quoteChars) {
  var length = quoteChars.length;
  for (var i = 0; i < length; i++) {
    var quoteChar = length == 1 ? quoteChars : quoteChars.charAt(i);
    if (str.charAt(0) == quoteChar && str.charAt(str.length - 1) == quoteChar) {
      return str.substring(1, str.length - 1);
    }
  }
  return str;
};
goog.string.truncate = function(str, chars, opt_protectEscapedCharacters) {
  if (opt_protectEscapedCharacters) {
    str = goog.string.unescapeEntities(str);
  }
  if (str.length > chars) {
    str = str.substring(0, chars - 3) + "...";
  }
  if (opt_protectEscapedCharacters) {
    str = goog.string.htmlEscape(str);
  }
  return str;
};
goog.string.truncateMiddle = function(str, chars, opt_protectEscapedCharacters, opt_trailingChars) {
  if (opt_protectEscapedCharacters) {
    str = goog.string.unescapeEntities(str);
  }
  if (opt_trailingChars && str.length > chars) {
    if (opt_trailingChars > chars) {
      opt_trailingChars = chars;
    }
    var endPoint = str.length - opt_trailingChars;
    var startPoint = chars - opt_trailingChars;
    str = str.substring(0, startPoint) + "..." + str.substring(endPoint);
  } else {
    if (str.length > chars) {
      var half = Math.floor(chars / 2);
      var endPos = str.length - half;
      half += chars % 2;
      str = str.substring(0, half) + "..." + str.substring(endPos);
    }
  }
  if (opt_protectEscapedCharacters) {
    str = goog.string.htmlEscape(str);
  }
  return str;
};
goog.string.specialEscapeChars_ = {"\x00":"\\0", "\b":"\\b", "\f":"\\f", "\n":"\\n", "\r":"\\r", "\t":"\\t", "\x0B":"\\x0B", '"':'\\"', "\\":"\\\\", "<":"<"};
goog.string.jsEscapeCache_ = {"'":"\\'"};
goog.string.quote = function(s) {
  s = String(s);
  var sb = ['"'];
  for (var i = 0; i < s.length; i++) {
    var ch = s.charAt(i);
    var cc = ch.charCodeAt(0);
    sb[i + 1] = goog.string.specialEscapeChars_[ch] || (cc > 31 && cc < 127 ? ch : goog.string.escapeChar(ch));
  }
  sb.push('"');
  return sb.join("");
};
goog.string.escapeString = function(str) {
  var sb = [];
  for (var i = 0; i < str.length; i++) {
    sb[i] = goog.string.escapeChar(str.charAt(i));
  }
  return sb.join("");
};
goog.string.escapeChar = function(c) {
  if (c in goog.string.jsEscapeCache_) {
    return goog.string.jsEscapeCache_[c];
  }
  if (c in goog.string.specialEscapeChars_) {
    return goog.string.jsEscapeCache_[c] = goog.string.specialEscapeChars_[c];
  }
  var rv = c;
  var cc = c.charCodeAt(0);
  if (cc > 31 && cc < 127) {
    rv = c;
  } else {
    if (cc < 256) {
      rv = "\\x";
      if (cc < 16 || cc > 256) {
        rv += "0";
      }
    } else {
      rv = "\\u";
      if (cc < 4096) {
        rv += "0";
      }
    }
    rv += cc.toString(16).toUpperCase();
  }
  return goog.string.jsEscapeCache_[c] = rv;
};
goog.string.contains = function(str, subString) {
  return str.indexOf(subString) != -1;
};
goog.string.caseInsensitiveContains = function(str, subString) {
  return goog.string.contains(str.toLowerCase(), subString.toLowerCase());
};
goog.string.countOf = function(s, ss) {
  return s && ss ? s.split(ss).length - 1 : 0;
};
goog.string.removeAt = function(s, index, stringLength) {
  var resultStr = s;
  if (index >= 0 && index < s.length && stringLength > 0) {
    resultStr = s.substr(0, index) + s.substr(index + stringLength, s.length - index - stringLength);
  }
  return resultStr;
};
goog.string.remove = function(str, substr) {
  return str.replace(substr, "");
};
goog.string.removeAll = function(s, ss) {
  var re = new RegExp(goog.string.regExpEscape(ss), "g");
  return s.replace(re, "");
};
goog.string.replaceAll = function(s, ss, replacement) {
  var re = new RegExp(goog.string.regExpEscape(ss), "g");
  return s.replace(re, replacement.replace(/\$/g, "$$$$"));
};
goog.string.regExpEscape = function(s) {
  return String(s).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, "\\$1").replace(/\x08/g, "\\x08");
};
goog.string.repeat = String.prototype.repeat ? function(string, length) {
  return string.repeat(length);
} : function(string, length) {
  return (new Array(length + 1)).join(string);
};
goog.string.padNumber = function(num, length, opt_precision) {
  var s = goog.isDef(opt_precision) ? num.toFixed(opt_precision) : String(num);
  var index = s.indexOf(".");
  if (index == -1) {
    index = s.length;
  }
  return goog.string.repeat("0", Math.max(0, length - index)) + s;
};
goog.string.makeSafe = function(obj) {
  return obj == null ? "" : String(obj);
};
goog.string.buildString = function(var_args) {
  return Array.prototype.join.call(arguments, "");
};
goog.string.getRandomString = function() {
  var x = 2147483648;
  return Math.floor(Math.random() * x).toString(36) + Math.abs(Math.floor(Math.random() * x) ^ goog.now()).toString(36);
};
goog.string.compareVersions = function(version1, version2) {
  var order = 0;
  var v1Subs = goog.string.trim(String(version1)).split(".");
  var v2Subs = goog.string.trim(String(version2)).split(".");
  var subCount = Math.max(v1Subs.length, v2Subs.length);
  for (var subIdx = 0; order == 0 && subIdx < subCount; subIdx++) {
    var v1Sub = v1Subs[subIdx] || "";
    var v2Sub = v2Subs[subIdx] || "";
    do {
      var v1Comp = /(\d*)(\D*)(.*)/.exec(v1Sub) || ["", "", "", ""];
      var v2Comp = /(\d*)(\D*)(.*)/.exec(v2Sub) || ["", "", "", ""];
      if (v1Comp[0].length == 0 && v2Comp[0].length == 0) {
        break;
      }
      var v1CompNum = v1Comp[1].length == 0 ? 0 : parseInt(v1Comp[1], 10);
      var v2CompNum = v2Comp[1].length == 0 ? 0 : parseInt(v2Comp[1], 10);
      order = goog.string.compareElements_(v1CompNum, v2CompNum) || goog.string.compareElements_(v1Comp[2].length == 0, v2Comp[2].length == 0) || goog.string.compareElements_(v1Comp[2], v2Comp[2]);
      v1Sub = v1Comp[3];
      v2Sub = v2Comp[3];
    } while (order == 0);
  }
  return order;
};
goog.string.compareElements_ = function(left, right) {
  if (left < right) {
    return -1;
  } else {
    if (left > right) {
      return 1;
    }
  }
  return 0;
};
goog.string.hashCode = function(str) {
  var result = 0;
  for (var i = 0; i < str.length; ++i) {
    result = 31 * result + str.charCodeAt(i) >>> 0;
  }
  return result;
};
goog.string.uniqueStringCounter_ = Math.random() * 2147483648 | 0;
goog.string.createUniqueString = function() {
  return "goog_" + goog.string.uniqueStringCounter_++;
};
goog.string.toNumber = function(str) {
  var num = Number(str);
  if (num == 0 && goog.string.isEmptyOrWhitespace(str)) {
    return NaN;
  }
  return num;
};
goog.string.isLowerCamelCase = function(str) {
  return /^[a-z]+([A-Z][a-z]*)*$/.test(str);
};
goog.string.isUpperCamelCase = function(str) {
  return /^([A-Z][a-z]*)+$/.test(str);
};
goog.string.toCamelCase = function(str) {
  return String(str).replace(/\-([a-z])/g, function(all, match) {
    return match.toUpperCase();
  });
};
goog.string.toSelectorCase = function(str) {
  return String(str).replace(/([A-Z])/g, "-$1").toLowerCase();
};
goog.string.toTitleCase = function(str, opt_delimiters) {
  var delimiters = goog.isString(opt_delimiters) ? goog.string.regExpEscape(opt_delimiters) : "\\s";
  delimiters = delimiters ? "|[" + delimiters + "]+" : "";
  var regexp = new RegExp("(^" + delimiters + ")([a-z])", "g");
  return str.replace(regexp, function(all, p1, p2) {
    return p1 + p2.toUpperCase();
  });
};
goog.string.capitalize = function(str) {
  return String(str.charAt(0)).toUpperCase() + String(str.substr(1)).toLowerCase();
};
goog.string.parseInt = function(value) {
  if (isFinite(value)) {
    value = String(value);
  }
  if (goog.isString(value)) {
    return /^\s*-?0x/i.test(value) ? parseInt(value, 16) : parseInt(value, 10);
  }
  return NaN;
};
goog.string.splitLimit = function(str, separator, limit) {
  var parts = str.split(separator);
  var returnVal = [];
  while (limit > 0 && parts.length) {
    returnVal.push(parts.shift());
    limit--;
  }
  if (parts.length) {
    returnVal.push(parts.join(separator));
  }
  return returnVal;
};
goog.string.lastComponent = function(str, separators) {
  if (!separators) {
    return str;
  } else {
    if (typeof separators == "string") {
      separators = [separators];
    }
  }
  var lastSeparatorIndex = -1;
  for (var i = 0; i < separators.length; i++) {
    if (separators[i] == "") {
      continue;
    }
    var currentSeparatorIndex = str.lastIndexOf(separators[i]);
    if (currentSeparatorIndex > lastSeparatorIndex) {
      lastSeparatorIndex = currentSeparatorIndex;
    }
  }
  if (lastSeparatorIndex == -1) {
    return str;
  }
  return str.slice(lastSeparatorIndex + 1);
};
goog.string.editDistance = function(a, b) {
  var v0 = [];
  var v1 = [];
  if (a == b) {
    return 0;
  }
  if (!a.length || !b.length) {
    return Math.max(a.length, b.length);
  }
  for (var i = 0; i < b.length + 1; i++) {
    v0[i] = i;
  }
  for (var i = 0; i < a.length; i++) {
    v1[0] = i + 1;
    for (var j = 0; j < b.length; j++) {
      var cost = Number(a[i] != b[j]);
      v1[j + 1] = Math.min(v1[j] + 1, v0[j + 1] + 1, v0[j] + cost);
    }
    for (var j = 0; j < v0.length; j++) {
      v0[j] = v1[j];
    }
  }
  return v1[b.length];
};
goog.provide("goog.asserts");
goog.provide("goog.asserts.AssertionError");
goog.require("goog.debug.Error");
goog.require("goog.dom.NodeType");
goog.require("goog.string");
goog.define("goog.asserts.ENABLE_ASSERTS", goog.DEBUG);
goog.asserts.AssertionError = function(messagePattern, messageArgs) {
  messageArgs.unshift(messagePattern);
  goog.debug.Error.call(this, goog.string.subs.apply(null, messageArgs));
  messageArgs.shift();
  this.messagePattern = messagePattern;
};
goog.inherits(goog.asserts.AssertionError, goog.debug.Error);
goog.asserts.AssertionError.prototype.name = "AssertionError";
goog.asserts.DEFAULT_ERROR_HANDLER = function(e) {
  throw e;
};
goog.asserts.errorHandler_ = goog.asserts.DEFAULT_ERROR_HANDLER;
goog.asserts.doAssertFailure_ = function(defaultMessage, defaultArgs, givenMessage, givenArgs) {
  var message = "Assertion failed";
  if (givenMessage) {
    message += ": " + givenMessage;
    var args = givenArgs;
  } else {
    if (defaultMessage) {
      message += ": " + defaultMessage;
      args = defaultArgs;
    }
  }
  var e = new goog.asserts.AssertionError("" + message, args || []);
  goog.asserts.errorHandler_(e);
};
goog.asserts.setErrorHandler = function(errorHandler) {
  if (goog.asserts.ENABLE_ASSERTS) {
    goog.asserts.errorHandler_ = errorHandler;
  }
};
goog.asserts.assert = function(condition, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !condition) {
    goog.asserts.doAssertFailure_("", null, opt_message, Array.prototype.slice.call(arguments, 2));
  }
  return condition;
};
goog.asserts.fail = function(opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS) {
    goog.asserts.errorHandler_(new goog.asserts.AssertionError("Failure" + (opt_message ? ": " + opt_message : ""), Array.prototype.slice.call(arguments, 1)));
  }
};
goog.asserts.assertNumber = function(value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !goog.isNumber(value)) {
    goog.asserts.doAssertFailure_("Expected number but got %s: %s.", [goog.typeOf(value), value], opt_message, Array.prototype.slice.call(arguments, 2));
  }
  return value;
};
goog.asserts.assertString = function(value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !goog.isString(value)) {
    goog.asserts.doAssertFailure_("Expected string but got %s: %s.", [goog.typeOf(value), value], opt_message, Array.prototype.slice.call(arguments, 2));
  }
  return value;
};
goog.asserts.assertFunction = function(value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !goog.isFunction(value)) {
    goog.asserts.doAssertFailure_("Expected function but got %s: %s.", [goog.typeOf(value), value], opt_message, Array.prototype.slice.call(arguments, 2));
  }
  return value;
};
goog.asserts.assertObject = function(value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !goog.isObject(value)) {
    goog.asserts.doAssertFailure_("Expected object but got %s: %s.", [goog.typeOf(value), value], opt_message, Array.prototype.slice.call(arguments, 2));
  }
  return value;
};
goog.asserts.assertArray = function(value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !goog.isArray(value)) {
    goog.asserts.doAssertFailure_("Expected array but got %s: %s.", [goog.typeOf(value), value], opt_message, Array.prototype.slice.call(arguments, 2));
  }
  return value;
};
goog.asserts.assertBoolean = function(value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !goog.isBoolean(value)) {
    goog.asserts.doAssertFailure_("Expected boolean but got %s: %s.", [goog.typeOf(value), value], opt_message, Array.prototype.slice.call(arguments, 2));
  }
  return value;
};
goog.asserts.assertElement = function(value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && (!goog.isObject(value) || value.nodeType != goog.dom.NodeType.ELEMENT)) {
    goog.asserts.doAssertFailure_("Expected Element but got %s: %s.", [goog.typeOf(value), value], opt_message, Array.prototype.slice.call(arguments, 2));
  }
  return value;
};
goog.asserts.assertInstanceof = function(value, type, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !(value instanceof type)) {
    goog.asserts.doAssertFailure_("Expected instanceof %s but got %s.", [goog.asserts.getType_(type), goog.asserts.getType_(value)], opt_message, Array.prototype.slice.call(arguments, 3));
  }
  return value;
};
goog.asserts.assertObjectPrototypeIsIntact = function() {
  for (var key in Object.prototype) {
    goog.asserts.fail(key + " should not be enumerable in Object.prototype.");
  }
};
goog.asserts.getType_ = function(value) {
  if (value instanceof Function) {
    return value.displayName || value.name || "unknown type name";
  } else {
    if (value instanceof Object) {
      return value.constructor.displayName || value.constructor.name || Object.prototype.toString.call(value);
    } else {
      return value === null ? "null" : typeof value;
    }
  }
};
goog.provide("ol");
ol.ASSUME_TOUCH = false;
ol.DEFAULT_MAX_ZOOM = 42;
ol.DEFAULT_MIN_ZOOM = 0;
ol.DEFAULT_RASTER_REPROJECTION_ERROR_THRESHOLD = 0.5;
ol.DEFAULT_TILE_SIZE = 256;
ol.DEFAULT_WMS_VERSION = "1.3.0";
ol.ENABLE_CANVAS = true;
ol.ENABLE_PROJ4JS = true;
ol.ENABLE_RASTER_REPROJECTION = true;
ol.ENABLE_WEBGL = true;
ol.DEBUG_WEBGL = true;
ol.INITIAL_ATLAS_SIZE = 256;
ol.MAX_ATLAS_SIZE = -1;
ol.MOUSEWHEELZOOM_MAXDELTA = 1;
ol.OVERVIEWMAP_MAX_RATIO = 0.75;
ol.OVERVIEWMAP_MIN_RATIO = 0.1;
ol.RASTER_REPROJECTION_MAX_SOURCE_TILES = 100;
ol.RASTER_REPROJECTION_MAX_SUBDIVISION = 10;
ol.RASTER_REPROJECTION_MAX_TRIANGLE_WIDTH = 0.25;
ol.SIMPLIFY_TOLERANCE = 0.5;
ol.WEBGL_TEXTURE_CACHE_HIGH_WATER_MARK = 1024;
ol.VERSION = "";
ol.WEBGL_MAX_TEXTURE_SIZE;
ol.WEBGL_EXTENSIONS;
ol.inherits = function(childCtor, parentCtor) {
  childCtor.prototype = Object.create(parentCtor.prototype);
  childCtor.prototype.constructor = childCtor;
};
ol.nullFunction = function() {
};
ol.getUid = function(obj) {
  return obj.ol_uid || (obj.ol_uid = ++ol.uidCounter_);
};
ol.uidCounter_ = 0;
goog.provide("ol.obj");
ol.obj.assign = typeof Object.assign === "function" ? Object.assign : function(target, var_sources) {
  if (target === undefined || target === null) {
    throw new TypeError("Cannot convert undefined or null to object");
  }
  var output = Object(target);
  for (var i = 1, ii = arguments.length; i < ii; ++i) {
    var source = arguments[i];
    if (source !== undefined && source !== null) {
      for (var key in source) {
        if (source.hasOwnProperty(key)) {
          output[key] = source[key];
        }
      }
    }
  }
  return output;
};
ol.obj.clear = function(object) {
  for (var property in object) {
    delete object[property];
  }
};
ol.obj.getValues = function(object) {
  var values = [];
  for (var property in object) {
    values.push(object[property]);
  }
  return values;
};
ol.obj.isEmpty = function(object) {
  var property;
  for (property in object) {
    return false;
  }
  return !property;
};
goog.provide("ol.events");
goog.require("ol.obj");
ol.events.bindListener_ = function(listenerObj) {
  var boundListener = function(evt) {
    var listener = listenerObj.listener;
    var bindTo = listenerObj.bindTo || listenerObj.target;
    if (listenerObj.callOnce) {
      ol.events.unlistenByKey(listenerObj);
    }
    return listener.call(bindTo, evt);
  };
  listenerObj.boundListener = boundListener;
  return boundListener;
};
ol.events.findListener_ = function(listeners, listener, opt_this, opt_setDeleteIndex) {
  var listenerObj;
  for (var i = 0, ii = listeners.length; i < ii; ++i) {
    listenerObj = listeners[i];
    if (listenerObj.listener === listener && listenerObj.bindTo === opt_this) {
      if (opt_setDeleteIndex) {
        listenerObj.deleteIndex = i;
      }
      return listenerObj;
    }
  }
  return undefined;
};
ol.events.getListeners = function(target, type) {
  var listenerMap = target.ol_lm;
  return listenerMap ? listenerMap[type] : undefined;
};
ol.events.getListenerMap_ = function(target) {
  var listenerMap = target.ol_lm;
  if (!listenerMap) {
    listenerMap = target.ol_lm = {};
  }
  return listenerMap;
};
ol.events.removeListeners_ = function(target, type) {
  var listeners = ol.events.getListeners(target, type);
  if (listeners) {
    for (var i = 0, ii = listeners.length; i < ii; ++i) {
      target.removeEventListener(type, listeners[i].boundListener);
      ol.obj.clear(listeners[i]);
    }
    listeners.length = 0;
    var listenerMap = target.ol_lm;
    if (listenerMap) {
      delete listenerMap[type];
      if (Object.keys(listenerMap).length === 0) {
        delete target.ol_lm;
      }
    }
  }
};
ol.events.listen = function(target, type, listener, opt_this, opt_once) {
  var listenerMap = ol.events.getListenerMap_(target);
  var listeners = listenerMap[type];
  if (!listeners) {
    listeners = listenerMap[type] = [];
  }
  var listenerObj = ol.events.findListener_(listeners, listener, opt_this, false);
  if (listenerObj) {
    if (!opt_once) {
      listenerObj.callOnce = false;
    }
  } else {
    listenerObj = {bindTo:opt_this, callOnce:!!opt_once, listener:listener, target:target, type:type};
    target.addEventListener(type, ol.events.bindListener_(listenerObj));
    listeners.push(listenerObj);
  }
  return listenerObj;
};
ol.events.listenOnce = function(target, type, listener, opt_this) {
  return ol.events.listen(target, type, listener, opt_this, true);
};
ol.events.unlisten = function(target, type, listener, opt_this) {
  var listeners = ol.events.getListeners(target, type);
  if (listeners) {
    var listenerObj = ol.events.findListener_(listeners, listener, opt_this, true);
    if (listenerObj) {
      ol.events.unlistenByKey(listenerObj);
    }
  }
};
ol.events.unlistenByKey = function(key) {
  if (key && key.target) {
    key.target.removeEventListener(key.type, key.boundListener);
    var listeners = ol.events.getListeners(key.target, key.type);
    if (listeners) {
      var i = "deleteIndex" in key ? key.deleteIndex : listeners.indexOf(key);
      if (i !== -1) {
        listeners.splice(i, 1);
      }
      if (listeners.length === 0) {
        ol.events.removeListeners_(key.target, key.type);
      }
    }
    ol.obj.clear(key);
  }
};
ol.events.unlistenAll = function(target) {
  var listenerMap = ol.events.getListenerMap_(target);
  for (var type in listenerMap) {
    ol.events.removeListeners_(target, type);
  }
};
goog.provide("ol.Disposable");
goog.require("ol");
ol.Disposable = function() {
};
ol.Disposable.prototype.disposed_ = false;
ol.Disposable.prototype.dispose = function() {
  if (!this.disposed_) {
    this.disposed_ = true;
    this.disposeInternal();
  }
};
ol.Disposable.prototype.disposeInternal = ol.nullFunction;
goog.provide("ol.events.Event");
ol.events.Event = function(type) {
  this.propagationStopped;
  this.type = type;
  this.target = null;
};
ol.events.Event.prototype.preventDefault = ol.events.Event.prototype.stopPropagation = function() {
  this.propagationStopped = true;
};
ol.events.Event.stopPropagation = function(evt) {
  evt.stopPropagation();
};
ol.events.Event.preventDefault = function(evt) {
  evt.preventDefault();
};
goog.provide("ol.events.EventTarget");
goog.require("ol");
goog.require("ol.Disposable");
goog.require("ol.events");
goog.require("ol.events.Event");
ol.events.EventTarget = function() {
  ol.Disposable.call(this);
  this.pendingRemovals_ = {};
  this.dispatching_ = {};
  this.listeners_ = {};
};
ol.inherits(ol.events.EventTarget, ol.Disposable);
ol.events.EventTarget.prototype.addEventListener = function(type, listener) {
  var listeners = this.listeners_[type];
  if (!listeners) {
    listeners = this.listeners_[type] = [];
  }
  if (listeners.indexOf(listener) === -1) {
    listeners.push(listener);
  }
};
ol.events.EventTarget.prototype.dispatchEvent = function(event) {
  var evt = typeof event === "string" ? new ol.events.Event(event) : event;
  var type = evt.type;
  evt.target = this;
  var listeners = this.listeners_[type];
  var propagate;
  if (listeners) {
    if (!(type in this.dispatching_)) {
      this.dispatching_[type] = 0;
      this.pendingRemovals_[type] = 0;
    }
    ++this.dispatching_[type];
    for (var i = 0, ii = listeners.length; i < ii; ++i) {
      if (listeners[i].call(this, evt) === false || evt.propagationStopped) {
        propagate = false;
        break;
      }
    }
    --this.dispatching_[type];
    if (this.dispatching_[type] === 0) {
      var pendingRemovals = this.pendingRemovals_[type];
      delete this.pendingRemovals_[type];
      while (pendingRemovals--) {
        this.removeEventListener(type, ol.nullFunction);
      }
      delete this.dispatching_[type];
    }
    return propagate;
  }
};
ol.events.EventTarget.prototype.disposeInternal = function() {
  ol.events.unlistenAll(this);
};
ol.events.EventTarget.prototype.getListeners = function(type) {
  return this.listeners_[type];
};
ol.events.EventTarget.prototype.hasListener = function(opt_type) {
  return opt_type ? opt_type in this.listeners_ : Object.keys(this.listeners_).length > 0;
};
ol.events.EventTarget.prototype.removeEventListener = function(type, listener) {
  var listeners = this.listeners_[type];
  if (listeners) {
    var index = listeners.indexOf(listener);
    if (type in this.pendingRemovals_) {
      listeners[index] = ol.nullFunction;
      ++this.pendingRemovals_[type];
    } else {
      listeners.splice(index, 1);
      if (listeners.length === 0) {
        delete this.listeners_[type];
      }
    }
  }
};
goog.provide("ol.events.EventType");
ol.events.EventType = {CHANGE:"change", CLEAR:"clear", CLICK:"click", DBLCLICK:"dblclick", DRAGENTER:"dragenter", DRAGOVER:"dragover", DROP:"drop", ERROR:"error", KEYDOWN:"keydown", KEYPRESS:"keypress", LOAD:"load", MOUSEDOWN:"mousedown", MOUSEMOVE:"mousemove", MOUSEOUT:"mouseout", MOUSEUP:"mouseup", MOUSEWHEEL:"mousewheel", MSPOINTERDOWN:"MSPointerDown", RESIZE:"resize", TOUCHSTART:"touchstart", TOUCHMOVE:"touchmove", TOUCHEND:"touchend", WHEEL:"wheel"};
goog.provide("ol.Observable");
goog.require("ol");
goog.require("ol.events");
goog.require("ol.events.EventTarget");
goog.require("ol.events.EventType");
ol.Observable = function() {
  ol.events.EventTarget.call(this);
  this.revision_ = 0;
};
ol.inherits(ol.Observable, ol.events.EventTarget);
ol.Observable.unByKey = function(key) {
  if (Array.isArray(key)) {
    for (var i = 0, ii = key.length; i < ii; ++i) {
      ol.events.unlistenByKey(key[i]);
    }
  } else {
    ol.events.unlistenByKey(key);
  }
};
ol.Observable.prototype.changed = function() {
  ++this.revision_;
  this.dispatchEvent(ol.events.EventType.CHANGE);
};
ol.Observable.prototype.dispatchEvent;
ol.Observable.prototype.getRevision = function() {
  return this.revision_;
};
ol.Observable.prototype.on = function(type, listener, opt_this) {
  if (Array.isArray(type)) {
    var len = type.length;
    var keys = new Array(len);
    for (var i = 0; i < len; ++i) {
      keys[i] = ol.events.listen(this, type[i], listener, opt_this);
    }
    return keys;
  } else {
    return ol.events.listen(this, type, listener, opt_this);
  }
};
ol.Observable.prototype.once = function(type, listener, opt_this) {
  if (Array.isArray(type)) {
    var len = type.length;
    var keys = new Array(len);
    for (var i = 0; i < len; ++i) {
      keys[i] = ol.events.listenOnce(this, type[i], listener, opt_this);
    }
    return keys;
  } else {
    return ol.events.listenOnce(this, type, listener, opt_this);
  }
};
ol.Observable.prototype.un = function(type, listener, opt_this) {
  if (Array.isArray(type)) {
    for (var i = 0, ii = type.length; i < ii; ++i) {
      ol.events.unlisten(this, type[i], listener, opt_this);
    }
    return;
  } else {
    ol.events.unlisten(this, type, listener, opt_this);
  }
};
goog.provide("ol.AssertionError");
goog.require("ol");
ol.AssertionError = function(code) {
  var path = ol.VERSION ? ol.VERSION.split("-")[0] : "latest";
  this.message = "Assertion failed. See https://openlayers.org/en/" + path + "/doc/errors/#" + code + " for details.";
  this.code = code;
  this.name = "AssertionError";
};
ol.inherits(ol.AssertionError, Error);
goog.provide("ol.CollectionEventType");
ol.CollectionEventType = {ADD:"add", REMOVE:"remove"};
goog.provide("ol.ObjectEventType");
ol.ObjectEventType = {PROPERTYCHANGE:"propertychange"};
goog.provide("ol.Object");
goog.require("ol");
goog.require("ol.ObjectEventType");
goog.require("ol.Observable");
goog.require("ol.events.Event");
goog.require("ol.obj");
ol.Object = function(opt_values) {
  ol.Observable.call(this);
  ol.getUid(this);
  this.values_ = {};
  if (opt_values !== undefined) {
    this.setProperties(opt_values);
  }
};
ol.inherits(ol.Object, ol.Observable);
ol.Object.changeEventTypeCache_ = {};
ol.Object.getChangeEventType = function(key) {
  return ol.Object.changeEventTypeCache_.hasOwnProperty(key) ? ol.Object.changeEventTypeCache_[key] : ol.Object.changeEventTypeCache_[key] = "change:" + key;
};
ol.Object.prototype.get = function(key) {
  var value;
  if (this.values_.hasOwnProperty(key)) {
    value = this.values_[key];
  }
  return value;
};
ol.Object.prototype.getKeys = function() {
  return Object.keys(this.values_);
};
ol.Object.prototype.getProperties = function() {
  return ol.obj.assign({}, this.values_);
};
ol.Object.prototype.notify = function(key, oldValue) {
  var eventType;
  eventType = ol.Object.getChangeEventType(key);
  this.dispatchEvent(new ol.Object.Event(eventType, key, oldValue));
  eventType = ol.ObjectEventType.PROPERTYCHANGE;
  this.dispatchEvent(new ol.Object.Event(eventType, key, oldValue));
};
ol.Object.prototype.set = function(key, value, opt_silent) {
  if (opt_silent) {
    this.values_[key] = value;
  } else {
    var oldValue = this.values_[key];
    this.values_[key] = value;
    if (oldValue !== value) {
      this.notify(key, oldValue);
    }
  }
};
ol.Object.prototype.setProperties = function(values, opt_silent) {
  var key;
  for (key in values) {
    this.set(key, values[key], opt_silent);
  }
};
ol.Object.prototype.unset = function(key, opt_silent) {
  if (key in this.values_) {
    var oldValue = this.values_[key];
    delete this.values_[key];
    if (!opt_silent) {
      this.notify(key, oldValue);
    }
  }
};
ol.Object.Event = function(type, key, oldValue) {
  ol.events.Event.call(this, type);
  this.key = key;
  this.oldValue = oldValue;
};
ol.inherits(ol.Object.Event, ol.events.Event);
goog.provide("ol.Collection");
goog.require("ol");
goog.require("ol.AssertionError");
goog.require("ol.CollectionEventType");
goog.require("ol.Object");
goog.require("ol.events.Event");
ol.Collection = function(opt_array, opt_options) {
  ol.Object.call(this);
  var options = opt_options || {};
  this.unique_ = !!options.unique;
  this.array_ = opt_array ? opt_array : [];
  if (this.unique_) {
    for (var i = 0, ii = this.array_.length; i < ii; ++i) {
      this.assertUnique_(this.array_[i], i);
    }
  }
  this.updateLength_();
};
ol.inherits(ol.Collection, ol.Object);
ol.Collection.prototype.clear = function() {
  while (this.getLength() > 0) {
    this.pop();
  }
};
ol.Collection.prototype.extend = function(arr) {
  var i, ii;
  for (i = 0, ii = arr.length; i < ii; ++i) {
    this.push(arr[i]);
  }
  return this;
};
ol.Collection.prototype.forEach = function(f, opt_this) {
  var fn = opt_this ? f.bind(opt_this) : f;
  var array = this.array_;
  for (var i = 0, ii = array.length; i < ii; ++i) {
    fn(array[i], i, array);
  }
};
ol.Collection.prototype.getArray = function() {
  return this.array_;
};
ol.Collection.prototype.item = function(index) {
  return this.array_[index];
};
ol.Collection.prototype.getLength = function() {
  return this.get(ol.Collection.Property_.LENGTH);
};
ol.Collection.prototype.insertAt = function(index, elem) {
  if (this.unique_) {
    this.assertUnique_(elem);
  }
  this.array_.splice(index, 0, elem);
  this.updateLength_();
  this.dispatchEvent(new ol.Collection.Event(ol.CollectionEventType.ADD, elem));
};
ol.Collection.prototype.pop = function() {
  return this.removeAt(this.getLength() - 1);
};
ol.Collection.prototype.push = function(elem) {
  if (this.unique_) {
    this.assertUnique_(elem);
  }
  var n = this.getLength();
  this.insertAt(n, elem);
  return this.getLength();
};
ol.Collection.prototype.remove = function(elem) {
  var arr = this.array_;
  var i, ii;
  for (i = 0, ii = arr.length; i < ii; ++i) {
    if (arr[i] === elem) {
      return this.removeAt(i);
    }
  }
  return undefined;
};
ol.Collection.prototype.removeAt = function(index) {
  var prev = this.array_[index];
  this.array_.splice(index, 1);
  this.updateLength_();
  this.dispatchEvent(new ol.Collection.Event(ol.CollectionEventType.REMOVE, prev));
  return prev;
};
ol.Collection.prototype.setAt = function(index, elem) {
  var n = this.getLength();
  if (index < n) {
    if (this.unique_) {
      this.assertUnique_(elem, index);
    }
    var prev = this.array_[index];
    this.array_[index] = elem;
    this.dispatchEvent(new ol.Collection.Event(ol.CollectionEventType.REMOVE, prev));
    this.dispatchEvent(new ol.Collection.Event(ol.CollectionEventType.ADD, elem));
  } else {
    var j;
    for (j = n; j < index; ++j) {
      this.insertAt(j, undefined);
    }
    this.insertAt(index, elem);
  }
};
ol.Collection.prototype.updateLength_ = function() {
  this.set(ol.Collection.Property_.LENGTH, this.array_.length);
};
ol.Collection.prototype.assertUnique_ = function(elem, opt_except) {
  for (var i = 0, ii = this.array_.length; i < ii; ++i) {
    if (this.array_[i] === elem && i !== opt_except) {
      throw new ol.AssertionError(58);
    }
  }
};
ol.Collection.Property_ = {LENGTH:"length"};
ol.Collection.Event = function(type, opt_element) {
  ol.events.Event.call(this, type);
  this.element = opt_element;
};
ol.inherits(ol.Collection.Event, ol.events.Event);
goog.provide("ol.asserts");
goog.require("ol.AssertionError");
ol.asserts.assert = function(assertion, errorCode) {
  if (!assertion) {
    throw new ol.AssertionError(errorCode);
  }
};
goog.provide("ol.extent.Corner");
ol.extent.Corner = {BOTTOM_LEFT:"bottom-left", BOTTOM_RIGHT:"bottom-right", TOP_LEFT:"top-left", TOP_RIGHT:"top-right"};
goog.provide("ol.extent.Relationship");
ol.extent.Relationship = {UNKNOWN:0, INTERSECTING:1, ABOVE:2, RIGHT:4, BELOW:8, LEFT:16};
goog.provide("ol.extent");
goog.require("ol.asserts");
goog.require("ol.extent.Corner");
goog.require("ol.extent.Relationship");
ol.extent.boundingExtent = function(coordinates) {
  var extent = ol.extent.createEmpty();
  for (var i = 0, ii = coordinates.length; i < ii; ++i) {
    ol.extent.extendCoordinate(extent, coordinates[i]);
  }
  return extent;
};
ol.extent.boundingExtentXYs_ = function(xs, ys, opt_extent) {
  var minX = Math.min.apply(null, xs);
  var minY = Math.min.apply(null, ys);
  var maxX = Math.max.apply(null, xs);
  var maxY = Math.max.apply(null, ys);
  return ol.extent.createOrUpdate(minX, minY, maxX, maxY, opt_extent);
};
ol.extent.buffer = function(extent, value, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = extent[0] - value;
    opt_extent[1] = extent[1] - value;
    opt_extent[2] = extent[2] + value;
    opt_extent[3] = extent[3] + value;
    return opt_extent;
  } else {
    return [extent[0] - value, extent[1] - value, extent[2] + value, extent[3] + value];
  }
};
ol.extent.clone = function(extent, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = extent[0];
    opt_extent[1] = extent[1];
    opt_extent[2] = extent[2];
    opt_extent[3] = extent[3];
    return opt_extent;
  } else {
    return extent.slice();
  }
};
ol.extent.closestSquaredDistanceXY = function(extent, x, y) {
  var dx, dy;
  if (x < extent[0]) {
    dx = extent[0] - x;
  } else {
    if (extent[2] < x) {
      dx = x - extent[2];
    } else {
      dx = 0;
    }
  }
  if (y < extent[1]) {
    dy = extent[1] - y;
  } else {
    if (extent[3] < y) {
      dy = y - extent[3];
    } else {
      dy = 0;
    }
  }
  return dx * dx + dy * dy;
};
ol.extent.containsCoordinate = function(extent, coordinate) {
  return ol.extent.containsXY(extent, coordinate[0], coordinate[1]);
};
ol.extent.containsExtent = function(extent1, extent2) {
  return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] && extent1[1] <= extent2[1] && extent2[3] <= extent1[3];
};
ol.extent.containsXY = function(extent, x, y) {
  return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];
};
ol.extent.coordinateRelationship = function(extent, coordinate) {
  var minX = extent[0];
  var minY = extent[1];
  var maxX = extent[2];
  var maxY = extent[3];
  var x = coordinate[0];
  var y = coordinate[1];
  var relationship = ol.extent.Relationship.UNKNOWN;
  if (x < minX) {
    relationship = relationship | ol.extent.Relationship.LEFT;
  } else {
    if (x > maxX) {
      relationship = relationship | ol.extent.Relationship.RIGHT;
    }
  }
  if (y < minY) {
    relationship = relationship | ol.extent.Relationship.BELOW;
  } else {
    if (y > maxY) {
      relationship = relationship | ol.extent.Relationship.ABOVE;
    }
  }
  if (relationship === ol.extent.Relationship.UNKNOWN) {
    relationship = ol.extent.Relationship.INTERSECTING;
  }
  return relationship;
};
ol.extent.createEmpty = function() {
  return [Infinity, Infinity, -Infinity, -Infinity];
};
ol.extent.createOrUpdate = function(minX, minY, maxX, maxY, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = minX;
    opt_extent[1] = minY;
    opt_extent[2] = maxX;
    opt_extent[3] = maxY;
    return opt_extent;
  } else {
    return [minX, minY, maxX, maxY];
  }
};
ol.extent.createOrUpdateEmpty = function(opt_extent) {
  return ol.extent.createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, opt_extent);
};
ol.extent.createOrUpdateFromCoordinate = function(coordinate, opt_extent) {
  var x = coordinate[0];
  var y = coordinate[1];
  return ol.extent.createOrUpdate(x, y, x, y, opt_extent);
};
ol.extent.createOrUpdateFromCoordinates = function(coordinates, opt_extent) {
  var extent = ol.extent.createOrUpdateEmpty(opt_extent);
  return ol.extent.extendCoordinates(extent, coordinates);
};
ol.extent.createOrUpdateFromFlatCoordinates = function(flatCoordinates, offset, end, stride, opt_extent) {
  var extent = ol.extent.createOrUpdateEmpty(opt_extent);
  return ol.extent.extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);
};
ol.extent.createOrUpdateFromRings = function(rings, opt_extent) {
  var extent = ol.extent.createOrUpdateEmpty(opt_extent);
  return ol.extent.extendRings(extent, rings);
};
ol.extent.equals = function(extent1, extent2) {
  return extent1[0] == extent2[0] && extent1[2] == extent2[2] && extent1[1] == extent2[1] && extent1[3] == extent2[3];
};
ol.extent.extend = function(extent1, extent2) {
  if (extent2[0] < extent1[0]) {
    extent1[0] = extent2[0];
  }
  if (extent2[2] > extent1[2]) {
    extent1[2] = extent2[2];
  }
  if (extent2[1] < extent1[1]) {
    extent1[1] = extent2[1];
  }
  if (extent2[3] > extent1[3]) {
    extent1[3] = extent2[3];
  }
  return extent1;
};
ol.extent.extendCoordinate = function(extent, coordinate) {
  if (coordinate[0] < extent[0]) {
    extent[0] = coordinate[0];
  }
  if (coordinate[0] > extent[2]) {
    extent[2] = coordinate[0];
  }
  if (coordinate[1] < extent[1]) {
    extent[1] = coordinate[1];
  }
  if (coordinate[1] > extent[3]) {
    extent[3] = coordinate[1];
  }
};
ol.extent.extendCoordinates = function(extent, coordinates) {
  var i, ii;
  for (i = 0, ii = coordinates.length; i < ii; ++i) {
    ol.extent.extendCoordinate(extent, coordinates[i]);
  }
  return extent;
};
ol.extent.extendFlatCoordinates = function(extent, flatCoordinates, offset, end, stride) {
  for (; offset < end; offset += stride) {
    ol.extent.extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);
  }
  return extent;
};
ol.extent.extendRings = function(extent, rings) {
  var i, ii;
  for (i = 0, ii = rings.length; i < ii; ++i) {
    ol.extent.extendCoordinates(extent, rings[i]);
  }
  return extent;
};
ol.extent.extendXY = function(extent, x, y) {
  extent[0] = Math.min(extent[0], x);
  extent[1] = Math.min(extent[1], y);
  extent[2] = Math.max(extent[2], x);
  extent[3] = Math.max(extent[3], y);
};
ol.extent.forEachCorner = function(extent, callback, opt_this) {
  var val;
  val = callback.call(opt_this, ol.extent.getBottomLeft(extent));
  if (val) {
    return val;
  }
  val = callback.call(opt_this, ol.extent.getBottomRight(extent));
  if (val) {
    return val;
  }
  val = callback.call(opt_this, ol.extent.getTopRight(extent));
  if (val) {
    return val;
  }
  val = callback.call(opt_this, ol.extent.getTopLeft(extent));
  if (val) {
    return val;
  }
  return false;
};
ol.extent.getArea = function(extent) {
  var area = 0;
  if (!ol.extent.isEmpty(extent)) {
    area = ol.extent.getWidth(extent) * ol.extent.getHeight(extent);
  }
  return area;
};
ol.extent.getBottomLeft = function(extent) {
  return [extent[0], extent[1]];
};
ol.extent.getBottomRight = function(extent) {
  return [extent[2], extent[1]];
};
ol.extent.getCenter = function(extent) {
  return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];
};
ol.extent.getCorner = function(extent, corner) {
  var coordinate;
  if (corner === ol.extent.Corner.BOTTOM_LEFT) {
    coordinate = ol.extent.getBottomLeft(extent);
  } else {
    if (corner === ol.extent.Corner.BOTTOM_RIGHT) {
      coordinate = ol.extent.getBottomRight(extent);
    } else {
      if (corner === ol.extent.Corner.TOP_LEFT) {
        coordinate = ol.extent.getTopLeft(extent);
      } else {
        if (corner === ol.extent.Corner.TOP_RIGHT) {
          coordinate = ol.extent.getTopRight(extent);
        } else {
          ol.asserts.assert(false, 13);
        }
      }
    }
  }
  return coordinate;
};
ol.extent.getEnlargedArea = function(extent1, extent2) {
  var minX = Math.min(extent1[0], extent2[0]);
  var minY = Math.min(extent1[1], extent2[1]);
  var maxX = Math.max(extent1[2], extent2[2]);
  var maxY = Math.max(extent1[3], extent2[3]);
  return (maxX - minX) * (maxY - minY);
};
ol.extent.getForViewAndSize = function(center, resolution, rotation, size, opt_extent) {
  var dx = resolution * size[0] / 2;
  var dy = resolution * size[1] / 2;
  var cosRotation = Math.cos(rotation);
  var sinRotation = Math.sin(rotation);
  var xCos = dx * cosRotation;
  var xSin = dx * sinRotation;
  var yCos = dy * cosRotation;
  var ySin = dy * sinRotation;
  var x = center[0];
  var y = center[1];
  var x0 = x - xCos + ySin;
  var x1 = x - xCos - ySin;
  var x2 = x + xCos - ySin;
  var x3 = x + xCos + ySin;
  var y0 = y - xSin - yCos;
  var y1 = y - xSin + yCos;
  var y2 = y + xSin + yCos;
  var y3 = y + xSin - yCos;
  return ol.extent.createOrUpdate(Math.min(x0, x1, x2, x3), Math.min(y0, y1, y2, y3), Math.max(x0, x1, x2, x3), Math.max(y0, y1, y2, y3), opt_extent);
};
ol.extent.getHeight = function(extent) {
  return extent[3] - extent[1];
};
ol.extent.getIntersectionArea = function(extent1, extent2) {
  var intersection = ol.extent.getIntersection(extent1, extent2);
  return ol.extent.getArea(intersection);
};
ol.extent.getIntersection = function(extent1, extent2, opt_extent) {
  var intersection = opt_extent ? opt_extent : ol.extent.createEmpty();
  if (ol.extent.intersects(extent1, extent2)) {
    if (extent1[0] > extent2[0]) {
      intersection[0] = extent1[0];
    } else {
      intersection[0] = extent2[0];
    }
    if (extent1[1] > extent2[1]) {
      intersection[1] = extent1[1];
    } else {
      intersection[1] = extent2[1];
    }
    if (extent1[2] < extent2[2]) {
      intersection[2] = extent1[2];
    } else {
      intersection[2] = extent2[2];
    }
    if (extent1[3] < extent2[3]) {
      intersection[3] = extent1[3];
    } else {
      intersection[3] = extent2[3];
    }
  }
  return intersection;
};
ol.extent.getMargin = function(extent) {
  return ol.extent.getWidth(extent) + ol.extent.getHeight(extent);
};
ol.extent.getSize = function(extent) {
  return [extent[2] - extent[0], extent[3] - extent[1]];
};
ol.extent.getTopLeft = function(extent) {
  return [extent[0], extent[3]];
};
ol.extent.getTopRight = function(extent) {
  return [extent[2], extent[3]];
};
ol.extent.getWidth = function(extent) {
  return extent[2] - extent[0];
};
ol.extent.intersects = function(extent1, extent2) {
  return extent1[0] <= extent2[2] && extent1[2] >= extent2[0] && extent1[1] <= extent2[3] && extent1[3] >= extent2[1];
};
ol.extent.isEmpty = function(extent) {
  return extent[2] < extent[0] || extent[3] < extent[1];
};
ol.extent.returnOrUpdate = function(extent, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = extent[0];
    opt_extent[1] = extent[1];
    opt_extent[2] = extent[2];
    opt_extent[3] = extent[3];
    return opt_extent;
  } else {
    return extent;
  }
};
ol.extent.scaleFromCenter = function(extent, value) {
  var deltaX = (extent[2] - extent[0]) / 2 * (value - 1);
  var deltaY = (extent[3] - extent[1]) / 2 * (value - 1);
  extent[0] -= deltaX;
  extent[2] += deltaX;
  extent[1] -= deltaY;
  extent[3] += deltaY;
};
ol.extent.intersectsSegment = function(extent, start, end) {
  var intersects = false;
  var startRel = ol.extent.coordinateRelationship(extent, start);
  var endRel = ol.extent.coordinateRelationship(extent, end);
  if (startRel === ol.extent.Relationship.INTERSECTING || endRel === ol.extent.Relationship.INTERSECTING) {
    intersects = true;
  } else {
    var minX = extent[0];
    var minY = extent[1];
    var maxX = extent[2];
    var maxY = extent[3];
    var startX = start[0];
    var startY = start[1];
    var endX = end[0];
    var endY = end[1];
    var slope = (endY - startY) / (endX - startX);
    var x, y;
    if (!!(endRel & ol.extent.Relationship.ABOVE) && !(startRel & ol.extent.Relationship.ABOVE)) {
      x = endX - (endY - maxY) / slope;
      intersects = x >= minX && x <= maxX;
    }
    if (!intersects && !!(endRel & ol.extent.Relationship.RIGHT) && !(startRel & ol.extent.Relationship.RIGHT)) {
      y = endY - (endX - maxX) * slope;
      intersects = y >= minY && y <= maxY;
    }
    if (!intersects && !!(endRel & ol.extent.Relationship.BELOW) && !(startRel & ol.extent.Relationship.BELOW)) {
      x = endX - (endY - minY) / slope;
      intersects = x >= minX && x <= maxX;
    }
    if (!intersects && !!(endRel & ol.extent.Relationship.LEFT) && !(startRel & ol.extent.Relationship.LEFT)) {
      y = endY - (endX - minX) * slope;
      intersects = y >= minY && y <= maxY;
    }
  }
  return intersects;
};
ol.extent.applyTransform = function(extent, transformFn, opt_extent) {
  var coordinates = [extent[0], extent[1], extent[0], extent[3], extent[2], extent[1], extent[2], extent[3]];
  transformFn(coordinates, coordinates, 2);
  var xs = [coordinates[0], coordinates[2], coordinates[4], coordinates[6]];
  var ys = [coordinates[1], coordinates[3], coordinates[5], coordinates[7]];
  return ol.extent.boundingExtentXYs_(xs, ys, opt_extent);
};
goog.provide("ol.layer.Property");
ol.layer.Property = {OPACITY:"opacity", VISIBLE:"visible", EXTENT:"extent", Z_INDEX:"zIndex", MAX_RESOLUTION:"maxResolution", MIN_RESOLUTION:"minResolution", SOURCE:"source"};
goog.provide("ol.math");
goog.require("ol.asserts");
ol.math.clamp = function(value, min, max) {
  return Math.min(Math.max(value, min), max);
};
ol.math.cosh = function() {
  var cosh;
  if ("cosh" in Math) {
    cosh = Math.cosh;
  } else {
    cosh = function(x) {
      var y = Math.exp(x);
      return (y + 1 / y) / 2;
    };
  }
  return cosh;
}();
ol.math.roundUpToPowerOfTwo = function(x) {
  ol.asserts.assert(0 < x, 29);
  return Math.pow(2, Math.ceil(Math.log(x) / Math.LN2));
};
ol.math.squaredSegmentDistance = function(x, y, x1, y1, x2, y2) {
  var dx = x2 - x1;
  var dy = y2 - y1;
  if (dx !== 0 || dy !== 0) {
    var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      x1 = x2;
      y1 = y2;
    } else {
      if (t > 0) {
        x1 += dx * t;
        y1 += dy * t;
      }
    }
  }
  return ol.math.squaredDistance(x, y, x1, y1);
};
ol.math.squaredDistance = function(x1, y1, x2, y2) {
  var dx = x2 - x1;
  var dy = y2 - y1;
  return dx * dx + dy * dy;
};
ol.math.solveLinearSystem = function(mat) {
  var n = mat.length;
  for (var i = 0; i < n; i++) {
    var maxRow = i;
    var maxEl = Math.abs(mat[i][i]);
    for (var r = i + 1; r < n; r++) {
      var absValue = Math.abs(mat[r][i]);
      if (absValue > maxEl) {
        maxEl = absValue;
        maxRow = r;
      }
    }
    if (maxEl === 0) {
      return null;
    }
    var tmp = mat[maxRow];
    mat[maxRow] = mat[i];
    mat[i] = tmp;
    for (var j = i + 1; j < n; j++) {
      var coef = -mat[j][i] / mat[i][i];
      for (var k = i; k < n + 1; k++) {
        if (i == k) {
          mat[j][k] = 0;
        } else {
          mat[j][k] += coef * mat[i][k];
        }
      }
    }
  }
  var x = new Array(n);
  for (var l = n - 1; l >= 0; l--) {
    x[l] = mat[l][n] / mat[l][l];
    for (var m = l - 1; m >= 0; m--) {
      mat[m][n] -= mat[m][l] * x[l];
    }
  }
  return x;
};
ol.math.toDegrees = function(angleInRadians) {
  return angleInRadians * 180 / Math.PI;
};
ol.math.toRadians = function(angleInDegrees) {
  return angleInDegrees * Math.PI / 180;
};
ol.math.modulo = function(a, b) {
  var r = a % b;
  return r * b < 0 ? r + b : r;
};
ol.math.lerp = function(a, b, x) {
  return a + x * (b - a);
};
goog.provide("ol.layer.Base");
goog.require("ol");
goog.require("ol.Object");
goog.require("ol.layer.Property");
goog.require("ol.math");
goog.require("ol.obj");
ol.layer.Base = function(options) {
  ol.Object.call(this);
  var properties = ol.obj.assign({}, options);
  properties[ol.layer.Property.OPACITY] = options.opacity !== undefined ? options.opacity : 1;
  properties[ol.layer.Property.VISIBLE] = options.visible !== undefined ? options.visible : true;
  properties[ol.layer.Property.Z_INDEX] = options.zIndex !== undefined ? options.zIndex : 0;
  properties[ol.layer.Property.MAX_RESOLUTION] = options.maxResolution !== undefined ? options.maxResolution : Infinity;
  properties[ol.layer.Property.MIN_RESOLUTION] = options.minResolution !== undefined ? options.minResolution : 0;
  this.setProperties(properties);
  this.state_ = {layer:this, managed:true};
  this.type;
};
ol.inherits(ol.layer.Base, ol.Object);
ol.layer.Base.prototype.getType = function() {
  return this.type;
};
ol.layer.Base.prototype.getLayerState = function() {
  this.state_.opacity = ol.math.clamp(this.getOpacity(), 0, 1);
  this.state_.sourceState = this.getSourceState();
  this.state_.visible = this.getVisible();
  this.state_.extent = this.getExtent();
  this.state_.zIndex = this.getZIndex();
  this.state_.maxResolution = this.getMaxResolution();
  this.state_.minResolution = Math.max(this.getMinResolution(), 0);
  return this.state_;
};
ol.layer.Base.prototype.getLayersArray = function(opt_array) {
};
ol.layer.Base.prototype.getLayerStatesArray = function(opt_states) {
};
ol.layer.Base.prototype.getExtent = function() {
  return this.get(ol.layer.Property.EXTENT);
};
ol.layer.Base.prototype.getMaxResolution = function() {
  return this.get(ol.layer.Property.MAX_RESOLUTION);
};
ol.layer.Base.prototype.getMinResolution = function() {
  return this.get(ol.layer.Property.MIN_RESOLUTION);
};
ol.layer.Base.prototype.getOpacity = function() {
  return this.get(ol.layer.Property.OPACITY);
};
ol.layer.Base.prototype.getSourceState = function() {
};
ol.layer.Base.prototype.getVisible = function() {
  return this.get(ol.layer.Property.VISIBLE);
};
ol.layer.Base.prototype.getZIndex = function() {
  return this.get(ol.layer.Property.Z_INDEX);
};
ol.layer.Base.prototype.setExtent = function(extent) {
  this.set(ol.layer.Property.EXTENT, extent);
};
ol.layer.Base.prototype.setMaxResolution = function(maxResolution) {
  this.set(ol.layer.Property.MAX_RESOLUTION, maxResolution);
};
ol.layer.Base.prototype.setMinResolution = function(minResolution) {
  this.set(ol.layer.Property.MIN_RESOLUTION, minResolution);
};
ol.layer.Base.prototype.setOpacity = function(opacity) {
  this.set(ol.layer.Property.OPACITY, opacity);
};
ol.layer.Base.prototype.setVisible = function(visible) {
  this.set(ol.layer.Property.VISIBLE, visible);
};
ol.layer.Base.prototype.setZIndex = function(zindex) {
  this.set(ol.layer.Property.Z_INDEX, zindex);
};
goog.provide("ol.source.State");
ol.source.State = {UNDEFINED:"undefined", LOADING:"loading", READY:"ready", ERROR:"error"};
goog.provide("ol.layer.Group");
goog.require("ol");
goog.require("ol.Collection");
goog.require("ol.CollectionEventType");
goog.require("ol.Object");
goog.require("ol.ObjectEventType");
goog.require("ol.asserts");
goog.require("ol.events");
goog.require("ol.events.EventType");
goog.require("ol.extent");
goog.require("ol.layer.Base");
goog.require("ol.obj");
goog.require("ol.source.State");
ol.layer.Group = function(opt_options) {
  var options = opt_options || {};
  var baseOptions = ol.obj.assign({}, options);
  delete baseOptions.layers;
  var layers = options.layers;
  ol.layer.Base.call(this, baseOptions);
  this.layersListenerKeys_ = [];
  this.listenerKeys_ = {};
  ol.events.listen(this, ol.Object.getChangeEventType(ol.layer.Group.Property_.LAYERS), this.handleLayersChanged_, this);
  if (layers) {
    if (Array.isArray(layers)) {
      layers = new ol.Collection(layers.slice(), {unique:true});
    } else {
      ol.asserts.assert(layers instanceof ol.Collection, 43);
      layers = layers;
    }
  } else {
    layers = new ol.Collection(undefined, {unique:true});
  }
  this.setLayers(layers);
};
ol.inherits(ol.layer.Group, ol.layer.Base);
ol.layer.Group.prototype.handleLayerChange_ = function() {
  this.changed();
};
ol.layer.Group.prototype.handleLayersChanged_ = function(event) {
  this.layersListenerKeys_.forEach(ol.events.unlistenByKey);
  this.layersListenerKeys_.length = 0;
  var layers = this.getLayers();
  this.layersListenerKeys_.push(ol.events.listen(layers, ol.CollectionEventType.ADD, this.handleLayersAdd_, this), ol.events.listen(layers, ol.CollectionEventType.REMOVE, this.handleLayersRemove_, this));
  for (var id in this.listenerKeys_) {
    this.listenerKeys_[id].forEach(ol.events.unlistenByKey);
  }
  ol.obj.clear(this.listenerKeys_);
  var layersArray = layers.getArray();
  var i, ii, layer;
  for (i = 0, ii = layersArray.length; i < ii; i++) {
    layer = layersArray[i];
    this.listenerKeys_[ol.getUid(layer).toString()] = [ol.events.listen(layer, ol.ObjectEventType.PROPERTYCHANGE, this.handleLayerChange_, this), ol.events.listen(layer, ol.events.EventType.CHANGE, this.handleLayerChange_, this)];
  }
  this.changed();
};
ol.layer.Group.prototype.handleLayersAdd_ = function(collectionEvent) {
  var layer = collectionEvent.element;
  var key = ol.getUid(layer).toString();
  this.listenerKeys_[key] = [ol.events.listen(layer, ol.ObjectEventType.PROPERTYCHANGE, this.handleLayerChange_, this), ol.events.listen(layer, ol.events.EventType.CHANGE, this.handleLayerChange_, this)];
  this.changed();
};
ol.layer.Group.prototype.handleLayersRemove_ = function(collectionEvent) {
  var layer = collectionEvent.element;
  var key = ol.getUid(layer).toString();
  this.listenerKeys_[key].forEach(ol.events.unlistenByKey);
  delete this.listenerKeys_[key];
  this.changed();
};
ol.layer.Group.prototype.getLayers = function() {
  return this.get(ol.layer.Group.Property_.LAYERS);
};
ol.layer.Group.prototype.setLayers = function(layers) {
  this.set(ol.layer.Group.Property_.LAYERS, layers);
};
ol.layer.Group.prototype.getLayersArray = function(opt_array) {
  var array = opt_array !== undefined ? opt_array : [];
  this.getLayers().forEach(function(layer) {
    layer.getLayersArray(array);
  });
  return array;
};
ol.layer.Group.prototype.getLayerStatesArray = function(opt_states) {
  var states = opt_states !== undefined ? opt_states : [];
  var pos = states.length;
  this.getLayers().forEach(function(layer) {
    layer.getLayerStatesArray(states);
  });
  var ownLayerState = this.getLayerState();
  var i, ii, layerState;
  for (i = pos, ii = states.length; i < ii; i++) {
    layerState = states[i];
    layerState.opacity *= ownLayerState.opacity;
    layerState.visible = layerState.visible && ownLayerState.visible;
    layerState.maxResolution = Math.min(layerState.maxResolution, ownLayerState.maxResolution);
    layerState.minResolution = Math.max(layerState.minResolution, ownLayerState.minResolution);
    if (ownLayerState.extent !== undefined) {
      if (layerState.extent !== undefined) {
        layerState.extent = ol.extent.getIntersection(layerState.extent, ownLayerState.extent);
      } else {
        layerState.extent = ownLayerState.extent;
      }
    }
  }
  return states;
};
ol.layer.Group.prototype.getSourceState = function() {
  return ol.source.State.READY;
};
ol.layer.Group.Property_ = {LAYERS:"layers"};
goog.provide("olcs.AbstractSynchronizer");
goog.require("goog.asserts");
goog.require("ol");
goog.require("ol.Observable");
goog.require("ol.events");
goog.require("ol.layer.Group");
olcs.AbstractSynchronizer = function(map, scene) {
  this.map = map;
  this.view = map.getView();
  this.scene = scene;
  this.olLayers = map.getLayerGroup().getLayers();
  this.mapLayerGroup = map.getLayerGroup();
  this.layerMap = {};
  this.olLayerListenKeys = {};
  this.olGroupListenKeys_ = {};
};
olcs.AbstractSynchronizer.prototype.synchronize = function() {
  this.destroyAll();
  this.addLayers_(this.mapLayerGroup);
};
olcs.AbstractSynchronizer.prototype.orderLayers = function() {
};
olcs.AbstractSynchronizer.prototype.addLayers_ = function(root) {
  var $jscomp$this = this;
  var fifo = [{layer:root, parents:[]}];
  var $jscomp$loop$12 = {};
  while (fifo.length > 0) {
    $jscomp$loop$12.olLayerWithParents = fifo.splice(0, 1)[0];
    $jscomp$loop$12.olLayer = $jscomp$loop$12.olLayerWithParents.layer;
    var olLayerId = ol.getUid($jscomp$loop$12.olLayer).toString();
    this.olLayerListenKeys[olLayerId] = [];
    goog.asserts.assert(!this.layerMap[olLayerId]);
    var cesiumObjects = null;
    if ($jscomp$loop$12.olLayer instanceof ol.layer.Group) {
      this.listenForGroupChanges_($jscomp$loop$12.olLayer);
      if ($jscomp$loop$12.olLayer !== this.mapLayerGroup) {
        cesiumObjects = this.createSingleLayerCounterparts($jscomp$loop$12.olLayerWithParents);
      }
      if (!cesiumObjects) {
        $jscomp$loop$12.olLayer.getLayers().forEach(function($jscomp$loop$12) {
          return function(l) {
            if (l) {
              var newOlLayerWithParents = {layer:l, parents:$jscomp$loop$12.olLayer === $jscomp$this.mapLayerGroup ? [] : [$jscomp$loop$12.olLayerWithParents.layer].concat($jscomp$loop$12.olLayerWithParents.parents)};
              fifo.push(newOlLayerWithParents);
            }
          };
        }($jscomp$loop$12));
      }
    } else {
      cesiumObjects = this.createSingleLayerCounterparts($jscomp$loop$12.olLayerWithParents);
      if (!cesiumObjects) {
        $jscomp$loop$12.layerId = olLayerId;
        $jscomp$loop$12.layerWithParents = $jscomp$loop$12.olLayerWithParents;
        $jscomp$loop$12.onLayerChange = function($jscomp$loop$12) {
          return function(e) {
            var cesiumObjs = $jscomp$this.createSingleLayerCounterparts($jscomp$loop$12.layerWithParents);
            if (cesiumObjs) {
              $jscomp$loop$12.layerWithParents.layer.un("change", $jscomp$loop$12.onLayerChange, $jscomp$this);
              $jscomp$this.addCesiumObjects_(cesiumObjs, $jscomp$loop$12.layerId, $jscomp$loop$12.layerWithParents.layer);
              $jscomp$this.orderLayers();
            }
          };
        }($jscomp$loop$12);
        this.olLayerListenKeys[olLayerId].push(ol.events.listen($jscomp$loop$12.layerWithParents.layer, "change", $jscomp$loop$12.onLayerChange, this));
      }
    }
    if (cesiumObjects) {
      this.addCesiumObjects_(cesiumObjects, olLayerId, $jscomp$loop$12.olLayer);
    }
    $jscomp$loop$12 = {olLayer:$jscomp$loop$12.olLayer, olLayerWithParents:$jscomp$loop$12.olLayerWithParents, layerWithParents:$jscomp$loop$12.layerWithParents, onLayerChange:$jscomp$loop$12.onLayerChange, layerId:$jscomp$loop$12.layerId};
  }
  this.orderLayers();
};
olcs.AbstractSynchronizer.prototype.addCesiumObjects_ = function(cesiumObjects, layerId, layer) {
  var $jscomp$this = this;
  this.layerMap[layerId] = cesiumObjects;
  this.olLayerListenKeys[layerId].push(ol.events.listen(layer, "change:zIndex", this.orderLayers, this));
  cesiumObjects.forEach(function(cesiumObject) {
    $jscomp$this.addCesiumObject(cesiumObject);
  });
};
olcs.AbstractSynchronizer.prototype.removeAndDestroySingleLayer_ = function(layer) {
  var $jscomp$this = this;
  var uid = ol.getUid(layer).toString();
  var counterparts = this.layerMap[uid];
  if (!!counterparts) {
    counterparts.forEach(function(counterpart) {
      $jscomp$this.removeSingleCesiumObject(counterpart, false);
      $jscomp$this.destroyCesiumObject(counterpart);
    });
    this.olLayerListenKeys[uid].forEach(ol.Observable.unByKey);
    delete this.olLayerListenKeys[uid];
  }
  delete this.layerMap[uid];
  return !!counterparts;
};
olcs.AbstractSynchronizer.prototype.unlistenSingleGroup_ = function(group) {
  if (group === this.mapLayerGroup) {
    return;
  }
  var uid = ol.getUid(group).toString();
  var keys = this.olGroupListenKeys_[uid];
  keys.forEach(function(key) {
    ol.Observable.unByKey(key);
  });
  delete this.olGroupListenKeys_[uid];
  delete this.layerMap[uid];
};
olcs.AbstractSynchronizer.prototype.removeLayer_ = function(root) {
  if (!!root) {
    var fifo = [root];
    while (fifo.length > 0) {
      var olLayer = fifo.splice(0, 1)[0];
      var done = this.removeAndDestroySingleLayer_(olLayer);
      if (olLayer instanceof ol.layer.Group) {
        this.unlistenSingleGroup_(olLayer);
        if (!done) {
          olLayer.getLayers().forEach(function(l) {
            fifo.push(l);
          });
        }
      }
    }
  }
};
olcs.AbstractSynchronizer.prototype.listenForGroupChanges_ = function(group) {
  var uuid = ol.getUid(group).toString();
  goog.asserts.assert(this.olGroupListenKeys_[uuid] === undefined);
  var listenKeyArray = [];
  this.olGroupListenKeys_[uuid] = listenKeyArray;
  var contentKeys = [];
  var listenAddRemove = function() {
    var collection = group.getLayers();
    if (collection) {
      contentKeys = [collection.on("add", function(event) {
        this.addLayers_(event.element);
      }, this), collection.on("remove", function(event) {
        this.removeLayer_(event.element);
      }, this)];
      listenKeyArray.push.apply(listenKeyArray, [].concat($jscomp.arrayFromIterable(contentKeys)));
    }
  }.bind(this);
  listenAddRemove();
  listenKeyArray.push(group.on("change:layers", function(e) {
    contentKeys.forEach(function(el) {
      var i = listenKeyArray.indexOf(el);
      if (i >= 0) {
        listenKeyArray.splice(i, 1);
      }
      ol.Observable.unByKey(el);
    });
    listenAddRemove();
  }));
};
olcs.AbstractSynchronizer.prototype.destroyAll = function() {
  this.removeAllCesiumObjects(true);
  var objKey;
  for (objKey in this.olGroupListenKeys_) {
    var keys = this.olGroupListenKeys_[objKey];
    keys.forEach(ol.Observable.unByKey);
  }
  for (objKey in this.olLayerListenKeys) {
    this.olLayerListenKeys[objKey].forEach(ol.Observable.unByKey);
  }
  this.olGroupListenKeys_ = {};
  this.olLayerListenKeys = {};
  this.layerMap = {};
};
olcs.AbstractSynchronizer.prototype.addCesiumObject = function(object) {
};
olcs.AbstractSynchronizer.prototype.destroyCesiumObject = function(object) {
};
olcs.AbstractSynchronizer.prototype.removeSingleCesiumObject = function(object, destroy) {
};
olcs.AbstractSynchronizer.prototype.removeAllCesiumObjects = function(destroy) {
};
olcs.AbstractSynchronizer.prototype.createSingleLayerCounterparts = function(olLayerWithParents) {
};
goog.provide("olcs.AutoRenderLoop");
olcs.AutoRenderLoop = function(ol3d, debug) {
  this.ol3d = ol3d;
  this.scene_ = ol3d.getCesiumScene();
  this.canvas_ = this.scene_.canvas;
  this.verboseRendering = debug;
  this._boundNotifyRepaintRequired = this.notifyRepaintRequired.bind(this);
  this.lastCameraViewMatrix_ = new Cesium.Matrix4;
  this.lastCameraMoveTime_ = 0;
  this.stoppedRendering = false;
  this._removePostRenderListener = this.scene_.postRender.addEventListener(this.postRender.bind(this));
  this.repaintEventNames_ = ["mousemove", "mousedown", "mouseup", "touchstart", "touchend", "touchmove", "pointerdown", "pointerup", "pointermove", "wheel"];
  var CameraPrototype = Cesium.Camera.prototype;
  this.interceptedAPIs_ = [[CameraPrototype, "setView"], [CameraPrototype, "move"], [CameraPrototype, "rotate"], [CameraPrototype, "lookAt"], [CameraPrototype, "flyTo"], [CameraPrototype, "flyToHome"], [CameraPrototype, "flyToBoundingSphere"]];
  this.originalAPIs_ = this.interceptedAPIs_.map(function(tuple) {
    return tuple[0][tuple[1]];
  });
  this.originalLoadWithXhr_ = Cesium.loadWithXhr.load;
  this.originalScheduleTask_ = Cesium.TaskProcessor.prototype.scheduleTask;
  this.enable();
};
olcs.AutoRenderLoop.prototype.enable = function() {
  for (var $jscomp$iter$0 = $jscomp.makeIterator(this.repaintEventNames_), $jscomp$key$repaintKey = $jscomp$iter$0.next(); !$jscomp$key$repaintKey.done; $jscomp$key$repaintKey = $jscomp$iter$0.next()) {
    var repaintKey = $jscomp$key$repaintKey.value;
    {
      this.canvas_.addEventListener(repaintKey, this._boundNotifyRepaintRequired, false);
    }
  }
  window.addEventListener("resize", this._boundNotifyRepaintRequired, false);
  var that = this;
  Cesium.loadWithXhr.load = function(url, responseType, method, data, headers, deferred, overrideMimeType, preferText, timeout) {
    deferred["promise"]["always"](that._boundNotifyRepaintRequired);
    that.originalLoadWithXhr_.apply(that, [].concat($jscomp.arrayFromIterable(arguments)));
  };
  Cesium.TaskProcessor.prototype.scheduleTask = function(parameters, transferableObjects) {
    var result = that.originalScheduleTask_.call(this, parameters, transferableObjects);
    var taskProcessor = this;
    if (!taskProcessor._originalWorkerMessageSinkRepaint) {
      var worker = taskProcessor["_worker"];
      taskProcessor._originalWorkerMessageSinkRepaint = worker.onmessage;
      worker.onmessage = function(event) {
        taskProcessor._originalWorkerMessageSinkRepaint(event);
        that.notifyRepaintRequired();
      };
    }
    return result;
  };
  var $jscomp$loop$13 = {};
  var i = 0;
  for (; i < this.interceptedAPIs_.length; $jscomp$loop$13 = {original:$jscomp$loop$13.original}, ++i) {
    var api = this.interceptedAPIs_[i];
    var parent = api[0];
    $jscomp$loop$13.original = this.originalAPIs_[i];
    parent[api[1]] = function($jscomp$loop$13) {
      return function(args) {
        var $jscomp$restParams = [];
        for (var $jscomp$restIndex = 0; $jscomp$restIndex < arguments.length; ++$jscomp$restIndex) {
          $jscomp$restParams[$jscomp$restIndex - 0] = arguments[$jscomp$restIndex];
        }
        {
          var args$4 = $jscomp$restParams;
          $jscomp$loop$13.original.apply(this, args$4);
          that.notifyRepaintRequired();
        }
      };
    }($jscomp$loop$13);
  }
  this.ol3d.getOlMap().getLayerGroup().on("change", this._boundNotifyRepaintRequired);
};
olcs.AutoRenderLoop.prototype.disable = function() {
  if (!!this._removePostRenderListener) {
    this._removePostRenderListener();
    this._removePostRenderListener = undefined;
  }
  for (var $jscomp$iter$1 = $jscomp.makeIterator(this.repaintEventNames_), $jscomp$key$repaintKey = $jscomp$iter$1.next(); !$jscomp$key$repaintKey.done; $jscomp$key$repaintKey = $jscomp$iter$1.next()) {
    var repaintKey = $jscomp$key$repaintKey.value;
    {
      this.canvas_.removeEventListener(repaintKey, this._boundNotifyRepaintRequired, false);
    }
  }
  window.removeEventListener("resize", this._boundNotifyRepaintRequired, false);
  Cesium.loadWithXhr.load = this.originalLoadWithXhr_;
  Cesium.TaskProcessor.prototype.scheduleTask = this.originalScheduleTask_;
  for (var i = 0; i < this.interceptedAPIs_.length; ++i) {
    var api = this.interceptedAPIs_[i];
    var parent = api[0];
    var original = this.originalAPIs_[i];
    parent[api[1]] = original;
  }
  this.ol3d.getOlMap().getLayerGroup().un("change", this._boundNotifyRepaintRequired);
};
olcs.AutoRenderLoop.prototype.postRender = function(date) {
  var now = Date.now();
  var scene = this.scene_;
  var camera = scene.camera;
  if (!Cesium.Matrix4.equalsEpsilon(this.lastCameraViewMatrix_, camera.viewMatrix, 1e-5)) {
    this.lastCameraMoveTime_ = now;
  }
  var cameraMovedInLastSecond = now - this.lastCameraMoveTime_ < 1000;
  var surface = scene.globe["_surface"];
  var tilesWaiting = !surface["tileProvider"].ready || surface["_tileLoadQueueHigh"].length > 0 || surface["_tileLoadQueueMedium"].length > 0 || surface["_tileLoadQueueLow"].length > 0 || surface["_debug"]["tilesWaitingForChildren"] > 0;
  var tweens = scene["tweens"];
  if (!cameraMovedInLastSecond && !tilesWaiting && tweens.length == 0) {
    if (this.verboseRendering) {
      console.log("stopping rendering @ " + Date.now());
    }
    this.ol3d.setBlockCesiumRendering(true);
    this.stoppedRendering = true;
  }
  Cesium.Matrix4.clone(camera.viewMatrix, this.lastCameraViewMatrix_);
};
olcs.AutoRenderLoop.prototype.restartRenderLoop = function() {
  this.notifyRepaintRequired();
};
olcs.AutoRenderLoop.prototype.notifyRepaintRequired = function() {
  if (this.verboseRendering && this.stoppedRendering) {
    console.log("starting rendering @ " + Date.now());
  }
  this.lastCameraMoveTime_ = Date.now();
  this.ol3d.setBlockCesiumRendering(false);
  this.stoppedRendering = false;
};
olcs.AutoRenderLoop.prototype.setDebug = function(debug) {
  this.verboseRendering = debug;
};
goog.provide("ol.geom.GeometryType");
ol.geom.GeometryType = {POINT:"Point", LINE_STRING:"LineString", LINEAR_RING:"LinearRing", POLYGON:"Polygon", MULTI_POINT:"MultiPoint", MULTI_LINE_STRING:"MultiLineString", MULTI_POLYGON:"MultiPolygon", GEOMETRY_COLLECTION:"GeometryCollection", CIRCLE:"Circle"};
/*

 Latitude/longitude spherical geodesy formulae taken from
 http://www.movable-type.co.uk/scripts/latlong.html
 Licensed under CC-BY-3.0.
*/
goog.provide("ol.Sphere");
goog.require("ol.math");
goog.require("ol.geom.GeometryType");
ol.Sphere = function(radius) {
  this.radius = radius;
};
ol.Sphere.prototype.geodesicArea = function(coordinates) {
  return ol.Sphere.getArea_(coordinates, this.radius);
};
ol.Sphere.prototype.haversineDistance = function(c1, c2) {
  return ol.Sphere.getDistance_(c1, c2, this.radius);
};
ol.Sphere.prototype.offset = function(c1, distance, bearing) {
  var lat1 = ol.math.toRadians(c1[1]);
  var lon1 = ol.math.toRadians(c1[0]);
  var dByR = distance / this.radius;
  var lat = Math.asin(Math.sin(lat1) * Math.cos(dByR) + Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing));
  var lon = lon1 + Math.atan2(Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1), Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat));
  return [ol.math.toDegrees(lon), ol.math.toDegrees(lat)];
};
ol.Sphere.DEFAULT_RADIUS = 6371008.8;
ol.Sphere.getLength = function(geometry, opt_options) {
  var options = opt_options || {};
  var radius = options.radius || ol.Sphere.DEFAULT_RADIUS;
  var projection = options.projection || "EPSG:3857";
  geometry = geometry.clone().transform(projection, "EPSG:4326");
  var type = geometry.getType();
  var length = 0;
  var coordinates, coords, i, ii, j, jj;
  switch(type) {
    case ol.geom.GeometryType.POINT:
    case ol.geom.GeometryType.MULTI_POINT:
      {
        break;
      }
    case ol.geom.GeometryType.LINE_STRING:
    case ol.geom.GeometryType.LINEAR_RING:
      {
        coordinates = geometry.getCoordinates();
        length = ol.Sphere.getLength_(coordinates, radius);
        break;
      }
    case ol.geom.GeometryType.MULTI_LINE_STRING:
    case ol.geom.GeometryType.POLYGON:
      {
        coordinates = geometry.getCoordinates();
        for (i = 0, ii = coordinates.length; i < ii; ++i) {
          length += ol.Sphere.getLength_(coordinates[i], radius);
        }
        break;
      }
    case ol.geom.GeometryType.MULTI_POLYGON:
      {
        coordinates = geometry.getCoordinates();
        for (i = 0, ii = coordinates.length; i < ii; ++i) {
          coords = coordinates[i];
          for (j = 0, jj = coords.length; j < jj; ++j) {
            length += ol.Sphere.getLength_(coords[j], radius);
          }
        }
        break;
      }
    case ol.geom.GeometryType.GEOMETRY_COLLECTION:
      {
        var geometries = geometry.getGeometries();
        for (i = 0, ii = geometries.length; i < ii; ++i) {
          length += ol.Sphere.getLength(geometries[i], opt_options);
        }
        break;
      }
    default:
      {
        throw new Error("Unsupported geometry type: " + type);
      }
  }
  return length;
};
ol.Sphere.getLength_ = function(coordinates, radius) {
  var length = 0;
  for (var i = 0, ii = coordinates.length; i < ii - 1; ++i) {
    length += ol.Sphere.getDistance_(coordinates[i], coordinates[i + 1], radius);
  }
  return length;
};
ol.Sphere.getDistance_ = function(c1, c2, radius) {
  var lat1 = ol.math.toRadians(c1[1]);
  var lat2 = ol.math.toRadians(c2[1]);
  var deltaLatBy2 = (lat2 - lat1) / 2;
  var deltaLonBy2 = ol.math.toRadians(c2[0] - c1[0]) / 2;
  var a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) + Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) * Math.cos(lat1) * Math.cos(lat2);
  return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
};
ol.Sphere.getArea = function(geometry, opt_options) {
  var options = opt_options || {};
  var radius = options.radius || ol.Sphere.DEFAULT_RADIUS;
  var projection = options.projection || "EPSG:3857";
  geometry = geometry.clone().transform(projection, "EPSG:4326");
  var type = geometry.getType();
  var area = 0;
  var coordinates, coords, i, ii, j, jj;
  switch(type) {
    case ol.geom.GeometryType.POINT:
    case ol.geom.GeometryType.MULTI_POINT:
    case ol.geom.GeometryType.LINE_STRING:
    case ol.geom.GeometryType.MULTI_LINE_STRING:
    case ol.geom.GeometryType.LINEAR_RING:
      {
        break;
      }
    case ol.geom.GeometryType.POLYGON:
      {
        coordinates = geometry.getCoordinates();
        area = Math.abs(ol.Sphere.getArea_(coordinates[0], radius));
        for (i = 1, ii = coordinates.length; i < ii; ++i) {
          area -= Math.abs(ol.Sphere.getArea_(coordinates[i], radius));
        }
        break;
      }
    case ol.geom.GeometryType.MULTI_POLYGON:
      {
        coordinates = geometry.getCoordinates();
        for (i = 0, ii = coordinates.length; i < ii; ++i) {
          coords = coordinates[i];
          area += Math.abs(ol.Sphere.getArea_(coords[0], radius));
          for (j = 1, jj = coords.length; j < jj; ++j) {
            area -= Math.abs(ol.Sphere.getArea_(coords[j], radius));
          }
        }
        break;
      }
    case ol.geom.GeometryType.GEOMETRY_COLLECTION:
      {
        var geometries = geometry.getGeometries();
        for (i = 0, ii = geometries.length; i < ii; ++i) {
          area += ol.Sphere.getArea(geometries[i], opt_options);
        }
        break;
      }
    default:
      {
        throw new Error("Unsupported geometry type: " + type);
      }
  }
  return area;
};
ol.Sphere.getArea_ = function(coordinates, radius) {
  var area = 0, len = coordinates.length;
  var x1 = coordinates[len - 1][0];
  var y1 = coordinates[len - 1][1];
  for (var i = 0; i < len; i++) {
    var x2 = coordinates[i][0], y2 = coordinates[i][1];
    area += ol.math.toRadians(x2 - x1) * (2 + Math.sin(ol.math.toRadians(y1)) + Math.sin(ol.math.toRadians(y2)));
    x1 = x2;
    y1 = y2;
  }
  return area * radius * radius / 2.0;
};
goog.provide("ol.proj.Units");
ol.proj.Units = {DEGREES:"degrees", FEET:"ft", METERS:"m", PIXELS:"pixels", TILE_PIXELS:"tile-pixels", USFEET:"us-ft"};
ol.proj.Units.METERS_PER_UNIT = {};
ol.proj.Units.METERS_PER_UNIT[ol.proj.Units.DEGREES] = 2 * Math.PI * 6370997 / 360;
ol.proj.Units.METERS_PER_UNIT[ol.proj.Units.FEET] = 0.3048;
ol.proj.Units.METERS_PER_UNIT[ol.proj.Units.METERS] = 1;
ol.proj.Units.METERS_PER_UNIT[ol.proj.Units.USFEET] = 1200 / 3937;
goog.provide("ol.proj.proj4");
ol.proj.proj4.cache_ = null;
ol.proj.proj4.set = function(proj4) {
  ol.proj.proj4.cache_ = proj4;
};
ol.proj.proj4.get = function() {
  return ol.proj.proj4.cache_ || window["proj4"];
};
goog.provide("ol.proj.Projection");
goog.require("ol");
goog.require("ol.proj.Units");
goog.require("ol.proj.proj4");
ol.proj.Projection = function(options) {
  this.code_ = options.code;
  this.units_ = options.units;
  this.extent_ = options.extent !== undefined ? options.extent : null;
  this.worldExtent_ = options.worldExtent !== undefined ? options.worldExtent : null;
  this.axisOrientation_ = options.axisOrientation !== undefined ? options.axisOrientation : "enu";
  this.global_ = options.global !== undefined ? options.global : false;
  this.canWrapX_ = !!(this.global_ && this.extent_);
  this.getPointResolutionFunc_ = options.getPointResolution;
  this.defaultTileGrid_ = null;
  this.metersPerUnit_ = options.metersPerUnit;
  var code = options.code;
  if (ol.ENABLE_PROJ4JS) {
    var proj4js = ol.proj.proj4.get();
    if (typeof proj4js == "function") {
      var def = proj4js.defs(code);
      if (def !== undefined) {
        if (def.axis !== undefined && options.axisOrientation === undefined) {
          this.axisOrientation_ = def.axis;
        }
        if (options.metersPerUnit === undefined) {
          this.metersPerUnit_ = def.to_meter;
        }
        if (options.units === undefined) {
          this.units_ = def.units;
        }
      }
    }
  }
};
ol.proj.Projection.prototype.canWrapX = function() {
  return this.canWrapX_;
};
ol.proj.Projection.prototype.getCode = function() {
  return this.code_;
};
ol.proj.Projection.prototype.getExtent = function() {
  return this.extent_;
};
ol.proj.Projection.prototype.getUnits = function() {
  return this.units_;
};
ol.proj.Projection.prototype.getMetersPerUnit = function() {
  return this.metersPerUnit_ || ol.proj.Units.METERS_PER_UNIT[this.units_];
};
ol.proj.Projection.prototype.getWorldExtent = function() {
  return this.worldExtent_;
};
ol.proj.Projection.prototype.getAxisOrientation = function() {
  return this.axisOrientation_;
};
ol.proj.Projection.prototype.isGlobal = function() {
  return this.global_;
};
ol.proj.Projection.prototype.setGlobal = function(global) {
  this.global_ = global;
  this.canWrapX_ = !!(global && this.extent_);
};
ol.proj.Projection.prototype.getDefaultTileGrid = function() {
  return this.defaultTileGrid_;
};
ol.proj.Projection.prototype.setDefaultTileGrid = function(tileGrid) {
  this.defaultTileGrid_ = tileGrid;
};
ol.proj.Projection.prototype.setExtent = function(extent) {
  this.extent_ = extent;
  this.canWrapX_ = !!(this.global_ && extent);
};
ol.proj.Projection.prototype.setWorldExtent = function(worldExtent) {
  this.worldExtent_ = worldExtent;
};
ol.proj.Projection.prototype.setGetPointResolution = function(func) {
  this.getPointResolutionFunc_ = func;
};
ol.proj.Projection.prototype.getPointResolutionFunc = function() {
  return this.getPointResolutionFunc_;
};
goog.provide("ol.proj.EPSG3857");
goog.require("ol");
goog.require("ol.math");
goog.require("ol.proj.Projection");
goog.require("ol.proj.Units");
ol.proj.EPSG3857.Projection_ = function(code) {
  ol.proj.Projection.call(this, {code:code, units:ol.proj.Units.METERS, extent:ol.proj.EPSG3857.EXTENT, global:true, worldExtent:ol.proj.EPSG3857.WORLD_EXTENT, getPointResolution:function(resolution, point) {
    return resolution / ol.math.cosh(point[1] / ol.proj.EPSG3857.RADIUS);
  }});
};
ol.inherits(ol.proj.EPSG3857.Projection_, ol.proj.Projection);
ol.proj.EPSG3857.RADIUS = 6378137;
ol.proj.EPSG3857.HALF_SIZE = Math.PI * ol.proj.EPSG3857.RADIUS;
ol.proj.EPSG3857.EXTENT = [-ol.proj.EPSG3857.HALF_SIZE, -ol.proj.EPSG3857.HALF_SIZE, ol.proj.EPSG3857.HALF_SIZE, ol.proj.EPSG3857.HALF_SIZE];
ol.proj.EPSG3857.WORLD_EXTENT = [-180, -85, 180, 85];
ol.proj.EPSG3857.PROJECTIONS = [new ol.proj.EPSG3857.Projection_("EPSG:3857"), new ol.proj.EPSG3857.Projection_("EPSG:102100"), new ol.proj.EPSG3857.Projection_("EPSG:102113"), new ol.proj.EPSG3857.Projection_("EPSG:900913"), new ol.proj.EPSG3857.Projection_("urn:ogc:def:crs:EPSG:6.18:3:3857"), new ol.proj.EPSG3857.Projection_("urn:ogc:def:crs:EPSG::3857"), new ol.proj.EPSG3857.Projection_("http://www.opengis.net/gml/srs/epsg.xml#3857")];
ol.proj.EPSG3857.fromEPSG4326 = function(input, opt_output, opt_dimension) {
  var length = input.length, dimension = opt_dimension > 1 ? opt_dimension : 2, output = opt_output;
  if (output === undefined) {
    if (dimension > 2) {
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  var halfSize = ol.proj.EPSG3857.HALF_SIZE;
  for (var i = 0; i < length; i += dimension) {
    output[i] = halfSize * input[i] / 180;
    var y = ol.proj.EPSG3857.RADIUS * Math.log(Math.tan(Math.PI * (input[i + 1] + 90) / 360));
    if (y > halfSize) {
      y = halfSize;
    } else {
      if (y < -halfSize) {
        y = -halfSize;
      }
    }
    output[i + 1] = y;
  }
  return output;
};
ol.proj.EPSG3857.toEPSG4326 = function(input, opt_output, opt_dimension) {
  var length = input.length, dimension = opt_dimension > 1 ? opt_dimension : 2, output = opt_output;
  if (output === undefined) {
    if (dimension > 2) {
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  for (var i = 0; i < length; i += dimension) {
    output[i] = 180 * input[i] / ol.proj.EPSG3857.HALF_SIZE;
    output[i + 1] = 360 * Math.atan(Math.exp(input[i + 1] / ol.proj.EPSG3857.RADIUS)) / Math.PI - 90;
  }
  return output;
};
goog.provide("ol.proj.EPSG4326");
goog.require("ol");
goog.require("ol.proj.Projection");
goog.require("ol.proj.Units");
ol.proj.EPSG4326.Projection_ = function(code, opt_axisOrientation) {
  ol.proj.Projection.call(this, {code:code, units:ol.proj.Units.DEGREES, extent:ol.proj.EPSG4326.EXTENT, axisOrientation:opt_axisOrientation, global:true, metersPerUnit:ol.proj.EPSG4326.METERS_PER_UNIT, worldExtent:ol.proj.EPSG4326.EXTENT});
};
ol.inherits(ol.proj.EPSG4326.Projection_, ol.proj.Projection);
ol.proj.EPSG4326.RADIUS = 6378137;
ol.proj.EPSG4326.EXTENT = [-180, -90, 180, 90];
ol.proj.EPSG4326.METERS_PER_UNIT = Math.PI * ol.proj.EPSG4326.RADIUS / 180;
ol.proj.EPSG4326.PROJECTIONS = [new ol.proj.EPSG4326.Projection_("CRS:84"), new ol.proj.EPSG4326.Projection_("EPSG:4326", "neu"), new ol.proj.EPSG4326.Projection_("urn:ogc:def:crs:EPSG::4326", "neu"), new ol.proj.EPSG4326.Projection_("urn:ogc:def:crs:EPSG:6.6:4326", "neu"), new ol.proj.EPSG4326.Projection_("urn:ogc:def:crs:OGC:1.3:CRS84"), new ol.proj.EPSG4326.Projection_("urn:ogc:def:crs:OGC:2:84"), new ol.proj.EPSG4326.Projection_("http://www.opengis.net/gml/srs/epsg.xml#4326", "neu"), new ol.proj.EPSG4326.Projection_("urn:x-ogc:def:crs:EPSG:4326", 
"neu")];
goog.provide("ol.proj.projections");
ol.proj.projections.cache_ = {};
ol.proj.projections.clear = function() {
  ol.proj.projections.cache_ = {};
};
ol.proj.projections.get = function(code) {
  var projections = ol.proj.projections.cache_;
  return projections[code] || null;
};
ol.proj.projections.add = function(code, projection) {
  var projections = ol.proj.projections.cache_;
  projections[code] = projection;
};
goog.provide("ol.proj.transforms");
goog.require("ol.obj");
ol.proj.transforms.cache_ = {};
ol.proj.transforms.clear = function() {
  ol.proj.transforms.cache_ = {};
};
ol.proj.transforms.add = function(source, destination, transformFn) {
  var sourceCode = source.getCode();
  var destinationCode = destination.getCode();
  var transforms = ol.proj.transforms.cache_;
  if (!(sourceCode in transforms)) {
    transforms[sourceCode] = {};
  }
  transforms[sourceCode][destinationCode] = transformFn;
};
ol.proj.transforms.remove = function(source, destination) {
  var sourceCode = source.getCode();
  var destinationCode = destination.getCode();
  var transforms = ol.proj.transforms.cache_;
  var transform = transforms[sourceCode][destinationCode];
  delete transforms[sourceCode][destinationCode];
  if (ol.obj.isEmpty(transforms[sourceCode])) {
    delete transforms[sourceCode];
  }
  return transform;
};
ol.proj.transforms.get = function(sourceCode, destinationCode) {
  var transform;
  var transforms = ol.proj.transforms.cache_;
  if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {
    transform = transforms[sourceCode][destinationCode];
  }
  return transform;
};
goog.provide("ol.proj");
goog.require("ol");
goog.require("ol.Sphere");
goog.require("ol.extent");
goog.require("ol.math");
goog.require("ol.proj.EPSG3857");
goog.require("ol.proj.EPSG4326");
goog.require("ol.proj.Projection");
goog.require("ol.proj.Units");
goog.require("ol.proj.proj4");
goog.require("ol.proj.projections");
goog.require("ol.proj.transforms");
ol.proj.METERS_PER_UNIT = ol.proj.Units.METERS_PER_UNIT;
ol.proj.SPHERE_ = new ol.Sphere(ol.Sphere.DEFAULT_RADIUS);
if (ol.ENABLE_PROJ4JS) {
  ol.proj.setProj4 = function(proj4) {
    ol.proj.proj4.set(proj4);
  };
}
ol.proj.getPointResolution = function(projection, resolution, point, opt_units) {
  projection = ol.proj.get(projection);
  var pointResolution;
  var getter = projection.getPointResolutionFunc();
  if (getter) {
    pointResolution = getter(resolution, point);
  } else {
    var units = projection.getUnits();
    if (units == ol.proj.Units.DEGREES && !opt_units || opt_units == ol.proj.Units.DEGREES) {
      pointResolution = resolution;
    } else {
      var toEPSG4326 = ol.proj.getTransformFromProjections(projection, ol.proj.get("EPSG:4326"));
      var vertices = [point[0] - resolution / 2, point[1], point[0] + resolution / 2, point[1], point[0], point[1] - resolution / 2, point[0], point[1] + resolution / 2];
      vertices = toEPSG4326(vertices, vertices, 2);
      var width = ol.proj.SPHERE_.haversineDistance(vertices.slice(0, 2), vertices.slice(2, 4));
      var height = ol.proj.SPHERE_.haversineDistance(vertices.slice(4, 6), vertices.slice(6, 8));
      pointResolution = (width + height) / 2;
      var metersPerUnit = opt_units ? ol.proj.Units.METERS_PER_UNIT[opt_units] : projection.getMetersPerUnit();
      if (metersPerUnit !== undefined) {
        pointResolution /= metersPerUnit;
      }
    }
  }
  return pointResolution;
};
ol.proj.addEquivalentProjections = function(projections) {
  ol.proj.addProjections(projections);
  projections.forEach(function(source) {
    projections.forEach(function(destination) {
      if (source !== destination) {
        ol.proj.transforms.add(source, destination, ol.proj.cloneTransform);
      }
    });
  });
};
ol.proj.addEquivalentTransforms = function(projections1, projections2, forwardTransform, inverseTransform) {
  projections1.forEach(function(projection1) {
    projections2.forEach(function(projection2) {
      ol.proj.transforms.add(projection1, projection2, forwardTransform);
      ol.proj.transforms.add(projection2, projection1, inverseTransform);
    });
  });
};
ol.proj.addProjection = function(projection) {
  ol.proj.projections.add(projection.getCode(), projection);
  ol.proj.transforms.add(projection, projection, ol.proj.cloneTransform);
};
ol.proj.addProjections = function(projections) {
  projections.forEach(ol.proj.addProjection);
};
ol.proj.clearAllProjections = function() {
  ol.proj.projections.clear();
  ol.proj.transforms.clear();
};
ol.proj.createProjection = function(projection, defaultCode) {
  if (!projection) {
    return ol.proj.get(defaultCode);
  } else {
    if (typeof projection === "string") {
      return ol.proj.get(projection);
    } else {
      return projection;
    }
  }
};
ol.proj.addCoordinateTransforms = function(source, destination, forward, inverse) {
  var sourceProj = ol.proj.get(source);
  var destProj = ol.proj.get(destination);
  ol.proj.transforms.add(sourceProj, destProj, ol.proj.createTransformFromCoordinateTransform(forward));
  ol.proj.transforms.add(destProj, sourceProj, ol.proj.createTransformFromCoordinateTransform(inverse));
};
ol.proj.createTransformFromCoordinateTransform = function(transform) {
  return function(input, opt_output, opt_dimension) {
    var length = input.length;
    var dimension = opt_dimension !== undefined ? opt_dimension : 2;
    var output = opt_output !== undefined ? opt_output : new Array(length);
    var point, i, j;
    for (i = 0; i < length; i += dimension) {
      point = transform([input[i], input[i + 1]]);
      output[i] = point[0];
      output[i + 1] = point[1];
      for (j = dimension - 1; j >= 2; --j) {
        output[i + j] = input[i + j];
      }
    }
    return output;
  };
};
ol.proj.fromLonLat = function(coordinate, opt_projection) {
  return ol.proj.transform(coordinate, "EPSG:4326", opt_projection !== undefined ? opt_projection : "EPSG:3857");
};
ol.proj.toLonLat = function(coordinate, opt_projection) {
  var lonLat = ol.proj.transform(coordinate, opt_projection !== undefined ? opt_projection : "EPSG:3857", "EPSG:4326");
  var lon = lonLat[0];
  if (lon < -180 || lon > 180) {
    lonLat[0] = ol.math.modulo(lon + 180, 360) - 180;
  }
  return lonLat;
};
ol.proj.get = function(projectionLike) {
  var projection = null;
  if (projectionLike instanceof ol.proj.Projection) {
    projection = projectionLike;
  } else {
    if (typeof projectionLike === "string") {
      var code = projectionLike;
      projection = ol.proj.projections.get(code);
      if (ol.ENABLE_PROJ4JS && !projection) {
        var proj4js = ol.proj.proj4.get();
        if (typeof proj4js == "function" && proj4js.defs(code) !== undefined) {
          projection = new ol.proj.Projection({code:code});
          ol.proj.addProjection(projection);
        }
      }
    }
  }
  return projection;
};
ol.proj.equivalent = function(projection1, projection2) {
  if (projection1 === projection2) {
    return true;
  }
  var equalUnits = projection1.getUnits() === projection2.getUnits();
  if (projection1.getCode() === projection2.getCode()) {
    return equalUnits;
  } else {
    var transformFn = ol.proj.getTransformFromProjections(projection1, projection2);
    return transformFn === ol.proj.cloneTransform && equalUnits;
  }
};
ol.proj.getTransform = function(source, destination) {
  var sourceProjection = ol.proj.get(source);
  var destinationProjection = ol.proj.get(destination);
  return ol.proj.getTransformFromProjections(sourceProjection, destinationProjection);
};
ol.proj.getTransformFromProjections = function(sourceProjection, destinationProjection) {
  var sourceCode = sourceProjection.getCode();
  var destinationCode = destinationProjection.getCode();
  var transform = ol.proj.transforms.get(sourceCode, destinationCode);
  if (ol.ENABLE_PROJ4JS && !transform) {
    var proj4js = ol.proj.proj4.get();
    if (typeof proj4js == "function") {
      var sourceDef = proj4js.defs(sourceCode);
      var destinationDef = proj4js.defs(destinationCode);
      if (sourceDef !== undefined && destinationDef !== undefined) {
        if (sourceDef === destinationDef) {
          ol.proj.addEquivalentProjections([destinationProjection, sourceProjection]);
        } else {
          var proj4Transform = proj4js(destinationCode, sourceCode);
          ol.proj.addCoordinateTransforms(destinationProjection, sourceProjection, proj4Transform.forward, proj4Transform.inverse);
        }
        transform = ol.proj.transforms.get(sourceCode, destinationCode);
      }
    }
  }
  if (!transform) {
    transform = ol.proj.identityTransform;
  }
  return transform;
};
ol.proj.identityTransform = function(input, opt_output, opt_dimension) {
  if (opt_output !== undefined && input !== opt_output) {
    for (var i = 0, ii = input.length; i < ii; ++i) {
      opt_output[i] = input[i];
    }
    input = opt_output;
  }
  return input;
};
ol.proj.cloneTransform = function(input, opt_output, opt_dimension) {
  var output;
  if (opt_output !== undefined) {
    for (var i = 0, ii = input.length; i < ii; ++i) {
      opt_output[i] = input[i];
    }
    output = opt_output;
  } else {
    output = input.slice();
  }
  return output;
};
ol.proj.transform = function(coordinate, source, destination) {
  var transformFn = ol.proj.getTransform(source, destination);
  return transformFn(coordinate, undefined, coordinate.length);
};
ol.proj.transformExtent = function(extent, source, destination) {
  var transformFn = ol.proj.getTransform(source, destination);
  return ol.extent.applyTransform(extent, transformFn);
};
ol.proj.transformWithProjections = function(point, sourceProjection, destinationProjection) {
  var transformFn = ol.proj.getTransformFromProjections(sourceProjection, destinationProjection);
  return transformFn(point);
};
ol.proj.addCommon = function() {
  ol.proj.addEquivalentProjections(ol.proj.EPSG3857.PROJECTIONS);
  ol.proj.addEquivalentProjections(ol.proj.EPSG4326.PROJECTIONS);
  ol.proj.addEquivalentTransforms(ol.proj.EPSG4326.PROJECTIONS, ol.proj.EPSG3857.PROJECTIONS, ol.proj.EPSG3857.fromEPSG4326, ol.proj.EPSG3857.toEPSG4326);
};
ol.proj.addCommon();
goog.provide("ol.easing");
ol.easing.easeIn = function(t) {
  return Math.pow(t, 3);
};
ol.easing.easeOut = function(t) {
  return 1 - ol.easing.easeIn(1 - t);
};
ol.easing.inAndOut = function(t) {
  return 3 * t * t - 2 * t * t * t;
};
ol.easing.linear = function(t) {
  return t;
};
ol.easing.upAndDown = function(t) {
  if (t < 0.5) {
    return ol.easing.inAndOut(2 * t);
  } else {
    return 1 - ol.easing.inAndOut(2 * (t - 0.5));
  }
};
goog.provide("ol.LayerType");
ol.LayerType = {IMAGE:"IMAGE", TILE:"TILE", VECTOR_TILE:"VECTOR_TILE", VECTOR:"VECTOR"};
goog.provide("ol.render.EventType");
ol.render.EventType = {POSTCOMPOSE:"postcompose", PRECOMPOSE:"precompose", RENDER:"render"};
goog.provide("ol.layer.Layer");
goog.require("ol.events");
goog.require("ol.events.EventType");
goog.require("ol");
goog.require("ol.Object");
goog.require("ol.layer.Base");
goog.require("ol.layer.Property");
goog.require("ol.obj");
goog.require("ol.render.EventType");
goog.require("ol.source.State");
ol.layer.Layer = function(options) {
  var baseOptions = ol.obj.assign({}, options);
  delete baseOptions.source;
  ol.layer.Base.call(this, baseOptions);
  this.mapPrecomposeKey_ = null;
  this.mapRenderKey_ = null;
  this.sourceChangeKey_ = null;
  if (options.map) {
    this.setMap(options.map);
  }
  ol.events.listen(this, ol.Object.getChangeEventType(ol.layer.Property.SOURCE), this.handleSourcePropertyChange_, this);
  var source = options.source ? options.source : null;
  this.setSource(source);
};
ol.inherits(ol.layer.Layer, ol.layer.Base);
ol.layer.Layer.visibleAtResolution = function(layerState, resolution) {
  return layerState.visible && resolution >= layerState.minResolution && resolution < layerState.maxResolution;
};
ol.layer.Layer.prototype.getLayersArray = function(opt_array) {
  var array = opt_array ? opt_array : [];
  array.push(this);
  return array;
};
ol.layer.Layer.prototype.getLayerStatesArray = function(opt_states) {
  var states = opt_states ? opt_states : [];
  states.push(this.getLayerState());
  return states;
};
ol.layer.Layer.prototype.getSource = function() {
  var source = this.get(ol.layer.Property.SOURCE);
  return source || null;
};
ol.layer.Layer.prototype.getSourceState = function() {
  var source = this.getSource();
  return !source ? ol.source.State.UNDEFINED : source.getState();
};
ol.layer.Layer.prototype.handleSourceChange_ = function() {
  this.changed();
};
ol.layer.Layer.prototype.handleSourcePropertyChange_ = function() {
  if (this.sourceChangeKey_) {
    ol.events.unlistenByKey(this.sourceChangeKey_);
    this.sourceChangeKey_ = null;
  }
  var source = this.getSource();
  if (source) {
    this.sourceChangeKey_ = ol.events.listen(source, ol.events.EventType.CHANGE, this.handleSourceChange_, this);
  }
  this.changed();
};
ol.layer.Layer.prototype.setMap = function(map) {
  if (this.mapPrecomposeKey_) {
    ol.events.unlistenByKey(this.mapPrecomposeKey_);
    this.mapPrecomposeKey_ = null;
  }
  if (!map) {
    this.changed();
  }
  if (this.mapRenderKey_) {
    ol.events.unlistenByKey(this.mapRenderKey_);
    this.mapRenderKey_ = null;
  }
  if (map) {
    this.mapPrecomposeKey_ = ol.events.listen(map, ol.render.EventType.PRECOMPOSE, function(evt) {
      var layerState = this.getLayerState();
      layerState.managed = false;
      layerState.zIndex = Infinity;
      evt.frameState.layerStatesArray.push(layerState);
      evt.frameState.layerStates[ol.getUid(this)] = layerState;
    }, this);
    this.mapRenderKey_ = ol.events.listen(this, ol.events.EventType.CHANGE, map.render, map);
    this.changed();
  }
};
ol.layer.Layer.prototype.setSource = function(source) {
  this.set(ol.layer.Property.SOURCE, source);
};
goog.provide("ol.layer.TileProperty");
ol.layer.TileProperty = {PRELOAD:"preload", USE_INTERIM_TILES_ON_ERROR:"useInterimTilesOnError"};
goog.provide("ol.layer.Tile");
goog.require("ol");
goog.require("ol.LayerType");
goog.require("ol.layer.Layer");
goog.require("ol.layer.TileProperty");
goog.require("ol.obj");
ol.layer.Tile = function(opt_options) {
  var options = opt_options ? opt_options : {};
  var baseOptions = ol.obj.assign({}, options);
  delete baseOptions.preload;
  delete baseOptions.useInterimTilesOnError;
  ol.layer.Layer.call(this, baseOptions);
  this.setPreload(options.preload !== undefined ? options.preload : 0);
  this.setUseInterimTilesOnError(options.useInterimTilesOnError !== undefined ? options.useInterimTilesOnError : true);
  this.type = ol.LayerType.TILE;
};
ol.inherits(ol.layer.Tile, ol.layer.Layer);
ol.layer.Tile.prototype.getPreload = function() {
  return this.get(ol.layer.TileProperty.PRELOAD);
};
ol.layer.Tile.prototype.getSource;
ol.layer.Tile.prototype.setPreload = function(preload) {
  this.set(ol.layer.TileProperty.PRELOAD, preload);
};
ol.layer.Tile.prototype.getUseInterimTilesOnError = function() {
  return this.get(ol.layer.TileProperty.USE_INTERIM_TILES_ON_ERROR);
};
ol.layer.Tile.prototype.setUseInterimTilesOnError = function(useInterimTilesOnError) {
  this.set(ol.layer.TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
};
goog.provide("ol.layer.Image");
goog.require("ol");
goog.require("ol.LayerType");
goog.require("ol.layer.Layer");
ol.layer.Image = function(opt_options) {
  var options = opt_options ? opt_options : {};
  ol.layer.Layer.call(this, options);
  this.type = ol.LayerType.IMAGE;
};
ol.inherits(ol.layer.Image, ol.layer.Layer);
ol.layer.Image.prototype.getSource;
goog.provide("ol.ImageState");
ol.ImageState = {IDLE:0, LOADING:1, LOADED:2, ERROR:3};
goog.provide("ol.array");
ol.array.binarySearch = function(haystack, needle, opt_comparator) {
  var mid, cmp;
  var comparator = opt_comparator || ol.array.numberSafeCompareFunction;
  var low = 0;
  var high = haystack.length;
  var found = false;
  while (low < high) {
    mid = low + (high - low >> 1);
    cmp = +comparator(haystack[mid], needle);
    if (cmp < 0.0) {
      low = mid + 1;
    } else {
      high = mid;
      found = !cmp;
    }
  }
  return found ? low : ~low;
};
ol.array.numberSafeCompareFunction = function(a, b) {
  return a > b ? 1 : a < b ? -1 : 0;
};
ol.array.includes = function(arr, obj) {
  return arr.indexOf(obj) >= 0;
};
ol.array.linearFindNearest = function(arr, target, direction) {
  var n = arr.length;
  if (arr[0] <= target) {
    return 0;
  } else {
    if (target <= arr[n - 1]) {
      return n - 1;
    } else {
      var i;
      if (direction > 0) {
        for (i = 1; i < n; ++i) {
          if (arr[i] < target) {
            return i - 1;
          }
        }
      } else {
        if (direction < 0) {
          for (i = 1; i < n; ++i) {
            if (arr[i] <= target) {
              return i;
            }
          }
        } else {
          for (i = 1; i < n; ++i) {
            if (arr[i] == target) {
              return i;
            } else {
              if (arr[i] < target) {
                if (arr[i - 1] - target < target - arr[i]) {
                  return i - 1;
                } else {
                  return i;
                }
              }
            }
          }
        }
      }
      return n - 1;
    }
  }
};
ol.array.reverseSubArray = function(arr, begin, end) {
  while (begin < end) {
    var tmp = arr[begin];
    arr[begin] = arr[end];
    arr[end] = tmp;
    ++begin;
    --end;
  }
};
ol.array.extend = function(arr, data) {
  var i;
  var extension = Array.isArray(data) ? data : [data];
  var length = extension.length;
  for (i = 0; i < length; i++) {
    arr[arr.length] = extension[i];
  }
};
ol.array.remove = function(arr, obj) {
  var i = arr.indexOf(obj);
  var found = i > -1;
  if (found) {
    arr.splice(i, 1);
  }
  return found;
};
ol.array.find = function(arr, func) {
  var length = arr.length >>> 0;
  var value;
  for (var i = 0; i < length; i++) {
    value = arr[i];
    if (func(value, i, arr)) {
      return value;
    }
  }
  return null;
};
ol.array.equals = function(arr1, arr2) {
  var len1 = arr1.length;
  if (len1 !== arr2.length) {
    return false;
  }
  for (var i = 0; i < len1; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }
  return true;
};
ol.array.stableSort = function(arr, compareFnc) {
  var length = arr.length;
  var tmp = Array(arr.length);
  var i;
  for (i = 0; i < length; i++) {
    tmp[i] = {index:i, value:arr[i]};
  }
  tmp.sort(function(a, b) {
    return compareFnc(a.value, b.value) || a.index - b.index;
  });
  for (i = 0; i < arr.length; i++) {
    arr[i] = tmp[i].value;
  }
};
ol.array.findIndex = function(arr, func) {
  var index;
  var found = !arr.every(function(el, idx) {
    index = idx;
    return !func(el, idx, arr);
  });
  return found ? index : -1;
};
ol.array.isSorted = function(arr, opt_func, opt_strict) {
  var compare = opt_func || ol.array.numberSafeCompareFunction;
  return arr.every(function(currentVal, index) {
    if (index === 0) {
      return true;
    }
    var res = compare(arr[index - 1], currentVal);
    return !(res > 0 || opt_strict && res === 0);
  });
};
goog.provide("ol.ImageBase");
goog.require("ol");
goog.require("ol.events.EventTarget");
goog.require("ol.events.EventType");
ol.ImageBase = function(extent, resolution, pixelRatio, state) {
  ol.events.EventTarget.call(this);
  this.extent = extent;
  this.pixelRatio_ = pixelRatio;
  this.resolution = resolution;
  this.state = state;
};
ol.inherits(ol.ImageBase, ol.events.EventTarget);
ol.ImageBase.prototype.changed = function() {
  this.dispatchEvent(ol.events.EventType.CHANGE);
};
ol.ImageBase.prototype.getExtent = function() {
  return this.extent;
};
ol.ImageBase.prototype.getImage = function() {
};
ol.ImageBase.prototype.getPixelRatio = function() {
  return this.pixelRatio_;
};
ol.ImageBase.prototype.getResolution = function() {
  return this.resolution;
};
ol.ImageBase.prototype.getState = function() {
  return this.state;
};
ol.ImageBase.prototype.load = function() {
};
goog.provide("ol.dom");
ol.dom.createCanvasContext2D = function(opt_width, opt_height) {
  var canvas = document.createElement("CANVAS");
  if (opt_width) {
    canvas.width = opt_width;
  }
  if (opt_height) {
    canvas.height = opt_height;
  }
  return canvas.getContext("2d");
};
ol.dom.outerWidth = function(element) {
  var width = element.offsetWidth;
  var style = getComputedStyle(element);
  width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);
  return width;
};
ol.dom.outerHeight = function(element) {
  var height = element.offsetHeight;
  var style = getComputedStyle(element);
  height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);
  return height;
};
ol.dom.replaceNode = function(newNode, oldNode) {
  var parent = oldNode.parentNode;
  if (parent) {
    parent.replaceChild(newNode, oldNode);
  }
};
ol.dom.removeNode = function(node) {
  return node && node.parentNode ? node.parentNode.removeChild(node) : null;
};
ol.dom.removeChildren = function(node) {
  while (node.lastChild) {
    node.removeChild(node.lastChild);
  }
};
goog.provide("ol.reproj");
goog.require("ol.dom");
goog.require("ol.extent");
goog.require("ol.math");
goog.require("ol.proj");
ol.reproj.calculateSourceResolution = function(sourceProj, targetProj, targetCenter, targetResolution) {
  var sourceCenter = ol.proj.transform(targetCenter, targetProj, sourceProj);
  var sourceResolution = ol.proj.getPointResolution(targetProj, targetResolution, targetCenter);
  var targetMetersPerUnit = targetProj.getMetersPerUnit();
  if (targetMetersPerUnit !== undefined) {
    sourceResolution *= targetMetersPerUnit;
  }
  var sourceMetersPerUnit = sourceProj.getMetersPerUnit();
  if (sourceMetersPerUnit !== undefined) {
    sourceResolution /= sourceMetersPerUnit;
  }
  var sourceExtent = sourceProj.getExtent();
  if (!sourceExtent || ol.extent.containsCoordinate(sourceExtent, sourceCenter)) {
    var compensationFactor = ol.proj.getPointResolution(sourceProj, sourceResolution, sourceCenter) / sourceResolution;
    if (isFinite(compensationFactor) && compensationFactor > 0) {
      sourceResolution /= compensationFactor;
    }
  }
  return sourceResolution;
};
ol.reproj.enlargeClipPoint_ = function(centroidX, centroidY, x, y) {
  var dX = x - centroidX, dY = y - centroidY;
  var distance = Math.sqrt(dX * dX + dY * dY);
  return [Math.round(x + dX / distance), Math.round(y + dY / distance)];
};
ol.reproj.render = function(width, height, pixelRatio, sourceResolution, sourceExtent, targetResolution, targetExtent, triangulation, sources, gutter, opt_renderEdges) {
  var context = ol.dom.createCanvasContext2D(Math.round(pixelRatio * width), Math.round(pixelRatio * height));
  if (sources.length === 0) {
    return context.canvas;
  }
  context.scale(pixelRatio, pixelRatio);
  var sourceDataExtent = ol.extent.createEmpty();
  sources.forEach(function(src, i, arr) {
    ol.extent.extend(sourceDataExtent, src.extent);
  });
  var canvasWidthInUnits = ol.extent.getWidth(sourceDataExtent);
  var canvasHeightInUnits = ol.extent.getHeight(sourceDataExtent);
  var stitchContext = ol.dom.createCanvasContext2D(Math.round(pixelRatio * canvasWidthInUnits / sourceResolution), Math.round(pixelRatio * canvasHeightInUnits / sourceResolution));
  var stitchScale = pixelRatio / sourceResolution;
  sources.forEach(function(src, i, arr) {
    var xPos = src.extent[0] - sourceDataExtent[0];
    var yPos = -(src.extent[3] - sourceDataExtent[3]);
    var srcWidth = ol.extent.getWidth(src.extent);
    var srcHeight = ol.extent.getHeight(src.extent);
    stitchContext.drawImage(src.image, gutter, gutter, src.image.width - 2 * gutter, src.image.height - 2 * gutter, xPos * stitchScale, yPos * stitchScale, srcWidth * stitchScale, srcHeight * stitchScale);
  });
  var targetTopLeft = ol.extent.getTopLeft(targetExtent);
  triangulation.getTriangles().forEach(function(triangle, i, arr) {
    var source = triangle.source, target = triangle.target;
    var x0 = source[0][0], y0 = source[0][1], x1 = source[1][0], y1 = source[1][1], x2 = source[2][0], y2 = source[2][1];
    var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution, v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
    var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution, v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
    var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution, v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;
    var sourceNumericalShiftX = x0, sourceNumericalShiftY = y0;
    x0 = 0;
    y0 = 0;
    x1 -= sourceNumericalShiftX;
    y1 -= sourceNumericalShiftY;
    x2 -= sourceNumericalShiftX;
    y2 -= sourceNumericalShiftY;
    var augmentedMatrix = [[x1, y1, 0, 0, u1 - u0], [x2, y2, 0, 0, u2 - u0], [0, 0, x1, y1, v1 - v0], [0, 0, x2, y2, v2 - v0]];
    var affineCoefs = ol.math.solveLinearSystem(augmentedMatrix);
    if (!affineCoefs) {
      return;
    }
    context.save();
    context.beginPath();
    var centroidX = (u0 + u1 + u2) / 3, centroidY = (v0 + v1 + v2) / 3;
    var p0 = ol.reproj.enlargeClipPoint_(centroidX, centroidY, u0, v0);
    var p1 = ol.reproj.enlargeClipPoint_(centroidX, centroidY, u1, v1);
    var p2 = ol.reproj.enlargeClipPoint_(centroidX, centroidY, u2, v2);
    context.moveTo(p1[0], p1[1]);
    context.lineTo(p0[0], p0[1]);
    context.lineTo(p2[0], p2[1]);
    context.clip();
    context.transform(affineCoefs[0], affineCoefs[2], affineCoefs[1], affineCoefs[3], u0, v0);
    context.translate(sourceDataExtent[0] - sourceNumericalShiftX, sourceDataExtent[3] - sourceNumericalShiftY);
    context.scale(sourceResolution / pixelRatio, -sourceResolution / pixelRatio);
    context.drawImage(stitchContext.canvas, 0, 0);
    context.restore();
  });
  if (opt_renderEdges) {
    context.save();
    context.strokeStyle = "black";
    context.lineWidth = 1;
    triangulation.getTriangles().forEach(function(triangle, i, arr) {
      var target = triangle.target;
      var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution, v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
      var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution, v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
      var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution, v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;
      context.beginPath();
      context.moveTo(u1, v1);
      context.lineTo(u0, v0);
      context.lineTo(u2, v2);
      context.closePath();
      context.stroke();
    });
    context.restore();
  }
  return context.canvas;
};
goog.provide("ol.reproj.Triangulation");
goog.require("ol");
goog.require("ol.extent");
goog.require("ol.math");
goog.require("ol.proj");
ol.reproj.Triangulation = function(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold) {
  this.sourceProj_ = sourceProj;
  this.targetProj_ = targetProj;
  var transformInvCache = {};
  var transformInv = ol.proj.getTransform(this.targetProj_, this.sourceProj_);
  this.transformInv_ = function(c) {
    var key = c[0] + "/" + c[1];
    if (!transformInvCache[key]) {
      transformInvCache[key] = transformInv(c);
    }
    return transformInvCache[key];
  };
  this.maxSourceExtent_ = maxSourceExtent;
  this.errorThresholdSquared_ = errorThreshold * errorThreshold;
  this.triangles_ = [];
  this.wrapsXInSource_ = false;
  this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!maxSourceExtent && !!this.sourceProj_.getExtent() && ol.extent.getWidth(maxSourceExtent) == ol.extent.getWidth(this.sourceProj_.getExtent());
  this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? ol.extent.getWidth(this.sourceProj_.getExtent()) : null;
  this.targetWorldWidth_ = this.targetProj_.getExtent() ? ol.extent.getWidth(this.targetProj_.getExtent()) : null;
  var destinationTopLeft = ol.extent.getTopLeft(targetExtent);
  var destinationTopRight = ol.extent.getTopRight(targetExtent);
  var destinationBottomRight = ol.extent.getBottomRight(targetExtent);
  var destinationBottomLeft = ol.extent.getBottomLeft(targetExtent);
  var sourceTopLeft = this.transformInv_(destinationTopLeft);
  var sourceTopRight = this.transformInv_(destinationTopRight);
  var sourceBottomRight = this.transformInv_(destinationBottomRight);
  var sourceBottomLeft = this.transformInv_(destinationBottomLeft);
  this.addQuad_(destinationTopLeft, destinationTopRight, destinationBottomRight, destinationBottomLeft, sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft, ol.RASTER_REPROJECTION_MAX_SUBDIVISION);
  if (this.wrapsXInSource_) {
    var leftBound = Infinity;
    this.triangles_.forEach(function(triangle, i, arr) {
      leftBound = Math.min(leftBound, triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);
    });
    this.triangles_.forEach(function(triangle) {
      if (Math.max(triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]) - leftBound > this.sourceWorldWidth_ / 2) {
        var newTriangle = [[triangle.source[0][0], triangle.source[0][1]], [triangle.source[1][0], triangle.source[1][1]], [triangle.source[2][0], triangle.source[2][1]]];
        if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {
          newTriangle[0][0] -= this.sourceWorldWidth_;
        }
        if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {
          newTriangle[1][0] -= this.sourceWorldWidth_;
        }
        if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {
          newTriangle[2][0] -= this.sourceWorldWidth_;
        }
        var minX = Math.min(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);
        var maxX = Math.max(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);
        if (maxX - minX < this.sourceWorldWidth_ / 2) {
          triangle.source = newTriangle;
        }
      }
    }, this);
  }
  transformInvCache = {};
};
ol.reproj.Triangulation.prototype.addTriangle_ = function(a, b, c, aSrc, bSrc, cSrc) {
  this.triangles_.push({source:[aSrc, bSrc, cSrc], target:[a, b, c]});
};
ol.reproj.Triangulation.prototype.addQuad_ = function(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {
  var sourceQuadExtent = ol.extent.boundingExtent([aSrc, bSrc, cSrc, dSrc]);
  var sourceCoverageX = this.sourceWorldWidth_ ? ol.extent.getWidth(sourceQuadExtent) / this.sourceWorldWidth_ : null;
  var sourceWorldWidth = this.sourceWorldWidth_;
  var wrapsX = this.sourceProj_.canWrapX() && sourceCoverageX > 0.5 && sourceCoverageX < 1;
  var needsSubdivision = false;
  if (maxSubdivision > 0) {
    if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
      var targetQuadExtent = ol.extent.boundingExtent([a, b, c, d]);
      var targetCoverageX = ol.extent.getWidth(targetQuadExtent) / this.targetWorldWidth_;
      needsSubdivision |= targetCoverageX > ol.RASTER_REPROJECTION_MAX_TRIANGLE_WIDTH;
    }
    if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {
      needsSubdivision |= sourceCoverageX > ol.RASTER_REPROJECTION_MAX_TRIANGLE_WIDTH;
    }
  }
  if (!needsSubdivision && this.maxSourceExtent_) {
    if (!ol.extent.intersects(sourceQuadExtent, this.maxSourceExtent_)) {
      return;
    }
  }
  if (!needsSubdivision) {
    if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) || !isFinite(bSrc[0]) || !isFinite(bSrc[1]) || !isFinite(cSrc[0]) || !isFinite(cSrc[1]) || !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {
      if (maxSubdivision > 0) {
        needsSubdivision = true;
      } else {
        return;
      }
    }
  }
  if (maxSubdivision > 0) {
    if (!needsSubdivision) {
      var center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];
      var centerSrc = this.transformInv_(center);
      var dx;
      if (wrapsX) {
        var centerSrcEstimX = (ol.math.modulo(aSrc[0], sourceWorldWidth) + ol.math.modulo(cSrc[0], sourceWorldWidth)) / 2;
        dx = centerSrcEstimX - ol.math.modulo(centerSrc[0], sourceWorldWidth);
      } else {
        dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];
      }
      var dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];
      var centerSrcErrorSquared = dx * dx + dy * dy;
      needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;
    }
    if (needsSubdivision) {
      if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {
        var bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];
        var bcSrc = this.transformInv_(bc);
        var da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];
        var daSrc = this.transformInv_(da);
        this.addQuad_(a, b, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);
        this.addQuad_(da, bc, c, d, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);
      } else {
        var ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];
        var abSrc = this.transformInv_(ab);
        var cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];
        var cdSrc = this.transformInv_(cd);
        this.addQuad_(a, ab, cd, d, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);
        this.addQuad_(ab, b, c, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);
      }
      return;
    }
  }
  if (wrapsX) {
    if (!this.canWrapXInSource_) {
      return;
    }
    this.wrapsXInSource_ = true;
  }
  this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);
  this.addTriangle_(a, b, c, aSrc, bSrc, cSrc);
};
ol.reproj.Triangulation.prototype.calculateSourceExtent = function() {
  var extent = ol.extent.createEmpty();
  this.triangles_.forEach(function(triangle, i, arr) {
    var src = triangle.source;
    ol.extent.extendCoordinate(extent, src[0]);
    ol.extent.extendCoordinate(extent, src[1]);
    ol.extent.extendCoordinate(extent, src[2]);
  });
  return extent;
};
ol.reproj.Triangulation.prototype.getTriangles = function() {
  return this.triangles_;
};
goog.provide("ol.reproj.Image");
goog.require("ol");
goog.require("ol.ImageBase");
goog.require("ol.ImageState");
goog.require("ol.events");
goog.require("ol.events.EventType");
goog.require("ol.extent");
goog.require("ol.reproj");
goog.require("ol.reproj.Triangulation");
ol.reproj.Image = function(sourceProj, targetProj, targetExtent, targetResolution, pixelRatio, getImageFunction) {
  this.targetProj_ = targetProj;
  this.maxSourceExtent_ = sourceProj.getExtent();
  var maxTargetExtent = targetProj.getExtent();
  var limitedTargetExtent = maxTargetExtent ? ol.extent.getIntersection(targetExtent, maxTargetExtent) : targetExtent;
  var targetCenter = ol.extent.getCenter(limitedTargetExtent);
  var sourceResolution = ol.reproj.calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution);
  var errorThresholdInPixels = ol.DEFAULT_RASTER_REPROJECTION_ERROR_THRESHOLD;
  this.triangulation_ = new ol.reproj.Triangulation(sourceProj, targetProj, limitedTargetExtent, this.maxSourceExtent_, sourceResolution * errorThresholdInPixels);
  this.targetResolution_ = targetResolution;
  this.targetExtent_ = targetExtent;
  var sourceExtent = this.triangulation_.calculateSourceExtent();
  this.sourceImage_ = getImageFunction(sourceExtent, sourceResolution, pixelRatio);
  this.sourcePixelRatio_ = this.sourceImage_ ? this.sourceImage_.getPixelRatio() : 1;
  this.canvas_ = null;
  this.sourceListenerKey_ = null;
  var state = ol.ImageState.LOADED;
  if (this.sourceImage_) {
    state = ol.ImageState.IDLE;
  }
  ol.ImageBase.call(this, targetExtent, targetResolution, this.sourcePixelRatio_, state);
};
ol.inherits(ol.reproj.Image, ol.ImageBase);
ol.reproj.Image.prototype.disposeInternal = function() {
  if (this.state == ol.ImageState.LOADING) {
    this.unlistenSource_();
  }
  ol.ImageBase.prototype.disposeInternal.call(this);
};
ol.reproj.Image.prototype.getImage = function() {
  return this.canvas_;
};
ol.reproj.Image.prototype.getProjection = function() {
  return this.targetProj_;
};
ol.reproj.Image.prototype.reproject_ = function() {
  var sourceState = this.sourceImage_.getState();
  if (sourceState == ol.ImageState.LOADED) {
    var width = ol.extent.getWidth(this.targetExtent_) / this.targetResolution_;
    var height = ol.extent.getHeight(this.targetExtent_) / this.targetResolution_;
    this.canvas_ = ol.reproj.render(width, height, this.sourcePixelRatio_, this.sourceImage_.getResolution(), this.maxSourceExtent_, this.targetResolution_, this.targetExtent_, this.triangulation_, [{extent:this.sourceImage_.getExtent(), image:this.sourceImage_.getImage()}], 0);
  }
  this.state = sourceState;
  this.changed();
};
ol.reproj.Image.prototype.load = function() {
  if (this.state == ol.ImageState.IDLE) {
    this.state = ol.ImageState.LOADING;
    this.changed();
    var sourceState = this.sourceImage_.getState();
    if (sourceState == ol.ImageState.LOADED || sourceState == ol.ImageState.ERROR) {
      this.reproject_();
    } else {
      this.sourceListenerKey_ = ol.events.listen(this.sourceImage_, ol.events.EventType.CHANGE, function(e) {
        var sourceState = this.sourceImage_.getState();
        if (sourceState == ol.ImageState.LOADED || sourceState == ol.ImageState.ERROR) {
          this.unlistenSource_();
          this.reproject_();
        }
      }, this);
      this.sourceImage_.load();
    }
  }
};
ol.reproj.Image.prototype.unlistenSource_ = function() {
  ol.events.unlistenByKey(this.sourceListenerKey_);
  this.sourceListenerKey_ = null;
};
goog.provide("ol.TileRange");
ol.TileRange = function(minX, maxX, minY, maxY) {
  this.minX = minX;
  this.maxX = maxX;
  this.minY = minY;
  this.maxY = maxY;
};
ol.TileRange.createOrUpdate = function(minX, maxX, minY, maxY, tileRange) {
  if (tileRange !== undefined) {
    tileRange.minX = minX;
    tileRange.maxX = maxX;
    tileRange.minY = minY;
    tileRange.maxY = maxY;
    return tileRange;
  } else {
    return new ol.TileRange(minX, maxX, minY, maxY);
  }
};
ol.TileRange.prototype.contains = function(tileCoord) {
  return this.containsXY(tileCoord[1], tileCoord[2]);
};
ol.TileRange.prototype.containsTileRange = function(tileRange) {
  return this.minX <= tileRange.minX && tileRange.maxX <= this.maxX && this.minY <= tileRange.minY && tileRange.maxY <= this.maxY;
};
ol.TileRange.prototype.containsXY = function(x, y) {
  return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;
};
ol.TileRange.prototype.equals = function(tileRange) {
  return this.minX == tileRange.minX && this.minY == tileRange.minY && this.maxX == tileRange.maxX && this.maxY == tileRange.maxY;
};
ol.TileRange.prototype.extend = function(tileRange) {
  if (tileRange.minX < this.minX) {
    this.minX = tileRange.minX;
  }
  if (tileRange.maxX > this.maxX) {
    this.maxX = tileRange.maxX;
  }
  if (tileRange.minY < this.minY) {
    this.minY = tileRange.minY;
  }
  if (tileRange.maxY > this.maxY) {
    this.maxY = tileRange.maxY;
  }
};
ol.TileRange.prototype.getHeight = function() {
  return this.maxY - this.minY + 1;
};
ol.TileRange.prototype.getSize = function() {
  return [this.getWidth(), this.getHeight()];
};
ol.TileRange.prototype.getWidth = function() {
  return this.maxX - this.minX + 1;
};
ol.TileRange.prototype.intersects = function(tileRange) {
  return this.minX <= tileRange.maxX && this.maxX >= tileRange.minX && this.minY <= tileRange.maxY && this.maxY >= tileRange.minY;
};
goog.provide("ol.size");
ol.size.buffer = function(size, buffer, opt_size) {
  if (opt_size === undefined) {
    opt_size = [0, 0];
  }
  opt_size[0] = size[0] + 2 * buffer;
  opt_size[1] = size[1] + 2 * buffer;
  return opt_size;
};
ol.size.hasArea = function(size) {
  return size[0] > 0 && size[1] > 0;
};
ol.size.scale = function(size, ratio, opt_size) {
  if (opt_size === undefined) {
    opt_size = [0, 0];
  }
  opt_size[0] = size[0] * ratio + 0.5 | 0;
  opt_size[1] = size[1] * ratio + 0.5 | 0;
  return opt_size;
};
ol.size.toSize = function(size, opt_size) {
  if (Array.isArray(size)) {
    return size;
  } else {
    if (opt_size === undefined) {
      opt_size = [size, size];
    } else {
      opt_size[0] = opt_size[1] = size;
    }
    return opt_size;
  }
};
goog.provide("ol.tilecoord");
ol.tilecoord.createOrUpdate = function(z, x, y, opt_tileCoord) {
  if (opt_tileCoord !== undefined) {
    opt_tileCoord[0] = z;
    opt_tileCoord[1] = x;
    opt_tileCoord[2] = y;
    return opt_tileCoord;
  } else {
    return [z, x, y];
  }
};
ol.tilecoord.getKeyZXY = function(z, x, y) {
  return z + "/" + x + "/" + y;
};
ol.tilecoord.getKey = function(tileCoord) {
  return ol.tilecoord.getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);
};
ol.tilecoord.fromKey = function(key) {
  return key.split("/").map(Number);
};
ol.tilecoord.hash = function(tileCoord) {
  return (tileCoord[1] << tileCoord[0]) + tileCoord[2];
};
ol.tilecoord.quadKey = function(tileCoord) {
  var z = tileCoord[0];
  var digits = new Array(z);
  var mask = 1 << z - 1;
  var i, charCode;
  for (i = 0; i < z; ++i) {
    charCode = 48;
    if (tileCoord[1] & mask) {
      charCode += 1;
    }
    if (tileCoord[2] & mask) {
      charCode += 2;
    }
    digits[i] = String.fromCharCode(charCode);
    mask >>= 1;
  }
  return digits.join("");
};
ol.tilecoord.withinExtentAndZ = function(tileCoord, tileGrid) {
  var z = tileCoord[0];
  var x = tileCoord[1];
  var y = tileCoord[2];
  if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {
    return false;
  }
  var extent = tileGrid.getExtent();
  var tileRange;
  if (!extent) {
    tileRange = tileGrid.getFullTileRange(z);
  } else {
    tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
  }
  if (!tileRange) {
    return true;
  } else {
    return tileRange.containsXY(x, y);
  }
};
goog.provide("ol.tilegrid.TileGrid");
goog.require("ol");
goog.require("ol.asserts");
goog.require("ol.TileRange");
goog.require("ol.array");
goog.require("ol.extent");
goog.require("ol.math");
goog.require("ol.size");
goog.require("ol.tilecoord");
ol.tilegrid.TileGrid = function(options) {
  this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;
  this.resolutions_ = options.resolutions;
  ol.asserts.assert(ol.array.isSorted(this.resolutions_, function(a, b) {
    return b - a;
  }, true), 17);
  var zoomFactor;
  if (!options.origins) {
    for (var i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {
      if (!zoomFactor) {
        zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];
      } else {
        if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {
          zoomFactor = undefined;
          break;
        }
      }
    }
  }
  this.zoomFactor_ = zoomFactor;
  this.maxZoom = this.resolutions_.length - 1;
  this.origin_ = options.origin !== undefined ? options.origin : null;
  this.origins_ = null;
  if (options.origins !== undefined) {
    this.origins_ = options.origins;
    ol.asserts.assert(this.origins_.length == this.resolutions_.length, 20);
  }
  var extent = options.extent;
  if (extent !== undefined && !this.origin_ && !this.origins_) {
    this.origin_ = ol.extent.getTopLeft(extent);
  }
  ol.asserts.assert(!this.origin_ && this.origins_ || this.origin_ && !this.origins_, 18);
  this.tileSizes_ = null;
  if (options.tileSizes !== undefined) {
    this.tileSizes_ = options.tileSizes;
    ol.asserts.assert(this.tileSizes_.length == this.resolutions_.length, 19);
  }
  this.tileSize_ = options.tileSize !== undefined ? options.tileSize : !this.tileSizes_ ? ol.DEFAULT_TILE_SIZE : null;
  ol.asserts.assert(!this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_, 22);
  this.extent_ = extent !== undefined ? extent : null;
  this.fullTileRanges_ = null;
  this.tmpSize_ = [0, 0];
  if (options.sizes !== undefined) {
    this.fullTileRanges_ = options.sizes.map(function(size, z) {
      var tileRange = new ol.TileRange(Math.min(0, size[0]), Math.max(size[0] - 1, -1), Math.min(0, size[1]), Math.max(size[1] - 1, -1));
      return tileRange;
    }, this);
  } else {
    if (extent) {
      this.calculateTileRanges_(extent);
    }
  }
};
ol.tilegrid.TileGrid.tmpTileCoord_ = [0, 0, 0];
ol.tilegrid.TileGrid.prototype.forEachTileCoord = function(extent, zoom, callback) {
  var tileRange = this.getTileRangeForExtentAndZ(extent, zoom);
  for (var i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {
    for (var j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {
      callback([zoom, i, j]);
    }
  }
};
ol.tilegrid.TileGrid.prototype.forEachTileCoordParentTileRange = function(tileCoord, callback, opt_this, opt_tileRange, opt_extent) {
  var tileRange, x, y;
  var tileCoordExtent = null;
  var z = tileCoord[0] - 1;
  if (this.zoomFactor_ === 2) {
    x = tileCoord[1];
    y = tileCoord[2];
  } else {
    tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);
  }
  while (z >= this.minZoom) {
    if (this.zoomFactor_ === 2) {
      x = Math.floor(x / 2);
      y = Math.floor(y / 2);
      tileRange = ol.TileRange.createOrUpdate(x, x, y, y, opt_tileRange);
    } else {
      tileRange = this.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);
    }
    if (callback.call(opt_this, z, tileRange)) {
      return true;
    }
    --z;
  }
  return false;
};
ol.tilegrid.TileGrid.prototype.getExtent = function() {
  return this.extent_;
};
ol.tilegrid.TileGrid.prototype.getMaxZoom = function() {
  return this.maxZoom;
};
ol.tilegrid.TileGrid.prototype.getMinZoom = function() {
  return this.minZoom;
};
ol.tilegrid.TileGrid.prototype.getOrigin = function(z) {
  if (this.origin_) {
    return this.origin_;
  } else {
    return this.origins_[z];
  }
};
ol.tilegrid.TileGrid.prototype.getResolution = function(z) {
  return this.resolutions_[z];
};
ol.tilegrid.TileGrid.prototype.getResolutions = function() {
  return this.resolutions_;
};
ol.tilegrid.TileGrid.prototype.getTileCoordChildTileRange = function(tileCoord, opt_tileRange, opt_extent) {
  if (tileCoord[0] < this.maxZoom) {
    if (this.zoomFactor_ === 2) {
      var minX = tileCoord[1] * 2;
      var minY = tileCoord[2] * 2;
      return ol.TileRange.createOrUpdate(minX, minX + 1, minY, minY + 1, opt_tileRange);
    }
    var tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);
    return this.getTileRangeForExtentAndZ(tileCoordExtent, tileCoord[0] + 1, opt_tileRange);
  }
  return null;
};
ol.tilegrid.TileGrid.prototype.getTileRangeExtent = function(z, tileRange, opt_extent) {
  var origin = this.getOrigin(z);
  var resolution = this.getResolution(z);
  var tileSize = ol.size.toSize(this.getTileSize(z), this.tmpSize_);
  var minX = origin[0] + tileRange.minX * tileSize[0] * resolution;
  var maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;
  var minY = origin[1] + tileRange.minY * tileSize[1] * resolution;
  var maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;
  return ol.extent.createOrUpdate(minX, minY, maxX, maxY, opt_extent);
};
ol.tilegrid.TileGrid.prototype.getTileRangeForExtentAndZ = function(extent, z, opt_tileRange) {
  var tileCoord = ol.tilegrid.TileGrid.tmpTileCoord_;
  this.getTileCoordForXYAndZ_(extent[0], extent[1], z, false, tileCoord);
  var minX = tileCoord[1];
  var minY = tileCoord[2];
  this.getTileCoordForXYAndZ_(extent[2], extent[3], z, true, tileCoord);
  return ol.TileRange.createOrUpdate(minX, tileCoord[1], minY, tileCoord[2], opt_tileRange);
};
ol.tilegrid.TileGrid.prototype.getTileCoordCenter = function(tileCoord) {
  var origin = this.getOrigin(tileCoord[0]);
  var resolution = this.getResolution(tileCoord[0]);
  var tileSize = ol.size.toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);
  return [origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution, origin[1] + (tileCoord[2] + 0.5) * tileSize[1] * resolution];
};
ol.tilegrid.TileGrid.prototype.getTileCoordExtent = function(tileCoord, opt_extent) {
  var origin = this.getOrigin(tileCoord[0]);
  var resolution = this.getResolution(tileCoord[0]);
  var tileSize = ol.size.toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);
  var minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;
  var minY = origin[1] + tileCoord[2] * tileSize[1] * resolution;
  var maxX = minX + tileSize[0] * resolution;
  var maxY = minY + tileSize[1] * resolution;
  return ol.extent.createOrUpdate(minX, minY, maxX, maxY, opt_extent);
};
ol.tilegrid.TileGrid.prototype.getTileCoordForCoordAndResolution = function(coordinate, resolution, opt_tileCoord) {
  return this.getTileCoordForXYAndResolution_(coordinate[0], coordinate[1], resolution, false, opt_tileCoord);
};
ol.tilegrid.TileGrid.prototype.getTileCoordForXYAndResolution_ = function(x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {
  var z = this.getZForResolution(resolution);
  var scale = resolution / this.getResolution(z);
  var origin = this.getOrigin(z);
  var tileSize = ol.size.toSize(this.getTileSize(z), this.tmpSize_);
  var adjustX = reverseIntersectionPolicy ? 0.5 : 0;
  var adjustY = reverseIntersectionPolicy ? 0 : 0.5;
  var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);
  var yFromOrigin = Math.floor((y - origin[1]) / resolution + adjustY);
  var tileCoordX = scale * xFromOrigin / tileSize[0];
  var tileCoordY = scale * yFromOrigin / tileSize[1];
  if (reverseIntersectionPolicy) {
    tileCoordX = Math.ceil(tileCoordX) - 1;
    tileCoordY = Math.ceil(tileCoordY) - 1;
  } else {
    tileCoordX = Math.floor(tileCoordX);
    tileCoordY = Math.floor(tileCoordY);
  }
  return ol.tilecoord.createOrUpdate(z, tileCoordX, tileCoordY, opt_tileCoord);
};
ol.tilegrid.TileGrid.prototype.getTileCoordForXYAndZ_ = function(x, y, z, reverseIntersectionPolicy, opt_tileCoord) {
  var origin = this.getOrigin(z);
  var resolution = this.getResolution(z);
  var tileSize = ol.size.toSize(this.getTileSize(z), this.tmpSize_);
  var adjustX = reverseIntersectionPolicy ? 0.5 : 0;
  var adjustY = reverseIntersectionPolicy ? 0 : 0.5;
  var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);
  var yFromOrigin = Math.floor((y - origin[1]) / resolution + adjustY);
  var tileCoordX = xFromOrigin / tileSize[0];
  var tileCoordY = yFromOrigin / tileSize[1];
  if (reverseIntersectionPolicy) {
    tileCoordX = Math.ceil(tileCoordX) - 1;
    tileCoordY = Math.ceil(tileCoordY) - 1;
  } else {
    tileCoordX = Math.floor(tileCoordX);
    tileCoordY = Math.floor(tileCoordY);
  }
  return ol.tilecoord.createOrUpdate(z, tileCoordX, tileCoordY, opt_tileCoord);
};
ol.tilegrid.TileGrid.prototype.getTileCoordForCoordAndZ = function(coordinate, z, opt_tileCoord) {
  return this.getTileCoordForXYAndZ_(coordinate[0], coordinate[1], z, false, opt_tileCoord);
};
ol.tilegrid.TileGrid.prototype.getTileCoordResolution = function(tileCoord) {
  return this.resolutions_[tileCoord[0]];
};
ol.tilegrid.TileGrid.prototype.getTileSize = function(z) {
  if (this.tileSize_) {
    return this.tileSize_;
  } else {
    return this.tileSizes_[z];
  }
};
ol.tilegrid.TileGrid.prototype.getFullTileRange = function(z) {
  if (!this.fullTileRanges_) {
    return null;
  } else {
    return this.fullTileRanges_[z];
  }
};
ol.tilegrid.TileGrid.prototype.getZForResolution = function(resolution, opt_direction) {
  var z = ol.array.linearFindNearest(this.resolutions_, resolution, opt_direction || 0);
  return ol.math.clamp(z, this.minZoom, this.maxZoom);
};
ol.tilegrid.TileGrid.prototype.calculateTileRanges_ = function(extent) {
  var length = this.resolutions_.length;
  var fullTileRanges = new Array(length);
  for (var z = this.minZoom; z < length; ++z) {
    fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);
  }
  this.fullTileRanges_ = fullTileRanges;
};
goog.provide("ol.tilegrid");
goog.require("ol");
goog.require("ol.size");
goog.require("ol.extent");
goog.require("ol.extent.Corner");
goog.require("ol.obj");
goog.require("ol.proj");
goog.require("ol.proj.Units");
goog.require("ol.tilegrid.TileGrid");
ol.tilegrid.getForProjection = function(projection) {
  var tileGrid = projection.getDefaultTileGrid();
  if (!tileGrid) {
    tileGrid = ol.tilegrid.createForProjection(projection);
    projection.setDefaultTileGrid(tileGrid);
  }
  return tileGrid;
};
ol.tilegrid.wrapX = function(tileGrid, tileCoord, projection) {
  var z = tileCoord[0];
  var center = tileGrid.getTileCoordCenter(tileCoord);
  var projectionExtent = ol.tilegrid.extentFromProjection(projection);
  if (!ol.extent.containsCoordinate(projectionExtent, center)) {
    var worldWidth = ol.extent.getWidth(projectionExtent);
    var worldsAway = Math.ceil((projectionExtent[0] - center[0]) / worldWidth);
    center[0] += worldWidth * worldsAway;
    return tileGrid.getTileCoordForCoordAndZ(center, z);
  } else {
    return tileCoord;
  }
};
ol.tilegrid.createForExtent = function(extent, opt_maxZoom, opt_tileSize, opt_corner) {
  var corner = opt_corner !== undefined ? opt_corner : ol.extent.Corner.TOP_LEFT;
  var resolutions = ol.tilegrid.resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize);
  return new ol.tilegrid.TileGrid({extent:extent, origin:ol.extent.getCorner(extent, corner), resolutions:resolutions, tileSize:opt_tileSize});
};
ol.tilegrid.createXYZ = function(opt_options) {
  var options = {};
  ol.obj.assign(options, opt_options !== undefined ? opt_options : {});
  if (options.extent === undefined) {
    options.extent = ol.proj.get("EPSG:3857").getExtent();
  }
  options.resolutions = ol.tilegrid.resolutionsFromExtent(options.extent, options.maxZoom, options.tileSize);
  delete options.maxZoom;
  return new ol.tilegrid.TileGrid(options);
};
ol.tilegrid.resolutionsFromExtent = function(extent, opt_maxZoom, opt_tileSize) {
  var maxZoom = opt_maxZoom !== undefined ? opt_maxZoom : ol.DEFAULT_MAX_ZOOM;
  var height = ol.extent.getHeight(extent);
  var width = ol.extent.getWidth(extent);
  var tileSize = ol.size.toSize(opt_tileSize !== undefined ? opt_tileSize : ol.DEFAULT_TILE_SIZE);
  var maxResolution = Math.max(width / tileSize[0], height / tileSize[1]);
  var length = maxZoom + 1;
  var resolutions = new Array(length);
  for (var z = 0; z < length; ++z) {
    resolutions[z] = maxResolution / Math.pow(2, z);
  }
  return resolutions;
};
ol.tilegrid.createForProjection = function(projection, opt_maxZoom, opt_tileSize, opt_corner) {
  var extent = ol.tilegrid.extentFromProjection(projection);
  return ol.tilegrid.createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner);
};
ol.tilegrid.extentFromProjection = function(projection) {
  projection = ol.proj.get(projection);
  var extent = projection.getExtent();
  if (!extent) {
    var half = 180 * ol.proj.METERS_PER_UNIT[ol.proj.Units.DEGREES] / projection.getMetersPerUnit();
    extent = ol.extent.createOrUpdate(-half, -half, half, half);
  }
  return extent;
};
goog.provide("ol.Attribution");
goog.require("ol.TileRange");
goog.require("ol.math");
goog.require("ol.tilegrid");
ol.Attribution = function(options) {
  this.html_ = options.html;
  this.tileRanges_ = options.tileRanges ? options.tileRanges : null;
};
ol.Attribution.prototype.getHTML = function() {
  return this.html_;
};
ol.Attribution.prototype.intersectsAnyTileRange = function(tileRanges, tileGrid, projection) {
  if (!this.tileRanges_) {
    return true;
  }
  var i, ii, tileRange, zKey;
  for (zKey in tileRanges) {
    if (!(zKey in this.tileRanges_)) {
      continue;
    }
    tileRange = tileRanges[zKey];
    var testTileRange;
    for (i = 0, ii = this.tileRanges_[zKey].length; i < ii; ++i) {
      testTileRange = this.tileRanges_[zKey][i];
      if (testTileRange.intersects(tileRange)) {
        return true;
      }
      var extentTileRange = tileGrid.getTileRangeForExtentAndZ(ol.tilegrid.extentFromProjection(projection), parseInt(zKey, 10));
      var width = extentTileRange.getWidth();
      if (tileRange.minX < extentTileRange.minX || tileRange.maxX > extentTileRange.maxX) {
        if (testTileRange.intersects(new ol.TileRange(ol.math.modulo(tileRange.minX, width), ol.math.modulo(tileRange.maxX, width), tileRange.minY, tileRange.maxY))) {
          return true;
        }
        if (tileRange.getWidth() > width && testTileRange.intersects(extentTileRange)) {
          return true;
        }
      }
    }
  }
  return false;
};
goog.provide("ol.source.Source");
goog.require("ol");
goog.require("ol.Attribution");
goog.require("ol.Object");
goog.require("ol.proj");
goog.require("ol.source.State");
ol.source.Source = function(options) {
  ol.Object.call(this);
  this.projection_ = ol.proj.get(options.projection);
  this.attributions_ = null;
  this.attributions2_ = this.adaptAttributions_(options.attributions);
  this.logo_ = options.logo;
  this.state_ = options.state !== undefined ? options.state : ol.source.State.READY;
  this.wrapX_ = options.wrapX !== undefined ? options.wrapX : false;
};
ol.inherits(ol.source.Source, ol.Object);
ol.source.Source.prototype.adaptAttributions_ = function(attributionLike) {
  if (!attributionLike) {
    return null;
  }
  if (attributionLike instanceof ol.Attribution) {
    this.attributions_ = [attributionLike];
    return function(frameState) {
      return [attributionLike.getHTML()];
    };
  }
  if (Array.isArray(attributionLike)) {
    if (attributionLike[0] instanceof ol.Attribution) {
      this.attributions_ = attributionLike;
      var attributions = attributionLike.map(function(attribution) {
        return attribution.getHTML();
      });
      return function(frameState) {
        return attributions;
      };
    }
    this.attributions_ = attributionLike.map(function(attribution) {
      return new ol.Attribution({html:attribution});
    });
    return function(frameState) {
      return attributionLike;
    };
  }
  if (typeof attributionLike === "function") {
    return attributionLike;
  }
  this.attributions_ = [new ol.Attribution({html:attributionLike})];
  return function(frameState) {
    return [attributionLike];
  };
};
ol.source.Source.prototype.forEachFeatureAtCoordinate = ol.nullFunction;
ol.source.Source.prototype.getAttributions = function() {
  return this.attributions_;
};
ol.source.Source.prototype.getAttributions2 = function() {
  return this.attributions2_;
};
ol.source.Source.prototype.getLogo = function() {
  return this.logo_;
};
ol.source.Source.prototype.getProjection = function() {
  return this.projection_;
};
ol.source.Source.prototype.getResolutions = function() {
};
ol.source.Source.prototype.getState = function() {
  return this.state_;
};
ol.source.Source.prototype.getWrapX = function() {
  return this.wrapX_;
};
ol.source.Source.prototype.refresh = function() {
  this.changed();
};
ol.source.Source.prototype.setAttributions = function(attributions) {
  this.attributions2_ = this.adaptAttributions_(attributions);
  this.changed();
};
ol.source.Source.prototype.setLogo = function(logo) {
  this.logo_ = logo;
};
ol.source.Source.prototype.setState = function(state) {
  this.state_ = state;
  this.changed();
};
goog.provide("ol.source.Image");
goog.require("ol");
goog.require("ol.ImageState");
goog.require("ol.array");
goog.require("ol.events.Event");
goog.require("ol.extent");
goog.require("ol.proj");
goog.require("ol.reproj.Image");
goog.require("ol.source.Source");
ol.source.Image = function(options) {
  ol.source.Source.call(this, {attributions:options.attributions, extent:options.extent, logo:options.logo, projection:options.projection, state:options.state});
  this.resolutions_ = options.resolutions !== undefined ? options.resolutions : null;
  this.reprojectedImage_ = null;
  this.reprojectedRevision_ = 0;
};
ol.inherits(ol.source.Image, ol.source.Source);
ol.source.Image.prototype.getResolutions = function() {
  return this.resolutions_;
};
ol.source.Image.prototype.findNearestResolution = function(resolution) {
  if (this.resolutions_) {
    var idx = ol.array.linearFindNearest(this.resolutions_, resolution, 0);
    resolution = this.resolutions_[idx];
  }
  return resolution;
};
ol.source.Image.prototype.getImage = function(extent, resolution, pixelRatio, projection) {
  var sourceProjection = this.getProjection();
  if (!ol.ENABLE_RASTER_REPROJECTION || !sourceProjection || !projection || ol.proj.equivalent(sourceProjection, projection)) {
    if (sourceProjection) {
      projection = sourceProjection;
    }
    return this.getImageInternal(extent, resolution, pixelRatio, projection);
  } else {
    if (this.reprojectedImage_) {
      if (this.reprojectedRevision_ == this.getRevision() && ol.proj.equivalent(this.reprojectedImage_.getProjection(), projection) && this.reprojectedImage_.getResolution() == resolution && ol.extent.equals(this.reprojectedImage_.getExtent(), extent)) {
        return this.reprojectedImage_;
      }
      this.reprojectedImage_.dispose();
      this.reprojectedImage_ = null;
    }
    this.reprojectedImage_ = new ol.reproj.Image(sourceProjection, projection, extent, resolution, pixelRatio, function(extent, resolution, pixelRatio) {
      return this.getImageInternal(extent, resolution, pixelRatio, sourceProjection);
    }.bind(this));
    this.reprojectedRevision_ = this.getRevision();
    return this.reprojectedImage_;
  }
};
ol.source.Image.prototype.getImageInternal = function(extent, resolution, pixelRatio, projection) {
};
ol.source.Image.prototype.handleImageChange = function(event) {
  var image = event.target;
  switch(image.getState()) {
    case ol.ImageState.LOADING:
      this.dispatchEvent(new ol.source.Image.Event(ol.source.Image.EventType_.IMAGELOADSTART, image));
      break;
    case ol.ImageState.LOADED:
      this.dispatchEvent(new ol.source.Image.Event(ol.source.Image.EventType_.IMAGELOADEND, image));
      break;
    case ol.ImageState.ERROR:
      this.dispatchEvent(new ol.source.Image.Event(ol.source.Image.EventType_.IMAGELOADERROR, image));
      break;
    default:
  }
};
ol.source.Image.defaultImageLoadFunction = function(image, src) {
  image.getImage().src = src;
};
ol.source.Image.Event = function(type, image) {
  ol.events.Event.call(this, type);
  this.image = image;
};
ol.inherits(ol.source.Image.Event, ol.events.Event);
ol.source.Image.EventType_ = {IMAGELOADSTART:"imageloadstart", IMAGELOADEND:"imageloadend", IMAGELOADERROR:"imageloaderror"};
goog.provide("ol.Image");
goog.require("ol");
goog.require("ol.ImageBase");
goog.require("ol.ImageState");
goog.require("ol.events");
goog.require("ol.events.EventType");
goog.require("ol.extent");
ol.Image = function(extent, resolution, pixelRatio, src, crossOrigin, imageLoadFunction) {
  ol.ImageBase.call(this, extent, resolution, pixelRatio, ol.ImageState.IDLE);
  this.src_ = src;
  this.image_ = new Image;
  if (crossOrigin !== null) {
    this.image_.crossOrigin = crossOrigin;
  }
  this.imageListenerKeys_ = null;
  this.state = ol.ImageState.IDLE;
  this.imageLoadFunction_ = imageLoadFunction;
};
ol.inherits(ol.Image, ol.ImageBase);
ol.Image.prototype.getImage = function() {
  return this.image_;
};
ol.Image.prototype.handleImageError_ = function() {
  this.state = ol.ImageState.ERROR;
  this.unlistenImage_();
  this.changed();
};
ol.Image.prototype.handleImageLoad_ = function() {
  if (this.resolution === undefined) {
    this.resolution = ol.extent.getHeight(this.extent) / this.image_.height;
  }
  this.state = ol.ImageState.LOADED;
  this.unlistenImage_();
  this.changed();
};
ol.Image.prototype.load = function() {
  if (this.state == ol.ImageState.IDLE || this.state == ol.ImageState.ERROR) {
    this.state = ol.ImageState.LOADING;
    this.changed();
    this.imageListenerKeys_ = [ol.events.listenOnce(this.image_, ol.events.EventType.ERROR, this.handleImageError_, this), ol.events.listenOnce(this.image_, ol.events.EventType.LOAD, this.handleImageLoad_, this)];
    this.imageLoadFunction_(this, this.src_);
  }
};
ol.Image.prototype.setImage = function(image) {
  this.image_ = image;
};
ol.Image.prototype.unlistenImage_ = function() {
  this.imageListenerKeys_.forEach(ol.events.unlistenByKey);
  this.imageListenerKeys_ = null;
};
goog.provide("ol.source.WMSServerType");
ol.source.WMSServerType = {CARMENTA_SERVER:"carmentaserver", GEOSERVER:"geoserver", MAPSERVER:"mapserver", QGIS:"qgis"};
goog.provide("ol.string");
ol.string.padNumber = function(number, width, opt_precision) {
  var numberString = opt_precision !== undefined ? number.toFixed(opt_precision) : "" + number;
  var decimal = numberString.indexOf(".");
  decimal = decimal === -1 ? numberString.length : decimal;
  return decimal > width ? numberString : (new Array(1 + width - decimal)).join("0") + numberString;
};
ol.string.compareVersions = function(v1, v2) {
  var s1 = ("" + v1).split(".");
  var s2 = ("" + v2).split(".");
  for (var i = 0; i < Math.max(s1.length, s2.length); i++) {
    var n1 = parseInt(s1[i] || "0", 10);
    var n2 = parseInt(s2[i] || "0", 10);
    if (n1 > n2) {
      return 1;
    }
    if (n2 > n1) {
      return -1;
    }
  }
  return 0;
};
goog.provide("ol.uri");
ol.uri.appendParams = function(uri, params) {
  var keyParams = [];
  Object.keys(params).forEach(function(k) {
    if (params[k] !== null && params[k] !== undefined) {
      keyParams.push(k + "=" + encodeURIComponent(params[k]));
    }
  });
  var qs = keyParams.join("&");
  uri = uri.replace(/[?&]$/, "");
  uri = uri.indexOf("?") === -1 ? uri + "?" : uri + "&";
  return uri + qs;
};
goog.provide("ol.source.ImageWMS");
goog.require("ol");
goog.require("ol.Image");
goog.require("ol.asserts");
goog.require("ol.events");
goog.require("ol.events.EventType");
goog.require("ol.extent");
goog.require("ol.obj");
goog.require("ol.proj");
goog.require("ol.reproj");
goog.require("ol.source.Image");
goog.require("ol.source.WMSServerType");
goog.require("ol.string");
goog.require("ol.uri");
ol.source.ImageWMS = function(opt_options) {
  var options = opt_options || {};
  ol.source.Image.call(this, {attributions:options.attributions, logo:options.logo, projection:options.projection, resolutions:options.resolutions});
  this.crossOrigin_ = options.crossOrigin !== undefined ? options.crossOrigin : null;
  this.url_ = options.url;
  this.imageLoadFunction_ = options.imageLoadFunction !== undefined ? options.imageLoadFunction : ol.source.Image.defaultImageLoadFunction;
  this.params_ = options.params || {};
  this.v13_ = true;
  this.updateV13_();
  this.serverType_ = options.serverType;
  this.hidpi_ = options.hidpi !== undefined ? options.hidpi : true;
  this.image_ = null;
  this.imageSize_ = [0, 0];
  this.renderedRevision_ = 0;
  this.ratio_ = options.ratio !== undefined ? options.ratio : 1.5;
};
ol.inherits(ol.source.ImageWMS, ol.source.Image);
ol.source.ImageWMS.GETFEATUREINFO_IMAGE_SIZE_ = [101, 101];
ol.source.ImageWMS.prototype.getGetFeatureInfoUrl = function(coordinate, resolution, projection, params) {
  if (this.url_ === undefined) {
    return undefined;
  }
  var projectionObj = ol.proj.get(projection);
  var sourceProjectionObj = this.getProjection();
  if (sourceProjectionObj && sourceProjectionObj !== projectionObj) {
    resolution = ol.reproj.calculateSourceResolution(sourceProjectionObj, projectionObj, coordinate, resolution);
    coordinate = ol.proj.transform(coordinate, projectionObj, sourceProjectionObj);
  }
  var extent = ol.extent.getForViewAndSize(coordinate, resolution, 0, ol.source.ImageWMS.GETFEATUREINFO_IMAGE_SIZE_);
  var baseParams = {"SERVICE":"WMS", "VERSION":ol.DEFAULT_WMS_VERSION, "REQUEST":"GetFeatureInfo", "FORMAT":"image/png", "TRANSPARENT":true, "QUERY_LAYERS":this.params_["LAYERS"]};
  ol.obj.assign(baseParams, this.params_, params);
  var x = Math.floor((coordinate[0] - extent[0]) / resolution);
  var y = Math.floor((extent[3] - coordinate[1]) / resolution);
  baseParams[this.v13_ ? "I" : "X"] = x;
  baseParams[this.v13_ ? "J" : "Y"] = y;
  return this.getRequestUrl_(extent, ol.source.ImageWMS.GETFEATUREINFO_IMAGE_SIZE_, 1, sourceProjectionObj || projectionObj, baseParams);
};
ol.source.ImageWMS.prototype.getParams = function() {
  return this.params_;
};
ol.source.ImageWMS.prototype.getImageInternal = function(extent, resolution, pixelRatio, projection) {
  if (this.url_ === undefined) {
    return null;
  }
  resolution = this.findNearestResolution(resolution);
  if (pixelRatio != 1 && (!this.hidpi_ || this.serverType_ === undefined)) {
    pixelRatio = 1;
  }
  var imageResolution = resolution / pixelRatio;
  var center = ol.extent.getCenter(extent);
  var viewWidth = Math.ceil(ol.extent.getWidth(extent) / imageResolution);
  var viewHeight = Math.ceil(ol.extent.getHeight(extent) / imageResolution);
  var viewExtent = ol.extent.getForViewAndSize(center, imageResolution, 0, [viewWidth, viewHeight]);
  var requestWidth = Math.ceil(this.ratio_ * ol.extent.getWidth(extent) / imageResolution);
  var requestHeight = Math.ceil(this.ratio_ * ol.extent.getHeight(extent) / imageResolution);
  var requestExtent = ol.extent.getForViewAndSize(center, imageResolution, 0, [requestWidth, requestHeight]);
  var image = this.image_;
  if (image && this.renderedRevision_ == this.getRevision() && image.getResolution() == resolution && image.getPixelRatio() == pixelRatio && ol.extent.containsExtent(image.getExtent(), viewExtent)) {
    return image;
  }
  var params = {"SERVICE":"WMS", "VERSION":ol.DEFAULT_WMS_VERSION, "REQUEST":"GetMap", "FORMAT":"image/png", "TRANSPARENT":true};
  ol.obj.assign(params, this.params_);
  this.imageSize_[0] = Math.round(ol.extent.getWidth(requestExtent) / imageResolution);
  this.imageSize_[1] = Math.round(ol.extent.getHeight(requestExtent) / imageResolution);
  var url = this.getRequestUrl_(requestExtent, this.imageSize_, pixelRatio, projection, params);
  this.image_ = new ol.Image(requestExtent, resolution, pixelRatio, url, this.crossOrigin_, this.imageLoadFunction_);
  this.renderedRevision_ = this.getRevision();
  ol.events.listen(this.image_, ol.events.EventType.CHANGE, this.handleImageChange, this);
  return this.image_;
};
ol.source.ImageWMS.prototype.getImageLoadFunction = function() {
  return this.imageLoadFunction_;
};
ol.source.ImageWMS.prototype.getRequestUrl_ = function(extent, size, pixelRatio, projection, params) {
  ol.asserts.assert(this.url_ !== undefined, 9);
  params[this.v13_ ? "CRS" : "SRS"] = projection.getCode();
  if (!("STYLES" in this.params_)) {
    params["STYLES"] = "";
  }
  if (pixelRatio != 1) {
    switch(this.serverType_) {
      case ol.source.WMSServerType.GEOSERVER:
        var dpi = 90 * pixelRatio + 0.5 | 0;
        if ("FORMAT_OPTIONS" in params) {
          params["FORMAT_OPTIONS"] += ";dpi:" + dpi;
        } else {
          params["FORMAT_OPTIONS"] = "dpi:" + dpi;
        }
        break;
      case ol.source.WMSServerType.MAPSERVER:
        params["MAP_RESOLUTION"] = 90 * pixelRatio;
        break;
      case ol.source.WMSServerType.CARMENTA_SERVER:
      case ol.source.WMSServerType.QGIS:
        params["DPI"] = 90 * pixelRatio;
        break;
      default:
        ol.asserts.assert(false, 8);
        break;
    }
  }
  params["WIDTH"] = size[0];
  params["HEIGHT"] = size[1];
  var axisOrientation = projection.getAxisOrientation();
  var bbox;
  if (this.v13_ && axisOrientation.substr(0, 2) == "ne") {
    bbox = [extent[1], extent[0], extent[3], extent[2]];
  } else {
    bbox = extent;
  }
  params["BBOX"] = bbox.join(",");
  return ol.uri.appendParams(this.url_, params);
};
ol.source.ImageWMS.prototype.getUrl = function() {
  return this.url_;
};
ol.source.ImageWMS.prototype.setImageLoadFunction = function(imageLoadFunction) {
  this.image_ = null;
  this.imageLoadFunction_ = imageLoadFunction;
  this.changed();
};
ol.source.ImageWMS.prototype.setUrl = function(url) {
  if (url != this.url_) {
    this.url_ = url;
    this.image_ = null;
    this.changed();
  }
};
ol.source.ImageWMS.prototype.updateParams = function(params) {
  ol.obj.assign(this.params_, params);
  this.updateV13_();
  this.image_ = null;
  this.changed();
};
ol.source.ImageWMS.prototype.updateV13_ = function() {
  var version = this.params_["VERSION"] || ol.DEFAULT_WMS_VERSION;
  this.v13_ = ol.string.compareVersions(version, "1.3") >= 0;
};
goog.provide("ol.TileState");
ol.TileState = {IDLE:0, LOADING:1, LOADED:2, ERROR:3, EMPTY:4, ABORT:5};
goog.provide("ol.Tile");
goog.require("ol");
goog.require("ol.TileState");
goog.require("ol.easing");
goog.require("ol.events.EventTarget");
goog.require("ol.events.EventType");
ol.Tile = function(tileCoord, state, opt_options) {
  ol.events.EventTarget.call(this);
  var options = opt_options ? opt_options : {};
  this.tileCoord = tileCoord;
  this.state = state;
  this.interimTile = null;
  this.key = "";
  this.transition_ = options.transition === undefined ? 250 : options.transition;
  this.transitionStarts_ = {};
};
ol.inherits(ol.Tile, ol.events.EventTarget);
ol.Tile.prototype.changed = function() {
  this.dispatchEvent(ol.events.EventType.CHANGE);
};
ol.Tile.prototype.getKey = function() {
  return this.key + "/" + this.tileCoord;
};
ol.Tile.prototype.getInterimTile = function() {
  if (!this.interimTile) {
    return this;
  }
  var tile = this.interimTile;
  do {
    if (tile.getState() == ol.TileState.LOADED) {
      return tile;
    }
    tile = tile.interimTile;
  } while (tile);
  return this;
};
ol.Tile.prototype.refreshInterimChain = function() {
  if (!this.interimTile) {
    return;
  }
  var tile = this.interimTile;
  var prev = this;
  do {
    if (tile.getState() == ol.TileState.LOADED) {
      tile.interimTile = null;
      break;
    } else {
      if (tile.getState() == ol.TileState.LOADING) {
        prev = tile;
      } else {
        if (tile.getState() == ol.TileState.IDLE) {
          prev.interimTile = tile.interimTile;
        } else {
          prev = tile;
        }
      }
    }
    tile = prev.interimTile;
  } while (tile);
};
ol.Tile.prototype.getTileCoord = function() {
  return this.tileCoord;
};
ol.Tile.prototype.getState = function() {
  return this.state;
};
ol.Tile.prototype.setState = function(state) {
  this.state = state;
  this.changed();
};
ol.Tile.prototype.load = function() {
};
ol.Tile.prototype.getAlpha = function(id, time) {
  if (!this.transition_) {
    return 1;
  }
  var start = this.transitionStarts_[id];
  if (!start) {
    start = time;
    this.transitionStarts_[id] = start;
  } else {
    if (start === -1) {
      return 1;
    }
  }
  var delta = time - start + 1000 / 60;
  if (delta >= this.transition_) {
    return 1;
  }
  return ol.easing.easeIn(delta / this.transition_);
};
ol.Tile.prototype.inTransition = function(id) {
  if (!this.transition_) {
    return false;
  }
  return this.transitionStarts_[id] !== -1;
};
ol.Tile.prototype.endTransition = function(id) {
  if (this.transition_) {
    this.transitionStarts_[id] = -1;
  }
};
goog.provide("ol.ImageTile");
goog.require("ol");
goog.require("ol.Tile");
goog.require("ol.TileState");
goog.require("ol.dom");
goog.require("ol.events");
goog.require("ol.events.EventType");
ol.ImageTile = function(tileCoord, state, src, crossOrigin, tileLoadFunction, opt_options) {
  ol.Tile.call(this, tileCoord, state, opt_options);
  this.crossOrigin_ = crossOrigin;
  this.src_ = src;
  this.image_ = new Image;
  if (crossOrigin !== null) {
    this.image_.crossOrigin = crossOrigin;
  }
  this.imageListenerKeys_ = null;
  this.tileLoadFunction_ = tileLoadFunction;
};
ol.inherits(ol.ImageTile, ol.Tile);
ol.ImageTile.prototype.disposeInternal = function() {
  if (this.state == ol.TileState.LOADING) {
    this.unlistenImage_();
    this.image_ = ol.ImageTile.getBlankImage();
  }
  if (this.interimTile) {
    this.interimTile.dispose();
  }
  this.state = ol.TileState.ABORT;
  this.changed();
  ol.Tile.prototype.disposeInternal.call(this);
};
ol.ImageTile.prototype.getImage = function() {
  return this.image_;
};
ol.ImageTile.prototype.getKey = function() {
  return this.src_;
};
ol.ImageTile.prototype.handleImageError_ = function() {
  this.state = ol.TileState.ERROR;
  this.unlistenImage_();
  this.image_ = ol.ImageTile.getBlankImage();
  this.changed();
};
ol.ImageTile.prototype.handleImageLoad_ = function() {
  if (this.image_.naturalWidth && this.image_.naturalHeight) {
    this.state = ol.TileState.LOADED;
  } else {
    this.state = ol.TileState.EMPTY;
  }
  this.unlistenImage_();
  this.changed();
};
ol.ImageTile.prototype.load = function() {
  if (this.state == ol.TileState.ERROR) {
    this.state = ol.TileState.IDLE;
    this.image_ = new Image;
    if (this.crossOrigin_ !== null) {
      this.image_.crossOrigin = this.crossOrigin_;
    }
  }
  if (this.state == ol.TileState.IDLE) {
    this.state = ol.TileState.LOADING;
    this.changed();
    this.imageListenerKeys_ = [ol.events.listenOnce(this.image_, ol.events.EventType.ERROR, this.handleImageError_, this), ol.events.listenOnce(this.image_, ol.events.EventType.LOAD, this.handleImageLoad_, this)];
    this.tileLoadFunction_(this, this.src_);
  }
};
ol.ImageTile.prototype.unlistenImage_ = function() {
  this.imageListenerKeys_.forEach(ol.events.unlistenByKey);
  this.imageListenerKeys_ = null;
};
ol.ImageTile.getBlankImage = function() {
  var ctx = ol.dom.createCanvasContext2D(1, 1);
  ctx.fillStyle = "rgba(0,0,0,0)";
  ctx.fillRect(0, 0, 1, 1);
  return ctx.canvas;
};
goog.provide("ol.structs.LRUCache");
goog.require("ol");
goog.require("ol.asserts");
goog.require("ol.events.EventTarget");
goog.require("ol.events.EventType");
ol.structs.LRUCache = function(opt_highWaterMark) {
  ol.events.EventTarget.call(this);
  this.highWaterMark = opt_highWaterMark !== undefined ? opt_highWaterMark : 2048;
  this.count_ = 0;
  this.entries_ = {};
  this.oldest_ = null;
  this.newest_ = null;
};
ol.inherits(ol.structs.LRUCache, ol.events.EventTarget);
ol.structs.LRUCache.prototype.canExpireCache = function() {
  return this.getCount() > this.highWaterMark;
};
ol.structs.LRUCache.prototype.clear = function() {
  this.count_ = 0;
  this.entries_ = {};
  this.oldest_ = null;
  this.newest_ = null;
  this.dispatchEvent(ol.events.EventType.CLEAR);
};
ol.structs.LRUCache.prototype.containsKey = function(key) {
  return this.entries_.hasOwnProperty(key);
};
ol.structs.LRUCache.prototype.forEach = function(f, opt_this) {
  var entry = this.oldest_;
  while (entry) {
    f.call(opt_this, entry.value_, entry.key_, this);
    entry = entry.newer;
  }
};
ol.structs.LRUCache.prototype.get = function(key) {
  var entry = this.entries_[key];
  ol.asserts.assert(entry !== undefined, 15);
  if (entry === this.newest_) {
    return entry.value_;
  } else {
    if (entry === this.oldest_) {
      this.oldest_ = this.oldest_.newer;
      this.oldest_.older = null;
    } else {
      entry.newer.older = entry.older;
      entry.older.newer = entry.newer;
    }
  }
  entry.newer = null;
  entry.older = this.newest_;
  this.newest_.newer = entry;
  this.newest_ = entry;
  return entry.value_;
};
ol.structs.LRUCache.prototype.remove = function(key) {
  var entry = this.entries_[key];
  ol.asserts.assert(entry !== undefined, 15);
  if (entry === this.newest_) {
    this.newest_ = entry.older;
    if (this.newest_) {
      this.newest_.newer = null;
    }
  } else {
    if (entry === this.oldest_) {
      this.oldest_ = entry.newer;
      if (this.oldest_) {
        this.oldest_.older = null;
      }
    } else {
      entry.newer.older = entry.older;
      entry.older.newer = entry.newer;
    }
  }
  delete this.entries_[key];
  --this.count_;
  return entry.value_;
};
ol.structs.LRUCache.prototype.getCount = function() {
  return this.count_;
};
ol.structs.LRUCache.prototype.getKeys = function() {
  var keys = new Array(this.count_);
  var i = 0;
  var entry;
  for (entry = this.newest_; entry; entry = entry.older) {
    keys[i++] = entry.key_;
  }
  return keys;
};
ol.structs.LRUCache.prototype.getValues = function() {
  var values = new Array(this.count_);
  var i = 0;
  var entry;
  for (entry = this.newest_; entry; entry = entry.older) {
    values[i++] = entry.value_;
  }
  return values;
};
ol.structs.LRUCache.prototype.peekLast = function() {
  return this.oldest_.value_;
};
ol.structs.LRUCache.prototype.peekLastKey = function() {
  return this.oldest_.key_;
};
ol.structs.LRUCache.prototype.peekFirstKey = function() {
  return this.newest_.key_;
};
ol.structs.LRUCache.prototype.pop = function() {
  var entry = this.oldest_;
  delete this.entries_[entry.key_];
  if (entry.newer) {
    entry.newer.older = null;
  }
  this.oldest_ = entry.newer;
  if (!this.oldest_) {
    this.newest_ = null;
  }
  --this.count_;
  return entry.value_;
};
ol.structs.LRUCache.prototype.replace = function(key, value) {
  this.get(key);
  this.entries_[key].value_ = value;
};
ol.structs.LRUCache.prototype.set = function(key, value) {
  ol.asserts.assert(!(key in this.entries_), 16);
  var entry = {key_:key, newer:null, older:this.newest_, value_:value};
  if (!this.newest_) {
    this.oldest_ = entry;
  } else {
    this.newest_.newer = entry;
  }
  this.newest_ = entry;
  this.entries_[key] = entry;
  ++this.count_;
};
ol.structs.LRUCache.prototype.prune = function() {
  while (this.canExpireCache()) {
    this.pop();
  }
};
goog.provide("ol.TileCache");
goog.require("ol");
goog.require("ol.structs.LRUCache");
goog.require("ol.tilecoord");
ol.TileCache = function(opt_highWaterMark) {
  ol.structs.LRUCache.call(this, opt_highWaterMark);
};
ol.inherits(ol.TileCache, ol.structs.LRUCache);
ol.TileCache.prototype.expireCache = function(usedTiles) {
  var tile, zKey;
  while (this.canExpireCache()) {
    tile = this.peekLast();
    zKey = tile.tileCoord[0].toString();
    if (zKey in usedTiles && usedTiles[zKey].contains(tile.tileCoord)) {
      break;
    } else {
      this.pop().dispose();
    }
  }
};
ol.TileCache.prototype.pruneExceptNewestZ = function() {
  if (this.getCount() === 0) {
    return;
  }
  var key = this.peekFirstKey();
  var tileCoord = ol.tilecoord.fromKey(key);
  var z = tileCoord[0];
  this.forEach(function(tile) {
    if (tile.tileCoord[0] !== z) {
      this.remove(ol.tilecoord.getKey(tile.tileCoord));
      tile.dispose();
    }
  }, this);
};
goog.provide("ol.reproj.Tile");
goog.require("ol");
goog.require("ol.Tile");
goog.require("ol.TileState");
goog.require("ol.events");
goog.require("ol.events.EventType");
goog.require("ol.extent");
goog.require("ol.math");
goog.require("ol.reproj");
goog.require("ol.reproj.Triangulation");
ol.reproj.Tile = function(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, opt_errorThreshold, opt_renderEdges) {
  ol.Tile.call(this, tileCoord, ol.TileState.IDLE);
  this.renderEdges_ = opt_renderEdges !== undefined ? opt_renderEdges : false;
  this.pixelRatio_ = pixelRatio;
  this.gutter_ = gutter;
  this.canvas_ = null;
  this.sourceTileGrid_ = sourceTileGrid;
  this.targetTileGrid_ = targetTileGrid;
  this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;
  this.sourceTiles_ = [];
  this.sourcesListenerKeys_ = null;
  this.sourceZ_ = 0;
  var targetExtent = targetTileGrid.getTileCoordExtent(this.wrappedTileCoord_);
  var maxTargetExtent = this.targetTileGrid_.getExtent();
  var maxSourceExtent = this.sourceTileGrid_.getExtent();
  var limitedTargetExtent = maxTargetExtent ? ol.extent.getIntersection(targetExtent, maxTargetExtent) : targetExtent;
  if (ol.extent.getArea(limitedTargetExtent) === 0) {
    this.state = ol.TileState.EMPTY;
    return;
  }
  var sourceProjExtent = sourceProj.getExtent();
  if (sourceProjExtent) {
    if (!maxSourceExtent) {
      maxSourceExtent = sourceProjExtent;
    } else {
      maxSourceExtent = ol.extent.getIntersection(maxSourceExtent, sourceProjExtent);
    }
  }
  var targetResolution = targetTileGrid.getResolution(this.wrappedTileCoord_[0]);
  var targetCenter = ol.extent.getCenter(limitedTargetExtent);
  var sourceResolution = ol.reproj.calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution);
  if (!isFinite(sourceResolution) || sourceResolution <= 0) {
    this.state = ol.TileState.EMPTY;
    return;
  }
  var errorThresholdInPixels = opt_errorThreshold !== undefined ? opt_errorThreshold : ol.DEFAULT_RASTER_REPROJECTION_ERROR_THRESHOLD;
  this.triangulation_ = new ol.reproj.Triangulation(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels);
  if (this.triangulation_.getTriangles().length === 0) {
    this.state = ol.TileState.EMPTY;
    return;
  }
  this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);
  var sourceExtent = this.triangulation_.calculateSourceExtent();
  if (maxSourceExtent) {
    if (sourceProj.canWrapX()) {
      sourceExtent[1] = ol.math.clamp(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);
      sourceExtent[3] = ol.math.clamp(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);
    } else {
      sourceExtent = ol.extent.getIntersection(sourceExtent, maxSourceExtent);
    }
  }
  if (!ol.extent.getArea(sourceExtent)) {
    this.state = ol.TileState.EMPTY;
  } else {
    var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(sourceExtent, this.sourceZ_);
    for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {
      for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {
        var tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);
        if (tile) {
          this.sourceTiles_.push(tile);
        }
      }
    }
    if (this.sourceTiles_.length === 0) {
      this.state = ol.TileState.EMPTY;
    }
  }
};
ol.inherits(ol.reproj.Tile, ol.Tile);
ol.reproj.Tile.prototype.disposeInternal = function() {
  if (this.state == ol.TileState.LOADING) {
    this.unlistenSources_();
  }
  ol.Tile.prototype.disposeInternal.call(this);
};
ol.reproj.Tile.prototype.getImage = function() {
  return this.canvas_;
};
ol.reproj.Tile.prototype.reproject_ = function() {
  var sources = [];
  this.sourceTiles_.forEach(function(tile, i, arr) {
    if (tile && tile.getState() == ol.TileState.LOADED) {
      sources.push({extent:this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord), image:tile.getImage()});
    }
  }, this);
  this.sourceTiles_.length = 0;
  if (sources.length === 0) {
    this.state = ol.TileState.ERROR;
  } else {
    var z = this.wrappedTileCoord_[0];
    var size = this.targetTileGrid_.getTileSize(z);
    var width = typeof size === "number" ? size : size[0];
    var height = typeof size === "number" ? size : size[1];
    var targetResolution = this.targetTileGrid_.getResolution(z);
    var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);
    var targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);
    this.canvas_ = ol.reproj.render(width, height, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, this.renderEdges_);
    this.state = ol.TileState.LOADED;
  }
  this.changed();
};
ol.reproj.Tile.prototype.load = function() {
  if (this.state == ol.TileState.IDLE) {
    this.state = ol.TileState.LOADING;
    this.changed();
    var leftToLoad = 0;
    this.sourcesListenerKeys_ = [];
    this.sourceTiles_.forEach(function(tile, i, arr) {
      var state = tile.getState();
      if (state == ol.TileState.IDLE || state == ol.TileState.LOADING) {
        leftToLoad++;
        var sourceListenKey;
        sourceListenKey = ol.events.listen(tile, ol.events.EventType.CHANGE, function(e) {
          var state = tile.getState();
          if (state == ol.TileState.LOADED || state == ol.TileState.ERROR || state == ol.TileState.EMPTY) {
            ol.events.unlistenByKey(sourceListenKey);
            leftToLoad--;
            if (leftToLoad === 0) {
              this.unlistenSources_();
              this.reproject_();
            }
          }
        }, this);
        this.sourcesListenerKeys_.push(sourceListenKey);
      }
    }, this);
    this.sourceTiles_.forEach(function(tile, i, arr) {
      var state = tile.getState();
      if (state == ol.TileState.IDLE) {
        tile.load();
      }
    });
    if (leftToLoad === 0) {
      setTimeout(this.reproject_.bind(this), 0);
    }
  }
};
ol.reproj.Tile.prototype.unlistenSources_ = function() {
  this.sourcesListenerKeys_.forEach(ol.events.unlistenByKey);
  this.sourcesListenerKeys_ = null;
};
goog.provide("ol.TileUrlFunction");
goog.require("ol.asserts");
goog.require("ol.math");
goog.require("ol.tilecoord");
ol.TileUrlFunction.createFromTemplate = function(template, tileGrid) {
  var zRegEx = /\{z\}/g;
  var xRegEx = /\{x\}/g;
  var yRegEx = /\{y\}/g;
  var dashYRegEx = /\{-y\}/g;
  return function(tileCoord, pixelRatio, projection) {
    if (!tileCoord) {
      return undefined;
    } else {
      return template.replace(zRegEx, tileCoord[0].toString()).replace(xRegEx, tileCoord[1].toString()).replace(yRegEx, function() {
        var y = -tileCoord[2] - 1;
        return y.toString();
      }).replace(dashYRegEx, function() {
        var z = tileCoord[0];
        var range = tileGrid.getFullTileRange(z);
        ol.asserts.assert(range, 55);
        var y = range.getHeight() + tileCoord[2];
        return y.toString();
      });
    }
  };
};
ol.TileUrlFunction.createFromTemplates = function(templates, tileGrid) {
  var len = templates.length;
  var tileUrlFunctions = new Array(len);
  for (var i = 0; i < len; ++i) {
    tileUrlFunctions[i] = ol.TileUrlFunction.createFromTemplate(templates[i], tileGrid);
  }
  return ol.TileUrlFunction.createFromTileUrlFunctions(tileUrlFunctions);
};
ol.TileUrlFunction.createFromTileUrlFunctions = function(tileUrlFunctions) {
  if (tileUrlFunctions.length === 1) {
    return tileUrlFunctions[0];
  }
  return function(tileCoord, pixelRatio, projection) {
    if (!tileCoord) {
      return undefined;
    } else {
      var h = ol.tilecoord.hash(tileCoord);
      var index = ol.math.modulo(h, tileUrlFunctions.length);
      return tileUrlFunctions[index](tileCoord, pixelRatio, projection);
    }
  };
};
ol.TileUrlFunction.nullTileUrlFunction = function(tileCoord, pixelRatio, projection) {
  return undefined;
};
ol.TileUrlFunction.expandUrl = function(url) {
  var urls = [];
  var match = /\{([a-z])-([a-z])\}/.exec(url);
  if (match) {
    var startCharCode = match[1].charCodeAt(0);
    var stopCharCode = match[2].charCodeAt(0);
    var charCode;
    for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {
      urls.push(url.replace(match[0], String.fromCharCode(charCode)));
    }
    return urls;
  }
  match = match = /\{(\d+)-(\d+)\}/.exec(url);
  if (match) {
    var stop = parseInt(match[2], 10);
    for (var i = parseInt(match[1], 10); i <= stop; i++) {
      urls.push(url.replace(match[0], i.toString()));
    }
    return urls;
  }
  urls.push(url);
  return urls;
};
goog.provide("ol.source.Tile");
goog.require("ol");
goog.require("ol.TileCache");
goog.require("ol.TileState");
goog.require("ol.events.Event");
goog.require("ol.proj");
goog.require("ol.size");
goog.require("ol.source.Source");
goog.require("ol.tilecoord");
goog.require("ol.tilegrid");
ol.source.Tile = function(options) {
  ol.source.Source.call(this, {attributions:options.attributions, extent:options.extent, logo:options.logo, projection:options.projection, state:options.state, wrapX:options.wrapX});
  this.opaque_ = options.opaque !== undefined ? options.opaque : false;
  this.tilePixelRatio_ = options.tilePixelRatio !== undefined ? options.tilePixelRatio : 1;
  this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;
  this.tileCache = new ol.TileCache(options.cacheSize);
  this.tmpSize = [0, 0];
  this.key_ = "";
  this.tileOptions = {transition:options.transition};
};
ol.inherits(ol.source.Tile, ol.source.Source);
ol.source.Tile.prototype.canExpireCache = function() {
  return this.tileCache.canExpireCache();
};
ol.source.Tile.prototype.expireCache = function(projection, usedTiles) {
  var tileCache = this.getTileCacheForProjection(projection);
  if (tileCache) {
    tileCache.expireCache(usedTiles);
  }
};
ol.source.Tile.prototype.forEachLoadedTile = function(projection, z, tileRange, callback) {
  var tileCache = this.getTileCacheForProjection(projection);
  if (!tileCache) {
    return false;
  }
  var covered = true;
  var tile, tileCoordKey, loaded;
  for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {
    for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {
      tileCoordKey = ol.tilecoord.getKeyZXY(z, x, y);
      loaded = false;
      if (tileCache.containsKey(tileCoordKey)) {
        tile = tileCache.get(tileCoordKey);
        loaded = tile.getState() === ol.TileState.LOADED;
        if (loaded) {
          loaded = callback(tile) !== false;
        }
      }
      if (!loaded) {
        covered = false;
      }
    }
  }
  return covered;
};
ol.source.Tile.prototype.getGutter = function(projection) {
  return 0;
};
ol.source.Tile.prototype.getKey = function() {
  return this.key_;
};
ol.source.Tile.prototype.setKey = function(key) {
  if (this.key_ !== key) {
    this.key_ = key;
    this.changed();
  }
};
ol.source.Tile.prototype.getOpaque = function(projection) {
  return this.opaque_;
};
ol.source.Tile.prototype.getResolutions = function() {
  return this.tileGrid.getResolutions();
};
ol.source.Tile.prototype.getTile = function(z, x, y, pixelRatio, projection) {
};
ol.source.Tile.prototype.getTileGrid = function() {
  return this.tileGrid;
};
ol.source.Tile.prototype.getTileGridForProjection = function(projection) {
  if (!this.tileGrid) {
    return ol.tilegrid.getForProjection(projection);
  } else {
    return this.tileGrid;
  }
};
ol.source.Tile.prototype.getTileCacheForProjection = function(projection) {
  var thisProj = this.getProjection();
  if (thisProj && !ol.proj.equivalent(thisProj, projection)) {
    return null;
  } else {
    return this.tileCache;
  }
};
ol.source.Tile.prototype.getTilePixelRatio = function(pixelRatio) {
  return this.tilePixelRatio_;
};
ol.source.Tile.prototype.getTilePixelSize = function(z, pixelRatio, projection) {
  var tileGrid = this.getTileGridForProjection(projection);
  var tilePixelRatio = this.getTilePixelRatio(pixelRatio);
  var tileSize = ol.size.toSize(tileGrid.getTileSize(z), this.tmpSize);
  if (tilePixelRatio == 1) {
    return tileSize;
  } else {
    return ol.size.scale(tileSize, tilePixelRatio, this.tmpSize);
  }
};
ol.source.Tile.prototype.getTileCoordForTileUrlFunction = function(tileCoord, opt_projection) {
  var projection = opt_projection !== undefined ? opt_projection : this.getProjection();
  var tileGrid = this.getTileGridForProjection(projection);
  if (this.getWrapX() && projection.isGlobal()) {
    tileCoord = ol.tilegrid.wrapX(tileGrid, tileCoord, projection);
  }
  return ol.tilecoord.withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;
};
ol.source.Tile.prototype.refresh = function() {
  this.tileCache.clear();
  this.changed();
};
ol.source.Tile.prototype.useTile = ol.nullFunction;
ol.source.Tile.Event = function(type, tile) {
  ol.events.Event.call(this, type);
  this.tile = tile;
};
ol.inherits(ol.source.Tile.Event, ol.events.Event);
goog.provide("ol.source.TileEventType");
ol.source.TileEventType = {TILELOADSTART:"tileloadstart", TILELOADEND:"tileloadend", TILELOADERROR:"tileloaderror"};
goog.provide("ol.source.UrlTile");
goog.require("ol");
goog.require("ol.TileState");
goog.require("ol.TileUrlFunction");
goog.require("ol.source.Tile");
goog.require("ol.source.TileEventType");
goog.require("ol.tilecoord");
ol.source.UrlTile = function(options) {
  ol.source.Tile.call(this, {attributions:options.attributions, cacheSize:options.cacheSize, extent:options.extent, logo:options.logo, opaque:options.opaque, projection:options.projection, state:options.state, tileGrid:options.tileGrid, tilePixelRatio:options.tilePixelRatio, wrapX:options.wrapX, transition:options.transition});
  this.tileLoadFunction = options.tileLoadFunction;
  this.tileUrlFunction = this.fixedTileUrlFunction ? this.fixedTileUrlFunction.bind(this) : ol.TileUrlFunction.nullTileUrlFunction;
  this.urls = null;
  if (options.urls) {
    this.setUrls(options.urls);
  } else {
    if (options.url) {
      this.setUrl(options.url);
    }
  }
  if (options.tileUrlFunction) {
    this.setTileUrlFunction(options.tileUrlFunction);
  }
  this.tileLoadingKeys_ = {};
};
ol.inherits(ol.source.UrlTile, ol.source.Tile);
ol.source.UrlTile.prototype.fixedTileUrlFunction;
ol.source.UrlTile.prototype.getTileLoadFunction = function() {
  return this.tileLoadFunction;
};
ol.source.UrlTile.prototype.getTileUrlFunction = function() {
  return this.tileUrlFunction;
};
ol.source.UrlTile.prototype.getUrls = function() {
  return this.urls;
};
ol.source.UrlTile.prototype.handleTileChange = function(event) {
  var tile = event.target;
  var uid = ol.getUid(tile);
  var tileState = tile.getState();
  var type;
  if (tileState == ol.TileState.LOADING) {
    this.tileLoadingKeys_[uid] = true;
    type = ol.source.TileEventType.TILELOADSTART;
  } else {
    if (uid in this.tileLoadingKeys_) {
      delete this.tileLoadingKeys_[uid];
      type = tileState == ol.TileState.ERROR ? ol.source.TileEventType.TILELOADERROR : tileState == ol.TileState.LOADED || tileState == ol.TileState.ABORT ? ol.source.TileEventType.TILELOADEND : undefined;
    }
  }
  if (type != undefined) {
    this.dispatchEvent(new ol.source.Tile.Event(type, tile));
  }
};
ol.source.UrlTile.prototype.setTileLoadFunction = function(tileLoadFunction) {
  this.tileCache.clear();
  this.tileLoadFunction = tileLoadFunction;
  this.changed();
};
ol.source.UrlTile.prototype.setTileUrlFunction = function(tileUrlFunction, opt_key) {
  this.tileUrlFunction = tileUrlFunction;
  this.tileCache.pruneExceptNewestZ();
  if (typeof opt_key !== "undefined") {
    this.setKey(opt_key);
  } else {
    this.changed();
  }
};
ol.source.UrlTile.prototype.setUrl = function(url) {
  var urls = this.urls = ol.TileUrlFunction.expandUrl(url);
  this.setTileUrlFunction(this.fixedTileUrlFunction ? this.fixedTileUrlFunction.bind(this) : ol.TileUrlFunction.createFromTemplates(urls, this.tileGrid), url);
};
ol.source.UrlTile.prototype.setUrls = function(urls) {
  this.urls = urls;
  var key = urls.join("\n");
  this.setTileUrlFunction(this.fixedTileUrlFunction ? this.fixedTileUrlFunction.bind(this) : ol.TileUrlFunction.createFromTemplates(urls, this.tileGrid), key);
};
ol.source.UrlTile.prototype.useTile = function(z, x, y) {
  var tileCoordKey = ol.tilecoord.getKeyZXY(z, x, y);
  if (this.tileCache.containsKey(tileCoordKey)) {
    this.tileCache.get(tileCoordKey);
  }
};
goog.provide("ol.source.TileImage");
goog.require("ol");
goog.require("ol.ImageTile");
goog.require("ol.TileCache");
goog.require("ol.TileState");
goog.require("ol.events");
goog.require("ol.events.EventType");
goog.require("ol.proj");
goog.require("ol.reproj.Tile");
goog.require("ol.source.UrlTile");
goog.require("ol.tilecoord");
goog.require("ol.tilegrid");
ol.source.TileImage = function(options) {
  ol.source.UrlTile.call(this, {attributions:options.attributions, cacheSize:options.cacheSize, extent:options.extent, logo:options.logo, opaque:options.opaque, projection:options.projection, state:options.state, tileGrid:options.tileGrid, tileLoadFunction:options.tileLoadFunction ? options.tileLoadFunction : ol.source.TileImage.defaultTileLoadFunction, tilePixelRatio:options.tilePixelRatio, tileUrlFunction:options.tileUrlFunction, url:options.url, urls:options.urls, wrapX:options.wrapX, transition:options.transition});
  this.crossOrigin = options.crossOrigin !== undefined ? options.crossOrigin : null;
  this.tileClass = options.tileClass !== undefined ? options.tileClass : ol.ImageTile;
  this.tileCacheForProjection = {};
  this.tileGridForProjection = {};
  this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;
  this.renderReprojectionEdges_ = false;
};
ol.inherits(ol.source.TileImage, ol.source.UrlTile);
ol.source.TileImage.prototype.canExpireCache = function() {
  if (!ol.ENABLE_RASTER_REPROJECTION) {
    return ol.source.UrlTile.prototype.canExpireCache.call(this);
  }
  if (this.tileCache.canExpireCache()) {
    return true;
  } else {
    for (var key in this.tileCacheForProjection) {
      if (this.tileCacheForProjection[key].canExpireCache()) {
        return true;
      }
    }
  }
  return false;
};
ol.source.TileImage.prototype.expireCache = function(projection, usedTiles) {
  if (!ol.ENABLE_RASTER_REPROJECTION) {
    ol.source.UrlTile.prototype.expireCache.call(this, projection, usedTiles);
    return;
  }
  var usedTileCache = this.getTileCacheForProjection(projection);
  this.tileCache.expireCache(this.tileCache == usedTileCache ? usedTiles : {});
  for (var id in this.tileCacheForProjection) {
    var tileCache = this.tileCacheForProjection[id];
    tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});
  }
};
ol.source.TileImage.prototype.getGutter = function(projection) {
  if (ol.ENABLE_RASTER_REPROJECTION && this.getProjection() && projection && !ol.proj.equivalent(this.getProjection(), projection)) {
    return 0;
  } else {
    return this.getGutterInternal();
  }
};
ol.source.TileImage.prototype.getGutterInternal = function() {
  return 0;
};
ol.source.TileImage.prototype.getOpaque = function(projection) {
  if (ol.ENABLE_RASTER_REPROJECTION && this.getProjection() && projection && !ol.proj.equivalent(this.getProjection(), projection)) {
    return false;
  } else {
    return ol.source.UrlTile.prototype.getOpaque.call(this, projection);
  }
};
ol.source.TileImage.prototype.getTileGridForProjection = function(projection) {
  if (!ol.ENABLE_RASTER_REPROJECTION) {
    return ol.source.UrlTile.prototype.getTileGridForProjection.call(this, projection);
  }
  var thisProj = this.getProjection();
  if (this.tileGrid && (!thisProj || ol.proj.equivalent(thisProj, projection))) {
    return this.tileGrid;
  } else {
    var projKey = ol.getUid(projection).toString();
    if (!(projKey in this.tileGridForProjection)) {
      this.tileGridForProjection[projKey] = ol.tilegrid.getForProjection(projection);
    }
    return this.tileGridForProjection[projKey];
  }
};
ol.source.TileImage.prototype.getTileCacheForProjection = function(projection) {
  if (!ol.ENABLE_RASTER_REPROJECTION) {
    return ol.source.UrlTile.prototype.getTileCacheForProjection.call(this, projection);
  }
  var thisProj = this.getProjection();
  if (!thisProj || ol.proj.equivalent(thisProj, projection)) {
    return this.tileCache;
  } else {
    var projKey = ol.getUid(projection).toString();
    if (!(projKey in this.tileCacheForProjection)) {
      this.tileCacheForProjection[projKey] = new ol.TileCache(this.tileCache.highWaterMark);
    }
    return this.tileCacheForProjection[projKey];
  }
};
ol.source.TileImage.prototype.createTile_ = function(z, x, y, pixelRatio, projection, key) {
  var tileCoord = [z, x, y];
  var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
  var tileUrl = urlTileCoord ? this.tileUrlFunction(urlTileCoord, pixelRatio, projection) : undefined;
  var tile = new this.tileClass(tileCoord, tileUrl !== undefined ? ol.TileState.IDLE : ol.TileState.EMPTY, tileUrl !== undefined ? tileUrl : "", this.crossOrigin, this.tileLoadFunction, this.tileOptions);
  tile.key = key;
  ol.events.listen(tile, ol.events.EventType.CHANGE, this.handleTileChange, this);
  return tile;
};
ol.source.TileImage.prototype.getTile = function(z, x, y, pixelRatio, projection) {
  var sourceProjection = this.getProjection();
  if (!ol.ENABLE_RASTER_REPROJECTION || !sourceProjection || !projection || ol.proj.equivalent(sourceProjection, projection)) {
    return this.getTileInternal(z, x, y, pixelRatio, sourceProjection || projection);
  } else {
    var cache = this.getTileCacheForProjection(projection);
    var tileCoord = [z, x, y];
    var tile;
    var tileCoordKey = ol.tilecoord.getKey(tileCoord);
    if (cache.containsKey(tileCoordKey)) {
      tile = cache.get(tileCoordKey);
    }
    var key = this.getKey();
    if (tile && tile.key == key) {
      return tile;
    } else {
      var sourceTileGrid = this.getTileGridForProjection(sourceProjection);
      var targetTileGrid = this.getTileGridForProjection(projection);
      var wrappedTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
      var newTile = new ol.reproj.Tile(sourceProjection, sourceTileGrid, projection, targetTileGrid, tileCoord, wrappedTileCoord, this.getTilePixelRatio(pixelRatio), this.getGutterInternal(), function(z, x, y, pixelRatio) {
        return this.getTileInternal(z, x, y, pixelRatio, sourceProjection);
      }.bind(this), this.reprojectionErrorThreshold_, this.renderReprojectionEdges_);
      newTile.key = key;
      if (tile) {
        newTile.interimTile = tile;
        newTile.refreshInterimChain();
        cache.replace(tileCoordKey, newTile);
      } else {
        cache.set(tileCoordKey, newTile);
      }
      return newTile;
    }
  }
};
ol.source.TileImage.prototype.getTileInternal = function(z, x, y, pixelRatio, projection) {
  var tile = null;
  var tileCoordKey = ol.tilecoord.getKeyZXY(z, x, y);
  var key = this.getKey();
  if (!this.tileCache.containsKey(tileCoordKey)) {
    tile = this.createTile_(z, x, y, pixelRatio, projection, key);
    this.tileCache.set(tileCoordKey, tile);
  } else {
    tile = this.tileCache.get(tileCoordKey);
    if (tile.key != key) {
      var interimTile = tile;
      tile = this.createTile_(z, x, y, pixelRatio, projection, key);
      if (interimTile.getState() == ol.TileState.IDLE) {
        tile.interimTile = interimTile.interimTile;
      } else {
        tile.interimTile = interimTile;
      }
      tile.refreshInterimChain();
      this.tileCache.replace(tileCoordKey, tile);
    }
  }
  return tile;
};
ol.source.TileImage.prototype.setRenderReprojectionEdges = function(render) {
  if (!ol.ENABLE_RASTER_REPROJECTION || this.renderReprojectionEdges_ == render) {
    return;
  }
  this.renderReprojectionEdges_ = render;
  for (var id in this.tileCacheForProjection) {
    this.tileCacheForProjection[id].clear();
  }
  this.changed();
};
ol.source.TileImage.prototype.setTileGridForProjection = function(projection, tilegrid) {
  if (ol.ENABLE_RASTER_REPROJECTION) {
    var proj = ol.proj.get(projection);
    if (proj) {
      var projKey = ol.getUid(proj).toString();
      if (!(projKey in this.tileGridForProjection)) {
        this.tileGridForProjection[projKey] = tilegrid;
      }
    }
  }
};
ol.source.TileImage.defaultTileLoadFunction = function(imageTile, src) {
  imageTile.getImage().src = src;
};
goog.provide("ol.source.TileWMS");
goog.require("ol");
goog.require("ol.asserts");
goog.require("ol.extent");
goog.require("ol.obj");
goog.require("ol.math");
goog.require("ol.proj");
goog.require("ol.reproj");
goog.require("ol.size");
goog.require("ol.source.TileImage");
goog.require("ol.source.WMSServerType");
goog.require("ol.tilecoord");
goog.require("ol.string");
goog.require("ol.uri");
ol.source.TileWMS = function(opt_options) {
  var options = opt_options || {};
  var params = options.params || {};
  var transparent = "TRANSPARENT" in params ? params["TRANSPARENT"] : true;
  ol.source.TileImage.call(this, {attributions:options.attributions, cacheSize:options.cacheSize, crossOrigin:options.crossOrigin, logo:options.logo, opaque:!transparent, projection:options.projection, reprojectionErrorThreshold:options.reprojectionErrorThreshold, tileClass:options.tileClass, tileGrid:options.tileGrid, tileLoadFunction:options.tileLoadFunction, url:options.url, urls:options.urls, wrapX:options.wrapX !== undefined ? options.wrapX : true, transition:options.transition});
  this.gutter_ = options.gutter !== undefined ? options.gutter : 0;
  this.params_ = params;
  this.v13_ = true;
  this.serverType_ = options.serverType;
  this.hidpi_ = options.hidpi !== undefined ? options.hidpi : true;
  this.tmpExtent_ = ol.extent.createEmpty();
  this.updateV13_();
  this.setKey(this.getKeyForParams_());
};
ol.inherits(ol.source.TileWMS, ol.source.TileImage);
ol.source.TileWMS.prototype.getGetFeatureInfoUrl = function(coordinate, resolution, projection, params) {
  var projectionObj = ol.proj.get(projection);
  var sourceProjectionObj = this.getProjection();
  var tileGrid = this.getTileGrid();
  if (!tileGrid) {
    tileGrid = this.getTileGridForProjection(projectionObj);
  }
  var tileCoord = tileGrid.getTileCoordForCoordAndResolution(coordinate, resolution);
  if (tileGrid.getResolutions().length <= tileCoord[0]) {
    return undefined;
  }
  var tileResolution = tileGrid.getResolution(tileCoord[0]);
  var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);
  var tileSize = ol.size.toSize(tileGrid.getTileSize(tileCoord[0]), this.tmpSize);
  var gutter = this.gutter_;
  if (gutter !== 0) {
    tileSize = ol.size.buffer(tileSize, gutter, this.tmpSize);
    tileExtent = ol.extent.buffer(tileExtent, tileResolution * gutter, tileExtent);
  }
  if (sourceProjectionObj && sourceProjectionObj !== projectionObj) {
    tileResolution = ol.reproj.calculateSourceResolution(sourceProjectionObj, projectionObj, coordinate, tileResolution);
    tileExtent = ol.proj.transformExtent(tileExtent, projectionObj, sourceProjectionObj);
    coordinate = ol.proj.transform(coordinate, projectionObj, sourceProjectionObj);
  }
  var baseParams = {"SERVICE":"WMS", "VERSION":ol.DEFAULT_WMS_VERSION, "REQUEST":"GetFeatureInfo", "FORMAT":"image/png", "TRANSPARENT":true, "QUERY_LAYERS":this.params_["LAYERS"]};
  ol.obj.assign(baseParams, this.params_, params);
  var x = Math.floor((coordinate[0] - tileExtent[0]) / tileResolution);
  var y = Math.floor((tileExtent[3] - coordinate[1]) / tileResolution);
  baseParams[this.v13_ ? "I" : "X"] = x;
  baseParams[this.v13_ ? "J" : "Y"] = y;
  return this.getRequestUrl_(tileCoord, tileSize, tileExtent, 1, sourceProjectionObj || projectionObj, baseParams);
};
ol.source.TileWMS.prototype.getGutterInternal = function() {
  return this.gutter_;
};
ol.source.TileWMS.prototype.getParams = function() {
  return this.params_;
};
ol.source.TileWMS.prototype.getRequestUrl_ = function(tileCoord, tileSize, tileExtent, pixelRatio, projection, params) {
  var urls = this.urls;
  if (!urls) {
    return undefined;
  }
  params["WIDTH"] = tileSize[0];
  params["HEIGHT"] = tileSize[1];
  params[this.v13_ ? "CRS" : "SRS"] = projection.getCode();
  if (!("STYLES" in this.params_)) {
    params["STYLES"] = "";
  }
  if (pixelRatio != 1) {
    switch(this.serverType_) {
      case ol.source.WMSServerType.GEOSERVER:
        var dpi = 90 * pixelRatio + 0.5 | 0;
        if ("FORMAT_OPTIONS" in params) {
          params["FORMAT_OPTIONS"] += ";dpi:" + dpi;
        } else {
          params["FORMAT_OPTIONS"] = "dpi:" + dpi;
        }
        break;
      case ol.source.WMSServerType.MAPSERVER:
        params["MAP_RESOLUTION"] = 90 * pixelRatio;
        break;
      case ol.source.WMSServerType.CARMENTA_SERVER:
      case ol.source.WMSServerType.QGIS:
        params["DPI"] = 90 * pixelRatio;
        break;
      default:
        ol.asserts.assert(false, 52);
        break;
    }
  }
  var axisOrientation = projection.getAxisOrientation();
  var bbox = tileExtent;
  if (this.v13_ && axisOrientation.substr(0, 2) == "ne") {
    var tmp;
    tmp = tileExtent[0];
    bbox[0] = tileExtent[1];
    bbox[1] = tmp;
    tmp = tileExtent[2];
    bbox[2] = tileExtent[3];
    bbox[3] = tmp;
  }
  params["BBOX"] = bbox.join(",");
  var url;
  if (urls.length == 1) {
    url = urls[0];
  } else {
    var index = ol.math.modulo(ol.tilecoord.hash(tileCoord), urls.length);
    url = urls[index];
  }
  return ol.uri.appendParams(url, params);
};
ol.source.TileWMS.prototype.getTilePixelRatio = function(pixelRatio) {
  return !this.hidpi_ || this.serverType_ === undefined ? 1 : pixelRatio;
};
ol.source.TileWMS.prototype.getKeyForParams_ = function() {
  var i = 0;
  var res = [];
  for (var key in this.params_) {
    res[i++] = key + "-" + this.params_[key];
  }
  return res.join("/");
};
ol.source.TileWMS.prototype.fixedTileUrlFunction = function(tileCoord, pixelRatio, projection) {
  var tileGrid = this.getTileGrid();
  if (!tileGrid) {
    tileGrid = this.getTileGridForProjection(projection);
  }
  if (tileGrid.getResolutions().length <= tileCoord[0]) {
    return undefined;
  }
  if (pixelRatio != 1 && (!this.hidpi_ || this.serverType_ === undefined)) {
    pixelRatio = 1;
  }
  var tileResolution = tileGrid.getResolution(tileCoord[0]);
  var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);
  var tileSize = ol.size.toSize(tileGrid.getTileSize(tileCoord[0]), this.tmpSize);
  var gutter = this.gutter_;
  if (gutter !== 0) {
    tileSize = ol.size.buffer(tileSize, gutter, this.tmpSize);
    tileExtent = ol.extent.buffer(tileExtent, tileResolution * gutter, tileExtent);
  }
  if (pixelRatio != 1) {
    tileSize = ol.size.scale(tileSize, pixelRatio, this.tmpSize);
  }
  var baseParams = {"SERVICE":"WMS", "VERSION":ol.DEFAULT_WMS_VERSION, "REQUEST":"GetMap", "FORMAT":"image/png", "TRANSPARENT":true};
  ol.obj.assign(baseParams, this.params_);
  return this.getRequestUrl_(tileCoord, tileSize, tileExtent, pixelRatio, projection, baseParams);
};
ol.source.TileWMS.prototype.updateParams = function(params) {
  ol.obj.assign(this.params_, params);
  this.updateV13_();
  this.setKey(this.getKeyForParams_());
};
ol.source.TileWMS.prototype.updateV13_ = function() {
  var version = this.params_["VERSION"] || ol.DEFAULT_WMS_VERSION;
  this.v13_ = ol.string.compareVersions(version, "1.3") >= 0;
};
goog.provide("olcs.util");
olcs.util.obj = function(param) {
  return param;
};
olcs.util.supportsImageRenderingPixelatedResult_ = undefined;
olcs.util.imageRenderingValueResult_ = undefined;
olcs.util.supportsImageRenderingPixelated = function() {
  if (olcs.util.supportsImageRenderingPixelatedResult_ === undefined) {
    var canvas = document.createElement("canvas");
    canvas.setAttribute("style", "image-rendering: -moz-crisp-edges; image-rendering: pixelated;");
    var tmp = canvas.style["imageRendering"];
    olcs.util.supportsImageRenderingPixelatedResult_ = !!tmp;
    if (olcs.util.supportsImageRenderingPixelatedResult_) {
      olcs.util.imageRenderingValueResult_ = tmp;
    }
  }
  return olcs.util.supportsImageRenderingPixelatedResult_;
};
olcs.util.imageRenderingValue = function() {
  olcs.util.supportsImageRenderingPixelated();
  return olcs.util.imageRenderingValueResult_ || "";
};
olcs.util.getSourceProjection = function(source) {
  return source.get("olcs.projection") || source.getProjection();
};
goog.provide("olcs.core.OLImageryProvider");
goog.require("ol.proj");
goog.require("olcs.util");
olcs.core.OLImageryProvider = function(source, opt_fallbackProj) {
  this.source_ = source;
  this.projection_ = null;
  this.fallbackProj_ = opt_fallbackProj || null;
  this.ready_ = false;
  this.credit_ = null;
  this.tilingScheme_ = null;
  this.rectangle_ = null;
  var proxy = this.source_.get("olcs.proxy");
  if (proxy) {
    if (typeof proxy === "function") {
      this.proxy_ = {"getURL":proxy};
    } else {
      if (typeof proxy === "string") {
        this.proxy_ = new Cesium.DefaultProxy(proxy);
      }
    }
  }
  this.errorEvent_ = new Cesium.Event;
  this.emptyCanvas_ = document.createElement("canvas");
  this.emptyCanvas_.width = 1;
  this.emptyCanvas_.height = 1;
  this.source_.on("change", function(e) {
    this.handleSourceChanged_();
  }, this);
  this.handleSourceChanged_();
};
Object.defineProperties(olcs.core.OLImageryProvider.prototype, {"ready":{"get":function() {
  return this.ready_;
}}, "rectangle":{"get":function() {
  return this.rectangle_;
}}, "tileWidth":{"get":function() {
  var tg = this.source_.getTileGrid();
  return tg ? Array.isArray(tg.getTileSize(0)) ? tg.getTileSize(0)[0] : tg.getTileSize(0) : 256;
}}, "tileHeight":{"get":function() {
  var tg = this.source_.getTileGrid();
  return tg ? Array.isArray(tg.getTileSize(0)) ? tg.getTileSize(0)[1] : tg.getTileSize(0) : 256;
}}, "maximumLevel":{"get":function() {
  var tg = this.source_.getTileGrid();
  return tg ? tg.getMaxZoom() : 18;
}}, "minimumLevel":{"get":function() {
  return 0;
}}, "tilingScheme":{"get":function() {
  return this.tilingScheme_;
}}, "tileDiscardPolicy":{"get":function() {
  return undefined;
}}, "errorEvent":{"get":function() {
  return this.errorEvent_;
}}, "credit":{"get":function() {
  return this.credit_;
}}, "proxy":{"get":function() {
  return this.proxy_;
}}, "hasAlphaChannel":{"get":function() {
  return true;
}}, "pickFeatures":{"get":function() {
  return undefined;
}}});
olcs.core.OLImageryProvider.prototype.handleSourceChanged_ = function() {
  if (!this.ready_ && this.source_.getState() == "ready") {
    this.projection_ = olcs.util.getSourceProjection(this.source_) || this.fallbackProj_;
    if (this.projection_ == ol.proj.get("EPSG:4326")) {
      this.tilingScheme_ = new Cesium.GeographicTilingScheme;
    } else {
      if (this.projection_ == ol.proj.get("EPSG:3857")) {
        this.tilingScheme_ = new Cesium.WebMercatorTilingScheme;
      } else {
        return;
      }
    }
    this.rectangle_ = this.tilingScheme_.rectangle;
    var credit = olcs.core.OLImageryProvider.createCreditForSource(this.source_);
    this.credit_ = credit || null;
    this.ready_ = true;
  }
};
olcs.core.OLImageryProvider.createCreditForSource = function(source) {
  var text = "";
  var attributions = source.getAttributions();
  if (typeof attributions === "function") {
    attributions = attributions();
  }
  if (attributions) {
    attributions.forEach(function(htmlOrAttr) {
      var html = typeof htmlOrAttr === "string" ? htmlOrAttr : htmlOrAttr.getHTML();
      text += html.replace(/<\/?[^>]+(>|$)/g, "") + " ";
    });
  }
  return text.length > 0 ? new Cesium.Credit(text, undefined, undefined) : null;
};
olcs.core.OLImageryProvider.prototype.getTileCredits = function(x, y, level) {
  return undefined;
};
olcs.core.OLImageryProvider.prototype.requestImage = function(x, y, level) {
  var tileUrlFunction = this.source_.getTileUrlFunction();
  if (tileUrlFunction && this.projection_) {
    var z_ = this.tilingScheme_ instanceof Cesium.GeographicTilingScheme ? level + 1 : level;
    var y_ = -y - 1;
    var url = tileUrlFunction.call(this.source_, [z_, x, y_], 1, this.projection_);
    if (this.proxy_) {
      url = this.proxy_.getURL(url);
    }
    return url ? Cesium.ImageryProvider.loadImage(this, url) : this.emptyCanvas_;
  } else {
    return this.emptyCanvas_;
  }
};
goog.provide("olcs.core");
goog.require("ol.easing");
goog.require("goog.asserts");
goog.require("ol.layer.Tile");
goog.require("ol.layer.Image");
goog.require("ol.proj");
goog.require("ol.source.Image");
goog.require("ol.source.ImageWMS");
goog.require("ol.source.TileImage");
goog.require("ol.source.TileWMS");
goog.require("olcs.core.OLImageryProvider");
goog.require("olcs.util");
olcs.core.computePixelSizeAtCoordinate = function(scene, target) {
  var camera = scene.camera;
  var canvas = scene.canvas;
  var frustum = camera.frustum;
  var distance = Cesium.Cartesian3.magnitude(Cesium.Cartesian3.subtract(camera.position, target, new Cesium.Cartesian3));
  var pixelSize = new Cesium.Cartesian2;
  return frustum.getPixelDimensions(canvas.clientWidth, canvas.clientHeight, distance, pixelSize);
};
olcs.core.computeBoundingBoxAtTarget = function(scene, target, amount) {
  var pixelSize = olcs.core.computePixelSizeAtCoordinate(scene, target);
  var transform = Cesium.Transforms.eastNorthUpToFixedFrame(target);
  var bottomLeft = Cesium.Matrix4.multiplyByPoint(transform, new Cesium.Cartesian3(-pixelSize.x * amount, -pixelSize.y * amount, 0), new Cesium.Cartesian3);
  var topRight = Cesium.Matrix4.multiplyByPoint(transform, new Cesium.Cartesian3(pixelSize.x * amount, pixelSize.y * amount, 0), new Cesium.Cartesian3);
  return Cesium.Ellipsoid.WGS84.cartesianArrayToCartographicArray([bottomLeft, topRight]);
};
olcs.core.applyHeightOffsetToGeometry = function(geometry, height) {
  geometry.applyTransform(function(input, output, stride) {
    goog.asserts.assert(input === output);
    if (stride !== undefined && stride >= 3) {
      for (var i = 0; i < output.length; i += stride) {
        output[i + 2] = output[i + 2] + height;
      }
    }
    return output;
  });
};
olcs.core.createMatrixAtCoordinates = function(coordinates, rotation, translation, scale) {
  rotation = rotation === undefined ? 0 : rotation;
  translation = translation === undefined ? Cesium.Cartesian3.ZERO : translation;
  scale = scale === undefined ? new Cesium.Cartesian3(1, 1, 1) : scale;
  var position = olcs.core.ol4326CoordinateToCesiumCartesian(coordinates);
  var rawMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(position);
  var quaternion = Cesium.Quaternion.fromAxisAngle(Cesium.Cartesian3.UNIT_Z, -rotation);
  var rotationMatrix = Cesium.Matrix4.fromTranslationQuaternionRotationScale(translation, quaternion, scale);
  return Cesium.Matrix4.multiply(rawMatrix, rotationMatrix, new Cesium.Matrix4);
};
olcs.core.rotateAroundAxis = function(camera, angle, axis, transform, opt_options) {
  var clamp = Cesium.Math.clamp;
  var defaultValue = Cesium.defaultValue;
  var options = opt_options || {};
  var duration = defaultValue(options.duration, 500);
  var easing = defaultValue(options.easing, ol.easing.linear);
  var callback = options.callback;
  var lastProgress = 0;
  var oldTransform = new Cesium.Matrix4;
  var start = Date.now();
  var step = function() {
    var timestamp = Date.now();
    var timeDifference = timestamp - start;
    var progress = easing(clamp(timeDifference / duration, 0, 1));
    goog.asserts.assert(progress >= lastProgress);
    camera.transform.clone(oldTransform);
    var stepAngle = (progress - lastProgress) * angle;
    lastProgress = progress;
    camera.lookAtTransform(transform);
    camera.rotate(axis, stepAngle);
    camera.lookAtTransform(oldTransform);
    if (progress < 1) {
      window.requestAnimationFrame(step);
    } else {
      if (callback) {
        callback();
      }
    }
  };
  window.requestAnimationFrame(step);
};
olcs.core.setHeadingUsingBottomCenter = function(scene, heading, bottomCenter, opt_options) {
  var camera = scene.camera;
  var angleToZenith = olcs.core.computeAngleToZenith(scene, bottomCenter);
  var axis = camera.right;
  var quaternion = Cesium.Quaternion.fromAxisAngle(axis, angleToZenith);
  var rotation = Cesium.Matrix3.fromQuaternion(quaternion);
  var vector = new Cesium.Cartesian3;
  Cesium.Cartesian3.subtract(camera.position, bottomCenter, vector);
  var zenith = new Cesium.Cartesian3;
  Cesium.Matrix3.multiplyByVector(rotation, vector, zenith);
  Cesium.Cartesian3.add(zenith, bottomCenter, zenith);
  var transform = Cesium.Matrix4.fromTranslation(zenith);
  var rotateAroundAxis = olcs.core.rotateAroundAxis;
  rotateAroundAxis(camera, heading, zenith, transform, opt_options);
};
olcs.core.pickOnTerrainOrEllipsoid = function(scene, pixel) {
  var ray = scene.camera.getPickRay(pixel);
  var target = scene.globe.pick(ray, scene);
  return target || scene.camera.pickEllipsoid(pixel);
};
olcs.core.pickBottomPoint = function(scene) {
  var canvas = scene.canvas;
  var bottom = new Cesium.Cartesian2(canvas.clientWidth / 2, canvas.clientHeight);
  return olcs.core.pickOnTerrainOrEllipsoid(scene, bottom);
};
olcs.core.pickCenterPoint = function(scene) {
  var canvas = scene.canvas;
  var center = new Cesium.Cartesian2(canvas.clientWidth / 2, canvas.clientHeight / 2);
  return olcs.core.pickOnTerrainOrEllipsoid(scene, center);
};
olcs.core.computeSignedTiltAngleOnGlobe = function(scene) {
  var camera = scene.camera;
  var ray = new Cesium.Ray(camera.position, camera.direction);
  var target = scene.globe.pick(ray, scene);
  if (!target) {
    var ellipsoid = Cesium.Ellipsoid.WGS84;
    var obj = Cesium.IntersectionTests.rayEllipsoid(ray, ellipsoid);
    if (obj) {
      target = Cesium.Ray.getPoint(ray, obj.start);
    }
  }
  if (!target) {
    return undefined;
  }
  var normal = new Cesium.Cartesian3;
  Cesium.Ellipsoid.WGS84.geocentricSurfaceNormal(target, normal);
  var angleBetween = olcs.core.signedAngleBetween;
  var angle = angleBetween(camera.direction, normal, camera.right) - Math.PI;
  return Cesium.Math.convertLongitudeRange(angle);
};
olcs.core.bottomFovRay = function(scene) {
  var camera = scene.camera;
  var fovy2 = camera.frustum.fovy / 2;
  var direction = camera.direction;
  var rotation = Cesium.Quaternion.fromAxisAngle(camera.right, fovy2);
  var matrix = Cesium.Matrix3.fromQuaternion(rotation);
  var vector = new Cesium.Cartesian3;
  Cesium.Matrix3.multiplyByVector(matrix, direction, vector);
  return new Cesium.Ray(camera.position, vector);
};
olcs.core.signedAngleBetween = function(first, second, normal) {
  var a = new Cesium.Cartesian3;
  var b = new Cesium.Cartesian3;
  var c = new Cesium.Cartesian3;
  Cesium.Cartesian3.normalize(first, a);
  Cesium.Cartesian3.normalize(second, b);
  Cesium.Cartesian3.cross(a, b, c);
  var cosine = Cesium.Cartesian3.dot(a, b);
  var sine = Cesium.Cartesian3.magnitude(c);
  var sign = Cesium.Cartesian3.dot(normal, c);
  var angle = Math.atan2(sine, cosine);
  return sign >= 0 ? angle : -angle;
};
olcs.core.computeAngleToZenith = function(scene, pivot) {
  var camera = scene.camera;
  var fy = camera.frustum.fovy / 2;
  var ray = olcs.core.bottomFovRay(scene);
  var direction = Cesium.Cartesian3.clone(ray.direction);
  Cesium.Cartesian3.negate(direction, direction);
  var normal = new Cesium.Cartesian3;
  Cesium.Ellipsoid.WGS84.geocentricSurfaceNormal(pivot, normal);
  var left = new Cesium.Cartesian3;
  Cesium.Cartesian3.negate(camera.right, left);
  var a = olcs.core.signedAngleBetween(normal, direction, left);
  return a + fy;
};
olcs.core.lookAt = function(camera, target, opt_globe) {
  if (opt_globe) {
    var height = opt_globe.getHeight(target);
    target.height = height || 0;
  }
  var ellipsoid = Cesium.Ellipsoid.WGS84;
  var targetb = ellipsoid.cartographicToCartesian(target);
  var position = camera.position;
  var up = new Cesium.Cartesian3;
  ellipsoid.geocentricSurfaceNormal(position, up);
  camera.lookAt(position, targetb, up);
};
olcs.core.extentToRectangle = function(extent, projection) {
  if (extent && projection) {
    var ext = ol.proj.transformExtent(extent, projection, "EPSG:4326");
    return Cesium.Rectangle.fromDegrees(ext[0], ext[1], ext[2], ext[3]);
  } else {
    return null;
  }
};
olcs.core.tileLayerToImageryLayer = function(olLayer, viewProj) {
  if (!(olLayer instanceof ol.layer.Tile) && !(olLayer instanceof ol.layer.Image)) {
    return null;
  }
  var provider = null;
  var source = olLayer.getSource();
  if (source instanceof ol.source.ImageWMS && source.getUrl() && source.getImageLoadFunction() === ol.source.Image.defaultImageLoadFunction) {
    var sourceProps = {"olcs.proxy":source.get("olcs.proxy"), "olcs.extent":source.get("olcs.extent"), "olcs.projection":source.get("olcs.projection"), "olcs.imagesource":source};
    source = new ol.source.TileWMS({url:source.getUrl(), attributions:source.getAttributions(), projection:source.getProjection(), logo:source.getLogo(), params:source.getParams()});
    source.setProperties(sourceProps);
  }
  if (source instanceof ol.source.TileImage) {
    var projection = olcs.util.getSourceProjection(source);
    if (!projection) {
      projection = viewProj;
    }
    if (olcs.core.isCesiumProjection(projection)) {
      provider = new olcs.core.OLImageryProvider(source, viewProj);
    } else {
      return null;
    }
  } else {
    return null;
  }
  var layerOptions = {};
  var forcedExtent = olLayer.get("olcs.extent");
  var ext = forcedExtent || olLayer.getExtent();
  if (ext) {
    layerOptions.rectangle = olcs.core.extentToRectangle(ext, viewProj);
  }
  var cesiumLayer = new Cesium.ImageryLayer(provider, layerOptions);
  return cesiumLayer;
};
olcs.core.updateCesiumLayerProperties = function(olLayerWithParents, csLayer) {
  var opacity = 1;
  var visible = true;
  [olLayerWithParents.layer].concat(olLayerWithParents.parents).forEach(function(olLayer) {
    var layerOpacity = olLayer.getOpacity();
    if (layerOpacity !== undefined) {
      opacity *= layerOpacity;
    }
    var layerVisible = olLayer.getVisible();
    if (layerVisible !== undefined) {
      visible &= layerVisible;
    }
  });
  csLayer.alpha = opacity;
  csLayer.show = visible;
};
olcs.core.ol4326CoordinateToCesiumCartesian = function(coordinate) {
  var coo = coordinate;
  return coo.length > 2 ? Cesium.Cartesian3.fromDegrees(coo[0], coo[1], coo[2]) : Cesium.Cartesian3.fromDegrees(coo[0], coo[1]);
};
olcs.core.ol4326CoordinateArrayToCsCartesians = function(coordinates) {
  goog.asserts.assert(coordinates !== null);
  var toCartesian = olcs.core.ol4326CoordinateToCesiumCartesian;
  var cartesians = [];
  for (var i = 0; i < coordinates.length; ++i) {
    cartesians.push(toCartesian(coordinates[i]));
  }
  return cartesians;
};
olcs.core.olGeometryCloneTo4326 = function(geometry, projection) {
  goog.asserts.assert(projection);
  var proj4326 = ol.proj.get("EPSG:4326");
  var proj = ol.proj.get(projection);
  if (proj !== proj4326) {
    var properties = geometry.getProperties();
    geometry = geometry.clone();
    geometry.transform(proj, proj4326);
    geometry.setProperties(properties);
  }
  return geometry;
};
olcs.core.convertColorToCesium = function(olColor) {
  olColor = olColor || "black";
  if (Array.isArray(olColor)) {
    return new Cesium.Color(Cesium.Color.byteToFloat(olColor[0]), Cesium.Color.byteToFloat(olColor[1]), Cesium.Color.byteToFloat(olColor[2]), olColor[3]);
  } else {
    if (typeof olColor == "string") {
      return Cesium.Color.fromCssColorString(olColor);
    }
  }
  goog.asserts.fail("impossible");
};
olcs.core.convertUrlToCesium = function(url) {
  var subdomains = "";
  var re = /\{(\d|[a-z])-(\d|[a-z])\}/;
  var match = re.exec(url);
  if (match) {
    url = url.replace(re, "{s}");
    var startCharCode = match[1].charCodeAt(0);
    var stopCharCode = match[2].charCodeAt(0);
    var charCode;
    for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {
      subdomains += String.fromCharCode(charCode);
    }
  }
  return {url:url, subdomains:subdomains};
};
olcs.core.resetToNorthZenith = function(map, scene) {
  return new Promise(function(resolve, reject) {
    var camera = scene.camera;
    var pivot = olcs.core.pickBottomPoint(scene);
    if (!pivot) {
      reject("Could not get bottom pivot");
      return;
    }
    var currentHeading = map.getView().getRotation();
    if (currentHeading === undefined) {
      reject("The view is not initialized");
      return;
    }
    var angle = olcs.core.computeAngleToZenith(scene, pivot);
    olcs.core.setHeadingUsingBottomCenter(scene, currentHeading, pivot);
    var transform = Cesium.Matrix4.fromTranslation(pivot);
    var axis = camera.right;
    var options = {callback:function() {
      var view = map.getView();
      olcs.core.normalizeView(view);
      resolve();
    }};
    olcs.core.rotateAroundAxis(camera, -angle, axis, transform, options);
  });
};
olcs.core.rotateAroundBottomCenter = function(scene, angle) {
  return new Promise(function(resolve, reject) {
    var camera = scene.camera;
    var pivot = olcs.core.pickBottomPoint(scene);
    if (!pivot) {
      reject("could not get bottom pivot");
      return;
    }
    var options = {callback:resolve};
    var transform = Cesium.Matrix4.fromTranslation(pivot);
    var axis = camera.right;
    var rotateAroundAxis = olcs.core.rotateAroundAxis;
    rotateAroundAxis(camera, -angle, axis, transform, options);
  });
};
olcs.core.normalizeView = function(view, angle) {
  angle = angle === undefined ? 0 : angle;
  var resolution = view.getResolution();
  view.setRotation(angle);
  view.setResolution(view.constrainResolution(resolution));
};
olcs.core.isCesiumProjection = function(projection) {
  var is3857 = projection === ol.proj.get("EPSG:3857");
  var is4326 = projection === ol.proj.get("EPSG:4326");
  return is3857 || is4326;
};
goog.provide("olcs.Camera");
goog.require("goog.asserts");
goog.require("ol.Observable");
goog.require("ol.events");
goog.require("ol.math");
goog.require("ol.proj");
goog.require("olcs.core");
olcs.Camera = function(scene, map) {
  this.scene_ = scene;
  this.cam_ = scene.camera;
  this.map_ = map;
  this.view_ = null;
  this.viewListenKey_ = null;
  this.toLonLat_ = olcs.Camera.identityProjection;
  this.fromLonLat_ = olcs.Camera.identityProjection;
  this.tilt_ = 0;
  this.distance_ = 0;
  this.lastCameraViewMatrix_ = null;
  this.viewUpdateInProgress_ = false;
  this.map_.on("change:view", function(e) {
    this.setView_(this.map_.getView());
  }, this);
  this.setView_(this.map_.getView());
};
olcs.Camera.identityProjection = function(input, opt_output, opt_dimension) {
  var dim = opt_dimension || input.length;
  if (opt_output) {
    for (var i = 0; i < dim; ++i) {
      opt_output[i] = input[i];
    }
  }
  return input;
};
olcs.Camera.prototype.setView_ = function(view) {
  if (this.view_) {
    ol.Observable.unByKey(this.viewListenKey_);
    this.viewListenKey_ = null;
  }
  this.view_ = view;
  if (view) {
    var toLonLat = ol.proj.getTransform(view.getProjection(), "EPSG:4326");
    var fromLonLat = ol.proj.getTransform("EPSG:4326", view.getProjection());
    goog.asserts.assert(toLonLat && fromLonLat);
    this.toLonLat_ = toLonLat;
    this.fromLonLat_ = fromLonLat;
    this.viewListenKey_ = ol.events.listen(view, "propertychange", this.handleViewEvent_, this);
    this.readFromView();
  } else {
    this.toLonLat_ = olcs.Camera.identityProjection;
    this.fromLonLat_ = olcs.Camera.identityProjection;
  }
};
olcs.Camera.prototype.handleViewEvent_ = function(e) {
  if (!this.viewUpdateInProgress_) {
    this.readFromView();
  }
};
olcs.Camera.prototype.setHeading = function(heading) {
  if (!this.view_) {
    return;
  }
  this.view_.setRotation(heading);
};
olcs.Camera.prototype.getHeading = function() {
  if (!this.view_) {
    return undefined;
  }
  var rotation = this.view_.getRotation();
  return rotation || 0;
};
olcs.Camera.prototype.setTilt = function(tilt) {
  this.tilt_ = tilt;
  this.updateCamera_();
};
olcs.Camera.prototype.getTilt = function() {
  return this.tilt_;
};
olcs.Camera.prototype.setDistance = function(distance) {
  this.distance_ = distance;
  this.updateCamera_();
  this.updateView();
};
olcs.Camera.prototype.getDistance = function() {
  return this.distance_;
};
olcs.Camera.prototype.setCenter = function(center) {
  if (!this.view_) {
    return;
  }
  this.view_.setCenter(center);
};
olcs.Camera.prototype.getCenter = function() {
  if (!this.view_) {
    return undefined;
  }
  return this.view_.getCenter();
};
olcs.Camera.prototype.setPosition = function(position) {
  if (!this.toLonLat_) {
    return;
  }
  var ll = this.toLonLat_(position);
  goog.asserts.assert(ll);
  var carto = new Cesium.Cartographic(ol.math.toRadians(ll[0]), ol.math.toRadians(ll[1]), this.getAltitude());
  this.cam_.position = Cesium.Ellipsoid.WGS84.cartographicToCartesian(carto);
  this.updateView();
};
olcs.Camera.prototype.getPosition = function() {
  if (!this.fromLonLat_) {
    return undefined;
  }
  var carto = Cesium.Ellipsoid.WGS84.cartesianToCartographic(this.cam_.position);
  var pos = this.fromLonLat_([ol.math.toDegrees(carto.longitude), ol.math.toDegrees(carto.latitude)]);
  goog.asserts.assert(pos);
  return pos;
};
olcs.Camera.prototype.setAltitude = function(altitude) {
  var carto = Cesium.Ellipsoid.WGS84.cartesianToCartographic(this.cam_.position);
  carto.height = altitude;
  this.cam_.position = Cesium.Ellipsoid.WGS84.cartographicToCartesian(carto);
  this.updateView();
};
olcs.Camera.prototype.getAltitude = function() {
  var carto = Cesium.Ellipsoid.WGS84.cartesianToCartographic(this.cam_.position);
  return carto.height;
};
olcs.Camera.prototype.lookAt = function(position) {
  if (!this.toLonLat_) {
    return;
  }
  var ll = this.toLonLat_(position);
  goog.asserts.assert(ll);
  var carto = Cesium.Cartographic.fromDegrees(ll[0], ll[1]);
  olcs.core.lookAt(this.cam_, carto, this.scene_.globe);
  this.updateView();
};
olcs.Camera.prototype.updateCamera_ = function() {
  if (!this.view_ || !this.toLonLat_) {
    return;
  }
  var center = this.view_.getCenter();
  if (!center) {
    return;
  }
  var ll = this.toLonLat_(center);
  goog.asserts.assert(ll);
  var carto = new Cesium.Cartographic(ol.math.toRadians(ll[0]), ol.math.toRadians(ll[1]));
  if (this.scene_.globe) {
    var height = this.scene_.globe.getHeight(carto);
    carto.height = height || 0;
  }
  var destination = Cesium.Ellipsoid.WGS84.cartographicToCartesian(carto);
  var orientation = {pitch:this.tilt_ - Cesium.Math.PI_OVER_TWO, heading:-this.view_.getRotation(), roll:undefined};
  this.cam_.setView({destination:destination, orientation:orientation});
  this.cam_.moveBackward(this.distance_);
  this.checkCameraChange(true);
};
olcs.Camera.prototype.readFromView = function() {
  if (!this.view_ || !this.toLonLat_) {
    return;
  }
  var center = this.view_.getCenter();
  if (center === undefined || center === null) {
    return;
  }
  var ll = this.toLonLat_(center);
  goog.asserts.assert(ll);
  var resolution = this.view_.getResolution();
  this.distance_ = this.calcDistanceForResolution(resolution || 0, ol.math.toRadians(ll[1]));
  this.updateCamera_();
};
olcs.Camera.prototype.updateView = function() {
  if (!this.view_ || !this.fromLonLat_) {
    return;
  }
  this.viewUpdateInProgress_ = true;
  var ellipsoid = Cesium.Ellipsoid.WGS84;
  var scene = this.scene_;
  var target = olcs.core.pickCenterPoint(scene);
  var bestTarget = target;
  if (!bestTarget) {
    var globe = scene.globe;
    var carto = this.cam_.positionCartographic.clone();
    var height = globe.getHeight(carto);
    carto.height = height || 0;
    bestTarget = Cesium.Ellipsoid.WGS84.cartographicToCartesian(carto);
  }
  this.distance_ = Cesium.Cartesian3.distance(bestTarget, this.cam_.position);
  var bestTargetCartographic = ellipsoid.cartesianToCartographic(bestTarget);
  this.view_.setCenter(this.fromLonLat_([ol.math.toDegrees(bestTargetCartographic.longitude), ol.math.toDegrees(bestTargetCartographic.latitude)]));
  this.view_.setResolution(this.calcResolutionForDistance(this.distance_, bestTargetCartographic ? bestTargetCartographic.latitude : 0));
  if (target) {
    var pos = this.cam_.position;
    var targetNormal = new Cesium.Cartesian3;
    ellipsoid.geocentricSurfaceNormal(target, targetNormal);
    var targetToCamera = new Cesium.Cartesian3;
    Cesium.Cartesian3.subtract(pos, target, targetToCamera);
    Cesium.Cartesian3.normalize(targetToCamera, targetToCamera);
    var up = this.cam_.up;
    var right = this.cam_.right;
    var normal = new Cesium.Cartesian3(-target.y, target.x, 0);
    var heading = Cesium.Cartesian3.angleBetween(right, normal);
    var cross = Cesium.Cartesian3.cross(target, up, new Cesium.Cartesian3);
    var orientation = cross.z;
    this.view_.setRotation(orientation < 0 ? heading : -heading);
    var tiltAngle = Math.acos(Cesium.Cartesian3.dot(targetNormal, targetToCamera));
    this.tilt_ = isNaN(tiltAngle) ? 0 : tiltAngle;
  } else {
    this.view_.setRotation(this.cam_.heading);
    this.tilt_ = -this.cam_.pitch + Math.PI / 2;
  }
  this.viewUpdateInProgress_ = false;
};
olcs.Camera.prototype.checkCameraChange = function(opt_dontSync) {
  var old = this.lastCameraViewMatrix_;
  var current = this.cam_.viewMatrix;
  if (!old || !Cesium.Matrix4.equalsEpsilon(old, current, 1e-5)) {
    this.lastCameraViewMatrix_ = current.clone();
    if (opt_dontSync !== true) {
      this.updateView();
    }
  }
};
olcs.Camera.prototype.calcDistanceForResolution = function(resolution, latitude) {
  var canvas = this.scene_.canvas;
  var fovy = this.cam_.frustum.fovy;
  goog.asserts.assert(!isNaN(fovy));
  var metersPerUnit = this.view_.getProjection().getMetersPerUnit();
  var visibleMapUnits = resolution * canvas.clientHeight;
  var relativeCircumference = Math.cos(Math.abs(latitude));
  var visibleMeters = visibleMapUnits * metersPerUnit * relativeCircumference;
  var requiredDistance = visibleMeters / 2 / Math.tan(fovy / 2);
  return requiredDistance;
};
olcs.Camera.prototype.calcResolutionForDistance = function(distance, latitude) {
  var canvas = this.scene_.canvas;
  var fovy = this.cam_.frustum.fovy;
  var metersPerUnit = this.view_.getProjection().getMetersPerUnit();
  var visibleMeters = 2 * distance * Math.tan(fovy / 2);
  var relativeCircumference = Math.cos(Math.abs(latitude));
  var visibleMapUnits = visibleMeters / metersPerUnit / relativeCircumference;
  var resolution = visibleMapUnits / canvas.clientHeight;
  return resolution;
};
goog.provide("olcs.contrib.LazyLoader");
olcs.contrib.LazyLoader = function(url) {
  this.promise;
  this.url_ = url;
};
olcs.contrib.LazyLoader.prototype.load = function() {
  var $jscomp$this = this;
  if (!this.promise) {
    this.promise = new Promise(function(resolve, reject) {
      var script = document.createElement("script");
      script.onload = function() {
        return resolve();
      };
      script.onerror = function() {
        return reject();
      };
      document.head.appendChild(script);
      script.src = $jscomp$this.url_;
    });
  }
  return this.promise;
};
goog.provide("ol.geom.GeometryLayout");
ol.geom.GeometryLayout = {XY:"XY", XYZ:"XYZ", XYM:"XYM", XYZM:"XYZM"};
goog.provide("ol.functions");
ol.functions.TRUE = function() {
  return true;
};
ol.functions.FALSE = function() {
  return false;
};
goog.provide("ol.geom.flat.transform");
ol.geom.flat.transform.transform2D = function(flatCoordinates, offset, end, stride, transform, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var i = 0;
  var j;
  for (j = offset; j < end; j += stride) {
    var x = flatCoordinates[j];
    var y = flatCoordinates[j + 1];
    dest[i++] = transform[0] * x + transform[2] * y + transform[4];
    dest[i++] = transform[1] * x + transform[3] * y + transform[5];
  }
  if (opt_dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
};
ol.geom.flat.transform.rotate = function(flatCoordinates, offset, end, stride, angle, anchor, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var cos = Math.cos(angle);
  var sin = Math.sin(angle);
  var anchorX = anchor[0];
  var anchorY = anchor[1];
  var i = 0;
  for (var j = offset; j < end; j += stride) {
    var deltaX = flatCoordinates[j] - anchorX;
    var deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + deltaX * cos - deltaY * sin;
    dest[i++] = anchorY + deltaX * sin + deltaY * cos;
    for (var k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (opt_dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
};
ol.geom.flat.transform.scale = function(flatCoordinates, offset, end, stride, sx, sy, anchor, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var anchorX = anchor[0];
  var anchorY = anchor[1];
  var i = 0;
  for (var j = offset; j < end; j += stride) {
    var deltaX = flatCoordinates[j] - anchorX;
    var deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + sx * deltaX;
    dest[i++] = anchorY + sy * deltaY;
    for (var k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (opt_dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
};
ol.geom.flat.transform.translate = function(flatCoordinates, offset, end, stride, deltaX, deltaY, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var i = 0;
  var j, k;
  for (j = offset; j < end; j += stride) {
    dest[i++] = flatCoordinates[j] + deltaX;
    dest[i++] = flatCoordinates[j + 1] + deltaY;
    for (k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (opt_dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
};
goog.provide("ol.transform");
goog.require("ol.asserts");
ol.transform.tmp_ = new Array(6);
ol.transform.create = function() {
  return [1, 0, 0, 1, 0, 0];
};
ol.transform.reset = function(transform) {
  return ol.transform.set(transform, 1, 0, 0, 1, 0, 0);
};
ol.transform.multiply = function(transform1, transform2) {
  var a1 = transform1[0];
  var b1 = transform1[1];
  var c1 = transform1[2];
  var d1 = transform1[3];
  var e1 = transform1[4];
  var f1 = transform1[5];
  var a2 = transform2[0];
  var b2 = transform2[1];
  var c2 = transform2[2];
  var d2 = transform2[3];
  var e2 = transform2[4];
  var f2 = transform2[5];
  transform1[0] = a1 * a2 + c1 * b2;
  transform1[1] = b1 * a2 + d1 * b2;
  transform1[2] = a1 * c2 + c1 * d2;
  transform1[3] = b1 * c2 + d1 * d2;
  transform1[4] = a1 * e2 + c1 * f2 + e1;
  transform1[5] = b1 * e2 + d1 * f2 + f1;
  return transform1;
};
ol.transform.set = function(transform, a, b, c, d, e, f) {
  transform[0] = a;
  transform[1] = b;
  transform[2] = c;
  transform[3] = d;
  transform[4] = e;
  transform[5] = f;
  return transform;
};
ol.transform.setFromArray = function(transform1, transform2) {
  transform1[0] = transform2[0];
  transform1[1] = transform2[1];
  transform1[2] = transform2[2];
  transform1[3] = transform2[3];
  transform1[4] = transform2[4];
  transform1[5] = transform2[5];
  return transform1;
};
ol.transform.apply = function(transform, coordinate) {
  var x = coordinate[0], y = coordinate[1];
  coordinate[0] = transform[0] * x + transform[2] * y + transform[4];
  coordinate[1] = transform[1] * x + transform[3] * y + transform[5];
  return coordinate;
};
ol.transform.rotate = function(transform, angle) {
  var cos = Math.cos(angle);
  var sin = Math.sin(angle);
  return ol.transform.multiply(transform, ol.transform.set(ol.transform.tmp_, cos, sin, -sin, cos, 0, 0));
};
ol.transform.scale = function(transform, x, y) {
  return ol.transform.multiply(transform, ol.transform.set(ol.transform.tmp_, x, 0, 0, y, 0, 0));
};
ol.transform.translate = function(transform, dx, dy) {
  return ol.transform.multiply(transform, ol.transform.set(ol.transform.tmp_, 1, 0, 0, 1, dx, dy));
};
ol.transform.compose = function(transform, dx1, dy1, sx, sy, angle, dx2, dy2) {
  var sin = Math.sin(angle);
  var cos = Math.cos(angle);
  transform[0] = sx * cos;
  transform[1] = sy * sin;
  transform[2] = -sx * sin;
  transform[3] = sy * cos;
  transform[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;
  transform[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;
  return transform;
};
ol.transform.invert = function(transform) {
  var det = ol.transform.determinant(transform);
  ol.asserts.assert(det !== 0, 32);
  var a = transform[0];
  var b = transform[1];
  var c = transform[2];
  var d = transform[3];
  var e = transform[4];
  var f = transform[5];
  transform[0] = d / det;
  transform[1] = -b / det;
  transform[2] = -c / det;
  transform[3] = a / det;
  transform[4] = (c * f - d * e) / det;
  transform[5] = -(a * f - b * e) / det;
  return transform;
};
ol.transform.determinant = function(mat) {
  return mat[0] * mat[3] - mat[1] * mat[2];
};
goog.provide("ol.geom.Geometry");
goog.require("ol");
goog.require("ol.Object");
goog.require("ol.extent");
goog.require("ol.functions");
goog.require("ol.geom.flat.transform");
goog.require("ol.proj");
goog.require("ol.proj.Units");
goog.require("ol.transform");
ol.geom.Geometry = function() {
  ol.Object.call(this);
  this.extent_ = ol.extent.createEmpty();
  this.extentRevision_ = -1;
  this.simplifiedGeometryCache = {};
  this.simplifiedGeometryMaxMinSquaredTolerance = 0;
  this.simplifiedGeometryRevision = 0;
  this.tmpTransform_ = ol.transform.create();
};
ol.inherits(ol.geom.Geometry, ol.Object);
ol.geom.Geometry.prototype.clone = function() {
};
ol.geom.Geometry.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {
};
ol.geom.Geometry.prototype.getClosestPoint = function(point, opt_closestPoint) {
  var closestPoint = opt_closestPoint ? opt_closestPoint : [NaN, NaN];
  this.closestPointXY(point[0], point[1], closestPoint, Infinity);
  return closestPoint;
};
ol.geom.Geometry.prototype.intersectsCoordinate = function(coordinate) {
  return this.containsXY(coordinate[0], coordinate[1]);
};
ol.geom.Geometry.prototype.computeExtent = function(extent) {
};
ol.geom.Geometry.prototype.containsXY = ol.functions.FALSE;
ol.geom.Geometry.prototype.getExtent = function(opt_extent) {
  if (this.extentRevision_ != this.getRevision()) {
    this.extent_ = this.computeExtent(this.extent_);
    this.extentRevision_ = this.getRevision();
  }
  return ol.extent.returnOrUpdate(this.extent_, opt_extent);
};
ol.geom.Geometry.prototype.rotate = function(angle, anchor) {
};
ol.geom.Geometry.prototype.scale = function(sx, opt_sy, opt_anchor) {
};
ol.geom.Geometry.prototype.simplify = function(tolerance) {
  return this.getSimplifiedGeometry(tolerance * tolerance);
};
ol.geom.Geometry.prototype.getSimplifiedGeometry = function(squaredTolerance) {
};
ol.geom.Geometry.prototype.getType = function() {
};
ol.geom.Geometry.prototype.applyTransform = function(transformFn) {
};
ol.geom.Geometry.prototype.intersectsExtent = function(extent) {
};
ol.geom.Geometry.prototype.translate = function(deltaX, deltaY) {
};
ol.geom.Geometry.prototype.transform = function(source, destination) {
  var tmpTransform = this.tmpTransform_;
  source = ol.proj.get(source);
  var transformFn = source.getUnits() == ol.proj.Units.TILE_PIXELS ? function(inCoordinates, outCoordinates, stride) {
    var pixelExtent = source.getExtent();
    var projectedExtent = source.getWorldExtent();
    var scale = ol.extent.getHeight(projectedExtent) / ol.extent.getHeight(pixelExtent);
    ol.transform.compose(tmpTransform, projectedExtent[0], projectedExtent[3], scale, -scale, 0, 0, 0);
    ol.geom.flat.transform.transform2D(inCoordinates, 0, inCoordinates.length, stride, tmpTransform, outCoordinates);
    return ol.proj.getTransform(source, destination)(inCoordinates, outCoordinates, stride);
  } : ol.proj.getTransform(source, destination);
  this.applyTransform(transformFn);
  return this;
};
goog.provide("ol.geom.SimpleGeometry");
goog.require("ol");
goog.require("ol.functions");
goog.require("ol.extent");
goog.require("ol.geom.Geometry");
goog.require("ol.geom.GeometryLayout");
goog.require("ol.geom.flat.transform");
goog.require("ol.obj");
ol.geom.SimpleGeometry = function() {
  ol.geom.Geometry.call(this);
  this.layout = ol.geom.GeometryLayout.XY;
  this.stride = 2;
  this.flatCoordinates = null;
};
ol.inherits(ol.geom.SimpleGeometry, ol.geom.Geometry);
ol.geom.SimpleGeometry.getLayoutForStride_ = function(stride) {
  var layout;
  if (stride == 2) {
    layout = ol.geom.GeometryLayout.XY;
  } else {
    if (stride == 3) {
      layout = ol.geom.GeometryLayout.XYZ;
    } else {
      if (stride == 4) {
        layout = ol.geom.GeometryLayout.XYZM;
      }
    }
  }
  return layout;
};
ol.geom.SimpleGeometry.getStrideForLayout = function(layout) {
  var stride;
  if (layout == ol.geom.GeometryLayout.XY) {
    stride = 2;
  } else {
    if (layout == ol.geom.GeometryLayout.XYZ || layout == ol.geom.GeometryLayout.XYM) {
      stride = 3;
    } else {
      if (layout == ol.geom.GeometryLayout.XYZM) {
        stride = 4;
      }
    }
  }
  return stride;
};
ol.geom.SimpleGeometry.prototype.containsXY = ol.functions.FALSE;
ol.geom.SimpleGeometry.prototype.computeExtent = function(extent) {
  return ol.extent.createOrUpdateFromFlatCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);
};
ol.geom.SimpleGeometry.prototype.getCoordinates = function() {
};
ol.geom.SimpleGeometry.prototype.getFirstCoordinate = function() {
  return this.flatCoordinates.slice(0, this.stride);
};
ol.geom.SimpleGeometry.prototype.getFlatCoordinates = function() {
  return this.flatCoordinates;
};
ol.geom.SimpleGeometry.prototype.getLastCoordinate = function() {
  return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride);
};
ol.geom.SimpleGeometry.prototype.getLayout = function() {
  return this.layout;
};
ol.geom.SimpleGeometry.prototype.getSimplifiedGeometry = function(squaredTolerance) {
  if (this.simplifiedGeometryRevision != this.getRevision()) {
    ol.obj.clear(this.simplifiedGeometryCache);
    this.simplifiedGeometryMaxMinSquaredTolerance = 0;
    this.simplifiedGeometryRevision = this.getRevision();
  }
  if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance) {
    return this;
  }
  var key = squaredTolerance.toString();
  if (this.simplifiedGeometryCache.hasOwnProperty(key)) {
    return this.simplifiedGeometryCache[key];
  } else {
    var simplifiedGeometry = this.getSimplifiedGeometryInternal(squaredTolerance);
    var simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();
    if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {
      this.simplifiedGeometryCache[key] = simplifiedGeometry;
      return simplifiedGeometry;
    } else {
      this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
      return this;
    }
  }
};
ol.geom.SimpleGeometry.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {
  return this;
};
ol.geom.SimpleGeometry.prototype.getStride = function() {
  return this.stride;
};
ol.geom.SimpleGeometry.prototype.setFlatCoordinatesInternal = function(layout, flatCoordinates) {
  this.stride = ol.geom.SimpleGeometry.getStrideForLayout(layout);
  this.layout = layout;
  this.flatCoordinates = flatCoordinates;
};
ol.geom.SimpleGeometry.prototype.setCoordinates = function(coordinates, opt_layout) {
};
ol.geom.SimpleGeometry.prototype.setLayout = function(layout, coordinates, nesting) {
  var stride;
  if (layout) {
    stride = ol.geom.SimpleGeometry.getStrideForLayout(layout);
  } else {
    var i;
    for (i = 0; i < nesting; ++i) {
      if (coordinates.length === 0) {
        this.layout = ol.geom.GeometryLayout.XY;
        this.stride = 2;
        return;
      } else {
        coordinates = coordinates[0];
      }
    }
    stride = coordinates.length;
    layout = ol.geom.SimpleGeometry.getLayoutForStride_(stride);
  }
  this.layout = layout;
  this.stride = stride;
};
ol.geom.SimpleGeometry.prototype.applyTransform = function(transformFn) {
  if (this.flatCoordinates) {
    transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);
    this.changed();
  }
};
ol.geom.SimpleGeometry.prototype.rotate = function(angle, anchor) {
  var flatCoordinates = this.getFlatCoordinates();
  if (flatCoordinates) {
    var stride = this.getStride();
    ol.geom.flat.transform.rotate(flatCoordinates, 0, flatCoordinates.length, stride, angle, anchor, flatCoordinates);
    this.changed();
  }
};
ol.geom.SimpleGeometry.prototype.scale = function(sx, opt_sy, opt_anchor) {
  var sy = opt_sy;
  if (sy === undefined) {
    sy = sx;
  }
  var anchor = opt_anchor;
  if (!anchor) {
    anchor = ol.extent.getCenter(this.getExtent());
  }
  var flatCoordinates = this.getFlatCoordinates();
  if (flatCoordinates) {
    var stride = this.getStride();
    ol.geom.flat.transform.scale(flatCoordinates, 0, flatCoordinates.length, stride, sx, sy, anchor, flatCoordinates);
    this.changed();
  }
};
ol.geom.SimpleGeometry.prototype.translate = function(deltaX, deltaY) {
  var flatCoordinates = this.getFlatCoordinates();
  if (flatCoordinates) {
    var stride = this.getStride();
    ol.geom.flat.transform.translate(flatCoordinates, 0, flatCoordinates.length, stride, deltaX, deltaY, flatCoordinates);
    this.changed();
  }
};
ol.geom.SimpleGeometry.transform2D = function(simpleGeometry, transform, opt_dest) {
  var flatCoordinates = simpleGeometry.getFlatCoordinates();
  if (!flatCoordinates) {
    return null;
  } else {
    var stride = simpleGeometry.getStride();
    return ol.geom.flat.transform.transform2D(flatCoordinates, 0, flatCoordinates.length, stride, transform, opt_dest);
  }
};
goog.provide("ol.geom.flat.deflate");
ol.geom.flat.deflate.coordinate = function(flatCoordinates, offset, coordinate, stride) {
  var i, ii;
  for (i = 0, ii = coordinate.length; i < ii; ++i) {
    flatCoordinates[offset++] = coordinate[i];
  }
  return offset;
};
ol.geom.flat.deflate.coordinates = function(flatCoordinates, offset, coordinates, stride) {
  var i, ii;
  for (i = 0, ii = coordinates.length; i < ii; ++i) {
    var coordinate = coordinates[i];
    var j;
    for (j = 0; j < stride; ++j) {
      flatCoordinates[offset++] = coordinate[j];
    }
  }
  return offset;
};
ol.geom.flat.deflate.coordinatess = function(flatCoordinates, offset, coordinatess, stride, opt_ends) {
  var ends = opt_ends ? opt_ends : [];
  var i = 0;
  var j, jj;
  for (j = 0, jj = coordinatess.length; j < jj; ++j) {
    var end = ol.geom.flat.deflate.coordinates(flatCoordinates, offset, coordinatess[j], stride);
    ends[i++] = end;
    offset = end;
  }
  ends.length = i;
  return ends;
};
ol.geom.flat.deflate.coordinatesss = function(flatCoordinates, offset, coordinatesss, stride, opt_endss) {
  var endss = opt_endss ? opt_endss : [];
  var i = 0;
  var j, jj;
  for (j = 0, jj = coordinatesss.length; j < jj; ++j) {
    var ends = ol.geom.flat.deflate.coordinatess(flatCoordinates, offset, coordinatesss[j], stride, endss[i]);
    endss[i++] = ends;
    offset = ends[ends.length - 1];
  }
  endss.length = i;
  return endss;
};
goog.provide("ol.geom.Point");
goog.require("ol");
goog.require("ol.extent");
goog.require("ol.geom.GeometryLayout");
goog.require("ol.geom.GeometryType");
goog.require("ol.geom.SimpleGeometry");
goog.require("ol.geom.flat.deflate");
goog.require("ol.math");
ol.geom.Point = function(coordinates, opt_layout) {
  ol.geom.SimpleGeometry.call(this);
  this.setCoordinates(coordinates, opt_layout);
};
ol.inherits(ol.geom.Point, ol.geom.SimpleGeometry);
ol.geom.Point.prototype.clone = function() {
  var point = new ol.geom.Point(null);
  point.setFlatCoordinates(this.layout, this.flatCoordinates.slice());
  return point;
};
ol.geom.Point.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {
  var flatCoordinates = this.flatCoordinates;
  var squaredDistance = ol.math.squaredDistance(x, y, flatCoordinates[0], flatCoordinates[1]);
  if (squaredDistance < minSquaredDistance) {
    var stride = this.stride;
    var i;
    for (i = 0; i < stride; ++i) {
      closestPoint[i] = flatCoordinates[i];
    }
    closestPoint.length = stride;
    return squaredDistance;
  } else {
    return minSquaredDistance;
  }
};
ol.geom.Point.prototype.getCoordinates = function() {
  return !this.flatCoordinates ? [] : this.flatCoordinates.slice();
};
ol.geom.Point.prototype.computeExtent = function(extent) {
  return ol.extent.createOrUpdateFromCoordinate(this.flatCoordinates, extent);
};
ol.geom.Point.prototype.getType = function() {
  return ol.geom.GeometryType.POINT;
};
ol.geom.Point.prototype.intersectsExtent = function(extent) {
  return ol.extent.containsXY(extent, this.flatCoordinates[0], this.flatCoordinates[1]);
};
ol.geom.Point.prototype.setCoordinates = function(coordinates, opt_layout) {
  if (!coordinates) {
    this.setFlatCoordinates(ol.geom.GeometryLayout.XY, null);
  } else {
    this.setLayout(opt_layout, coordinates, 0);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = ol.geom.flat.deflate.coordinate(this.flatCoordinates, 0, coordinates, this.stride);
    this.changed();
  }
};
ol.geom.Point.prototype.setFlatCoordinates = function(layout, flatCoordinates) {
  this.setFlatCoordinatesInternal(layout, flatCoordinates);
  this.changed();
};
goog.provide("olcs.RasterSynchronizer");
goog.require("ol.layer.Group");
goog.require("goog.asserts");
goog.require("ol.array");
goog.require("ol");
goog.require("olcs.AbstractSynchronizer");
goog.require("olcs.core");
olcs.RasterSynchronizer = function(map, scene) {
  this.cesiumLayers_ = scene.imageryLayers;
  this.ourLayers_ = new Cesium.ImageryLayerCollection;
  olcs.AbstractSynchronizer.call(this, map, scene);
};
ol.inherits(olcs.RasterSynchronizer, olcs.AbstractSynchronizer);
olcs.RasterSynchronizer.prototype.addCesiumObject = function(object) {
  this.cesiumLayers_.add(object);
  this.ourLayers_.add(object);
};
olcs.RasterSynchronizer.prototype.destroyCesiumObject = function(object) {
  object.destroy();
};
olcs.RasterSynchronizer.prototype.removeSingleCesiumObject = function(object, destroy) {
  this.cesiumLayers_.remove(object, destroy);
  this.ourLayers_.remove(object, false);
};
olcs.RasterSynchronizer.prototype.removeAllCesiumObjects = function(destroy) {
  for (var i = 0; i < this.ourLayers_.length; ++i) {
    this.cesiumLayers_.remove(this.ourLayers_.get(i), destroy);
  }
  this.ourLayers_.removeAll(false);
};
olcs.RasterSynchronizer.prototype.convertLayerToCesiumImageries = function(olLayer, viewProj) {
  var result = olcs.core.tileLayerToImageryLayer(olLayer, viewProj);
  return result ? [result] : null;
};
olcs.RasterSynchronizer.prototype.createSingleLayerCounterparts = function(olLayerWithParents) {
  var olLayer = olLayerWithParents.layer;
  var uid = ol.getUid(olLayer).toString();
  var viewProj = this.view.getProjection();
  goog.asserts.assert(viewProj);
  var cesiumObjects = this.convertLayerToCesiumImageries(olLayer, viewProj);
  if (cesiumObjects) {
    var listenKeyArray = [];
    [olLayerWithParents.layer].concat(olLayerWithParents.parents).forEach(function(olLayerItem) {
      listenKeyArray.push(olLayerItem.on(["change:opacity", "change:visible"], function() {
        goog.asserts.assert(cesiumObjects);
        for (var i = 0; i < cesiumObjects.length; ++i) {
          olcs.core.updateCesiumLayerProperties(olLayerWithParents, cesiumObjects[i]);
        }
      }));
    });
    for (var i = 0; i < cesiumObjects.length; ++i) {
      olcs.core.updateCesiumLayerProperties(olLayerWithParents, cesiumObjects[i]);
    }
    listenKeyArray.push(olLayer.on("change:extent", function(e) {
      for (var i$5 = 0; i$5 < cesiumObjects.length; ++i$5) {
        this.cesiumLayers_.remove(cesiumObjects[i$5], true);
        this.ourLayers_.remove(cesiumObjects[i$5], false);
      }
      delete this.layerMap[ol.getUid(olLayer)];
      this.synchronize();
    }, this));
    listenKeyArray.push(olLayer.on("change", function(e) {
      for (var i$6 = 0; i$6 < cesiumObjects.length; ++i$6) {
        var position = this.cesiumLayers_.indexOf(cesiumObjects[i$6]);
        if (position >= 0) {
          this.cesiumLayers_.remove(cesiumObjects[i$6], false);
          this.cesiumLayers_.add(cesiumObjects[i$6], position);
        }
      }
    }, this));
    this.olLayerListenKeys[uid].push.apply(this.olLayerListenKeys[uid], [].concat($jscomp.arrayFromIterable(listenKeyArray)));
  }
  return Array.isArray(cesiumObjects) ? cesiumObjects : null;
};
olcs.RasterSynchronizer.prototype.orderLayers = function() {
  var $jscomp$this = this;
  var layers = [];
  var zIndices = {};
  var queue = [this.mapLayerGroup];
  while (queue.length > 0) {
    var olLayer = queue.splice(0, 1)[0];
    layers.push(olLayer);
    zIndices[ol.getUid(olLayer)] = olLayer.getZIndex();
    if (olLayer instanceof ol.layer.Group) {
      var sublayers = olLayer.getLayers();
      if (sublayers) {
        queue.unshift.apply(queue, [].concat($jscomp.arrayFromIterable(sublayers.getArray())));
      }
    }
  }
  ol.array.stableSort(layers, function(layer1, layer2) {
    return zIndices[ol.getUid(layer1)] - zIndices[ol.getUid(layer2)];
  });
  layers.forEach(function(olLayer) {
    var olLayerId = ol.getUid(olLayer).toString();
    var cesiumObjects = $jscomp$this.layerMap[olLayerId];
    if (cesiumObjects) {
      cesiumObjects.forEach($jscomp$this.raiseToTop, $jscomp$this);
    }
  });
};
olcs.RasterSynchronizer.prototype.raiseToTop = function(counterpart) {
  this.cesiumLayers_.raiseToTop(counterpart);
};
goog.provide("ol.format.FormatType");
ol.format.FormatType = {ARRAY_BUFFER:"arraybuffer", JSON:"json", TEXT:"text", XML:"xml"};
goog.provide("ol.xml");
goog.require("ol.array");
ol.xml.DOCUMENT = document.implementation.createDocument("", "", null);
ol.xml.createElementNS = function(namespaceURI, qualifiedName) {
  return ol.xml.DOCUMENT.createElementNS(namespaceURI, qualifiedName);
};
ol.xml.getAllTextContent = function(node, normalizeWhitespace) {
  return ol.xml.getAllTextContent_(node, normalizeWhitespace, []).join("");
};
ol.xml.getAllTextContent_ = function(node, normalizeWhitespace, accumulator) {
  if (node.nodeType == Node.CDATA_SECTION_NODE || node.nodeType == Node.TEXT_NODE) {
    if (normalizeWhitespace) {
      accumulator.push(String(node.nodeValue).replace(/(\r\n|\r|\n)/g, ""));
    } else {
      accumulator.push(node.nodeValue);
    }
  } else {
    var n;
    for (n = node.firstChild; n; n = n.nextSibling) {
      ol.xml.getAllTextContent_(n, normalizeWhitespace, accumulator);
    }
  }
  return accumulator;
};
ol.xml.isDocument = function(value) {
  return value instanceof Document;
};
ol.xml.isNode = function(value) {
  return value instanceof Node;
};
ol.xml.getAttributeNS = function(node, namespaceURI, name) {
  return node.getAttributeNS(namespaceURI, name) || "";
};
ol.xml.setAttributeNS = function(node, namespaceURI, name, value) {
  node.setAttributeNS(namespaceURI, name, value);
};
ol.xml.parse = function(xml) {
  return (new DOMParser).parseFromString(xml, "application/xml");
};
ol.xml.makeArrayExtender = function(valueReader, opt_this) {
  return function(node, objectStack) {
    var value = valueReader.call(opt_this, node, objectStack);
    if (value !== undefined) {
      var array = objectStack[objectStack.length - 1];
      ol.array.extend(array, value);
    }
  };
};
ol.xml.makeArrayPusher = function(valueReader, opt_this) {
  return function(node, objectStack) {
    var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);
    if (value !== undefined) {
      var array = objectStack[objectStack.length - 1];
      array.push(value);
    }
  };
};
ol.xml.makeReplacer = function(valueReader, opt_this) {
  return function(node, objectStack) {
    var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);
    if (value !== undefined) {
      objectStack[objectStack.length - 1] = value;
    }
  };
};
ol.xml.makeObjectPropertyPusher = function(valueReader, opt_property, opt_this) {
  return function(node, objectStack) {
    var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);
    if (value !== undefined) {
      var object = objectStack[objectStack.length - 1];
      var property = opt_property !== undefined ? opt_property : node.localName;
      var array;
      if (property in object) {
        array = object[property];
      } else {
        array = object[property] = [];
      }
      array.push(value);
    }
  };
};
ol.xml.makeObjectPropertySetter = function(valueReader, opt_property, opt_this) {
  return function(node, objectStack) {
    var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);
    if (value !== undefined) {
      var object = objectStack[objectStack.length - 1];
      var property = opt_property !== undefined ? opt_property : node.localName;
      object[property] = value;
    }
  };
};
ol.xml.makeChildAppender = function(nodeWriter, opt_this) {
  return function(node, value, objectStack) {
    nodeWriter.call(opt_this !== undefined ? opt_this : this, node, value, objectStack);
    var parent = objectStack[objectStack.length - 1];
    var parentNode = parent.node;
    parentNode.appendChild(node);
  };
};
ol.xml.makeArraySerializer = function(nodeWriter, opt_this) {
  var serializersNS, nodeFactory;
  return function(node, value, objectStack) {
    if (serializersNS === undefined) {
      serializersNS = {};
      var serializers = {};
      serializers[node.localName] = nodeWriter;
      serializersNS[node.namespaceURI] = serializers;
      nodeFactory = ol.xml.makeSimpleNodeFactory(node.localName);
    }
    ol.xml.serialize(serializersNS, nodeFactory, value, objectStack);
  };
};
ol.xml.makeSimpleNodeFactory = function(opt_nodeName, opt_namespaceURI) {
  var fixedNodeName = opt_nodeName;
  return function(value, objectStack, opt_nodeName) {
    var context = objectStack[objectStack.length - 1];
    var node = context.node;
    var nodeName = fixedNodeName;
    if (nodeName === undefined) {
      nodeName = opt_nodeName;
    }
    var namespaceURI = opt_namespaceURI;
    if (opt_namespaceURI === undefined) {
      namespaceURI = node.namespaceURI;
    }
    return ol.xml.createElementNS(namespaceURI, nodeName);
  };
};
ol.xml.OBJECT_PROPERTY_NODE_FACTORY = ol.xml.makeSimpleNodeFactory();
ol.xml.makeSequence = function(object, orderedKeys) {
  var length = orderedKeys.length;
  var sequence = new Array(length);
  for (var i = 0; i < length; ++i) {
    sequence[i] = object[orderedKeys[i]];
  }
  return sequence;
};
ol.xml.makeStructureNS = function(namespaceURIs, structure, opt_structureNS) {
  var structureNS = opt_structureNS !== undefined ? opt_structureNS : {};
  var i, ii;
  for (i = 0, ii = namespaceURIs.length; i < ii; ++i) {
    structureNS[namespaceURIs[i]] = structure;
  }
  return structureNS;
};
ol.xml.parseNode = function(parsersNS, node, objectStack, opt_this) {
  var n;
  for (n = node.firstElementChild; n; n = n.nextElementSibling) {
    var parsers = parsersNS[n.namespaceURI];
    if (parsers !== undefined) {
      var parser = parsers[n.localName];
      if (parser !== undefined) {
        parser.call(opt_this, n, objectStack);
      }
    }
  }
};
ol.xml.pushParseAndPop = function(object, parsersNS, node, objectStack, opt_this) {
  objectStack.push(object);
  ol.xml.parseNode(parsersNS, node, objectStack, opt_this);
  return objectStack.pop();
};
ol.xml.serialize = function(serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this) {
  var length = (opt_keys !== undefined ? opt_keys : values).length;
  var value, node;
  for (var i = 0; i < length; ++i) {
    value = values[i];
    if (value !== undefined) {
      node = nodeFactory.call(opt_this, value, objectStack, opt_keys !== undefined ? opt_keys[i] : undefined);
      if (node !== undefined) {
        serializersNS[node.namespaceURI][node.localName].call(opt_this, node, value, objectStack);
      }
    }
  }
};
ol.xml.pushSerializeAndPop = function(object, serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this) {
  objectStack.push(object);
  ol.xml.serialize(serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this);
  return objectStack.pop();
};
goog.provide("ol.featureloader");
goog.require("ol");
goog.require("ol.format.FormatType");
goog.require("ol.xml");
ol.featureloader.loadFeaturesXhr = function(url, format, success, failure) {
  return function(extent, resolution, projection) {
    var xhr = new XMLHttpRequest;
    xhr.open("GET", typeof url === "function" ? url(extent, resolution, projection) : url, true);
    if (format.getType() == ol.format.FormatType.ARRAY_BUFFER) {
      xhr.responseType = "arraybuffer";
    }
    xhr.onload = function(event) {
      if (!xhr.status || xhr.status >= 200 && xhr.status < 300) {
        var type = format.getType();
        var source;
        if (type == ol.format.FormatType.JSON || type == ol.format.FormatType.TEXT) {
          source = xhr.responseText;
        } else {
          if (type == ol.format.FormatType.XML) {
            source = xhr.responseXML;
            if (!source) {
              source = ol.xml.parse(xhr.responseText);
            }
          } else {
            if (type == ol.format.FormatType.ARRAY_BUFFER) {
              source = xhr.response;
            }
          }
        }
        if (source) {
          success.call(this, format.readFeatures(source, {featureProjection:projection}), format.readProjection(source), format.getLastExtent());
        } else {
          failure.call(this);
        }
      } else {
        failure.call(this);
      }
    }.bind(this);
    xhr.onerror = function() {
      failure.call(this);
    }.bind(this);
    xhr.send();
  };
};
ol.featureloader.xhr = function(url, format) {
  return ol.featureloader.loadFeaturesXhr(url, format, function(features, dataProjection) {
    this.addFeatures(features);
  }, ol.nullFunction);
};
goog.provide("ol.loadingstrategy");
ol.loadingstrategy.all = function(extent, resolution) {
  return [[-Infinity, -Infinity, Infinity, Infinity]];
};
ol.loadingstrategy.bbox = function(extent, resolution) {
  return [extent];
};
ol.loadingstrategy.tile = function(tileGrid) {
  return function(extent, resolution) {
    var z = tileGrid.getZForResolution(resolution);
    var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
    var extents = [];
    var tileCoord = [z, 0, 0];
    for (tileCoord[1] = tileRange.minX; tileCoord[1] <= tileRange.maxX; ++tileCoord[1]) {
      for (tileCoord[2] = tileRange.minY; tileCoord[2] <= tileRange.maxY; ++tileCoord[2]) {
        extents.push(tileGrid.getTileCoordExtent(tileCoord));
      }
    }
    return extents;
  };
};
goog.provide("ol.source.VectorEventType");
ol.source.VectorEventType = {ADDFEATURE:"addfeature", CHANGEFEATURE:"changefeature", CLEAR:"clear", REMOVEFEATURE:"removefeature"};
goog.provide("ol.ext.rbush");
ol.ext.rbush = function() {
};
(function() {
  (function(exports) {
    var commonjsGlobal = typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    function createCommonjsModule(fn, module) {
      return module = {exports:{}}, fn(module, module.exports), module.exports;
    }
    var quickselect = createCommonjsModule(function(module, exports) {
      (function(global, factory) {
        module.exports = factory();
      })(commonjsGlobal, function() {
        function quickselect(arr, k, left, right, compare) {
          quickselectStep(arr, k, left || 0, right || arr.length - 1, compare || defaultCompare);
        }
        function quickselectStep(arr, k, left, right, compare) {
          while (right > left) {
            if (right - left > 600) {
              var n = right - left + 1;
              var m = k - left + 1;
              var z = Math.log(n);
              var s = 0.5 * Math.exp(2 * z / 3);
              var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
              var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
              var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
              quickselectStep(arr, k, newLeft, newRight, compare);
            }
            var t = arr[k];
            var i = left;
            var j = right;
            swap(arr, left, k);
            if (compare(arr[right], t) > 0) {
              swap(arr, left, right);
            }
            while (i < j) {
              swap(arr, i, j);
              i++;
              j--;
              while (compare(arr[i], t) < 0) {
                i++;
              }
              while (compare(arr[j], t) > 0) {
                j--;
              }
            }
            if (compare(arr[left], t) === 0) {
              swap(arr, left, j);
            } else {
              j++;
              swap(arr, j, right);
            }
            if (j <= k) {
              left = j + 1;
            }
            if (k <= j) {
              right = j - 1;
            }
          }
        }
        function swap(arr, i, j) {
          var tmp = arr[i];
          arr[i] = arr[j];
          arr[j] = tmp;
        }
        function defaultCompare(a, b) {
          return a < b ? -1 : a > b ? 1 : 0;
        }
        return quickselect;
      });
    });
    var rbush_1 = rbush;
    function rbush(maxEntries, format) {
      if (!(this instanceof rbush)) {
        return new rbush(maxEntries, format);
      }
      this._maxEntries = Math.max(4, maxEntries || 9);
      this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
      if (format) {
        this._initFormat(format);
      }
      this.clear();
    }
    rbush.prototype = {all:function() {
      return this._all(this.data, []);
    }, search:function(bbox) {
      var node = this.data, result = [], toBBox = this.toBBox;
      if (!intersects(bbox, node)) {
        return result;
      }
      var nodesToSearch = [], i, len, child, childBBox;
      while (node) {
        for (i = 0, len = node.children.length; i < len; i++) {
          child = node.children[i];
          childBBox = node.leaf ? toBBox(child) : child;
          if (intersects(bbox, childBBox)) {
            if (node.leaf) {
              result.push(child);
            } else {
              if (contains(bbox, childBBox)) {
                this._all(child, result);
              } else {
                nodesToSearch.push(child);
              }
            }
          }
        }
        node = nodesToSearch.pop();
      }
      return result;
    }, collides:function(bbox) {
      var node = this.data, toBBox = this.toBBox;
      if (!intersects(bbox, node)) {
        return false;
      }
      var nodesToSearch = [], i, len, child, childBBox;
      while (node) {
        for (i = 0, len = node.children.length; i < len; i++) {
          child = node.children[i];
          childBBox = node.leaf ? toBBox(child) : child;
          if (intersects(bbox, childBBox)) {
            if (node.leaf || contains(bbox, childBBox)) {
              return true;
            }
            nodesToSearch.push(child);
          }
        }
        node = nodesToSearch.pop();
      }
      return false;
    }, load:function(data) {
      if (!(data && data.length)) {
        return this;
      }
      if (data.length < this._minEntries) {
        for (var i = 0, len = data.length; i < len; i++) {
          this.insert(data[i]);
        }
        return this;
      }
      var node = this._build(data.slice(), 0, data.length - 1, 0);
      if (!this.data.children.length) {
        this.data = node;
      } else {
        if (this.data.height === node.height) {
          this._splitRoot(this.data, node);
        } else {
          if (this.data.height < node.height) {
            var tmpNode = this.data;
            this.data = node;
            node = tmpNode;
          }
          this._insert(node, this.data.height - node.height - 1, true);
        }
      }
      return this;
    }, insert:function(item) {
      if (item) {
        this._insert(item, this.data.height - 1);
      }
      return this;
    }, clear:function() {
      this.data = createNode([]);
      return this;
    }, remove:function(item, equalsFn) {
      if (!item) {
        return this;
      }
      var node = this.data, bbox = this.toBBox(item), path = [], indexes = [], i, parent, index, goingUp;
      while (node || path.length) {
        if (!node) {
          node = path.pop();
          parent = path[path.length - 1];
          i = indexes.pop();
          goingUp = true;
        }
        if (node.leaf) {
          index = findItem(item, node.children, equalsFn);
          if (index !== -1) {
            node.children.splice(index, 1);
            path.push(node);
            this._condense(path);
            return this;
          }
        }
        if (!goingUp && !node.leaf && contains(node, bbox)) {
          path.push(node);
          indexes.push(i);
          i = 0;
          parent = node;
          node = node.children[0];
        } else {
          if (parent) {
            i++;
            node = parent.children[i];
            goingUp = false;
          } else {
            node = null;
          }
        }
      }
      return this;
    }, toBBox:function(item) {
      return item;
    }, compareMinX:compareNodeMinX, compareMinY:compareNodeMinY, toJSON:function() {
      return this.data;
    }, fromJSON:function(data) {
      this.data = data;
      return this;
    }, _all:function(node, result) {
      var nodesToSearch = [];
      while (node) {
        if (node.leaf) {
          result.push.apply(result, node.children);
        } else {
          nodesToSearch.push.apply(nodesToSearch, node.children);
        }
        node = nodesToSearch.pop();
      }
      return result;
    }, _build:function(items, left, right, height) {
      var N = right - left + 1, M = this._maxEntries, node;
      if (N <= M) {
        node = createNode(items.slice(left, right + 1));
        calcBBox(node, this.toBBox);
        return node;
      }
      if (!height) {
        height = Math.ceil(Math.log(N) / Math.log(M));
        M = Math.ceil(N / Math.pow(M, height - 1));
      }
      node = createNode([]);
      node.leaf = false;
      node.height = height;
      var N2 = Math.ceil(N / M), N1 = N2 * Math.ceil(Math.sqrt(M)), i, j, right2, right3;
      multiSelect(items, left, right, N1, this.compareMinX);
      for (i = left; i <= right; i += N1) {
        right2 = Math.min(i + N1 - 1, right);
        multiSelect(items, i, right2, N2, this.compareMinY);
        for (j = i; j <= right2; j += N2) {
          right3 = Math.min(j + N2 - 1, right2);
          node.children.push(this._build(items, j, right3, height - 1));
        }
      }
      calcBBox(node, this.toBBox);
      return node;
    }, _chooseSubtree:function(bbox, node, level, path) {
      var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;
      while (true) {
        path.push(node);
        if (node.leaf || path.length - 1 === level) {
          break;
        }
        minArea = minEnlargement = Infinity;
        for (i = 0, len = node.children.length; i < len; i++) {
          child = node.children[i];
          area = bboxArea(child);
          enlargement = enlargedArea(bbox, child) - area;
          if (enlargement < minEnlargement) {
            minEnlargement = enlargement;
            minArea = area < minArea ? area : minArea;
            targetNode = child;
          } else {
            if (enlargement === minEnlargement) {
              if (area < minArea) {
                minArea = area;
                targetNode = child;
              }
            }
          }
        }
        node = targetNode || node.children[0];
      }
      return node;
    }, _insert:function(item, level, isNode) {
      var toBBox = this.toBBox, bbox = isNode ? item : toBBox(item), insertPath = [];
      var node = this._chooseSubtree(bbox, this.data, level, insertPath);
      node.children.push(item);
      extend(node, bbox);
      while (level >= 0) {
        if (insertPath[level].children.length > this._maxEntries) {
          this._split(insertPath, level);
          level--;
        } else {
          break;
        }
      }
      this._adjustParentBBoxes(bbox, insertPath, level);
    }, _split:function(insertPath, level) {
      var node = insertPath[level], M = node.children.length, m = this._minEntries;
      this._chooseSplitAxis(node, m, M);
      var splitIndex = this._chooseSplitIndex(node, m, M);
      var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
      newNode.height = node.height;
      newNode.leaf = node.leaf;
      calcBBox(node, this.toBBox);
      calcBBox(newNode, this.toBBox);
      if (level) {
        insertPath[level - 1].children.push(newNode);
      } else {
        this._splitRoot(node, newNode);
      }
    }, _splitRoot:function(node, newNode) {
      this.data = createNode([node, newNode]);
      this.data.height = node.height + 1;
      this.data.leaf = false;
      calcBBox(this.data, this.toBBox);
    }, _chooseSplitIndex:function(node, m, M) {
      var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;
      minOverlap = minArea = Infinity;
      for (i = m; i <= M - m; i++) {
        bbox1 = distBBox(node, 0, i, this.toBBox);
        bbox2 = distBBox(node, i, M, this.toBBox);
        overlap = intersectionArea(bbox1, bbox2);
        area = bboxArea(bbox1) + bboxArea(bbox2);
        if (overlap < minOverlap) {
          minOverlap = overlap;
          index = i;
          minArea = area < minArea ? area : minArea;
        } else {
          if (overlap === minOverlap) {
            if (area < minArea) {
              minArea = area;
              index = i;
            }
          }
        }
      }
      return index;
    }, _chooseSplitAxis:function(node, m, M) {
      var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX, compareMinY = node.leaf ? this.compareMinY : compareNodeMinY, xMargin = this._allDistMargin(node, m, M, compareMinX), yMargin = this._allDistMargin(node, m, M, compareMinY);
      if (xMargin < yMargin) {
        node.children.sort(compareMinX);
      }
    }, _allDistMargin:function(node, m, M, compare) {
      node.children.sort(compare);
      var toBBox = this.toBBox, leftBBox = distBBox(node, 0, m, toBBox), rightBBox = distBBox(node, M - m, M, toBBox), margin = bboxMargin(leftBBox) + bboxMargin(rightBBox), i, child;
      for (i = m; i < M - m; i++) {
        child = node.children[i];
        extend(leftBBox, node.leaf ? toBBox(child) : child);
        margin += bboxMargin(leftBBox);
      }
      for (i = M - m - 1; i >= m; i--) {
        child = node.children[i];
        extend(rightBBox, node.leaf ? toBBox(child) : child);
        margin += bboxMargin(rightBBox);
      }
      return margin;
    }, _adjustParentBBoxes:function(bbox, path, level) {
      for (var i = level; i >= 0; i--) {
        extend(path[i], bbox);
      }
    }, _condense:function(path) {
      for (var i = path.length - 1, siblings; i >= 0; i--) {
        if (path[i].children.length === 0) {
          if (i > 0) {
            siblings = path[i - 1].children;
            siblings.splice(siblings.indexOf(path[i]), 1);
          } else {
            this.clear();
          }
        } else {
          calcBBox(path[i], this.toBBox);
        }
      }
    }, _initFormat:function(format) {
      var compareArr = ["return a", " - b", ";"];
      this.compareMinX = new Function("a", "b", compareArr.join(format[0]));
      this.compareMinY = new Function("a", "b", compareArr.join(format[1]));
      this.toBBox = new Function("a", "return {minX: a" + format[0] + ", minY: a" + format[1] + ", maxX: a" + format[2] + ", maxY: a" + format[3] + "};");
    }};
    function findItem(item, items, equalsFn) {
      if (!equalsFn) {
        return items.indexOf(item);
      }
      for (var i = 0; i < items.length; i++) {
        if (equalsFn(item, items[i])) {
          return i;
        }
      }
      return -1;
    }
    function calcBBox(node, toBBox) {
      distBBox(node, 0, node.children.length, toBBox, node);
    }
    function distBBox(node, k, p, toBBox, destNode) {
      if (!destNode) {
        destNode = createNode(null);
      }
      destNode.minX = Infinity;
      destNode.minY = Infinity;
      destNode.maxX = -Infinity;
      destNode.maxY = -Infinity;
      for (var i = k, child; i < p; i++) {
        child = node.children[i];
        extend(destNode, node.leaf ? toBBox(child) : child);
      }
      return destNode;
    }
    function extend(a, b) {
      a.minX = Math.min(a.minX, b.minX);
      a.minY = Math.min(a.minY, b.minY);
      a.maxX = Math.max(a.maxX, b.maxX);
      a.maxY = Math.max(a.maxY, b.maxY);
      return a;
    }
    function compareNodeMinX(a, b) {
      return a.minX - b.minX;
    }
    function compareNodeMinY(a, b) {
      return a.minY - b.minY;
    }
    function bboxArea(a) {
      return (a.maxX - a.minX) * (a.maxY - a.minY);
    }
    function bboxMargin(a) {
      return a.maxX - a.minX + (a.maxY - a.minY);
    }
    function enlargedArea(a, b) {
      return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
    }
    function intersectionArea(a, b) {
      var minX = Math.max(a.minX, b.minX), minY = Math.max(a.minY, b.minY), maxX = Math.min(a.maxX, b.maxX), maxY = Math.min(a.maxY, b.maxY);
      return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
    }
    function contains(a, b) {
      return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;
    }
    function intersects(a, b) {
      return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;
    }
    function createNode(children) {
      return {children:children, height:1, leaf:true, minX:Infinity, minY:Infinity, maxX:-Infinity, maxY:-Infinity};
    }
    function multiSelect(arr, left, right, n, compare) {
      var stack = [left, right], mid;
      while (stack.length) {
        right = stack.pop();
        left = stack.pop();
        if (right - left <= n) {
          continue;
        }
        mid = left + Math.ceil((right - left) / n / 2) * n;
        quickselect(arr, mid, left, right, compare);
        stack.push(left, mid, mid, right);
      }
    }
    exports["default"] = rbush_1;
  })(this.rbush = this.rbush || {});
}).call(ol.ext);
ol.ext.rbush = ol.ext.rbush.default;
goog.provide("ol.structs.RBush");
goog.require("ol");
goog.require("ol.ext.rbush");
goog.require("ol.extent");
goog.require("ol.obj");
ol.structs.RBush = function(opt_maxEntries) {
  this.rbush_ = ol.ext.rbush(opt_maxEntries);
  this.items_ = {};
};
ol.structs.RBush.prototype.insert = function(extent, value) {
  var item = {minX:extent[0], minY:extent[1], maxX:extent[2], maxY:extent[3], value:value};
  this.rbush_.insert(item);
  this.items_[ol.getUid(value)] = item;
};
ol.structs.RBush.prototype.load = function(extents, values) {
  var items = new Array(values.length);
  for (var i = 0, l = values.length; i < l; i++) {
    var extent = extents[i];
    var value = values[i];
    var item = {minX:extent[0], minY:extent[1], maxX:extent[2], maxY:extent[3], value:value};
    items[i] = item;
    this.items_[ol.getUid(value)] = item;
  }
  this.rbush_.load(items);
};
ol.structs.RBush.prototype.remove = function(value) {
  var uid = ol.getUid(value);
  var item = this.items_[uid];
  delete this.items_[uid];
  return this.rbush_.remove(item) !== null;
};
ol.structs.RBush.prototype.update = function(extent, value) {
  var item = this.items_[ol.getUid(value)];
  var bbox = [item.minX, item.minY, item.maxX, item.maxY];
  if (!ol.extent.equals(bbox, extent)) {
    this.remove(value);
    this.insert(extent, value);
  }
};
ol.structs.RBush.prototype.getAll = function() {
  var items = this.rbush_.all();
  return items.map(function(item) {
    return item.value;
  });
};
ol.structs.RBush.prototype.getInExtent = function(extent) {
  var bbox = {minX:extent[0], minY:extent[1], maxX:extent[2], maxY:extent[3]};
  var items = this.rbush_.search(bbox);
  return items.map(function(item) {
    return item.value;
  });
};
ol.structs.RBush.prototype.forEach = function(callback, opt_this) {
  return this.forEach_(this.getAll(), callback, opt_this);
};
ol.structs.RBush.prototype.forEachInExtent = function(extent, callback, opt_this) {
  return this.forEach_(this.getInExtent(extent), callback, opt_this);
};
ol.structs.RBush.prototype.forEach_ = function(values, callback, opt_this) {
  var result;
  for (var i = 0, l = values.length; i < l; i++) {
    result = callback.call(opt_this, values[i]);
    if (result) {
      return result;
    }
  }
  return result;
};
ol.structs.RBush.prototype.isEmpty = function() {
  return ol.obj.isEmpty(this.items_);
};
ol.structs.RBush.prototype.clear = function() {
  this.rbush_.clear();
  this.items_ = {};
};
ol.structs.RBush.prototype.getExtent = function(opt_extent) {
  var data = this.rbush_.data;
  return ol.extent.createOrUpdate(data.minX, data.minY, data.maxX, data.maxY, opt_extent);
};
ol.structs.RBush.prototype.concat = function(rbush) {
  this.rbush_.load(rbush.rbush_.all());
  for (var i in rbush.items_) {
    this.items_[i | 0] = rbush.items_[i | 0];
  }
};
goog.provide("ol.source.Vector");
goog.require("ol");
goog.require("ol.Collection");
goog.require("ol.CollectionEventType");
goog.require("ol.ObjectEventType");
goog.require("ol.array");
goog.require("ol.asserts");
goog.require("ol.events");
goog.require("ol.events.Event");
goog.require("ol.events.EventType");
goog.require("ol.extent");
goog.require("ol.featureloader");
goog.require("ol.functions");
goog.require("ol.loadingstrategy");
goog.require("ol.obj");
goog.require("ol.source.Source");
goog.require("ol.source.State");
goog.require("ol.source.VectorEventType");
goog.require("ol.structs.RBush");
ol.source.Vector = function(opt_options) {
  var options = opt_options || {};
  ol.source.Source.call(this, {attributions:options.attributions, logo:options.logo, projection:undefined, state:ol.source.State.READY, wrapX:options.wrapX !== undefined ? options.wrapX : true});
  this.loader_ = ol.nullFunction;
  this.format_ = options.format;
  this.overlaps_ = options.overlaps == undefined ? true : options.overlaps;
  this.url_ = options.url;
  if (options.loader !== undefined) {
    this.loader_ = options.loader;
  } else {
    if (this.url_ !== undefined) {
      ol.asserts.assert(this.format_, 7);
      this.loader_ = ol.featureloader.xhr(this.url_, this.format_);
    }
  }
  this.strategy_ = options.strategy !== undefined ? options.strategy : ol.loadingstrategy.all;
  var useSpatialIndex = options.useSpatialIndex !== undefined ? options.useSpatialIndex : true;
  this.featuresRtree_ = useSpatialIndex ? new ol.structs.RBush : null;
  this.loadedExtentsRtree_ = new ol.structs.RBush;
  this.nullGeometryFeatures_ = {};
  this.idIndex_ = {};
  this.undefIdIndex_ = {};
  this.featureChangeKeys_ = {};
  this.featuresCollection_ = null;
  var collection, features;
  if (options.features instanceof ol.Collection) {
    collection = options.features;
    features = collection.getArray();
  } else {
    if (Array.isArray(options.features)) {
      features = options.features;
    }
  }
  if (!useSpatialIndex && collection === undefined) {
    collection = new ol.Collection(features);
  }
  if (features !== undefined) {
    this.addFeaturesInternal(features);
  }
  if (collection !== undefined) {
    this.bindFeaturesCollection_(collection);
  }
};
ol.inherits(ol.source.Vector, ol.source.Source);
ol.source.Vector.prototype.addFeature = function(feature) {
  this.addFeatureInternal(feature);
  this.changed();
};
ol.source.Vector.prototype.addFeatureInternal = function(feature) {
  var featureKey = ol.getUid(feature).toString();
  if (!this.addToIndex_(featureKey, feature)) {
    return;
  }
  this.setupChangeEvents_(featureKey, feature);
  var geometry = feature.getGeometry();
  if (geometry) {
    var extent = geometry.getExtent();
    if (this.featuresRtree_) {
      this.featuresRtree_.insert(extent, feature);
    }
  } else {
    this.nullGeometryFeatures_[featureKey] = feature;
  }
  this.dispatchEvent(new ol.source.Vector.Event(ol.source.VectorEventType.ADDFEATURE, feature));
};
ol.source.Vector.prototype.setupChangeEvents_ = function(featureKey, feature) {
  this.featureChangeKeys_[featureKey] = [ol.events.listen(feature, ol.events.EventType.CHANGE, this.handleFeatureChange_, this), ol.events.listen(feature, ol.ObjectEventType.PROPERTYCHANGE, this.handleFeatureChange_, this)];
};
ol.source.Vector.prototype.addToIndex_ = function(featureKey, feature) {
  var valid = true;
  var id = feature.getId();
  if (id !== undefined) {
    if (!(id.toString() in this.idIndex_)) {
      this.idIndex_[id.toString()] = feature;
    } else {
      valid = false;
    }
  } else {
    ol.asserts.assert(!(featureKey in this.undefIdIndex_), 30);
    this.undefIdIndex_[featureKey] = feature;
  }
  return valid;
};
ol.source.Vector.prototype.addFeatures = function(features) {
  this.addFeaturesInternal(features);
  this.changed();
};
ol.source.Vector.prototype.addFeaturesInternal = function(features) {
  var featureKey, i, length, feature;
  var extents = [];
  var newFeatures = [];
  var geometryFeatures = [];
  for (i = 0, length = features.length; i < length; i++) {
    feature = features[i];
    featureKey = ol.getUid(feature).toString();
    if (this.addToIndex_(featureKey, feature)) {
      newFeatures.push(feature);
    }
  }
  for (i = 0, length = newFeatures.length; i < length; i++) {
    feature = newFeatures[i];
    featureKey = ol.getUid(feature).toString();
    this.setupChangeEvents_(featureKey, feature);
    var geometry = feature.getGeometry();
    if (geometry) {
      var extent = geometry.getExtent();
      extents.push(extent);
      geometryFeatures.push(feature);
    } else {
      this.nullGeometryFeatures_[featureKey] = feature;
    }
  }
  if (this.featuresRtree_) {
    this.featuresRtree_.load(extents, geometryFeatures);
  }
  for (i = 0, length = newFeatures.length; i < length; i++) {
    this.dispatchEvent(new ol.source.Vector.Event(ol.source.VectorEventType.ADDFEATURE, newFeatures[i]));
  }
};
ol.source.Vector.prototype.bindFeaturesCollection_ = function(collection) {
  var modifyingCollection = false;
  ol.events.listen(this, ol.source.VectorEventType.ADDFEATURE, function(evt) {
    if (!modifyingCollection) {
      modifyingCollection = true;
      collection.push(evt.feature);
      modifyingCollection = false;
    }
  });
  ol.events.listen(this, ol.source.VectorEventType.REMOVEFEATURE, function(evt) {
    if (!modifyingCollection) {
      modifyingCollection = true;
      collection.remove(evt.feature);
      modifyingCollection = false;
    }
  });
  ol.events.listen(collection, ol.CollectionEventType.ADD, function(evt) {
    if (!modifyingCollection) {
      modifyingCollection = true;
      this.addFeature(evt.element);
      modifyingCollection = false;
    }
  }, this);
  ol.events.listen(collection, ol.CollectionEventType.REMOVE, function(evt) {
    if (!modifyingCollection) {
      modifyingCollection = true;
      this.removeFeature(evt.element);
      modifyingCollection = false;
    }
  }, this);
  this.featuresCollection_ = collection;
};
ol.source.Vector.prototype.clear = function(opt_fast) {
  if (opt_fast) {
    for (var featureId in this.featureChangeKeys_) {
      var keys = this.featureChangeKeys_[featureId];
      keys.forEach(ol.events.unlistenByKey);
    }
    if (!this.featuresCollection_) {
      this.featureChangeKeys_ = {};
      this.idIndex_ = {};
      this.undefIdIndex_ = {};
    }
  } else {
    if (this.featuresRtree_) {
      this.featuresRtree_.forEach(this.removeFeatureInternal, this);
      for (var id in this.nullGeometryFeatures_) {
        this.removeFeatureInternal(this.nullGeometryFeatures_[id]);
      }
    }
  }
  if (this.featuresCollection_) {
    this.featuresCollection_.clear();
  }
  if (this.featuresRtree_) {
    this.featuresRtree_.clear();
  }
  this.loadedExtentsRtree_.clear();
  this.nullGeometryFeatures_ = {};
  var clearEvent = new ol.source.Vector.Event(ol.source.VectorEventType.CLEAR);
  this.dispatchEvent(clearEvent);
  this.changed();
};
ol.source.Vector.prototype.forEachFeature = function(callback, opt_this) {
  if (this.featuresRtree_) {
    return this.featuresRtree_.forEach(callback, opt_this);
  } else {
    if (this.featuresCollection_) {
      return this.featuresCollection_.forEach(callback, opt_this);
    }
  }
};
ol.source.Vector.prototype.forEachFeatureAtCoordinateDirect = function(coordinate, callback, opt_this) {
  var extent = [coordinate[0], coordinate[1], coordinate[0], coordinate[1]];
  return this.forEachFeatureInExtent(extent, function(feature) {
    var geometry = feature.getGeometry();
    if (geometry.intersectsCoordinate(coordinate)) {
      return callback.call(opt_this, feature);
    } else {
      return undefined;
    }
  });
};
ol.source.Vector.prototype.forEachFeatureInExtent = function(extent, callback, opt_this) {
  if (this.featuresRtree_) {
    return this.featuresRtree_.forEachInExtent(extent, callback, opt_this);
  } else {
    if (this.featuresCollection_) {
      return this.featuresCollection_.forEach(callback, opt_this);
    }
  }
};
ol.source.Vector.prototype.forEachFeatureIntersectingExtent = function(extent, callback, opt_this) {
  return this.forEachFeatureInExtent(extent, function(feature) {
    var geometry = feature.getGeometry();
    if (geometry.intersectsExtent(extent)) {
      var result = callback.call(opt_this, feature);
      if (result) {
        return result;
      }
    }
  });
};
ol.source.Vector.prototype.getFeaturesCollection = function() {
  return this.featuresCollection_;
};
ol.source.Vector.prototype.getFeatures = function() {
  var features;
  if (this.featuresCollection_) {
    features = this.featuresCollection_.getArray();
  } else {
    if (this.featuresRtree_) {
      features = this.featuresRtree_.getAll();
      if (!ol.obj.isEmpty(this.nullGeometryFeatures_)) {
        ol.array.extend(features, ol.obj.getValues(this.nullGeometryFeatures_));
      }
    }
  }
  return features;
};
ol.source.Vector.prototype.getFeaturesAtCoordinate = function(coordinate) {
  var features = [];
  this.forEachFeatureAtCoordinateDirect(coordinate, function(feature) {
    features.push(feature);
  });
  return features;
};
ol.source.Vector.prototype.getFeaturesInExtent = function(extent) {
  return this.featuresRtree_.getInExtent(extent);
};
ol.source.Vector.prototype.getClosestFeatureToCoordinate = function(coordinate, opt_filter) {
  var x = coordinate[0];
  var y = coordinate[1];
  var closestFeature = null;
  var closestPoint = [NaN, NaN];
  var minSquaredDistance = Infinity;
  var extent = [-Infinity, -Infinity, Infinity, Infinity];
  var filter = opt_filter ? opt_filter : ol.functions.TRUE;
  this.featuresRtree_.forEachInExtent(extent, function(feature) {
    if (filter(feature)) {
      var geometry = feature.getGeometry();
      var previousMinSquaredDistance = minSquaredDistance;
      minSquaredDistance = geometry.closestPointXY(x, y, closestPoint, minSquaredDistance);
      if (minSquaredDistance < previousMinSquaredDistance) {
        closestFeature = feature;
        var minDistance = Math.sqrt(minSquaredDistance);
        extent[0] = x - minDistance;
        extent[1] = y - minDistance;
        extent[2] = x + minDistance;
        extent[3] = y + minDistance;
      }
    }
  });
  return closestFeature;
};
ol.source.Vector.prototype.getExtent = function(opt_extent) {
  return this.featuresRtree_.getExtent(opt_extent);
};
ol.source.Vector.prototype.getFeatureById = function(id) {
  var feature = this.idIndex_[id.toString()];
  return feature !== undefined ? feature : null;
};
ol.source.Vector.prototype.getFormat = function() {
  return this.format_;
};
ol.source.Vector.prototype.getOverlaps = function() {
  return this.overlaps_;
};
ol.source.Vector.prototype.getResolutions = function() {
};
ol.source.Vector.prototype.getUrl = function() {
  return this.url_;
};
ol.source.Vector.prototype.handleFeatureChange_ = function(event) {
  var feature = event.target;
  var featureKey = ol.getUid(feature).toString();
  var geometry = feature.getGeometry();
  if (!geometry) {
    if (!(featureKey in this.nullGeometryFeatures_)) {
      if (this.featuresRtree_) {
        this.featuresRtree_.remove(feature);
      }
      this.nullGeometryFeatures_[featureKey] = feature;
    }
  } else {
    var extent = geometry.getExtent();
    if (featureKey in this.nullGeometryFeatures_) {
      delete this.nullGeometryFeatures_[featureKey];
      if (this.featuresRtree_) {
        this.featuresRtree_.insert(extent, feature);
      }
    } else {
      if (this.featuresRtree_) {
        this.featuresRtree_.update(extent, feature);
      }
    }
  }
  var id = feature.getId();
  if (id !== undefined) {
    var sid = id.toString();
    if (featureKey in this.undefIdIndex_) {
      delete this.undefIdIndex_[featureKey];
      this.idIndex_[sid] = feature;
    } else {
      if (this.idIndex_[sid] !== feature) {
        this.removeFromIdIndex_(feature);
        this.idIndex_[sid] = feature;
      }
    }
  } else {
    if (!(featureKey in this.undefIdIndex_)) {
      this.removeFromIdIndex_(feature);
      this.undefIdIndex_[featureKey] = feature;
    }
  }
  this.changed();
  this.dispatchEvent(new ol.source.Vector.Event(ol.source.VectorEventType.CHANGEFEATURE, feature));
};
ol.source.Vector.prototype.isEmpty = function() {
  return this.featuresRtree_.isEmpty() && ol.obj.isEmpty(this.nullGeometryFeatures_);
};
ol.source.Vector.prototype.loadFeatures = function(extent, resolution, projection) {
  var loadedExtentsRtree = this.loadedExtentsRtree_;
  var extentsToLoad = this.strategy_(extent, resolution);
  var i, ii;
  for (i = 0, ii = extentsToLoad.length; i < ii; ++i) {
    var extentToLoad = extentsToLoad[i];
    var alreadyLoaded = loadedExtentsRtree.forEachInExtent(extentToLoad, function(object) {
      return ol.extent.containsExtent(object.extent, extentToLoad);
    });
    if (!alreadyLoaded) {
      this.loader_.call(this, extentToLoad, resolution, projection);
      loadedExtentsRtree.insert(extentToLoad, {extent:extentToLoad.slice()});
    }
  }
};
ol.source.Vector.prototype.removeLoadedExtent = function(extent) {
  var loadedExtentsRtree = this.loadedExtentsRtree_;
  var obj;
  loadedExtentsRtree.forEachInExtent(extent, function(object) {
    if (ol.extent.equals(object.extent, extent)) {
      obj = object;
      return true;
    }
  });
  if (obj) {
    loadedExtentsRtree.remove(obj);
  }
};
ol.source.Vector.prototype.removeFeature = function(feature) {
  var featureKey = ol.getUid(feature).toString();
  if (featureKey in this.nullGeometryFeatures_) {
    delete this.nullGeometryFeatures_[featureKey];
  } else {
    if (this.featuresRtree_) {
      this.featuresRtree_.remove(feature);
    }
  }
  this.removeFeatureInternal(feature);
  this.changed();
};
ol.source.Vector.prototype.removeFeatureInternal = function(feature) {
  var featureKey = ol.getUid(feature).toString();
  this.featureChangeKeys_[featureKey].forEach(ol.events.unlistenByKey);
  delete this.featureChangeKeys_[featureKey];
  var id = feature.getId();
  if (id !== undefined) {
    delete this.idIndex_[id.toString()];
  } else {
    delete this.undefIdIndex_[featureKey];
  }
  this.dispatchEvent(new ol.source.Vector.Event(ol.source.VectorEventType.REMOVEFEATURE, feature));
};
ol.source.Vector.prototype.removeFromIdIndex_ = function(feature) {
  var removed = false;
  for (var id in this.idIndex_) {
    if (this.idIndex_[id] === feature) {
      delete this.idIndex_[id];
      removed = true;
      break;
    }
  }
  return removed;
};
ol.source.Vector.prototype.setLoader = function(loader) {
  this.loader_ = loader;
};
ol.source.Vector.Event = function(type, opt_feature) {
  ol.events.Event.call(this, type);
  this.feature = opt_feature;
};
ol.inherits(ol.source.Vector.Event, ol.events.Event);
goog.provide("ol.color");
goog.require("ol.asserts");
goog.require("ol.math");
ol.color.HEX_COLOR_RE_ = /^#(?:[0-9a-f]{3,4}){1,2}$/i;
ol.color.NAMED_COLOR_RE_ = /^([a-z]*)$/i;
ol.color.asArray = function(color) {
  if (Array.isArray(color)) {
    return color;
  } else {
    return ol.color.fromString(color);
  }
};
ol.color.asString = function(color) {
  if (typeof color === "string") {
    return color;
  } else {
    return ol.color.toString(color);
  }
};
ol.color.fromNamed = function(color) {
  var el = document.createElement("div");
  el.style.color = color;
  document.body.appendChild(el);
  var rgb = getComputedStyle(el).color;
  document.body.removeChild(el);
  return rgb;
};
ol.color.fromString = function() {
  var MAX_CACHE_SIZE = 1024;
  var cache = {};
  var cacheSize = 0;
  return function(s) {
    var color;
    if (cache.hasOwnProperty(s)) {
      color = cache[s];
    } else {
      if (cacheSize >= MAX_CACHE_SIZE) {
        var i = 0;
        var key;
        for (key in cache) {
          if ((i++ & 3) === 0) {
            delete cache[key];
            --cacheSize;
          }
        }
      }
      color = ol.color.fromStringInternal_(s);
      cache[s] = color;
      ++cacheSize;
    }
    return color;
  };
}();
ol.color.fromStringInternal_ = function(s) {
  var r, g, b, a, color, parts;
  if (ol.color.NAMED_COLOR_RE_.exec(s)) {
    s = ol.color.fromNamed(s);
  }
  if (ol.color.HEX_COLOR_RE_.exec(s)) {
    var n = s.length - 1;
    var d;
    if (n <= 4) {
      d = 1;
    } else {
      d = 2;
    }
    var hasAlpha = n === 4 || n === 8;
    r = parseInt(s.substr(1 + 0 * d, d), 16);
    g = parseInt(s.substr(1 + 1 * d, d), 16);
    b = parseInt(s.substr(1 + 2 * d, d), 16);
    if (hasAlpha) {
      a = parseInt(s.substr(1 + 3 * d, d), 16);
    } else {
      a = 255;
    }
    if (d == 1) {
      r = (r << 4) + r;
      g = (g << 4) + g;
      b = (b << 4) + b;
      if (hasAlpha) {
        a = (a << 4) + a;
      }
    }
    color = [r, g, b, a / 255];
  } else {
    if (s.indexOf("rgba(") == 0) {
      parts = s.slice(5, -1).split(",").map(Number);
      color = ol.color.normalize(parts);
    } else {
      if (s.indexOf("rgb(") == 0) {
        parts = s.slice(4, -1).split(",").map(Number);
        parts.push(1);
        color = ol.color.normalize(parts);
      } else {
        ol.asserts.assert(false, 14);
      }
    }
  }
  return color;
};
ol.color.normalize = function(color, opt_color) {
  var result = opt_color || [];
  result[0] = ol.math.clamp(color[0] + 0.5 | 0, 0, 255);
  result[1] = ol.math.clamp(color[1] + 0.5 | 0, 0, 255);
  result[2] = ol.math.clamp(color[2] + 0.5 | 0, 0, 255);
  result[3] = ol.math.clamp(color[3], 0, 1);
  return result;
};
ol.color.toString = function(color) {
  var r = color[0];
  if (r != (r | 0)) {
    r = r + 0.5 | 0;
  }
  var g = color[1];
  if (g != (g | 0)) {
    g = g + 0.5 | 0;
  }
  var b = color[2];
  if (b != (b | 0)) {
    b = b + 0.5 | 0;
  }
  var a = color[3] === undefined ? 1 : color[3];
  return "rgba(" + r + "," + g + "," + b + "," + a + ")";
};
goog.provide("ol.colorlike");
goog.require("ol.color");
ol.colorlike.asColorLike = function(color) {
  if (ol.colorlike.isColorLike(color)) {
    return color;
  } else {
    return ol.color.asString(color);
  }
};
ol.colorlike.isColorLike = function(color) {
  return typeof color === "string" || color instanceof CanvasPattern || color instanceof CanvasGradient;
};
goog.provide("ol.webgl");
ol.webgl.ONE = 1;
ol.webgl.SRC_ALPHA = 770;
ol.webgl.COLOR_ATTACHMENT0 = 36064;
ol.webgl.COLOR_BUFFER_BIT = 16384;
ol.webgl.TRIANGLES = 4;
ol.webgl.TRIANGLE_STRIP = 5;
ol.webgl.ONE_MINUS_SRC_ALPHA = 771;
ol.webgl.ARRAY_BUFFER = 34962;
ol.webgl.ELEMENT_ARRAY_BUFFER = 34963;
ol.webgl.STREAM_DRAW = 35040;
ol.webgl.STATIC_DRAW = 35044;
ol.webgl.DYNAMIC_DRAW = 35048;
ol.webgl.CULL_FACE = 2884;
ol.webgl.BLEND = 3042;
ol.webgl.STENCIL_TEST = 2960;
ol.webgl.DEPTH_TEST = 2929;
ol.webgl.SCISSOR_TEST = 3089;
ol.webgl.UNSIGNED_BYTE = 5121;
ol.webgl.UNSIGNED_SHORT = 5123;
ol.webgl.UNSIGNED_INT = 5125;
ol.webgl.FLOAT = 5126;
ol.webgl.RGBA = 6408;
ol.webgl.FRAGMENT_SHADER = 35632;
ol.webgl.VERTEX_SHADER = 35633;
ol.webgl.LINK_STATUS = 35714;
ol.webgl.LINEAR = 9729;
ol.webgl.TEXTURE_MAG_FILTER = 10240;
ol.webgl.TEXTURE_MIN_FILTER = 10241;
ol.webgl.TEXTURE_WRAP_S = 10242;
ol.webgl.TEXTURE_WRAP_T = 10243;
ol.webgl.TEXTURE_2D = 3553;
ol.webgl.TEXTURE0 = 33984;
ol.webgl.CLAMP_TO_EDGE = 33071;
ol.webgl.COMPILE_STATUS = 35713;
ol.webgl.FRAMEBUFFER = 36160;
ol.webgl.CONTEXT_IDS_ = ["experimental-webgl", "webgl", "webkit-3d", "moz-webgl"];
ol.webgl.getContext = function(canvas, opt_attributes) {
  var context, i, ii = ol.webgl.CONTEXT_IDS_.length;
  for (i = 0; i < ii; ++i) {
    try {
      context = canvas.getContext(ol.webgl.CONTEXT_IDS_[i], opt_attributes);
      if (context) {
        return context;
      }
    } catch (e) {
    }
  }
  return null;
};
goog.provide("ol.has");
goog.require("ol");
goog.require("ol.webgl");
var ua = typeof navigator !== "undefined" ? navigator.userAgent.toLowerCase() : "";
ol.has.FIREFOX = ua.indexOf("firefox") !== -1;
ol.has.SAFARI = ua.indexOf("safari") !== -1 && ua.indexOf("chrom") == -1;
ol.has.WEBKIT = ua.indexOf("webkit") !== -1 && ua.indexOf("edge") == -1;
ol.has.MAC = ua.indexOf("macintosh") !== -1;
ol.has.DEVICE_PIXEL_RATIO = window.devicePixelRatio || 1;
ol.has.CANVAS_LINE_DASH = false;
ol.has.CANVAS = ol.ENABLE_CANVAS && function() {
  if (!("HTMLCanvasElement" in window)) {
    return false;
  }
  try {
    var context = document.createElement("CANVAS").getContext("2d");
    if (!context) {
      return false;
    } else {
      if (context.setLineDash !== undefined) {
        ol.has.CANVAS_LINE_DASH = true;
      }
      return true;
    }
  } catch (e) {
    return false;
  }
}();
ol.has.DEVICE_ORIENTATION = "DeviceOrientationEvent" in window;
ol.has.GEOLOCATION = "geolocation" in navigator;
ol.has.TOUCH = ol.ASSUME_TOUCH || "ontouchstart" in window;
ol.has.POINTER = "PointerEvent" in window;
ol.has.MSPOINTER = !!navigator.msPointerEnabled;
ol.has.WEBGL;
(function() {
  if (ol.ENABLE_WEBGL) {
    var hasWebGL = false;
    var textureSize;
    var extensions = [];
    if ("WebGLRenderingContext" in window) {
      try {
        var canvas = document.createElement("CANVAS");
        var gl = ol.webgl.getContext(canvas, {failIfMajorPerformanceCaveat:true});
        if (gl) {
          hasWebGL = true;
          textureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
          extensions = gl.getSupportedExtensions();
        }
      } catch (e) {
      }
    }
    ol.has.WEBGL = hasWebGL;
    ol.WEBGL_EXTENSIONS = extensions;
    ol.WEBGL_MAX_TEXTURE_SIZE = textureSize;
  }
})();
goog.provide("ol.css");
ol.css.CLASS_HIDDEN = "ol-hidden";
ol.css.CLASS_SELECTABLE = "ol-selectable";
ol.css.CLASS_UNSELECTABLE = "ol-unselectable";
ol.css.CLASS_UNSUPPORTED = "ol-unsupported";
ol.css.CLASS_CONTROL = "ol-control";
ol.css.getFontFamilies = function() {
  var style;
  var cache = {};
  return function(font) {
    if (!style) {
      style = document.createElement("div").style;
    }
    if (!(font in cache)) {
      style.font = font;
      var family = style.fontFamily;
      style.font = "";
      if (!family) {
        return null;
      }
      cache[font] = family.split(/,\s?/);
    }
    return cache[font];
  };
}();
goog.provide("ol.render.canvas");
goog.require("ol.css");
goog.require("ol.dom");
goog.require("ol.obj");
goog.require("ol.structs.LRUCache");
goog.require("ol.transform");
ol.render.canvas.defaultFont = "10px sans-serif";
ol.render.canvas.defaultFillStyle = [0, 0, 0, 1];
ol.render.canvas.defaultLineCap = "round";
ol.render.canvas.defaultLineDash = [];
ol.render.canvas.defaultLineDashOffset = 0;
ol.render.canvas.defaultLineJoin = "round";
ol.render.canvas.defaultMiterLimit = 10;
ol.render.canvas.defaultStrokeStyle = [0, 0, 0, 1];
ol.render.canvas.defaultTextAlign = "center";
ol.render.canvas.defaultTextBaseline = "middle";
ol.render.canvas.defaultPadding = [0, 0, 0, 0];
ol.render.canvas.defaultLineWidth = 1;
ol.render.canvas.labelCache = new ol.structs.LRUCache;
ol.render.canvas.checkedFonts_ = {};
ol.render.canvas.measureContext_ = null;
ol.render.canvas.textHeights_ = {};
ol.render.canvas.checkFont = function() {
  var retries = 60;
  var checked = ol.render.canvas.checkedFonts_;
  var labelCache = ol.render.canvas.labelCache;
  var font = "32px monospace";
  var text = "wmytzilWMYTZIL@#/&?$%10";
  var interval, referenceWidth;
  function isAvailable(fontFamily) {
    var context = ol.render.canvas.getMeasureContext();
    context.font = font;
    referenceWidth = context.measureText(text).width;
    var available = true;
    if (fontFamily != "monospace") {
      context.font = "32px " + fontFamily + ",monospace";
      var width = context.measureText(text).width;
      available = width != referenceWidth;
    }
    return available;
  }
  function check() {
    var done = true;
    for (var font in checked) {
      if (checked[font] < retries) {
        if (isAvailable(font)) {
          checked[font] = retries;
          ol.obj.clear(ol.render.canvas.textHeights_);
          ol.render.canvas.measureContext_ = null;
          labelCache.clear();
        } else {
          ++checked[font];
          done = false;
        }
      }
    }
    if (done) {
      window.clearInterval(interval);
      interval = undefined;
    }
  }
  return function(fontSpec) {
    var fontFamilies = ol.css.getFontFamilies(fontSpec);
    if (!fontFamilies) {
      return;
    }
    for (var i = 0, ii = fontFamilies.length; i < ii; ++i) {
      var fontFamily = fontFamilies[i];
      if (!(fontFamily in checked)) {
        checked[fontFamily] = retries;
        if (!isAvailable(fontFamily)) {
          checked[fontFamily] = 0;
          if (interval === undefined) {
            interval = window.setInterval(check, 32);
          }
        }
      }
    }
  };
}();
ol.render.canvas.getMeasureContext = function() {
  var context = ol.render.canvas.measureContext_;
  if (!context) {
    context = ol.render.canvas.measureContext_ = ol.dom.createCanvasContext2D(1, 1);
  }
  return context;
};
ol.render.canvas.measureTextHeight = function() {
  var span;
  var heights = ol.render.canvas.textHeights_;
  return function(font) {
    var height = heights[font];
    if (height == undefined) {
      if (!span) {
        span = document.createElement("span");
        span.textContent = "M";
        span.style.margin = span.style.padding = "0 !important";
        span.style.position = "absolute !important";
        span.style.left = "-99999px !important";
      }
      span.style.font = font;
      document.body.appendChild(span);
      height = heights[font] = span.offsetHeight;
      document.body.removeChild(span);
    }
    return height;
  };
}();
ol.render.canvas.measureTextWidth = function(font, text) {
  var measureContext = ol.render.canvas.getMeasureContext();
  if (font != measureContext.font) {
    measureContext.font = font;
  }
  return measureContext.measureText(text).width;
};
ol.render.canvas.rotateAtOffset = function(context, rotation, offsetX, offsetY) {
  if (rotation !== 0) {
    context.translate(offsetX, offsetY);
    context.rotate(rotation);
    context.translate(-offsetX, -offsetY);
  }
};
ol.render.canvas.resetTransform_ = ol.transform.create();
ol.render.canvas.drawImage = function(context, transform, opacity, image, originX, originY, w, h, x, y, scale) {
  var alpha;
  if (opacity != 1) {
    alpha = context.globalAlpha;
    context.globalAlpha = alpha * opacity;
  }
  if (transform) {
    context.setTransform.apply(context, transform);
  }
  context.drawImage(image, originX, originY, w, h, x, y, w * scale, h * scale);
  if (alpha) {
    context.globalAlpha = alpha;
  }
  if (transform) {
    context.setTransform.apply(context, ol.render.canvas.resetTransform_);
  }
};
goog.provide("ol.style.Image");
ol.style.Image = function(options) {
  this.opacity_ = options.opacity;
  this.rotateWithView_ = options.rotateWithView;
  this.rotation_ = options.rotation;
  this.scale_ = options.scale;
  this.snapToPixel_ = options.snapToPixel;
};
ol.style.Image.prototype.getOpacity = function() {
  return this.opacity_;
};
ol.style.Image.prototype.getRotateWithView = function() {
  return this.rotateWithView_;
};
ol.style.Image.prototype.getRotation = function() {
  return this.rotation_;
};
ol.style.Image.prototype.getScale = function() {
  return this.scale_;
};
ol.style.Image.prototype.getSnapToPixel = function() {
  return this.snapToPixel_;
};
ol.style.Image.prototype.getAnchor = function() {
};
ol.style.Image.prototype.getImage = function(pixelRatio) {
};
ol.style.Image.prototype.getHitDetectionImage = function(pixelRatio) {
};
ol.style.Image.prototype.getImageState = function() {
};
ol.style.Image.prototype.getImageSize = function() {
};
ol.style.Image.prototype.getHitDetectionImageSize = function() {
};
ol.style.Image.prototype.getOrigin = function() {
};
ol.style.Image.prototype.getSize = function() {
};
ol.style.Image.prototype.setOpacity = function(opacity) {
  this.opacity_ = opacity;
};
ol.style.Image.prototype.setRotateWithView = function(rotateWithView) {
  this.rotateWithView_ = rotateWithView;
};
ol.style.Image.prototype.setRotation = function(rotation) {
  this.rotation_ = rotation;
};
ol.style.Image.prototype.setScale = function(scale) {
  this.scale_ = scale;
};
ol.style.Image.prototype.setSnapToPixel = function(snapToPixel) {
  this.snapToPixel_ = snapToPixel;
};
ol.style.Image.prototype.listenImageChange = function(listener, thisArg) {
};
ol.style.Image.prototype.load = function() {
};
ol.style.Image.prototype.unlistenImageChange = function(listener, thisArg) {
};
goog.provide("ol.style.RegularShape");
goog.require("ol");
goog.require("ol.colorlike");
goog.require("ol.dom");
goog.require("ol.has");
goog.require("ol.ImageState");
goog.require("ol.render.canvas");
goog.require("ol.style.Image");
ol.style.RegularShape = function(options) {
  this.checksums_ = null;
  this.canvas_ = null;
  this.hitDetectionCanvas_ = null;
  this.fill_ = options.fill !== undefined ? options.fill : null;
  this.origin_ = [0, 0];
  this.points_ = options.points;
  this.radius_ = options.radius !== undefined ? options.radius : options.radius1;
  this.radius2_ = options.radius2;
  this.angle_ = options.angle !== undefined ? options.angle : 0;
  this.stroke_ = options.stroke !== undefined ? options.stroke : null;
  this.anchor_ = null;
  this.size_ = null;
  this.imageSize_ = null;
  this.hitDetectionImageSize_ = null;
  this.atlasManager_ = options.atlasManager;
  this.render_(this.atlasManager_);
  var snapToPixel = options.snapToPixel !== undefined ? options.snapToPixel : true;
  var rotateWithView = options.rotateWithView !== undefined ? options.rotateWithView : false;
  ol.style.Image.call(this, {opacity:1, rotateWithView:rotateWithView, rotation:options.rotation !== undefined ? options.rotation : 0, scale:1, snapToPixel:snapToPixel});
};
ol.inherits(ol.style.RegularShape, ol.style.Image);
ol.style.RegularShape.prototype.clone = function() {
  var style = new ol.style.RegularShape({fill:this.getFill() ? this.getFill().clone() : undefined, points:this.getPoints(), radius:this.getRadius(), radius2:this.getRadius2(), angle:this.getAngle(), snapToPixel:this.getSnapToPixel(), stroke:this.getStroke() ? this.getStroke().clone() : undefined, rotation:this.getRotation(), rotateWithView:this.getRotateWithView(), atlasManager:this.atlasManager_});
  style.setOpacity(this.getOpacity());
  style.setScale(this.getScale());
  return style;
};
ol.style.RegularShape.prototype.getAnchor = function() {
  return this.anchor_;
};
ol.style.RegularShape.prototype.getAngle = function() {
  return this.angle_;
};
ol.style.RegularShape.prototype.getFill = function() {
  return this.fill_;
};
ol.style.RegularShape.prototype.getHitDetectionImage = function(pixelRatio) {
  return this.hitDetectionCanvas_;
};
ol.style.RegularShape.prototype.getImage = function(pixelRatio) {
  return this.canvas_;
};
ol.style.RegularShape.prototype.getImageSize = function() {
  return this.imageSize_;
};
ol.style.RegularShape.prototype.getHitDetectionImageSize = function() {
  return this.hitDetectionImageSize_;
};
ol.style.RegularShape.prototype.getImageState = function() {
  return ol.ImageState.LOADED;
};
ol.style.RegularShape.prototype.getOrigin = function() {
  return this.origin_;
};
ol.style.RegularShape.prototype.getPoints = function() {
  return this.points_;
};
ol.style.RegularShape.prototype.getRadius = function() {
  return this.radius_;
};
ol.style.RegularShape.prototype.getRadius2 = function() {
  return this.radius2_;
};
ol.style.RegularShape.prototype.getSize = function() {
  return this.size_;
};
ol.style.RegularShape.prototype.getStroke = function() {
  return this.stroke_;
};
ol.style.RegularShape.prototype.listenImageChange = function(listener, thisArg) {
};
ol.style.RegularShape.prototype.load = function() {
};
ol.style.RegularShape.prototype.unlistenImageChange = function(listener, thisArg) {
};
ol.style.RegularShape.prototype.render_ = function(atlasManager) {
  var imageSize;
  var lineCap = "";
  var lineJoin = "";
  var miterLimit = 0;
  var lineDash = null;
  var lineDashOffset = 0;
  var strokeStyle;
  var strokeWidth = 0;
  if (this.stroke_) {
    strokeStyle = this.stroke_.getColor();
    if (strokeStyle === null) {
      strokeStyle = ol.render.canvas.defaultStrokeStyle;
    }
    strokeStyle = ol.colorlike.asColorLike(strokeStyle);
    strokeWidth = this.stroke_.getWidth();
    if (strokeWidth === undefined) {
      strokeWidth = ol.render.canvas.defaultLineWidth;
    }
    lineDash = this.stroke_.getLineDash();
    lineDashOffset = this.stroke_.getLineDashOffset();
    if (!ol.has.CANVAS_LINE_DASH) {
      lineDash = null;
      lineDashOffset = 0;
    }
    lineJoin = this.stroke_.getLineJoin();
    if (lineJoin === undefined) {
      lineJoin = ol.render.canvas.defaultLineJoin;
    }
    lineCap = this.stroke_.getLineCap();
    if (lineCap === undefined) {
      lineCap = ol.render.canvas.defaultLineCap;
    }
    miterLimit = this.stroke_.getMiterLimit();
    if (miterLimit === undefined) {
      miterLimit = ol.render.canvas.defaultMiterLimit;
    }
  }
  var size = 2 * (this.radius_ + strokeWidth) + 1;
  var renderOptions = {strokeStyle:strokeStyle, strokeWidth:strokeWidth, size:size, lineCap:lineCap, lineDash:lineDash, lineDashOffset:lineDashOffset, lineJoin:lineJoin, miterLimit:miterLimit};
  if (atlasManager === undefined) {
    var context = ol.dom.createCanvasContext2D(size, size);
    this.canvas_ = context.canvas;
    size = this.canvas_.width;
    imageSize = size;
    this.draw_(renderOptions, context, 0, 0);
    this.createHitDetectionCanvas_(renderOptions);
  } else {
    size = Math.round(size);
    var hasCustomHitDetectionImage = !this.fill_;
    var renderHitDetectionCallback;
    if (hasCustomHitDetectionImage) {
      renderHitDetectionCallback = this.drawHitDetectionCanvas_.bind(this, renderOptions);
    }
    var id = this.getChecksum();
    var info = atlasManager.add(id, size, size, this.draw_.bind(this, renderOptions), renderHitDetectionCallback);
    this.canvas_ = info.image;
    this.origin_ = [info.offsetX, info.offsetY];
    imageSize = info.image.width;
    if (hasCustomHitDetectionImage) {
      this.hitDetectionCanvas_ = info.hitImage;
      this.hitDetectionImageSize_ = [info.hitImage.width, info.hitImage.height];
    } else {
      this.hitDetectionCanvas_ = this.canvas_;
      this.hitDetectionImageSize_ = [imageSize, imageSize];
    }
  }
  this.anchor_ = [size / 2, size / 2];
  this.size_ = [size, size];
  this.imageSize_ = [imageSize, imageSize];
};
ol.style.RegularShape.prototype.draw_ = function(renderOptions, context, x, y) {
  var i, angle0, radiusC;
  context.setTransform(1, 0, 0, 1, 0, 0);
  context.translate(x, y);
  context.beginPath();
  var points = this.points_;
  if (points === Infinity) {
    context.arc(renderOptions.size / 2, renderOptions.size / 2, this.radius_, 0, 2 * Math.PI, true);
  } else {
    var radius2 = this.radius2_ !== undefined ? this.radius2_ : this.radius_;
    if (radius2 !== this.radius_) {
      points = 2 * points;
    }
    for (i = 0; i <= points; i++) {
      angle0 = i * 2 * Math.PI / points - Math.PI / 2 + this.angle_;
      radiusC = i % 2 === 0 ? this.radius_ : radius2;
      context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0), renderOptions.size / 2 + radiusC * Math.sin(angle0));
    }
  }
  if (this.fill_) {
    var color = this.fill_.getColor();
    if (color === null) {
      color = ol.render.canvas.defaultFillStyle;
    }
    context.fillStyle = ol.colorlike.asColorLike(color);
    context.fill();
  }
  if (this.stroke_) {
    context.strokeStyle = renderOptions.strokeStyle;
    context.lineWidth = renderOptions.strokeWidth;
    if (renderOptions.lineDash) {
      context.setLineDash(renderOptions.lineDash);
      context.lineDashOffset = renderOptions.lineDashOffset;
    }
    context.lineCap = renderOptions.lineCap;
    context.lineJoin = renderOptions.lineJoin;
    context.miterLimit = renderOptions.miterLimit;
    context.stroke();
  }
  context.closePath();
};
ol.style.RegularShape.prototype.createHitDetectionCanvas_ = function(renderOptions) {
  this.hitDetectionImageSize_ = [renderOptions.size, renderOptions.size];
  if (this.fill_) {
    this.hitDetectionCanvas_ = this.canvas_;
    return;
  }
  var context = ol.dom.createCanvasContext2D(renderOptions.size, renderOptions.size);
  this.hitDetectionCanvas_ = context.canvas;
  this.drawHitDetectionCanvas_(renderOptions, context, 0, 0);
};
ol.style.RegularShape.prototype.drawHitDetectionCanvas_ = function(renderOptions, context, x, y) {
  context.setTransform(1, 0, 0, 1, 0, 0);
  context.translate(x, y);
  context.beginPath();
  var points = this.points_;
  if (points === Infinity) {
    context.arc(renderOptions.size / 2, renderOptions.size / 2, this.radius_, 0, 2 * Math.PI, true);
  } else {
    var radius2 = this.radius2_ !== undefined ? this.radius2_ : this.radius_;
    if (radius2 !== this.radius_) {
      points = 2 * points;
    }
    var i, radiusC, angle0;
    for (i = 0; i <= points; i++) {
      angle0 = i * 2 * Math.PI / points - Math.PI / 2 + this.angle_;
      radiusC = i % 2 === 0 ? this.radius_ : radius2;
      context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0), renderOptions.size / 2 + radiusC * Math.sin(angle0));
    }
  }
  context.fillStyle = ol.render.canvas.defaultFillStyle;
  context.fill();
  if (this.stroke_) {
    context.strokeStyle = renderOptions.strokeStyle;
    context.lineWidth = renderOptions.strokeWidth;
    if (renderOptions.lineDash) {
      context.setLineDash(renderOptions.lineDash);
      context.lineDashOffset = renderOptions.lineDashOffset;
    }
    context.stroke();
  }
  context.closePath();
};
ol.style.RegularShape.prototype.getChecksum = function() {
  var strokeChecksum = this.stroke_ ? this.stroke_.getChecksum() : "-";
  var fillChecksum = this.fill_ ? this.fill_.getChecksum() : "-";
  var recalculate = !this.checksums_ || (strokeChecksum != this.checksums_[1] || fillChecksum != this.checksums_[2] || this.radius_ != this.checksums_[3] || this.radius2_ != this.checksums_[4] || this.angle_ != this.checksums_[5] || this.points_ != this.checksums_[6]);
  if (recalculate) {
    var checksum = "r" + strokeChecksum + fillChecksum + (this.radius_ !== undefined ? this.radius_.toString() : "-") + (this.radius2_ !== undefined ? this.radius2_.toString() : "-") + (this.angle_ !== undefined ? this.angle_.toString() : "-") + (this.points_ !== undefined ? this.points_.toString() : "-");
    this.checksums_ = [checksum, strokeChecksum, fillChecksum, this.radius_, this.radius2_, this.angle_, this.points_];
  }
  return this.checksums_[0];
};
goog.provide("ol.style.Circle");
goog.require("ol");
goog.require("ol.style.RegularShape");
ol.style.Circle = function(opt_options) {
  var options = opt_options || {};
  ol.style.RegularShape.call(this, {points:Infinity, fill:options.fill, radius:options.radius, snapToPixel:options.snapToPixel, stroke:options.stroke, atlasManager:options.atlasManager});
};
ol.inherits(ol.style.Circle, ol.style.RegularShape);
ol.style.Circle.prototype.clone = function() {
  var style = new ol.style.Circle({fill:this.getFill() ? this.getFill().clone() : undefined, stroke:this.getStroke() ? this.getStroke().clone() : undefined, radius:this.getRadius(), snapToPixel:this.getSnapToPixel(), atlasManager:this.atlasManager_});
  style.setOpacity(this.getOpacity());
  style.setScale(this.getScale());
  return style;
};
ol.style.Circle.prototype.setRadius = function(radius) {
  this.radius_ = radius;
  this.render_(this.atlasManager_);
};
goog.provide("ol.style.Fill");
goog.require("ol");
goog.require("ol.color");
ol.style.Fill = function(opt_options) {
  var options = opt_options || {};
  this.color_ = options.color !== undefined ? options.color : null;
  this.checksum_ = undefined;
};
ol.style.Fill.prototype.clone = function() {
  var color = this.getColor();
  return new ol.style.Fill({color:color && color.slice ? color.slice() : color || undefined});
};
ol.style.Fill.prototype.getColor = function() {
  return this.color_;
};
ol.style.Fill.prototype.setColor = function(color) {
  this.color_ = color;
  this.checksum_ = undefined;
};
ol.style.Fill.prototype.getChecksum = function() {
  if (this.checksum_ === undefined) {
    if (this.color_ instanceof CanvasPattern || this.color_ instanceof CanvasGradient) {
      this.checksum_ = ol.getUid(this.color_).toString();
    } else {
      this.checksum_ = "f" + (this.color_ ? ol.color.asString(this.color_) : "-");
    }
  }
  return this.checksum_;
};
goog.provide("ol.style.Stroke");
goog.require("ol");
ol.style.Stroke = function(opt_options) {
  var options = opt_options || {};
  this.color_ = options.color !== undefined ? options.color : null;
  this.lineCap_ = options.lineCap;
  this.lineDash_ = options.lineDash !== undefined ? options.lineDash : null;
  this.lineDashOffset_ = options.lineDashOffset;
  this.lineJoin_ = options.lineJoin;
  this.miterLimit_ = options.miterLimit;
  this.width_ = options.width;
  this.checksum_ = undefined;
};
ol.style.Stroke.prototype.clone = function() {
  var color = this.getColor();
  return new ol.style.Stroke({color:color && color.slice ? color.slice() : color || undefined, lineCap:this.getLineCap(), lineDash:this.getLineDash() ? this.getLineDash().slice() : undefined, lineDashOffset:this.getLineDashOffset(), lineJoin:this.getLineJoin(), miterLimit:this.getMiterLimit(), width:this.getWidth()});
};
ol.style.Stroke.prototype.getColor = function() {
  return this.color_;
};
ol.style.Stroke.prototype.getLineCap = function() {
  return this.lineCap_;
};
ol.style.Stroke.prototype.getLineDash = function() {
  return this.lineDash_;
};
ol.style.Stroke.prototype.getLineDashOffset = function() {
  return this.lineDashOffset_;
};
ol.style.Stroke.prototype.getLineJoin = function() {
  return this.lineJoin_;
};
ol.style.Stroke.prototype.getMiterLimit = function() {
  return this.miterLimit_;
};
ol.style.Stroke.prototype.getWidth = function() {
  return this.width_;
};
ol.style.Stroke.prototype.setColor = function(color) {
  this.color_ = color;
  this.checksum_ = undefined;
};
ol.style.Stroke.prototype.setLineCap = function(lineCap) {
  this.lineCap_ = lineCap;
  this.checksum_ = undefined;
};
ol.style.Stroke.prototype.setLineDash = function(lineDash) {
  this.lineDash_ = lineDash;
  this.checksum_ = undefined;
};
ol.style.Stroke.prototype.setLineDashOffset = function(lineDashOffset) {
  this.lineDashOffset_ = lineDashOffset;
  this.checksum_ = undefined;
};
ol.style.Stroke.prototype.setLineJoin = function(lineJoin) {
  this.lineJoin_ = lineJoin;
  this.checksum_ = undefined;
};
ol.style.Stroke.prototype.setMiterLimit = function(miterLimit) {
  this.miterLimit_ = miterLimit;
  this.checksum_ = undefined;
};
ol.style.Stroke.prototype.setWidth = function(width) {
  this.width_ = width;
  this.checksum_ = undefined;
};
ol.style.Stroke.prototype.getChecksum = function() {
  if (this.checksum_ === undefined) {
    this.checksum_ = "s";
    if (this.color_) {
      if (typeof this.color_ === "string") {
        this.checksum_ += this.color_;
      } else {
        this.checksum_ += ol.getUid(this.color_).toString();
      }
    } else {
      this.checksum_ += "-";
    }
    this.checksum_ += "," + (this.lineCap_ !== undefined ? this.lineCap_.toString() : "-") + "," + (this.lineDash_ ? this.lineDash_.toString() : "-") + "," + (this.lineDashOffset_ !== undefined ? this.lineDashOffset_ : "-") + "," + (this.lineJoin_ !== undefined ? this.lineJoin_ : "-") + "," + (this.miterLimit_ !== undefined ? this.miterLimit_.toString() : "-") + "," + (this.width_ !== undefined ? this.width_.toString() : "-");
  }
  return this.checksum_;
};
goog.provide("ol.style.Style");
goog.require("ol.asserts");
goog.require("ol.geom.GeometryType");
goog.require("ol.style.Circle");
goog.require("ol.style.Fill");
goog.require("ol.style.Stroke");
ol.style.Style = function(opt_options) {
  var options = opt_options || {};
  this.geometry_ = null;
  this.geometryFunction_ = ol.style.Style.defaultGeometryFunction;
  if (options.geometry !== undefined) {
    this.setGeometry(options.geometry);
  }
  this.fill_ = options.fill !== undefined ? options.fill : null;
  this.image_ = options.image !== undefined ? options.image : null;
  this.renderer_ = options.renderer !== undefined ? options.renderer : null;
  this.stroke_ = options.stroke !== undefined ? options.stroke : null;
  this.text_ = options.text !== undefined ? options.text : null;
  this.zIndex_ = options.zIndex;
};
ol.style.Style.prototype.clone = function() {
  var geometry = this.getGeometry();
  if (geometry && geometry.clone) {
    geometry = geometry.clone();
  }
  return new ol.style.Style({geometry:geometry, fill:this.getFill() ? this.getFill().clone() : undefined, image:this.getImage() ? this.getImage().clone() : undefined, stroke:this.getStroke() ? this.getStroke().clone() : undefined, text:this.getText() ? this.getText().clone() : undefined, zIndex:this.getZIndex()});
};
ol.style.Style.prototype.getRenderer = function() {
  return this.renderer_;
};
ol.style.Style.prototype.setRenderer = function(renderer) {
  this.renderer_ = renderer;
};
ol.style.Style.prototype.getGeometry = function() {
  return this.geometry_;
};
ol.style.Style.prototype.getGeometryFunction = function() {
  return this.geometryFunction_;
};
ol.style.Style.prototype.getFill = function() {
  return this.fill_;
};
ol.style.Style.prototype.setFill = function(fill) {
  this.fill_ = fill;
};
ol.style.Style.prototype.getImage = function() {
  return this.image_;
};
ol.style.Style.prototype.setImage = function(image) {
  this.image_ = image;
};
ol.style.Style.prototype.getStroke = function() {
  return this.stroke_;
};
ol.style.Style.prototype.setStroke = function(stroke) {
  this.stroke_ = stroke;
};
ol.style.Style.prototype.getText = function() {
  return this.text_;
};
ol.style.Style.prototype.setText = function(text) {
  this.text_ = text;
};
ol.style.Style.prototype.getZIndex = function() {
  return this.zIndex_;
};
ol.style.Style.prototype.setGeometry = function(geometry) {
  if (typeof geometry === "function") {
    this.geometryFunction_ = geometry;
  } else {
    if (typeof geometry === "string") {
      this.geometryFunction_ = function(feature) {
        return feature.get(geometry);
      };
    } else {
      if (!geometry) {
        this.geometryFunction_ = ol.style.Style.defaultGeometryFunction;
      } else {
        if (geometry !== undefined) {
          this.geometryFunction_ = function() {
            return geometry;
          };
        }
      }
    }
  }
  this.geometry_ = geometry;
};
ol.style.Style.prototype.setZIndex = function(zIndex) {
  this.zIndex_ = zIndex;
};
ol.style.Style.createFunction = function(obj) {
  var styleFunction;
  if (typeof obj === "function") {
    styleFunction = obj;
  } else {
    var styles;
    if (Array.isArray(obj)) {
      styles = obj;
    } else {
      ol.asserts.assert(obj instanceof ol.style.Style, 41);
      styles = [obj];
    }
    styleFunction = function() {
      return styles;
    };
  }
  return styleFunction;
};
ol.style.Style.default_ = null;
ol.style.Style.defaultFunction = function(feature, resolution) {
  if (!ol.style.Style.default_) {
    var fill = new ol.style.Fill({color:"rgba(255,255,255,0.4)"});
    var stroke = new ol.style.Stroke({color:"#3399CC", width:1.25});
    ol.style.Style.default_ = [new ol.style.Style({image:new ol.style.Circle({fill:fill, stroke:stroke, radius:5}), fill:fill, stroke:stroke})];
  }
  return ol.style.Style.default_;
};
ol.style.Style.createDefaultEditing = function() {
  var styles = {};
  var white = [255, 255, 255, 1];
  var blue = [0, 153, 255, 1];
  var width = 3;
  styles[ol.geom.GeometryType.POLYGON] = [new ol.style.Style({fill:new ol.style.Fill({color:[255, 255, 255, 0.5]})})];
  styles[ol.geom.GeometryType.MULTI_POLYGON] = styles[ol.geom.GeometryType.POLYGON];
  styles[ol.geom.GeometryType.LINE_STRING] = [new ol.style.Style({stroke:new ol.style.Stroke({color:white, width:width + 2})}), new ol.style.Style({stroke:new ol.style.Stroke({color:blue, width:width})})];
  styles[ol.geom.GeometryType.MULTI_LINE_STRING] = styles[ol.geom.GeometryType.LINE_STRING];
  styles[ol.geom.GeometryType.CIRCLE] = styles[ol.geom.GeometryType.POLYGON].concat(styles[ol.geom.GeometryType.LINE_STRING]);
  styles[ol.geom.GeometryType.POINT] = [new ol.style.Style({image:new ol.style.Circle({radius:width * 2, fill:new ol.style.Fill({color:blue}), stroke:new ol.style.Stroke({color:white, width:width / 2})}), zIndex:Infinity})];
  styles[ol.geom.GeometryType.MULTI_POINT] = styles[ol.geom.GeometryType.POINT];
  styles[ol.geom.GeometryType.GEOMETRY_COLLECTION] = styles[ol.geom.GeometryType.POLYGON].concat(styles[ol.geom.GeometryType.LINE_STRING], styles[ol.geom.GeometryType.POINT]);
  return styles;
};
ol.style.Style.defaultGeometryFunction = function(feature) {
  return feature.getGeometry();
};
goog.provide("ol.Feature");
goog.require("ol.asserts");
goog.require("ol.events");
goog.require("ol.events.EventType");
goog.require("ol");
goog.require("ol.Object");
goog.require("ol.geom.Geometry");
goog.require("ol.style.Style");
ol.Feature = function(opt_geometryOrProperties) {
  ol.Object.call(this);
  this.id_ = undefined;
  this.geometryName_ = "geometry";
  this.style_ = null;
  this.styleFunction_ = undefined;
  this.geometryChangeKey_ = null;
  ol.events.listen(this, ol.Object.getChangeEventType(this.geometryName_), this.handleGeometryChanged_, this);
  if (opt_geometryOrProperties !== undefined) {
    if (opt_geometryOrProperties instanceof ol.geom.Geometry || !opt_geometryOrProperties) {
      var geometry = opt_geometryOrProperties;
      this.setGeometry(geometry);
    } else {
      var properties = opt_geometryOrProperties;
      this.setProperties(properties);
    }
  }
};
ol.inherits(ol.Feature, ol.Object);
ol.Feature.prototype.clone = function() {
  var clone = new ol.Feature(this.getProperties());
  clone.setGeometryName(this.getGeometryName());
  var geometry = this.getGeometry();
  if (geometry) {
    clone.setGeometry(geometry.clone());
  }
  var style = this.getStyle();
  if (style) {
    clone.setStyle(style);
  }
  return clone;
};
ol.Feature.prototype.getGeometry = function() {
  return this.get(this.geometryName_);
};
ol.Feature.prototype.getId = function() {
  return this.id_;
};
ol.Feature.prototype.getGeometryName = function() {
  return this.geometryName_;
};
ol.Feature.prototype.getStyle = function() {
  return this.style_;
};
ol.Feature.prototype.getStyleFunction = function() {
  return this.styleFunction_;
};
ol.Feature.prototype.handleGeometryChange_ = function() {
  this.changed();
};
ol.Feature.prototype.handleGeometryChanged_ = function() {
  if (this.geometryChangeKey_) {
    ol.events.unlistenByKey(this.geometryChangeKey_);
    this.geometryChangeKey_ = null;
  }
  var geometry = this.getGeometry();
  if (geometry) {
    this.geometryChangeKey_ = ol.events.listen(geometry, ol.events.EventType.CHANGE, this.handleGeometryChange_, this);
  }
  this.changed();
};
ol.Feature.prototype.setGeometry = function(geometry) {
  this.set(this.geometryName_, geometry);
};
ol.Feature.prototype.setStyle = function(style) {
  this.style_ = style;
  this.styleFunction_ = !style ? undefined : ol.Feature.createStyleFunction(style);
  this.changed();
};
ol.Feature.prototype.setId = function(id) {
  this.id_ = id;
  this.changed();
};
ol.Feature.prototype.setGeometryName = function(name) {
  ol.events.unlisten(this, ol.Object.getChangeEventType(this.geometryName_), this.handleGeometryChanged_, this);
  this.geometryName_ = name;
  ol.events.listen(this, ol.Object.getChangeEventType(this.geometryName_), this.handleGeometryChanged_, this);
  this.handleGeometryChanged_();
};
ol.Feature.createStyleFunction = function(obj) {
  var styleFunction;
  if (typeof obj === "function") {
    if (obj.length == 2) {
      styleFunction = function(resolution) {
        return obj(this, resolution);
      };
    } else {
      styleFunction = obj;
    }
  } else {
    var styles;
    if (Array.isArray(obj)) {
      styles = obj;
    } else {
      ol.asserts.assert(obj instanceof ol.style.Style, 41);
      styles = [obj];
    }
    styleFunction = function() {
      return styles;
    };
  }
  return styleFunction;
};
goog.provide("ol.coordinate");
goog.require("ol.math");
goog.require("ol.string");
ol.coordinate.add = function(coordinate, delta) {
  coordinate[0] += delta[0];
  coordinate[1] += delta[1];
  return coordinate;
};
ol.coordinate.closestOnCircle = function(coordinate, circle) {
  var r = circle.getRadius();
  var center = circle.getCenter();
  var x0 = center[0];
  var y0 = center[1];
  var x1 = coordinate[0];
  var y1 = coordinate[1];
  var dx = x1 - x0;
  var dy = y1 - y0;
  if (dx === 0 && dy === 0) {
    dx = 1;
  }
  var d = Math.sqrt(dx * dx + dy * dy);
  var x, y;
  x = x0 + r * dx / d;
  y = y0 + r * dy / d;
  return [x, y];
};
ol.coordinate.closestOnSegment = function(coordinate, segment) {
  var x0 = coordinate[0];
  var y0 = coordinate[1];
  var start = segment[0];
  var end = segment[1];
  var x1 = start[0];
  var y1 = start[1];
  var x2 = end[0];
  var y2 = end[1];
  var dx = x2 - x1;
  var dy = y2 - y1;
  var along = dx === 0 && dy === 0 ? 0 : (dx * (x0 - x1) + dy * (y0 - y1)) / (dx * dx + dy * dy || 0);
  var x, y;
  if (along <= 0) {
    x = x1;
    y = y1;
  } else {
    if (along >= 1) {
      x = x2;
      y = y2;
    } else {
      x = x1 + along * dx;
      y = y1 + along * dy;
    }
  }
  return [x, y];
};
ol.coordinate.createStringXY = function(opt_fractionDigits) {
  return function(coordinate) {
    return ol.coordinate.toStringXY(coordinate, opt_fractionDigits);
  };
};
ol.coordinate.degreesToStringHDMS = function(hemispheres, degrees, opt_fractionDigits) {
  var normalizedDegrees = ol.math.modulo(degrees + 180, 360) - 180;
  var x = Math.abs(3600 * normalizedDegrees);
  var dflPrecision = opt_fractionDigits || 0;
  var precision = Math.pow(10, dflPrecision);
  var deg = Math.floor(x / 3600);
  var min = Math.floor((x - deg * 3600) / 60);
  var sec = x - deg * 3600 - min * 60;
  sec = Math.ceil(sec * precision) / precision;
  if (sec >= 60) {
    sec = 0;
    min += 1;
  }
  if (min >= 60) {
    min = 0;
    deg += 1;
  }
  return deg + "\u00b0 " + ol.string.padNumber(min, 2) + "\u2032 " + ol.string.padNumber(sec, 2, dflPrecision) + "\u2033" + (normalizedDegrees == 0 ? "" : " " + hemispheres.charAt(normalizedDegrees < 0 ? 1 : 0));
};
ol.coordinate.format = function(coordinate, template, opt_fractionDigits) {
  if (coordinate) {
    return template.replace("{x}", coordinate[0].toFixed(opt_fractionDigits)).replace("{y}", coordinate[1].toFixed(opt_fractionDigits));
  } else {
    return "";
  }
};
ol.coordinate.equals = function(coordinate1, coordinate2) {
  var equals = true;
  for (var i = coordinate1.length - 1; i >= 0; --i) {
    if (coordinate1[i] != coordinate2[i]) {
      equals = false;
      break;
    }
  }
  return equals;
};
ol.coordinate.rotate = function(coordinate, angle) {
  var cosAngle = Math.cos(angle);
  var sinAngle = Math.sin(angle);
  var x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  var y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  coordinate[0] = x;
  coordinate[1] = y;
  return coordinate;
};
ol.coordinate.scale = function(coordinate, scale) {
  coordinate[0] *= scale;
  coordinate[1] *= scale;
  return coordinate;
};
ol.coordinate.sub = function(coordinate, delta) {
  coordinate[0] -= delta[0];
  coordinate[1] -= delta[1];
  return coordinate;
};
ol.coordinate.squaredDistance = function(coord1, coord2) {
  var dx = coord1[0] - coord2[0];
  var dy = coord1[1] - coord2[1];
  return dx * dx + dy * dy;
};
ol.coordinate.distance = function(coord1, coord2) {
  return Math.sqrt(ol.coordinate.squaredDistance(coord1, coord2));
};
ol.coordinate.squaredDistanceToSegment = function(coordinate, segment) {
  return ol.coordinate.squaredDistance(coordinate, ol.coordinate.closestOnSegment(coordinate, segment));
};
ol.coordinate.toStringHDMS = function(coordinate, opt_fractionDigits) {
  if (coordinate) {
    return ol.coordinate.degreesToStringHDMS("NS", coordinate[1], opt_fractionDigits) + " " + ol.coordinate.degreesToStringHDMS("EW", coordinate[0], opt_fractionDigits);
  } else {
    return "";
  }
};
ol.coordinate.toStringXY = function(coordinate, opt_fractionDigits) {
  return ol.coordinate.format(coordinate, "{x}, {y}", opt_fractionDigits);
};
goog.provide("ol.source.Cluster");
goog.require("ol");
goog.require("ol.asserts");
goog.require("ol.Feature");
goog.require("ol.coordinate");
goog.require("ol.events.EventType");
goog.require("ol.extent");
goog.require("ol.geom.Point");
goog.require("ol.source.Vector");
ol.source.Cluster = function(options) {
  ol.source.Vector.call(this, {attributions:options.attributions, extent:options.extent, logo:options.logo, projection:options.projection, wrapX:options.wrapX});
  this.resolution = undefined;
  this.distance = options.distance !== undefined ? options.distance : 20;
  this.features = [];
  this.geometryFunction = options.geometryFunction || function(feature) {
    var geometry = feature.getGeometry();
    ol.asserts.assert(geometry instanceof ol.geom.Point, 10);
    return geometry;
  };
  this.source = options.source;
  this.source.on(ol.events.EventType.CHANGE, ol.source.Cluster.prototype.refresh, this);
};
ol.inherits(ol.source.Cluster, ol.source.Vector);
ol.source.Cluster.prototype.getDistance = function() {
  return this.distance;
};
ol.source.Cluster.prototype.getSource = function() {
  return this.source;
};
ol.source.Cluster.prototype.loadFeatures = function(extent, resolution, projection) {
  this.source.loadFeatures(extent, resolution, projection);
  if (resolution !== this.resolution) {
    this.clear();
    this.resolution = resolution;
    this.cluster();
    this.addFeatures(this.features);
  }
};
ol.source.Cluster.prototype.setDistance = function(distance) {
  this.distance = distance;
  this.refresh();
};
ol.source.Cluster.prototype.refresh = function() {
  this.clear();
  this.cluster();
  this.addFeatures(this.features);
  ol.source.Vector.prototype.refresh.call(this);
};
ol.source.Cluster.prototype.cluster = function() {
  if (this.resolution === undefined) {
    return;
  }
  this.features.length = 0;
  var extent = ol.extent.createEmpty();
  var mapDistance = this.distance * this.resolution;
  var features = this.source.getFeatures();
  var clustered = {};
  for (var i = 0, ii = features.length; i < ii; i++) {
    var feature = features[i];
    if (!(ol.getUid(feature).toString() in clustered)) {
      var geometry = this.geometryFunction(feature);
      if (geometry) {
        var coordinates = geometry.getCoordinates();
        ol.extent.createOrUpdateFromCoordinate(coordinates, extent);
        ol.extent.buffer(extent, mapDistance, extent);
        var neighbors = this.source.getFeaturesInExtent(extent);
        neighbors = neighbors.filter(function(neighbor) {
          var uid = ol.getUid(neighbor).toString();
          if (!(uid in clustered)) {
            clustered[uid] = true;
            return true;
          } else {
            return false;
          }
        });
        this.features.push(this.createCluster(neighbors));
      }
    }
  }
};
ol.source.Cluster.prototype.createCluster = function(features) {
  var centroid = [0, 0];
  for (var i = features.length - 1; i >= 0; --i) {
    var geometry = this.geometryFunction(features[i]);
    if (geometry) {
      ol.coordinate.add(centroid, geometry.getCoordinates());
    } else {
      features.splice(i, 1);
    }
  }
  ol.coordinate.scale(centroid, 1 / features.length);
  var cluster = new ol.Feature(new ol.geom.Point(centroid));
  cluster.set("features", features);
  return cluster;
};
goog.provide("ol.layer.VectorRenderType");
ol.layer.VectorRenderType = {IMAGE:"image", VECTOR:"vector"};
goog.provide("ol.layer.Vector");
goog.require("ol");
goog.require("ol.LayerType");
goog.require("ol.layer.Layer");
goog.require("ol.layer.VectorRenderType");
goog.require("ol.obj");
goog.require("ol.style.Style");
ol.layer.Vector = function(opt_options) {
  var options = opt_options ? opt_options : {};
  var baseOptions = ol.obj.assign({}, options);
  delete baseOptions.style;
  delete baseOptions.renderBuffer;
  delete baseOptions.updateWhileAnimating;
  delete baseOptions.updateWhileInteracting;
  ol.layer.Layer.call(this, baseOptions);
  this.declutter_ = options.declutter !== undefined ? options.declutter : false;
  this.renderBuffer_ = options.renderBuffer !== undefined ? options.renderBuffer : 100;
  this.style_ = null;
  this.styleFunction_ = undefined;
  this.setStyle(options.style);
  this.updateWhileAnimating_ = options.updateWhileAnimating !== undefined ? options.updateWhileAnimating : false;
  this.updateWhileInteracting_ = options.updateWhileInteracting !== undefined ? options.updateWhileInteracting : false;
  this.renderMode_ = options.renderMode || ol.layer.VectorRenderType.VECTOR;
  this.type = ol.LayerType.VECTOR;
};
ol.inherits(ol.layer.Vector, ol.layer.Layer);
ol.layer.Vector.prototype.getDeclutter = function() {
  return this.declutter_;
};
ol.layer.Vector.prototype.setDeclutter = function(declutter) {
  this.declutter_ = declutter;
};
ol.layer.Vector.prototype.getRenderBuffer = function() {
  return this.renderBuffer_;
};
ol.layer.Vector.prototype.getRenderOrder = function() {
  return this.get(ol.layer.Vector.Property_.RENDER_ORDER);
};
ol.layer.Vector.prototype.getSource;
ol.layer.Vector.prototype.getStyle = function() {
  return this.style_;
};
ol.layer.Vector.prototype.getStyleFunction = function() {
  return this.styleFunction_;
};
ol.layer.Vector.prototype.getUpdateWhileAnimating = function() {
  return this.updateWhileAnimating_;
};
ol.layer.Vector.prototype.getUpdateWhileInteracting = function() {
  return this.updateWhileInteracting_;
};
ol.layer.Vector.prototype.setRenderOrder = function(renderOrder) {
  this.set(ol.layer.Vector.Property_.RENDER_ORDER, renderOrder);
};
ol.layer.Vector.prototype.setStyle = function(style) {
  this.style_ = style !== undefined ? style : ol.style.Style.defaultFunction;
  this.styleFunction_ = style === null ? undefined : ol.style.Style.createFunction(this.style_);
  this.changed();
};
ol.layer.Vector.prototype.getRenderMode = function() {
  return this.renderMode_;
};
ol.layer.Vector.Property_ = {RENDER_ORDER:"renderOrder"};
goog.provide("ol.style.IconAnchorUnits");
ol.style.IconAnchorUnits = {FRACTION:"fraction", PIXELS:"pixels"};
goog.provide("ol.style.IconImageCache");
goog.require("ol.color");
ol.style.IconImageCache = function() {
  this.cache_ = {};
  this.cacheSize_ = 0;
  this.maxCacheSize_ = 32;
};
ol.style.IconImageCache.getKey = function(src, crossOrigin, color) {
  var colorString = color ? ol.color.asString(color) : "null";
  return crossOrigin + ":" + src + ":" + colorString;
};
ol.style.IconImageCache.prototype.clear = function() {
  this.cache_ = {};
  this.cacheSize_ = 0;
};
ol.style.IconImageCache.prototype.expire = function() {
  if (this.cacheSize_ > this.maxCacheSize_) {
    var i = 0;
    var key, iconImage;
    for (key in this.cache_) {
      iconImage = this.cache_[key];
      if ((i++ & 3) === 0 && !iconImage.hasListener()) {
        delete this.cache_[key];
        --this.cacheSize_;
      }
    }
  }
};
ol.style.IconImageCache.prototype.get = function(src, crossOrigin, color) {
  var key = ol.style.IconImageCache.getKey(src, crossOrigin, color);
  return key in this.cache_ ? this.cache_[key] : null;
};
ol.style.IconImageCache.prototype.set = function(src, crossOrigin, color, iconImage) {
  var key = ol.style.IconImageCache.getKey(src, crossOrigin, color);
  this.cache_[key] = iconImage;
  ++this.cacheSize_;
};
ol.style.IconImageCache.prototype.setSize = function(maxCacheSize) {
  this.maxCacheSize_ = maxCacheSize;
  this.expire();
};
goog.provide("ol.style");
goog.require("ol.style.IconImageCache");
ol.style.iconImageCache = new ol.style.IconImageCache;
goog.provide("ol.style.IconImage");
goog.require("ol");
goog.require("ol.dom");
goog.require("ol.events");
goog.require("ol.events.EventTarget");
goog.require("ol.events.EventType");
goog.require("ol.ImageState");
goog.require("ol.style");
ol.style.IconImage = function(image, src, size, crossOrigin, imageState, color) {
  ol.events.EventTarget.call(this);
  this.hitDetectionImage_ = null;
  this.image_ = !image ? new Image : image;
  if (crossOrigin !== null) {
    this.image_.crossOrigin = crossOrigin;
  }
  this.canvas_ = color ? document.createElement("CANVAS") : null;
  this.color_ = color;
  this.imageListenerKeys_ = null;
  this.imageState_ = imageState;
  this.size_ = size;
  this.src_ = src;
  this.tainting_ = false;
  if (this.imageState_ == ol.ImageState.LOADED) {
    this.determineTainting_();
  }
};
ol.inherits(ol.style.IconImage, ol.events.EventTarget);
ol.style.IconImage.get = function(image, src, size, crossOrigin, imageState, color) {
  var iconImageCache = ol.style.iconImageCache;
  var iconImage = iconImageCache.get(src, crossOrigin, color);
  if (!iconImage) {
    iconImage = new ol.style.IconImage(image, src, size, crossOrigin, imageState, color);
    iconImageCache.set(src, crossOrigin, color, iconImage);
  }
  return iconImage;
};
ol.style.IconImage.prototype.determineTainting_ = function() {
  var context = ol.dom.createCanvasContext2D(1, 1);
  try {
    context.drawImage(this.image_, 0, 0);
    context.getImageData(0, 0, 1, 1);
  } catch (e) {
    this.tainting_ = true;
  }
};
ol.style.IconImage.prototype.dispatchChangeEvent_ = function() {
  this.dispatchEvent(ol.events.EventType.CHANGE);
};
ol.style.IconImage.prototype.handleImageError_ = function() {
  this.imageState_ = ol.ImageState.ERROR;
  this.unlistenImage_();
  this.dispatchChangeEvent_();
};
ol.style.IconImage.prototype.handleImageLoad_ = function() {
  this.imageState_ = ol.ImageState.LOADED;
  if (this.size_) {
    this.image_.width = this.size_[0];
    this.image_.height = this.size_[1];
  }
  this.size_ = [this.image_.width, this.image_.height];
  this.unlistenImage_();
  this.determineTainting_();
  this.replaceColor_();
  this.dispatchChangeEvent_();
};
ol.style.IconImage.prototype.getImage = function(pixelRatio) {
  return this.canvas_ ? this.canvas_ : this.image_;
};
ol.style.IconImage.prototype.getImageState = function() {
  return this.imageState_;
};
ol.style.IconImage.prototype.getHitDetectionImage = function(pixelRatio) {
  if (!this.hitDetectionImage_) {
    if (this.tainting_) {
      var width = this.size_[0];
      var height = this.size_[1];
      var context = ol.dom.createCanvasContext2D(width, height);
      context.fillRect(0, 0, width, height);
      this.hitDetectionImage_ = context.canvas;
    } else {
      this.hitDetectionImage_ = this.image_;
    }
  }
  return this.hitDetectionImage_;
};
ol.style.IconImage.prototype.getSize = function() {
  return this.size_;
};
ol.style.IconImage.prototype.getSrc = function() {
  return this.src_;
};
ol.style.IconImage.prototype.load = function() {
  if (this.imageState_ == ol.ImageState.IDLE) {
    this.imageState_ = ol.ImageState.LOADING;
    this.imageListenerKeys_ = [ol.events.listenOnce(this.image_, ol.events.EventType.ERROR, this.handleImageError_, this), ol.events.listenOnce(this.image_, ol.events.EventType.LOAD, this.handleImageLoad_, this)];
    try {
      this.image_.src = this.src_;
    } catch (e) {
      this.handleImageError_();
    }
  }
};
ol.style.IconImage.prototype.replaceColor_ = function() {
  if (this.tainting_ || this.color_ === null) {
    return;
  }
  this.canvas_.width = this.image_.width;
  this.canvas_.height = this.image_.height;
  var ctx = this.canvas_.getContext("2d");
  ctx.drawImage(this.image_, 0, 0);
  var imgData = ctx.getImageData(0, 0, this.image_.width, this.image_.height);
  var data = imgData.data;
  var r = this.color_[0] / 255.0;
  var g = this.color_[1] / 255.0;
  var b = this.color_[2] / 255.0;
  for (var i = 0, ii = data.length; i < ii; i += 4) {
    data[i] *= r;
    data[i + 1] *= g;
    data[i + 2] *= b;
  }
  ctx.putImageData(imgData, 0, 0);
};
ol.style.IconImage.prototype.unlistenImage_ = function() {
  this.imageListenerKeys_.forEach(ol.events.unlistenByKey);
  this.imageListenerKeys_ = null;
};
goog.provide("ol.style.IconOrigin");
ol.style.IconOrigin = {BOTTOM_LEFT:"bottom-left", BOTTOM_RIGHT:"bottom-right", TOP_LEFT:"top-left", TOP_RIGHT:"top-right"};
goog.provide("ol.style.Icon");
goog.require("ol");
goog.require("ol.ImageState");
goog.require("ol.asserts");
goog.require("ol.color");
goog.require("ol.events");
goog.require("ol.events.EventType");
goog.require("ol.style.IconAnchorUnits");
goog.require("ol.style.IconImage");
goog.require("ol.style.IconOrigin");
goog.require("ol.style.Image");
ol.style.Icon = function(opt_options) {
  var options = opt_options || {};
  this.anchor_ = options.anchor !== undefined ? options.anchor : [0.5, 0.5];
  this.normalizedAnchor_ = null;
  this.anchorOrigin_ = options.anchorOrigin !== undefined ? options.anchorOrigin : ol.style.IconOrigin.TOP_LEFT;
  this.anchorXUnits_ = options.anchorXUnits !== undefined ? options.anchorXUnits : ol.style.IconAnchorUnits.FRACTION;
  this.anchorYUnits_ = options.anchorYUnits !== undefined ? options.anchorYUnits : ol.style.IconAnchorUnits.FRACTION;
  this.crossOrigin_ = options.crossOrigin !== undefined ? options.crossOrigin : null;
  var image = options.img !== undefined ? options.img : null;
  var imgSize = options.imgSize !== undefined ? options.imgSize : null;
  var src = options.src;
  ol.asserts.assert(!(src !== undefined && image), 4);
  ol.asserts.assert(!image || image && imgSize, 5);
  if ((src === undefined || src.length === 0) && image) {
    src = image.src || ol.getUid(image).toString();
  }
  ol.asserts.assert(src !== undefined && src.length > 0, 6);
  var imageState = options.src !== undefined ? ol.ImageState.IDLE : ol.ImageState.LOADED;
  this.color_ = options.color !== undefined ? ol.color.asArray(options.color) : null;
  this.iconImage_ = ol.style.IconImage.get(image, src, imgSize, this.crossOrigin_, imageState, this.color_);
  this.offset_ = options.offset !== undefined ? options.offset : [0, 0];
  this.offsetOrigin_ = options.offsetOrigin !== undefined ? options.offsetOrigin : ol.style.IconOrigin.TOP_LEFT;
  this.origin_ = null;
  this.size_ = options.size !== undefined ? options.size : null;
  var opacity = options.opacity !== undefined ? options.opacity : 1;
  var rotateWithView = options.rotateWithView !== undefined ? options.rotateWithView : false;
  var rotation = options.rotation !== undefined ? options.rotation : 0;
  var scale = options.scale !== undefined ? options.scale : 1;
  var snapToPixel = options.snapToPixel !== undefined ? options.snapToPixel : true;
  ol.style.Image.call(this, {opacity:opacity, rotation:rotation, scale:scale, snapToPixel:snapToPixel, rotateWithView:rotateWithView});
};
ol.inherits(ol.style.Icon, ol.style.Image);
ol.style.Icon.prototype.clone = function() {
  return new ol.style.Icon({anchor:this.anchor_.slice(), anchorOrigin:this.anchorOrigin_, anchorXUnits:this.anchorXUnits_, anchorYUnits:this.anchorYUnits_, crossOrigin:this.crossOrigin_, color:this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || undefined, src:this.getSrc(), offset:this.offset_.slice(), offsetOrigin:this.offsetOrigin_, size:this.size_ !== null ? this.size_.slice() : undefined, opacity:this.getOpacity(), scale:this.getScale(), snapToPixel:this.getSnapToPixel(), 
  rotation:this.getRotation(), rotateWithView:this.getRotateWithView()});
};
ol.style.Icon.prototype.getAnchor = function() {
  if (this.normalizedAnchor_) {
    return this.normalizedAnchor_;
  }
  var anchor = this.anchor_;
  var size = this.getSize();
  if (this.anchorXUnits_ == ol.style.IconAnchorUnits.FRACTION || this.anchorYUnits_ == ol.style.IconAnchorUnits.FRACTION) {
    if (!size) {
      return null;
    }
    anchor = this.anchor_.slice();
    if (this.anchorXUnits_ == ol.style.IconAnchorUnits.FRACTION) {
      anchor[0] *= size[0];
    }
    if (this.anchorYUnits_ == ol.style.IconAnchorUnits.FRACTION) {
      anchor[1] *= size[1];
    }
  }
  if (this.anchorOrigin_ != ol.style.IconOrigin.TOP_LEFT) {
    if (!size) {
      return null;
    }
    if (anchor === this.anchor_) {
      anchor = this.anchor_.slice();
    }
    if (this.anchorOrigin_ == ol.style.IconOrigin.TOP_RIGHT || this.anchorOrigin_ == ol.style.IconOrigin.BOTTOM_RIGHT) {
      anchor[0] = -anchor[0] + size[0];
    }
    if (this.anchorOrigin_ == ol.style.IconOrigin.BOTTOM_LEFT || this.anchorOrigin_ == ol.style.IconOrigin.BOTTOM_RIGHT) {
      anchor[1] = -anchor[1] + size[1];
    }
  }
  this.normalizedAnchor_ = anchor;
  return this.normalizedAnchor_;
};
ol.style.Icon.prototype.getColor = function() {
  return this.color_;
};
ol.style.Icon.prototype.getImage = function(pixelRatio) {
  return this.iconImage_.getImage(pixelRatio);
};
ol.style.Icon.prototype.getImageSize = function() {
  return this.iconImage_.getSize();
};
ol.style.Icon.prototype.getHitDetectionImageSize = function() {
  return this.getImageSize();
};
ol.style.Icon.prototype.getImageState = function() {
  return this.iconImage_.getImageState();
};
ol.style.Icon.prototype.getHitDetectionImage = function(pixelRatio) {
  return this.iconImage_.getHitDetectionImage(pixelRatio);
};
ol.style.Icon.prototype.getOrigin = function() {
  if (this.origin_) {
    return this.origin_;
  }
  var offset = this.offset_;
  if (this.offsetOrigin_ != ol.style.IconOrigin.TOP_LEFT) {
    var size = this.getSize();
    var iconImageSize = this.iconImage_.getSize();
    if (!size || !iconImageSize) {
      return null;
    }
    offset = offset.slice();
    if (this.offsetOrigin_ == ol.style.IconOrigin.TOP_RIGHT || this.offsetOrigin_ == ol.style.IconOrigin.BOTTOM_RIGHT) {
      offset[0] = iconImageSize[0] - size[0] - offset[0];
    }
    if (this.offsetOrigin_ == ol.style.IconOrigin.BOTTOM_LEFT || this.offsetOrigin_ == ol.style.IconOrigin.BOTTOM_RIGHT) {
      offset[1] = iconImageSize[1] - size[1] - offset[1];
    }
  }
  this.origin_ = offset;
  return this.origin_;
};
ol.style.Icon.prototype.getSrc = function() {
  return this.iconImage_.getSrc();
};
ol.style.Icon.prototype.getSize = function() {
  return !this.size_ ? this.iconImage_.getSize() : this.size_;
};
ol.style.Icon.prototype.listenImageChange = function(listener, thisArg) {
  return ol.events.listen(this.iconImage_, ol.events.EventType.CHANGE, listener, thisArg);
};
ol.style.Icon.prototype.load = function() {
  this.iconImage_.load();
};
ol.style.Icon.prototype.unlistenImageChange = function(listener, thisArg) {
  ol.events.unlisten(this.iconImage_, ol.events.EventType.CHANGE, listener, thisArg);
};
goog.provide("olcs.core.VectorLayerCounterpart");
goog.require("ol.Observable");
olcs.core.VectorLayerCounterpart = function(layerProjection, scene) {
  var billboards = new Cesium.BillboardCollection({scene:scene});
  var primitives = new Cesium.PrimitiveCollection;
  this.olListenKeys = [];
  this.rootCollection_ = new Cesium.PrimitiveCollection;
  this.context = {projection:layerProjection, billboards:billboards, featureToCesiumMap:{}, primitives:primitives};
  this.rootCollection_.add(billboards);
  this.rootCollection_.add(primitives);
};
olcs.core.VectorLayerCounterpart.prototype.destroy = function() {
  this.olListenKeys.forEach(ol.Observable.unByKey);
  this.olListenKeys.length = 0;
};
olcs.core.VectorLayerCounterpart.prototype.getRootPrimitive = function() {
  return this.rootCollection_;
};
goog.provide("olcs.FeatureConverter");
goog.require("ol.geom.Geometry");
goog.require("ol.style.Icon");
goog.require("ol.source.Vector");
goog.require("ol.source.Cluster");
goog.require("goog.asserts");
goog.require("ol");
goog.require("ol.events");
goog.require("ol.extent");
goog.require("ol.geom.SimpleGeometry");
goog.require("olcs.core");
goog.require("olcs.core.VectorLayerCounterpart");
goog.require("olcs.util");
olcs.FeatureConverter = function(scene) {
  this.scene = scene;
  this.boundOnRemoveOrClearFeatureListener_ = this.onRemoveOrClearFeature_.bind(this);
};
olcs.FeatureConverter.prototype.onRemoveOrClearFeature_ = function(evt) {
  var source = evt.target;
  goog.asserts.assertInstanceof(source, ol.source.Vector);
  var cancellers = olcs.util.obj(source)["olcs_cancellers"];
  if (cancellers) {
    var feature = evt.feature;
    if (feature) {
      var id = ol.getUid(feature);
      var canceller = cancellers[id];
      if (canceller) {
        canceller();
        delete cancellers[id];
      }
    } else {
      for (var key in cancellers) {
        if (cancellers.hasOwnProperty(key)) {
          cancellers[key]();
        }
      }
      olcs.util.obj(source)["olcs_cancellers"] = {};
    }
  }
};
olcs.FeatureConverter.prototype.setReferenceForPicking = function(layer, feature, primitive) {
  primitive.olLayer = layer;
  primitive.olFeature = feature;
};
olcs.FeatureConverter.prototype.createColoredPrimitive = function(layer, feature, olGeometry, geometry, color, opt_lineWidth) {
  var createInstance = function(geometry, color) {
    return new Cesium.GeometryInstance({geometry:geometry, attributes:{color:Cesium.ColorGeometryInstanceAttribute.fromColor(color)}});
  };
  var options = {flat:true, renderState:{depthTest:{enabled:true}}};
  if (opt_lineWidth !== undefined) {
    if (!options.renderState) {
      options.renderState = {};
    }
    options.renderState.lineWidth = opt_lineWidth;
  }
  var instances = createInstance(geometry, color);
  var heightReference = this.getHeightReference(layer, feature, olGeometry);
  var primitive;
  if (heightReference == Cesium.HeightReference.CLAMP_TO_GROUND) {
    var ctor = instances.geometry.constructor;
    if (ctor && !ctor["createShadowVolume"]) {
      return null;
    }
    primitive = new Cesium.GroundPrimitive({geometryInstances:instances});
  } else {
    var appearance = new Cesium.PerInstanceColorAppearance(options);
    primitive = new Cesium.Primitive({geometryInstances:instances, appearance:appearance});
  }
  this.setReferenceForPicking(layer, feature, primitive);
  return primitive;
};
olcs.FeatureConverter.prototype.extractColorFromOlStyle = function(style, outline) {
  var fillColor = style.getFill() ? style.getFill().getColor() : null;
  var strokeColor = style.getStroke() ? style.getStroke().getColor() : null;
  var olColor = "black";
  if (strokeColor && outline) {
    olColor = strokeColor;
  } else {
    if (fillColor) {
      olColor = fillColor;
    }
  }
  return olcs.core.convertColorToCesium(olColor);
};
olcs.FeatureConverter.prototype.extractLineWidthFromOlStyle = function(style) {
  var width = style.getStroke() ? style.getStroke().getWidth() : undefined;
  return width !== undefined ? width : 1;
};
olcs.FeatureConverter.prototype.wrapFillAndOutlineGeometries = function(layer, feature, olGeometry, fillGeometry, outlineGeometry, olStyle) {
  var fillColor = this.extractColorFromOlStyle(olStyle, false);
  var outlineColor = this.extractColorFromOlStyle(olStyle, true);
  var primitives = new Cesium.PrimitiveCollection;
  if (olStyle.getFill()) {
    var p1 = this.createColoredPrimitive(layer, feature, olGeometry, fillGeometry, fillColor);
    goog.asserts.assert(!!p1);
    primitives.add(p1);
  }
  if (olStyle.getStroke()) {
    var width = this.extractLineWidthFromOlStyle(olStyle);
    var p2 = this.createColoredPrimitive(layer, feature, olGeometry, outlineGeometry, outlineColor, width);
    if (p2) {
      primitives.add(p2);
    }
  }
  return primitives;
};
olcs.FeatureConverter.prototype.addTextStyle = function(layer, feature, geometry, style, primitive) {
  var primitives;
  if (!(primitive instanceof Cesium.PrimitiveCollection)) {
    primitives = new Cesium.PrimitiveCollection;
    primitives.add(primitive);
  } else {
    primitives = primitive;
  }
  if (!style.getText()) {
    return primitives;
  }
  var text = style.getText();
  var label = this.olGeometry4326TextPartToCesium(layer, feature, geometry, text);
  if (label) {
    primitives.add(label);
  }
  return primitives;
};
olcs.FeatureConverter.prototype.csAddBillboard = function(billboards, bbOptions, layer, feature, geometry, style) {
  var bb = billboards.add(bbOptions);
  this.setReferenceForPicking(layer, feature, bb);
  return bb;
};
olcs.FeatureConverter.prototype.olCircleGeometryToCesium = function(layer, feature, olGeometry, projection, olStyle) {
  olGeometry = olcs.core.olGeometryCloneTo4326(olGeometry, projection);
  goog.asserts.assert(olGeometry.getType() == "Circle");
  var center = olGeometry.getCenter();
  var height = center.length == 3 ? center[2] : 0.0;
  var point = center.slice();
  point[0] += olGeometry.getRadius();
  center = olcs.core.ol4326CoordinateToCesiumCartesian(center);
  point = olcs.core.ol4326CoordinateToCesiumCartesian(point);
  var radius = Cesium.Cartesian3.distance(center, point);
  var fillGeometry = new Cesium.CircleGeometry({center:center, radius:radius, height:height});
  var outlineGeometry = new Cesium.CircleOutlineGeometry({center:center, radius:radius, extrudedHeight:height, height:height});
  var primitives = this.wrapFillAndOutlineGeometries(layer, feature, olGeometry, fillGeometry, outlineGeometry, olStyle);
  return this.addTextStyle(layer, feature, olGeometry, olStyle, primitives);
};
olcs.FeatureConverter.prototype.createStackedGroundCorridors = function(layer, feature, width, color, positions) {
  var previousDistance = 0;
  width = Math.max(3, width);
  var geometryInstances = [];
  for (var $jscomp$iter$2 = $jscomp.makeIterator([1000, 4000, 16000, 64000, 254000, 1000000, 10000000]), $jscomp$key$distance = $jscomp$iter$2.next(); !$jscomp$key$distance.done; $jscomp$key$distance = $jscomp$iter$2.next()) {
    var distance = $jscomp$key$distance.value;
    {
      width *= 2.14;
      var geometryOptions = {positions:positions, width:width, vertexFormat:Cesium.VertexFormat.POSITION_ONLY};
      geometryInstances.push(new Cesium.GeometryInstance({geometry:new Cesium.CorridorGeometry(geometryOptions), attributes:{color:Cesium.ColorGeometryInstanceAttribute.fromColor(color), distanceDisplayCondition:new Cesium.DistanceDisplayConditionGeometryInstanceAttribute(previousDistance, distance - 1)}}));
      previousDistance = distance;
    }
  }
  return new Cesium.GroundPrimitive({geometryInstances:geometryInstances});
};
olcs.FeatureConverter.prototype.olLineStringGeometryToCesium = function(layer, feature, olGeometry, projection, olStyle) {
  olGeometry = olcs.core.olGeometryCloneTo4326(olGeometry, projection);
  goog.asserts.assert(olGeometry.getType() == "LineString");
  var positions = olcs.core.ol4326CoordinateArrayToCsCartesians(olGeometry.getCoordinates());
  var width = this.extractLineWidthFromOlStyle(olStyle);
  var outlinePrimitive;
  var heightReference = this.getHeightReference(layer, feature, olGeometry);
  if (heightReference == Cesium.HeightReference.CLAMP_TO_GROUND) {
    var color = this.extractColorFromOlStyle(olStyle, true);
    outlinePrimitive = this.createStackedGroundCorridors(layer, feature, width, color, positions);
  } else {
    var appearance = new Cesium.PolylineMaterialAppearance({material:this.olStyleToCesium(feature, olStyle, true)});
    var geometryOptions = {positions:positions, width:width, vertexFormat:appearance.vertexFormat};
    outlinePrimitive = new Cesium.Primitive({geometryInstances:new Cesium.GeometryInstance({geometry:new Cesium.PolylineGeometry(geometryOptions)}), appearance:appearance});
  }
  this.setReferenceForPicking(layer, feature, outlinePrimitive);
  return this.addTextStyle(layer, feature, olGeometry, olStyle, outlinePrimitive);
};
olcs.FeatureConverter.prototype.olPolygonGeometryToCesium = function(layer, feature, olGeometry, projection, olStyle) {
  olGeometry = olcs.core.olGeometryCloneTo4326(olGeometry, projection);
  goog.asserts.assert(olGeometry.getType() == "Polygon");
  var fillGeometry, outlineGeometry;
  if (olGeometry.getCoordinates()[0].length == 5 && feature.getGeometry().get("olcs.polygon_kind") === "rectangle") {
    var coordinates = olGeometry.getCoordinates()[0];
    var extent = ol.extent.boundingExtent(coordinates);
    var rectangle = Cesium.Rectangle.fromDegrees(extent[0], extent[1], extent[2], extent[3]);
    var maxHeight = 0.0;
    if (coordinates[0].length == 3) {
      for (var c = 0; c < coordinates.length; c++) {
        maxHeight = Math.max(maxHeight, coordinates[c][2]);
      }
    }
    fillGeometry = new Cesium.RectangleGeometry({ellipsoid:Cesium.Ellipsoid.WGS84, rectangle:rectangle, height:maxHeight});
    outlineGeometry = new Cesium.RectangleOutlineGeometry({ellipsoid:Cesium.Ellipsoid.WGS84, rectangle:rectangle, height:maxHeight});
  } else {
    var rings = olGeometry.getLinearRings();
    var hierarchy = {};
    var polygonHierarchy = hierarchy;
    goog.asserts.assert(rings.length > 0);
    for (var i = 0; i < rings.length; ++i) {
      var olPos = rings[i].getCoordinates();
      var positions = olcs.core.ol4326CoordinateArrayToCsCartesians(olPos);
      goog.asserts.assert(positions && positions.length > 0);
      if (i == 0) {
        hierarchy.positions = positions;
      } else {
        if (!hierarchy.holes) {
          hierarchy.holes = [];
        }
        hierarchy.holes.push({positions:positions});
      }
    }
    fillGeometry = new Cesium.PolygonGeometry({polygonHierarchy:polygonHierarchy, perPositionHeight:true});
    outlineGeometry = new Cesium.PolygonOutlineGeometry({polygonHierarchy:hierarchy, perPositionHeight:true});
  }
  var primitives = this.wrapFillAndOutlineGeometries(layer, feature, olGeometry, fillGeometry, outlineGeometry, olStyle);
  return this.addTextStyle(layer, feature, olGeometry, olStyle, primitives);
};
olcs.FeatureConverter.prototype.getHeightReference = function(layer, feature, geometry) {
  var altitudeMode = geometry.get("altitudeMode");
  if (altitudeMode === undefined) {
    altitudeMode = feature.get("altitudeMode");
  }
  if (altitudeMode === undefined) {
    altitudeMode = layer.get("altitudeMode");
  }
  var heightReference = Cesium.HeightReference.NONE;
  if (altitudeMode === "clampToGround") {
    heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;
  } else {
    if (altitudeMode === "relativeToGround") {
      heightReference = Cesium.HeightReference.RELATIVE_TO_GROUND;
    }
  }
  return heightReference;
};
olcs.FeatureConverter.prototype.createBillboardFromImage = function(layer, feature, olGeometry, projection, style, imageStyle, billboards, opt_newBillboardCallback) {
  if (imageStyle instanceof ol.style.Icon) {
    imageStyle.load();
  }
  var image = imageStyle.getImage(1);
  var isImageLoaded = function(image) {
    return image.src != "" && image.naturalHeight != 0 && image.naturalWidth != 0 && image.complete;
  };
  var reallyCreateBillboard = function() {
    if (!image) {
      return;
    }
    if (!(image instanceof HTMLCanvasElement || image instanceof Image || image instanceof HTMLImageElement)) {
      return;
    }
    var center = olGeometry.getCoordinates();
    var position = olcs.core.ol4326CoordinateToCesiumCartesian(center);
    var color;
    var opacity = imageStyle.getOpacity();
    if (opacity !== undefined) {
      color = new Cesium.Color(1.0, 1.0, 1.0, opacity);
    }
    var heightReference = this.getHeightReference(layer, feature, olGeometry);
    var bbOptions = {image:image, color:color, scale:imageStyle.getScale(), heightReference:heightReference, verticalOrigin:Cesium.VerticalOrigin.BOTTOM, position:position};
    var bb = this.csAddBillboard(billboards, bbOptions, layer, feature, olGeometry, style);
    if (opt_newBillboardCallback) {
      opt_newBillboardCallback(bb);
    }
  }.bind(this);
  if (image instanceof Image && !isImageLoaded(image)) {
    var cancelled = false;
    var source = layer.getSource();
    var canceller = function() {
      cancelled = true;
    };
    source.on(["removefeature", "clear"], this.boundOnRemoveOrClearFeatureListener_);
    var cancellers = olcs.util.obj(source)["olcs_cancellers"];
    if (!cancellers) {
      cancellers = olcs.util.obj(source)["olcs_cancellers"] = {};
    }
    var fuid = ol.getUid(feature);
    if (cancellers[fuid]) {
      cancellers[fuid]();
    }
    cancellers[fuid] = canceller;
    var listener = function() {
      if (!billboards.isDestroyed() && !cancelled) {
        reallyCreateBillboard();
      }
    };
    ol.events.listenOnce(image, "load", listener);
  } else {
    reallyCreateBillboard();
  }
};
olcs.FeatureConverter.prototype.olPointGeometryToCesium = function(layer, feature, olGeometry, projection, style, billboards, opt_newBillboardCallback) {
  goog.asserts.assert(olGeometry.getType() == "Point");
  olGeometry = olcs.core.olGeometryCloneTo4326(olGeometry, projection);
  var modelPrimitive = null;
  var imageStyle = style.getImage();
  if (imageStyle) {
    var olcsModelFunction = olGeometry.get("olcs_model") || feature.get("olcs_model");
    if (olcsModelFunction) {
      var olcsModel = olcsModelFunction();
      var options = Object.assign({}, {scene:this.scene}, olcsModel.cesiumOptions);
      var model = Cesium.Model.fromGltf(options);
      modelPrimitive = new Cesium.PrimitiveCollection;
      modelPrimitive.add(model);
      if (olcsModel.debugModelMatrix) {
        modelPrimitive.add(new Cesium.DebugModelMatrixPrimitive({modelMatrix:olcsModel.debugModelMatrix}));
      }
    } else {
      this.createBillboardFromImage(layer, feature, olGeometry, projection, style, imageStyle, billboards, opt_newBillboardCallback);
    }
  }
  if (style.getText()) {
    return this.addTextStyle(layer, feature, olGeometry, style, modelPrimitive || new Cesium.Primitive);
  } else {
    return modelPrimitive;
  }
};
olcs.FeatureConverter.prototype.olMultiGeometryToCesium = function(layer, feature, geometry, projection, olStyle, billboards, opt_newBillboardCallback) {
  var $jscomp$this = this;
  var accumulate = function(geometries, functor) {
    var primitives = new Cesium.PrimitiveCollection;
    geometries.forEach(function(geometry) {
      primitives.add(functor(layer, feature, geometry, projection, olStyle));
    });
    return primitives;
  };
  var subgeos;
  switch(geometry.getType()) {
    case "MultiPoint":
      geometry = geometry;
      subgeos = geometry.getPoints();
      if (olStyle.getText()) {
        var primitives = new Cesium.PrimitiveCollection;
        subgeos.forEach(function(geometry) {
          goog.asserts.assert(geometry);
          var result = $jscomp$this.olPointGeometryToCesium(layer, feature, geometry, projection, olStyle, billboards, opt_newBillboardCallback);
          if (result) {
            primitives.add(result);
          }
        });
        return primitives;
      } else {
        subgeos.forEach(function(geometry) {
          goog.asserts.assert(geometry);
          $jscomp$this.olPointGeometryToCesium(layer, feature, geometry, projection, olStyle, billboards, opt_newBillboardCallback);
        });
        return null;
      }
    case "MultiLineString":
      geometry = geometry;
      subgeos = geometry.getLineStrings();
      return accumulate(subgeos, this.olLineStringGeometryToCesium.bind(this));
    case "MultiPolygon":
      geometry = geometry;
      subgeos = geometry.getPolygons();
      return accumulate(subgeos, this.olPolygonGeometryToCesium.bind(this));
    default:
      goog.asserts.fail("Unhandled multi geometry type" + geometry.getType());
  }
};
olcs.FeatureConverter.prototype.olGeometry4326TextPartToCesium = function(layer, feature, geometry, style) {
  var text = style.getText();
  goog.asserts.assert(text !== undefined);
  var labels = new Cesium.LabelCollection({scene:this.scene});
  var extentCenter = ol.extent.getCenter(geometry.getExtent());
  if (geometry instanceof ol.geom.SimpleGeometry) {
    var first = geometry.getFirstCoordinate();
    extentCenter[2] = first.length == 3 ? first[2] : 0.0;
  }
  var options = {};
  options.position = olcs.core.ol4326CoordinateToCesiumCartesian(extentCenter);
  options.text = text;
  options.heightReference = this.getHeightReference(layer, feature, geometry);
  var offsetX = style.getOffsetX();
  var offsetY = style.getOffsetY();
  if (offsetX != 0 && offsetY != 0) {
    var offset = new Cesium.Cartesian2(offsetX, offsetY);
    options.pixelOffset = offset;
  }
  options.font = style.getFont() || "10px sans-serif";
  var labelStyle = undefined;
  if (style.getFill()) {
    options.fillColor = this.extractColorFromOlStyle(style, false);
    labelStyle = Cesium.LabelStyle.FILL;
  }
  if (style.getStroke()) {
    options.outlineWidth = this.extractLineWidthFromOlStyle(style);
    options.outlineColor = this.extractColorFromOlStyle(style, true);
    labelStyle = Cesium.LabelStyle.OUTLINE;
  }
  if (style.getFill() && style.getStroke()) {
    labelStyle = Cesium.LabelStyle.FILL_AND_OUTLINE;
  }
  options.style = labelStyle;
  var horizontalOrigin;
  switch(style.getTextAlign()) {
    case "left":
      horizontalOrigin = Cesium.HorizontalOrigin.LEFT;
      break;
    case "right":
      horizontalOrigin = Cesium.HorizontalOrigin.RIGHT;
      break;
    case "center":
    default:
      horizontalOrigin = Cesium.HorizontalOrigin.CENTER;
  }
  options.horizontalOrigin = horizontalOrigin;
  if (style.getTextBaseline()) {
    var verticalOrigin;
    switch(style.getTextBaseline()) {
      case "top":
        verticalOrigin = Cesium.VerticalOrigin.TOP;
        break;
      case "middle":
        verticalOrigin = Cesium.VerticalOrigin.CENTER;
        break;
      case "bottom":
        verticalOrigin = Cesium.VerticalOrigin.BOTTOM;
        break;
      case "alphabetic":
        verticalOrigin = Cesium.VerticalOrigin.TOP;
        break;
      case "hanging":
        verticalOrigin = Cesium.VerticalOrigin.BOTTOM;
        break;
      default:
        goog.asserts.fail("unhandled baseline " + style.getTextBaseline());
    }
    options.verticalOrigin = verticalOrigin;
  }
  var l = labels.add(options);
  this.setReferenceForPicking(layer, feature, l);
  return labels;
};
olcs.FeatureConverter.prototype.olStyleToCesium = function(feature, style, outline) {
  var fill = style.getFill();
  var stroke = style.getStroke();
  if (outline && !stroke || !outline && !fill) {
    return null;
  }
  var color = outline ? stroke.getColor() : fill.getColor();
  color = olcs.core.convertColorToCesium(color);
  if (outline && stroke.getLineDash()) {
    return Cesium.Material.fromType("Stripe", {horizontal:false, repeat:500, evenColor:color, oddColor:new Cesium.Color(0, 0, 0, 0)});
  } else {
    return Cesium.Material.fromType("Color", {color:color});
  }
};
olcs.FeatureConverter.prototype.computePlainStyle = function(layer, feature, fallbackStyleFunction, resolution) {
  var featureStyleFunction = feature.getStyleFunction();
  var style = null;
  if (featureStyleFunction) {
    style = featureStyleFunction.call(feature, resolution);
  }
  if (!style && fallbackStyleFunction) {
    style = fallbackStyleFunction(feature, resolution);
  }
  if (!style) {
    return null;
  }
  return Array.isArray(style) ? style : [style];
};
olcs.FeatureConverter.prototype.getGeometryFromFeature = function(feature, style, opt_geom) {
  if (opt_geom) {
    return opt_geom;
  }
  var geom3d = feature.get("olcs.3d_geometry");
  if (geom3d && geom3d instanceof ol.geom.Geometry) {
    return geom3d;
  }
  if (style) {
    var geomFuncRes = style.getGeometryFunction()(feature);
    if (geomFuncRes instanceof ol.geom.Geometry) {
      return geomFuncRes;
    }
  }
  return feature.getGeometry();
};
olcs.FeatureConverter.prototype.olFeatureToCesium = function(layer, feature, style, context, opt_geom) {
  var $jscomp$this = this;
  var geom = this.getGeometryFromFeature(feature, style, opt_geom);
  if (!geom) {
    return null;
  }
  var proj = context.projection;
  var newBillboardAddedCallback = function(bb) {
    var featureBb = context.featureToCesiumMap[ol.getUid(feature)];
    if (featureBb instanceof Array) {
      featureBb.push(bb);
    } else {
      context.featureToCesiumMap[ol.getUid(feature)] = [bb];
    }
  };
  switch(geom.getType()) {
    case "GeometryCollection":
      var primitives = new Cesium.PrimitiveCollection;
      var collection = geom;
      collection.getGeometries().forEach(function(geom) {
        if (geom) {
          var prims = $jscomp$this.olFeatureToCesium(layer, feature, style, context, geom);
          if (prims) {
            primitives.add(prims);
          }
        }
      });
      return primitives;
    case "Point":
      geom = geom;
      var bbs = context.billboards;
      var result = this.olPointGeometryToCesium(layer, feature, geom, proj, style, bbs, newBillboardAddedCallback);
      if (!result) {
        return null;
      } else {
        return result;
      }
    case "Circle":
      geom = geom;
      return this.olCircleGeometryToCesium(layer, feature, geom, proj, style);
    case "LineString":
      geom = geom;
      return this.olLineStringGeometryToCesium(layer, feature, geom, proj, style);
    case "Polygon":
      geom = geom;
      return this.olPolygonGeometryToCesium(layer, feature, geom, proj, style);
    case "MultiPoint":
    case "MultiLineString":
    case "MultiPolygon":
      var result2 = this.olMultiGeometryToCesium(layer, feature, geom, proj, style, context.billboards, newBillboardAddedCallback);
      if (!result2) {
        return null;
      } else {
        return result2;
      }
    case "LinearRing":
      throw new Error("LinearRing should only be part of polygon.");
    default:
      throw new Error("Ol geom type not handled : " + geom.getType());
  }
};
olcs.FeatureConverter.prototype.olVectorLayerToCesium = function(olLayer, olView, featurePrimitiveMap) {
  var proj = olView.getProjection();
  var resolution = olView.getResolution();
  if (resolution === undefined || !proj) {
    goog.asserts.fail("View not ready");
    throw new Error("View not ready");
  }
  var source = olLayer.getSource();
  if (source instanceof ol.source.Cluster) {
    source = source.getSource();
  }
  goog.asserts.assertInstanceof(source, ol.source.Vector);
  var features = source.getFeatures();
  var counterpart = new olcs.core.VectorLayerCounterpart(proj, this.scene);
  var context = counterpart.context;
  for (var i = 0; i < features.length; ++i) {
    var feature = features[i];
    if (!feature) {
      continue;
    }
    var layerStyle = olLayer.getStyleFunction();
    var styles = this.computePlainStyle(olLayer, feature, layerStyle, resolution);
    if (!styles || !styles.length) {
      continue;
    }
    var primitives = null;
    for (var i$7 = 0; i$7 < styles.length; i$7++) {
      var prims = this.olFeatureToCesium(olLayer, feature, styles[i$7], context);
      if (prims) {
        if (!primitives) {
          primitives = prims;
        } else {
          if (prims) {
            var i$8 = 0, prim;
            while (prim = prims.get(i$8)) {
              primitives.add(prim);
              i$8++;
            }
          }
        }
      }
    }
    if (!primitives) {
      continue;
    }
    featurePrimitiveMap[ol.getUid(feature)] = primitives;
    counterpart.getRootPrimitive().add(primitives);
  }
  return counterpart;
};
olcs.FeatureConverter.prototype.convert = function(layer, view, feature, context) {
  var proj = view.getProjection();
  var resolution = view.getResolution();
  if (resolution == undefined || !proj) {
    return null;
  }
  var layerStyle = layer.getStyleFunction();
  var styles = this.computePlainStyle(layer, feature, layerStyle, resolution);
  if (!styles.length) {
    return null;
  }
  context.projection = proj;
  var primitives = null;
  for (var i = 0; i < styles.length; i++) {
    var prims = this.olFeatureToCesium(layer, feature, styles[i], context);
    if (!primitives) {
      primitives = prims;
    } else {
      if (prims) {
        var i$9 = 0, prim;
        while (prim = prims.get(i$9)) {
          primitives.add(prim);
          i$9++;
        }
      }
    }
  }
  return primitives;
};
goog.provide("olcs.VectorSynchronizer");
goog.require("ol.source.Vector");
goog.require("ol.layer.Layer");
goog.require("ol.source.Cluster");
goog.require("ol.layer.Image");
goog.require("goog.asserts");
goog.require("ol");
goog.require("ol.events");
goog.require("ol.layer.Vector");
goog.require("olcs.AbstractSynchronizer");
goog.require("olcs.FeatureConverter");
olcs.VectorSynchronizer = function(map, scene, opt_converter) {
  this.converter = opt_converter || new olcs.FeatureConverter(scene);
  this.csAllPrimitives_ = new Cesium.PrimitiveCollection;
  scene.primitives.add(this.csAllPrimitives_);
  this.csAllPrimitives_.destroyPrimitives = false;
  olcs.AbstractSynchronizer.call(this, map, scene);
};
ol.inherits(olcs.VectorSynchronizer, olcs.AbstractSynchronizer);
olcs.VectorSynchronizer.prototype.addCesiumObject = function(counterpart) {
  goog.asserts.assert(counterpart);
  counterpart.getRootPrimitive()["counterpart"] = counterpart;
  this.csAllPrimitives_.add(counterpart.getRootPrimitive());
};
olcs.VectorSynchronizer.prototype.destroyCesiumObject = function(object) {
  object.getRootPrimitive().destroy();
};
olcs.VectorSynchronizer.prototype.removeSingleCesiumObject = function(object, destroy) {
  object.destroy();
  this.csAllPrimitives_.destroyPrimitives = destroy;
  this.csAllPrimitives_.remove(object.getRootPrimitive());
  this.csAllPrimitives_.destroyPrimitives = false;
};
olcs.VectorSynchronizer.prototype.removeAllCesiumObjects = function(destroy) {
  this.csAllPrimitives_.destroyPrimitives = destroy;
  if (destroy) {
    for (var i = 0; i < this.csAllPrimitives_.length; ++i) {
      this.csAllPrimitives_.get(i)["counterpart"].destroy();
    }
  }
  this.csAllPrimitives_.removeAll();
  this.csAllPrimitives_.destroyPrimitives = false;
};
olcs.VectorSynchronizer.prototype.updateLayerVisibility = function(olLayerWithParents, csPrimitive) {
  var visible = true;
  [olLayerWithParents.layer].concat(olLayerWithParents.parents).forEach(function(olLayer) {
    var layerVisible = olLayer.getVisible();
    if (layerVisible !== undefined) {
      visible &= layerVisible;
    } else {
      visible = false;
    }
  });
  csPrimitive.show = visible;
};
olcs.VectorSynchronizer.prototype.createSingleLayerCounterparts = function(olLayerWithParents) {
  var $jscomp$this = this;
  var olLayer = olLayerWithParents.layer;
  if (!(olLayer instanceof ol.layer.Vector)) {
    return null;
  }
  goog.asserts.assertInstanceof(olLayer, ol.layer.Layer);
  var source = olLayer.getSource();
  if (source instanceof ol.source.Cluster) {
    source = source.getSource();
  }
  goog.asserts.assertInstanceof(source, ol.source.Vector);
  goog.asserts.assert(this.view);
  var view = this.view;
  var featurePrimitiveMap = {};
  var counterpart = this.converter.olVectorLayerToCesium(olLayer, view, featurePrimitiveMap);
  var csPrimitives = counterpart.getRootPrimitive();
  var olListenKeys = counterpart.olListenKeys;
  [olLayerWithParents.layer].concat(olLayerWithParents.parents).forEach(function(olLayerItem) {
    olListenKeys.push(ol.events.listen(olLayerItem, "change:visible", function() {
      $jscomp$this.updateLayerVisibility(olLayerWithParents, csPrimitives);
    }));
  });
  this.updateLayerVisibility(olLayerWithParents, csPrimitives);
  var onAddFeature = function(feature) {
    goog.asserts.assert(olLayer instanceof ol.layer.Vector || olLayer instanceof ol.layer.Image);
    var context = counterpart.context;
    var prim = this.converter.convert(olLayer, view, feature, context);
    if (prim) {
      featurePrimitiveMap[ol.getUid(feature)] = prim;
      csPrimitives.add(prim);
    }
  }.bind(this);
  var onRemoveFeature = function(feature) {
    var id = ol.getUid(feature);
    var context = counterpart.context;
    var bbs = context.featureToCesiumMap[id];
    if (bbs) {
      delete context.featureToCesiumMap[id];
      bbs.forEach(function(bb) {
        if (bb instanceof Cesium.Billboard) {
          context.billboards.remove(bb);
        }
      });
    }
    var csPrimitive = featurePrimitiveMap[id];
    delete featurePrimitiveMap[id];
    if (csPrimitive) {
      csPrimitives.remove(csPrimitive);
    }
  }.bind(this);
  olListenKeys.push(ol.events.listen(source, "addfeature", function(e) {
    goog.asserts.assert(e.feature);
    onAddFeature(e.feature);
  }, this));
  olListenKeys.push(ol.events.listen(source, "removefeature", function(e) {
    goog.asserts.assert(e.feature);
    onRemoveFeature(e.feature);
  }, this));
  olListenKeys.push(ol.events.listen(source, "changefeature", function(e) {
    var feature = e.feature;
    goog.asserts.assert(feature);
    onRemoveFeature(feature);
    onAddFeature(feature);
  }, this));
  return counterpart ? [counterpart] : null;
};
goog.provide("ol.MapEventType");
ol.MapEventType = {POSTRENDER:"postrender", MOVESTART:"movestart", MOVEEND:"moveend"};
goog.provide("ol.OverlayPositioning");
ol.OverlayPositioning = {BOTTOM_LEFT:"bottom-left", BOTTOM_CENTER:"bottom-center", BOTTOM_RIGHT:"bottom-right", CENTER_LEFT:"center-left", CENTER_CENTER:"center-center", CENTER_RIGHT:"center-right", TOP_LEFT:"top-left", TOP_CENTER:"top-center", TOP_RIGHT:"top-right"};
goog.provide("ol.Overlay");
goog.require("ol");
goog.require("ol.MapEventType");
goog.require("ol.Object");
goog.require("ol.OverlayPositioning");
goog.require("ol.css");
goog.require("ol.dom");
goog.require("ol.events");
goog.require("ol.extent");
ol.Overlay = function(options) {
  ol.Object.call(this);
  this.options = options;
  this.id = options.id;
  this.insertFirst = options.insertFirst !== undefined ? options.insertFirst : true;
  this.stopEvent = options.stopEvent !== undefined ? options.stopEvent : true;
  this.element = document.createElement("DIV");
  this.element.className = options.className !== undefined ? options.className : "ol-overlay-container " + ol.css.CLASS_SELECTABLE;
  this.element.style.position = "absolute";
  this.autoPan = options.autoPan !== undefined ? options.autoPan : false;
  this.autoPanAnimation = options.autoPanAnimation || {};
  this.autoPanMargin = options.autoPanMargin !== undefined ? options.autoPanMargin : 20;
  this.rendered = {bottom_:"", left_:"", right_:"", top_:"", visible:true};
  this.mapPostrenderListenerKey = null;
  ol.events.listen(this, ol.Object.getChangeEventType(ol.Overlay.Property.ELEMENT), this.handleElementChanged, this);
  ol.events.listen(this, ol.Object.getChangeEventType(ol.Overlay.Property.MAP), this.handleMapChanged, this);
  ol.events.listen(this, ol.Object.getChangeEventType(ol.Overlay.Property.OFFSET), this.handleOffsetChanged, this);
  ol.events.listen(this, ol.Object.getChangeEventType(ol.Overlay.Property.POSITION), this.handlePositionChanged, this);
  ol.events.listen(this, ol.Object.getChangeEventType(ol.Overlay.Property.POSITIONING), this.handlePositioningChanged, this);
  if (options.element !== undefined) {
    this.setElement(options.element);
  }
  this.setOffset(options.offset !== undefined ? options.offset : [0, 0]);
  this.setPositioning(options.positioning !== undefined ? options.positioning : ol.OverlayPositioning.TOP_LEFT);
  if (options.position !== undefined) {
    this.setPosition(options.position);
  }
};
ol.inherits(ol.Overlay, ol.Object);
ol.Overlay.prototype.getElement = function() {
  return this.get(ol.Overlay.Property.ELEMENT);
};
ol.Overlay.prototype.getId = function() {
  return this.id;
};
ol.Overlay.prototype.getMap = function() {
  return this.get(ol.Overlay.Property.MAP);
};
ol.Overlay.prototype.getOffset = function() {
  return this.get(ol.Overlay.Property.OFFSET);
};
ol.Overlay.prototype.getPosition = function() {
  return this.get(ol.Overlay.Property.POSITION);
};
ol.Overlay.prototype.getPositioning = function() {
  return this.get(ol.Overlay.Property.POSITIONING);
};
ol.Overlay.prototype.handleElementChanged = function() {
  ol.dom.removeChildren(this.element);
  var element = this.getElement();
  if (element) {
    this.element.appendChild(element);
  }
};
ol.Overlay.prototype.handleMapChanged = function() {
  if (this.mapPostrenderListenerKey) {
    ol.dom.removeNode(this.element);
    ol.events.unlistenByKey(this.mapPostrenderListenerKey);
    this.mapPostrenderListenerKey = null;
  }
  var map = this.getMap();
  if (map) {
    this.mapPostrenderListenerKey = ol.events.listen(map, ol.MapEventType.POSTRENDER, this.render, this);
    this.updatePixelPosition();
    var container = this.stopEvent ? map.getOverlayContainerStopEvent() : map.getOverlayContainer();
    if (this.insertFirst) {
      container.insertBefore(this.element, container.childNodes[0] || null);
    } else {
      container.appendChild(this.element);
    }
  }
};
ol.Overlay.prototype.render = function() {
  this.updatePixelPosition();
};
ol.Overlay.prototype.handleOffsetChanged = function() {
  this.updatePixelPosition();
};
ol.Overlay.prototype.handlePositionChanged = function() {
  this.updatePixelPosition();
  if (this.get(ol.Overlay.Property.POSITION) && this.autoPan) {
    this.panIntoView();
  }
};
ol.Overlay.prototype.handlePositioningChanged = function() {
  this.updatePixelPosition();
};
ol.Overlay.prototype.setElement = function(element) {
  this.set(ol.Overlay.Property.ELEMENT, element);
};
ol.Overlay.prototype.setMap = function(map) {
  this.set(ol.Overlay.Property.MAP, map);
};
ol.Overlay.prototype.setOffset = function(offset) {
  this.set(ol.Overlay.Property.OFFSET, offset);
};
ol.Overlay.prototype.setPosition = function(position) {
  this.set(ol.Overlay.Property.POSITION, position);
};
ol.Overlay.prototype.panIntoView = function() {
  var map = this.getMap();
  if (!map || !map.getTargetElement()) {
    return;
  }
  var mapRect = this.getRect(map.getTargetElement(), map.getSize());
  var element = this.getElement();
  var overlayRect = this.getRect(element, [ol.dom.outerWidth(element), ol.dom.outerHeight(element)]);
  var margin = this.autoPanMargin;
  if (!ol.extent.containsExtent(mapRect, overlayRect)) {
    var offsetLeft = overlayRect[0] - mapRect[0];
    var offsetRight = mapRect[2] - overlayRect[2];
    var offsetTop = overlayRect[1] - mapRect[1];
    var offsetBottom = mapRect[3] - overlayRect[3];
    var delta = [0, 0];
    if (offsetLeft < 0) {
      delta[0] = offsetLeft - margin;
    } else {
      if (offsetRight < 0) {
        delta[0] = Math.abs(offsetRight) + margin;
      }
    }
    if (offsetTop < 0) {
      delta[1] = offsetTop - margin;
    } else {
      if (offsetBottom < 0) {
        delta[1] = Math.abs(offsetBottom) + margin;
      }
    }
    if (delta[0] !== 0 || delta[1] !== 0) {
      var center = map.getView().getCenter();
      var centerPx = map.getPixelFromCoordinate(center);
      var newCenterPx = [centerPx[0] + delta[0], centerPx[1] + delta[1]];
      map.getView().animate({center:map.getCoordinateFromPixel(newCenterPx), duration:this.autoPanAnimation.duration, easing:this.autoPanAnimation.easing});
    }
  }
};
ol.Overlay.prototype.getRect = function(element, size) {
  var box = element.getBoundingClientRect();
  var offsetX = box.left + window.pageXOffset;
  var offsetY = box.top + window.pageYOffset;
  return [offsetX, offsetY, offsetX + size[0], offsetY + size[1]];
};
ol.Overlay.prototype.setPositioning = function(positioning) {
  this.set(ol.Overlay.Property.POSITIONING, positioning);
};
ol.Overlay.prototype.setVisible = function(visible) {
  if (this.rendered.visible !== visible) {
    this.element.style.display = visible ? "" : "none";
    this.rendered.visible = visible;
  }
};
ol.Overlay.prototype.updatePixelPosition = function() {
  var map = this.getMap();
  var position = this.getPosition();
  if (!map || !map.isRendered() || !position) {
    this.setVisible(false);
    return;
  }
  var pixel = map.getPixelFromCoordinate(position);
  var mapSize = map.getSize();
  this.updateRenderedPosition(pixel, mapSize);
};
ol.Overlay.prototype.updateRenderedPosition = function(pixel, mapSize) {
  var style = this.element.style;
  var offset = this.getOffset();
  var positioning = this.getPositioning();
  this.setVisible(true);
  var offsetX = offset[0];
  var offsetY = offset[1];
  if (positioning == ol.OverlayPositioning.BOTTOM_RIGHT || positioning == ol.OverlayPositioning.CENTER_RIGHT || positioning == ol.OverlayPositioning.TOP_RIGHT) {
    if (this.rendered.left_ !== "") {
      this.rendered.left_ = style.left = "";
    }
    var right = Math.round(mapSize[0] - pixel[0] - offsetX) + "px";
    if (this.rendered.right_ != right) {
      this.rendered.right_ = style.right = right;
    }
  } else {
    if (this.rendered.right_ !== "") {
      this.rendered.right_ = style.right = "";
    }
    if (positioning == ol.OverlayPositioning.BOTTOM_CENTER || positioning == ol.OverlayPositioning.CENTER_CENTER || positioning == ol.OverlayPositioning.TOP_CENTER) {
      offsetX -= this.element.offsetWidth / 2;
    }
    var left = Math.round(pixel[0] + offsetX) + "px";
    if (this.rendered.left_ != left) {
      this.rendered.left_ = style.left = left;
    }
  }
  if (positioning == ol.OverlayPositioning.BOTTOM_LEFT || positioning == ol.OverlayPositioning.BOTTOM_CENTER || positioning == ol.OverlayPositioning.BOTTOM_RIGHT) {
    if (this.rendered.top_ !== "") {
      this.rendered.top_ = style.top = "";
    }
    var bottom = Math.round(mapSize[1] - pixel[1] - offsetY) + "px";
    if (this.rendered.bottom_ != bottom) {
      this.rendered.bottom_ = style.bottom = bottom;
    }
  } else {
    if (this.rendered.bottom_ !== "") {
      this.rendered.bottom_ = style.bottom = "";
    }
    if (positioning == ol.OverlayPositioning.CENTER_LEFT || positioning == ol.OverlayPositioning.CENTER_CENTER || positioning == ol.OverlayPositioning.CENTER_RIGHT) {
      offsetY -= this.element.offsetHeight / 2;
    }
    var top = Math.round(pixel[1] + offsetY) + "px";
    if (this.rendered.top_ != top) {
      this.rendered.top_ = style.top = top;
    }
  }
};
ol.Overlay.prototype.getOptions = function() {
  return this.options;
};
ol.Overlay.Property = {ELEMENT:"element", MAP:"map", OFFSET:"offset", POSITION:"position", POSITIONING:"positioning"};
goog.provide("olcs.SynchronizedOverlay");
goog.require("ol");
goog.require("ol.Overlay");
goog.require("ol.proj");
goog.require("ol.dom");
goog.require("ol.Observable");
olcs.SynchronizedOverlay = function(options) {
  this.scenePostRenderListenerRemover_ = null;
  this.scene_ = options.scene;
  this.synchronizer_ = options.synchronizer;
  this.parent_ = options.parent;
  this.positionWGS84_ = undefined;
  this.observer_ = new MutationObserver(this.handleElementChanged.bind(this));
  this.attributeObserver_ = [];
  this.listenerKeys_ = [];
  this.listenerKeys_.push(this.parent_.on("change:position", this.setPropertyFromEvent_.bind(this)));
  this.listenerKeys_.push(this.parent_.on("change:element", this.setPropertyFromEvent_.bind(this)));
  this.listenerKeys_.push(this.parent_.on("change:offset", this.setPropertyFromEvent_.bind(this)));
  this.listenerKeys_.push(this.parent_.on("change:position", this.setPropertyFromEvent_.bind(this)));
  this.listenerKeys_.push(this.parent_.on("change:positioning", this.setPropertyFromEvent_.bind(this)));
  ol.Overlay.call(this, this.parent_.getOptions());
  this.setProperties(this.parent_.getProperties());
  this.handleMapChanged();
};
ol.inherits(olcs.SynchronizedOverlay, ol.Overlay);
olcs.SynchronizedOverlay.prototype.observeTarget_ = function(target) {
  this.observer_.disconnect();
  this.observer_.observe(target, {attributes:false, childList:true, characterData:true, subtree:true});
  this.attributeObserver_.forEach(function(observer) {
    observer.disconnect();
  });
  this.attributeObserver_.length = 0;
  for (var i = 0; i < target.childNodes.length; i++) {
    var node = target.childNodes[i];
    if (node.nodeType === 1) {
      var observer = new MutationObserver(this.handleElementChanged.bind(this));
      observer.observe(node, {attributes:true, subtree:true});
      this.attributeObserver_.push(observer);
    }
  }
};
olcs.SynchronizedOverlay.prototype.setPropertyFromEvent_ = function(event) {
  if (event.target && event.key) {
    this.set(event.key, event.target.get(event.key));
  }
};
olcs.SynchronizedOverlay.prototype.getScene = function() {
  return this.scene_;
};
olcs.SynchronizedOverlay.prototype.handleMapChanged = function() {
  if (this.scenePostRenderListenerRemover_) {
    this.scenePostRenderListenerRemover_();
    ol.dom.removeNode(this.element);
  }
  this.scenePostRenderListenerRemover_ = null;
  var scene = this.getScene();
  if (scene) {
    this.scenePostRenderListenerRemover_ = scene.postRender.addEventListener(this.updatePixelPosition.bind(this));
    this.updatePixelPosition();
    var container = this.stopEvent ? this.synchronizer_.getOverlayContainerStopEvent() : this.synchronizer_.getOverlayContainer();
    if (this.insertFirst) {
      container.insertBefore(this.element, container.childNodes[0] || null);
    } else {
      container.appendChild(this.element);
    }
  }
};
olcs.SynchronizedOverlay.prototype.handlePositionChanged = function() {
  var position = this.getPosition();
  if (position) {
    var sourceProjection = this.parent_.getMap().getView().getProjection();
    this.positionWGS84_ = ol.proj.transform(position, sourceProjection, "EPSG:4326");
  } else {
    this.positionWGS84_ = undefined;
  }
  this.updatePixelPosition();
};
olcs.SynchronizedOverlay.prototype.handleElementChanged = function() {
  function cloneNode(node, parent) {
    var clone = node.cloneNode();
    if (parent) {
      parent.appendChild(clone);
    }
    if (node.nodeType != Node.TEXT_NODE) {
      clone.addEventListener("click", function(event) {
        node.dispatchEvent(new MouseEvent("click", event));
        event.stopPropagation();
      });
    }
    var nodes = node.childNodes;
    for (var i = 0; i < nodes.length; i++) {
      if (!nodes[i]) {
        continue;
      }
      cloneNode(nodes[i], clone);
    }
    return clone;
  }
  ol.dom.removeChildren(this.element);
  var element = this.getElement();
  if (element) {
    if (element.parentNode && element.parentNode.childNodes) {
      for (var $jscomp$iter$3 = $jscomp.makeIterator(element.parentNode.childNodes), $jscomp$key$node = $jscomp$iter$3.next(); !$jscomp$key$node.done; $jscomp$key$node = $jscomp$iter$3.next()) {
        var node = $jscomp$key$node.value;
        {
          var clonedNode = cloneNode(node, null);
          this.element.appendChild(clonedNode);
        }
      }
    }
  }
  if (element.parentNode) {
    this.observeTarget_(element.parentNode);
  }
};
olcs.SynchronizedOverlay.prototype.updatePixelPosition = function() {
  var position = this.positionWGS84_;
  if (!this.scene_ || !position) {
    this.setVisible(false);
    return;
  }
  var cartesian;
  if (position.length === 2) {
    cartesian = Cesium.Cartesian3.fromDegreesArray(position)[0];
  } else {
    cartesian = Cesium.Cartesian3.fromDegreesArrayHeights(position)[0];
  }
  var camera = this.scene_.camera;
  var ellipsoidBoundingSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3, 6356752);
  var occluder = new Cesium.Occluder(ellipsoidBoundingSphere, camera.position);
  if (!occluder.isPointVisible(cartesian)) {
    this.setVisible(false);
    return;
  }
  var cullingVolume = camera.frustum.computeCullingVolume(camera.position, camera.direction, camera.up);
  if (cullingVolume.computeVisibility(new Cesium.BoundingSphere(cartesian)) !== 1) {
    this.setVisible(false);
    return;
  }
  this.setVisible(true);
  var pixelCartesian = this.scene_.cartesianToCanvasCoordinates(cartesian);
  var pixel = [pixelCartesian.x, pixelCartesian.y];
  var mapSize = [this.scene_.canvas.width, this.scene_.canvas.height];
  this.updateRenderedPosition(pixel, mapSize);
};
olcs.SynchronizedOverlay.prototype.destroy = function() {
  if (this.scenePostRenderListenerRemover_) {
    this.scenePostRenderListenerRemover_();
  }
  if (this.observer_) {
    this.observer_.disconnect();
  }
  ol.Observable.unByKey(this.listenerKeys_);
  this.listenerKeys_.splice(0);
  if (this.element.removeNode) {
    this.element.removeNode(true);
  } else {
    this.element.remove();
  }
  this.element = null;
};
goog.provide("olcs.OverlaySynchronizer");
goog.require("olcs.SynchronizedOverlay");
goog.require("ol");
goog.require("ol.events");
olcs.OverlaySynchronizer = function(map, scene) {
  var $jscomp$this = this;
  this.map = map;
  this.overlays_ = this.map.getOverlays();
  this.scene = scene;
  this.overlayContainerStopEvent_ = document.createElement("DIV");
  this.overlayContainerStopEvent_.className = "ol-overlaycontainer-stopevent";
  var overlayEvents = ["click", "dblclick", "mousedown", "touchstart", "MSPointerDown", "pointerdown", "mousewheel", "wheel"];
  overlayEvents.forEach(function(event) {
    ol.events.listen($jscomp$this.overlayContainerStopEvent_, event, function(evt) {
      return evt.stopPropagation();
    });
  });
  this.scene.canvas.parentElement.appendChild(this.overlayContainerStopEvent_);
  this.overlayContainer_ = document.createElement("DIV");
  this.overlayContainer_.className = "ol-overlaycontainer";
  this.scene.canvas.parentElement.appendChild(this.overlayContainer_);
  this.overlayMap_ = {};
};
olcs.OverlaySynchronizer.prototype.getOverlayContainerStopEvent = function() {
  return this.overlayContainerStopEvent_;
};
olcs.OverlaySynchronizer.prototype.getOverlayContainer = function() {
  return this.overlayContainer_;
};
olcs.OverlaySynchronizer.prototype.synchronize = function() {
  this.destroyAll();
  this.addOverlays();
  this.overlays_.on("add", this.addOverlayFromEvent_.bind(this));
  this.overlays_.on("remove", this.removeOverlayFromEvent_.bind(this));
};
olcs.OverlaySynchronizer.prototype.addOverlayFromEvent_ = function(event) {
  var overlay = event.element;
  this.addOverlay(overlay);
};
olcs.OverlaySynchronizer.prototype.addOverlays = function() {
  this.overlays_.forEach(this.addOverlay, this);
};
olcs.OverlaySynchronizer.prototype.addOverlay = function(overlay) {
  if (!overlay) {
    return;
  }
  var cesiumOverlay = new olcs.SynchronizedOverlay({scene:this.scene, synchronizer:this, parent:overlay});
  var overlayId = ol.getUid(overlay).toString();
  this.overlayMap_[overlayId] = cesiumOverlay;
};
olcs.OverlaySynchronizer.prototype.removeOverlayFromEvent_ = function(event) {
  var removedOverlay = event.element;
  this.removeOverlay(removedOverlay);
};
olcs.OverlaySynchronizer.prototype.removeOverlay = function(overlay) {
  var overlayId = ol.getUid(overlay).toString();
  var csOverlay = this.overlayMap_[overlayId];
  if (csOverlay) {
    csOverlay.destroy();
    delete this.overlayMap_[overlayId];
  }
};
olcs.OverlaySynchronizer.prototype.destroyAll = function() {
  var $jscomp$this = this;
  Object.keys(this.overlayMap_).forEach(function(key) {
    var overlay = $jscomp$this.overlayMap_[key];
    overlay.destroy();
    delete $jscomp$this.overlayMap_[key];
  });
};
goog.provide("olcs.OLCesium");
goog.require("ol.geom.Point");
goog.require("goog.asserts");
goog.require("ol.proj");
goog.require("ol.events");
goog.require("olcs.util");
goog.require("olcs.core");
goog.require("olcs.AutoRenderLoop");
goog.require("olcs.Camera");
goog.require("olcs.RasterSynchronizer");
goog.require("olcs.VectorSynchronizer");
goog.require("olcs.OverlaySynchronizer");
olcs.OLCesium = function(options) {
  this.autoRenderLoop_ = null;
  this.map_ = options.map;
  this.time_ = options.time || function() {
    return Cesium.JulianDate.now();
  };
  this.to4326Transform_ = ol.proj.getTransform(this.map_.getView().getProjection(), "EPSG:4326");
  this.resolutionScale_ = 1.0;
  this.canvasClientWidth_ = 0.0;
  this.canvasClientHeight_ = 0.0;
  this.resolutionScaleChanged_ = true;
  var fillArea = "position:absolute;top:0;left:0;width:100%;height:100%;";
  this.container_ = document.createElement("DIV");
  var containerAttribute = document.createAttribute("style");
  containerAttribute.value = fillArea + "visibility:hidden;";
  this.container_.setAttributeNode(containerAttribute);
  var targetElement = options.target || null;
  if (targetElement) {
    if (typeof targetElement === "string") {
      targetElement = document.getElementById(targetElement);
    }
    targetElement.appendChild(this.container_);
  } else {
    var oc = this.map_.getViewport().querySelector(".ol-overlaycontainer");
    if (oc && oc.parentNode) {
      oc.parentNode.insertBefore(this.container_, oc);
    }
  }
  this.isOverMap_ = !targetElement;
  if (this.isOverMap_ && options.stopOpenLayersEventsPropagation) {
    var overlayEvents = ["click", "dblclick", "mousedown", "touchstart", "MSPointerDown", "pointerdown", "mousewheel", "wheel"];
    for (var i = 0, ii = overlayEvents.length; i < ii; ++i) {
      ol.events.listen(this.container_, overlayEvents[i], function(evt) {
        return evt.stopPropagation();
      });
    }
  }
  this.canvas_ = document.createElement("CANVAS");
  var canvasAttribute = document.createAttribute("style");
  canvasAttribute.value = fillArea;
  this.canvas_.setAttributeNode(canvasAttribute);
  if (olcs.util.supportsImageRenderingPixelated()) {
    this.canvas_.style["imageRendering"] = olcs.util.imageRenderingValue();
  }
  this.canvas_.oncontextmenu = function() {
    return false;
  };
  this.canvas_.onselectstart = function() {
    return false;
  };
  this.container_.appendChild(this.canvas_);
  this.enabled_ = false;
  this.pausedInteractions_ = [];
  this.hiddenRootGroup_ = null;
  var sceneOptions = options.sceneOptions !== undefined ? options.sceneOptions : {};
  sceneOptions.canvas = this.canvas_;
  sceneOptions.scene3DOnly = true;
  this.scene_ = new Cesium.Scene(sceneOptions);
  var sscc = this.scene_.screenSpaceCameraController;
  sscc.tiltEventTypes.push({"eventType":Cesium.CameraEventType.LEFT_DRAG, "modifier":Cesium.KeyboardEventModifier.SHIFT});
  sscc.tiltEventTypes.push({"eventType":Cesium.CameraEventType.LEFT_DRAG, "modifier":Cesium.KeyboardEventModifier.ALT});
  sscc.enableLook = false;
  this.scene_.camera.constrainedAxis = Cesium.Cartesian3.UNIT_Z;
  this.camera_ = new olcs.Camera(this.scene_, this.map_);
  this.globe_ = new Cesium.Globe(Cesium.Ellipsoid.WGS84);
  this.globe_.baseColor = Cesium.Color.WHITE;
  this.scene_.globe = this.globe_;
  this.scene_.skyAtmosphere = new Cesium.SkyAtmosphere;
  var firstImageryProvider = new Cesium.SingleTileImageryProvider({url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=", rectangle:Cesium.Rectangle.fromDegrees(0, 0, 1, 1)});
  this.globe_.imageryLayers.addImageryProvider(firstImageryProvider, 0);
  this.dataSourceCollection_ = new Cesium.DataSourceCollection;
  this.dataSourceDisplay_ = new Cesium.DataSourceDisplay({scene:this.scene_, dataSourceCollection:this.dataSourceCollection_});
  var synchronizers = options.createSynchronizers ? options.createSynchronizers(this.map_, this.scene_, this.dataSourceCollection_) : [new olcs.RasterSynchronizer(this.map_, this.scene_), new olcs.VectorSynchronizer(this.map_, this.scene_), new olcs.OverlaySynchronizer(this.map_, this.scene_)];
  this.handleResize_();
  for (var i$10 = synchronizers.length - 1; i$10 >= 0; --i$10) {
    synchronizers[i$10].synchronize();
  }
  if (this.isOverMap_) {
    var credits = this.canvas_.nextElementSibling;
    if (credits) {
      credits.style.display = "none";
    }
  }
  this.lastFrameTime_ = 0;
  this.renderId_ = undefined;
  this.targetFrameRate_ = Number.POSITIVE_INFINITY;
  this.blockCesiumRendering_ = false;
  this.warmingUp_ = false;
  this.trackedFeature_ = null;
  this.trackedEntity_ = null;
  this.entityView_ = null;
  this.needTrackedEntityUpdate_ = false;
  this.boundingSphereScratch_ = new Cesium.BoundingSphere;
  var eventHelper = new Cesium.EventHelper;
  eventHelper.add(this.scene_.postRender, olcs.OLCesium.prototype.updateTrackedEntity_, this);
  Cesium.Camera.enableSuspendTerrainAdjustment = false;
};
Object.defineProperties(olcs.OLCesium.prototype, {"trackedFeature":{"get":function() {
  return this.trackedFeature_;
}, "set":function(feature) {
  if (this.trackedFeature_ !== feature) {
    var scene = this.scene_;
    if (!feature || !feature.getGeometry()) {
      this.needTrackedEntityUpdate_ = false;
      scene.screenSpaceCameraController.enableTilt = true;
      if (this.trackedEntity_) {
        this.dataSourceDisplay_.defaultDataSource.entities.remove(this.trackedEntity_);
      }
      this.trackedEntity_ = null;
      this.trackedFeature_ = null;
      this.entityView_ = null;
      scene.camera.lookAtTransform(Cesium.Matrix4.IDENTITY);
      return;
    }
    this.trackedFeature_ = feature;
    this.needTrackedEntityUpdate_ = true;
    var to4326Transform = this.to4326Transform_;
    var toCesiumPosition = function() {
      var geometry = feature.getGeometry();
      goog.asserts.assertInstanceof(geometry, ol.geom.Point);
      var coo = geometry.getCoordinates();
      var coo4326 = to4326Transform(coo, undefined, coo.length);
      return olcs.core.ol4326CoordinateToCesiumCartesian(coo4326);
    };
    var options = {"position":new Cesium.CallbackProperty(function(time, result) {
      return toCesiumPosition();
    }, false), "point":{"pixelSize":1, "color":Cesium.Color.TRANSPARENT}};
    this.trackedEntity_ = this.dataSourceDisplay_.defaultDataSource.entities.add(options);
  }
}}});
olcs.OLCesium.prototype.render_ = function() {
  if (this.renderId_ !== undefined) {
    cancelAnimationFrame(this.renderId_);
    this.renderId_ = undefined;
  }
  if ((this.enabled_ || this.warmingUp_) && !this.blockCesiumRendering_) {
    this.renderId_ = requestAnimationFrame(this.onAnimationFrame_.bind(this));
  }
};
olcs.OLCesium.prototype.onAnimationFrame_ = function(frameTime) {
  this.renderId_ = undefined;
  var interval = 1000.0 / this.targetFrameRate_;
  var delta = frameTime - this.lastFrameTime_;
  if (delta < interval) {
    this.render_();
    return;
  }
  this.lastFrameTime_ = frameTime;
  var julianDate = this.time_();
  this.scene_.initializeFrame();
  this.handleResize_();
  this.dataSourceDisplay_.update(julianDate);
  if (this.entityView_) {
    var trackedEntity = this.trackedEntity_;
    var trackedState = this.dataSourceDisplay_.getBoundingSphere(trackedEntity, false, this.boundingSphereScratch_);
    if (trackedState === Cesium.BoundingSphereState.DONE) {
      this.boundingSphereScratch_.radius = 1;
      this.entityView_.update(julianDate, this.boundingSphereScratch_);
    }
  }
  this.scene_.render(julianDate);
  this.camera_.checkCameraChange();
  this.render_();
};
olcs.OLCesium.prototype.updateTrackedEntity_ = function() {
  if (!this.needTrackedEntityUpdate_) {
    return;
  }
  var trackedEntity = this.trackedEntity_;
  var scene = this.scene_;
  var state = this.dataSourceDisplay_.getBoundingSphere(trackedEntity, false, this.boundingSphereScratch_);
  if (state === Cesium.BoundingSphereState.PENDING) {
    return;
  }
  scene.screenSpaceCameraController.enableTilt = false;
  var bs = state !== Cesium.BoundingSphereState.FAILED ? this.boundingSphereScratch_ : undefined;
  if (bs) {
    bs.radius = 1;
  }
  this.entityView_ = new Cesium.EntityView(trackedEntity, scene, scene.mapProjection.ellipsoid);
  this.entityView_.update(this.time_(), bs);
  this.needTrackedEntityUpdate_ = false;
};
olcs.OLCesium.prototype.handleResize_ = function() {
  var width = this.canvas_.clientWidth;
  var height = this.canvas_.clientHeight;
  if (width === 0 | height === 0) {
    return;
  }
  if (width === this.canvasClientWidth_ && height === this.canvasClientHeight_ && !this.resolutionScaleChanged_) {
    return;
  }
  var resolutionScale = this.resolutionScale_;
  if (!olcs.util.supportsImageRenderingPixelated()) {
    resolutionScale *= window.devicePixelRatio || 1.0;
  }
  this.resolutionScaleChanged_ = false;
  this.canvasClientWidth_ = width;
  this.canvasClientHeight_ = height;
  width *= resolutionScale;
  height *= resolutionScale;
  this.canvas_.width = width;
  this.canvas_.height = height;
  this.scene_.camera.frustum.aspectRatio = width / height;
};
olcs.OLCesium.prototype.getCamera = function() {
  return this.camera_;
};
olcs.OLCesium.prototype.getOlMap = function() {
  return this.map_;
};
olcs.OLCesium.prototype.getOlView = function() {
  var view = this.map_.getView();
  goog.asserts.assert(view);
  return view;
};
olcs.OLCesium.prototype.getCesiumScene = function() {
  return this.scene_;
};
olcs.OLCesium.prototype.getDataSources = function() {
  return this.dataSourceCollection_;
};
olcs.OLCesium.prototype.getDataSourceDisplay = function() {
  return this.dataSourceDisplay_;
};
olcs.OLCesium.prototype.getEnabled = function() {
  return this.enabled_;
};
olcs.OLCesium.prototype.setEnabled = function(enable) {
  var $jscomp$this = this;
  if (this.enabled_ === enable) {
    return;
  }
  this.enabled_ = enable;
  this.container_.style.visibility = this.enabled_ ? "visible" : "hidden";
  var interactions;
  if (this.enabled_) {
    this.throwOnUnitializedMap_();
    if (this.isOverMap_) {
      interactions = this.map_.getInteractions();
      interactions.forEach(function(el, i, arr) {
        $jscomp$this.pausedInteractions_.push(el);
      });
      interactions.clear();
      var rootGroup = this.map_.getLayerGroup();
      if (rootGroup.getVisible()) {
        this.hiddenRootGroup_ = rootGroup;
        this.hiddenRootGroup_.setVisible(false);
      }
      this.map_.getOverlayContainer().classList.add("olcs-hideoverlay");
      this.map_.getOverlayContainerStopEvent().classList.add("olcs-hideoverlay");
    }
    this.camera_.readFromView();
    this.render_();
  } else {
    if (this.isOverMap_) {
      interactions = this.map_.getInteractions();
      this.pausedInteractions_.forEach(function(interaction) {
        interactions.push(interaction);
      });
      this.pausedInteractions_.length = 0;
      this.map_.getOverlayContainer().classList.remove("olcs-hideoverlay");
      this.map_.getOverlayContainerStopEvent().classList.remove("olcs-hideoverlay");
      if (this.hiddenRootGroup_) {
        this.hiddenRootGroup_.setVisible(true);
        this.hiddenRootGroup_ = null;
      }
    }
    this.camera_.updateView();
  }
};
olcs.OLCesium.prototype.warmUp = function(height, timeout) {
  var $jscomp$this = this;
  if (this.enabled_) {
    return;
  }
  this.throwOnUnitializedMap_();
  this.camera_.readFromView();
  var ellipsoid = this.globe_.ellipsoid;
  var csCamera = this.scene_.camera;
  var position = ellipsoid.cartesianToCartographic(csCamera.position);
  if (position.height < height) {
    position.height = height;
    csCamera.position = ellipsoid.cartographicToCartesian(position);
  }
  this.warmingUp_ = true;
  this.render_();
  setTimeout(function() {
    $jscomp$this.warmingUp_ = false;
  }, timeout);
};
olcs.OLCesium.prototype.setBlockCesiumRendering = function(block) {
  if (this.blockCesiumRendering_ !== block) {
    this.blockCesiumRendering_ = block;
    this.render_();
  }
};
olcs.OLCesium.prototype.enableAutoRenderLoop = function() {
  if (!this.autoRenderLoop_) {
    this.autoRenderLoop_ = new olcs.AutoRenderLoop(this, false);
  }
};
olcs.OLCesium.prototype.getAutoRenderLoop = function() {
  return this.autoRenderLoop_;
};
olcs.OLCesium.prototype.setResolutionScale = function(value) {
  value = Math.max(0, value);
  if (value !== this.resolutionScale_) {
    this.resolutionScale_ = Math.max(0, value);
    this.resolutionScaleChanged_ = true;
    if (this.autoRenderLoop_) {
      this.autoRenderLoop_.restartRenderLoop();
    }
  }
};
olcs.OLCesium.prototype.setTargetFrameRate = function(value) {
  if (this.targetFrameRate_ !== value) {
    this.targetFrameRate_ = value;
    this.render_();
  }
};
olcs.OLCesium.prototype.throwOnUnitializedMap_ = function() {
  var map = this.map_;
  var view = map.getView();
  var center = view.getCenter();
  if (!view.isDef() || isNaN(center[0]) || isNaN(center[1])) {
    throw new Error("The OpenLayers map is not properly initialized: " + center + " / " + view.getResolution());
  }
};
goog.provide("olcs.contrib.Manager");
goog.require("olcs.contrib.LazyLoader");
goog.require("olcs.OLCesium");
goog.require("olcs.core");
goog.require("ol.math");
goog.require("ol.Observable");
goog.require("goog.asserts");
olcs.contrib.Manager = function(cesiumUrl, options) {
  var $jscomp$super$this;
  var $jscomp$destructuring$var0 = options === undefined ? {} : options;
  var map = $jscomp$destructuring$var0.map;
  var cameraExtentInRadians = $jscomp$destructuring$var0.cameraExtentInRadians;
  $jscomp$super$this = ol.Observable.call(this) || this;
  $jscomp$super$this.cesiumUrl_ = cesiumUrl;
  $jscomp$super$this.map = map;
  $jscomp$super$this.cameraExtentInRadians = cameraExtentInRadians || null;
  $jscomp$super$this.boundingSphere_;
  $jscomp$super$this.blockLimiter_ = false;
  $jscomp$super$this.promise_;
  $jscomp$super$this.ol3d;
  $jscomp$super$this.cesiumInitialTilt_ = ol.math.toRadians(50);
  $jscomp$super$this.fogDensity = 0.0001;
  $jscomp$super$this.fogSSEFactor = 25;
  $jscomp$super$this.minimumZoomDistance = 2;
  $jscomp$super$this.maximumZoomDistance = 10000000;
  $jscomp$super$this.limitCameraToBoundingSphereRatio = function(height) {
    return height > 3000 ? 9 : 3;
  };
  return $jscomp$super$this;
};
$jscomp.inherits(olcs.contrib.Manager, ol.Observable);
olcs.contrib.Manager.prototype.load = function() {
  var $jscomp$this = this;
  if (!this.promise_) {
    var cesiumLazyLoader = new olcs.contrib.LazyLoader(this.cesiumUrl_);
    this.promise_ = cesiumLazyLoader.load().then(function() {
      return $jscomp$this.onCesiumLoaded();
    });
  }
  return this.promise_;
};
olcs.contrib.Manager.prototype.onCesiumLoaded = function() {
  if (this.cameraExtentInRadians) {
    var rect = new (Function.prototype.bind.apply(Cesium.Rectangle, [null].concat($jscomp.arrayFromIterable(this.cameraExtentInRadians))));
    Cesium.Camera.DEFAULT_VIEW_RECTANGLE = rect;
    this.boundingSphere_ = Cesium.BoundingSphere.fromRectangle3D(rect, Cesium.Ellipsoid.WGS84, 300);
  }
  this.ol3d = this.instantiateOLCesium();
  var scene = this.ol3d.getCesiumScene();
  this.configureForUsability(scene);
  this.configureForPerformance(scene);
  this.dispatchEvent("load");
  return this.ol3d;
};
olcs.contrib.Manager.prototype.instantiateOLCesium = function() {
  goog.asserts.assert(this.map);
  var ol3d = new olcs.OLCesium({map:this.map});
  var scene = ol3d.getCesiumScene();
  var terrainProvider = new Cesium.CesiumTerrainProvider({url:"//assets.agi.com/stk-terrain/world"});
  scene.terrainProvider = terrainProvider;
  return ol3d;
};
olcs.contrib.Manager.prototype.configureForPerformance = function(scene) {
  var fog = scene.fog;
  fog.enabled = true;
  fog.density = this.fogDensity;
  fog.screenSpaceErrorFactor = this.fogSSEFactor;
};
olcs.contrib.Manager.prototype.configureForUsability = function(scene) {
  var sscController = scene.screenSpaceCameraController;
  sscController.minimumZoomDistance = this.minimumZoomDistance;
  sscController.maximumZoomDistance = this.maximumZoomDistance;
  scene.globe.depthTestAgainstTerrain = true;
  scene.globe.baseColor = Cesium.Color.WHITE;
  scene.backgroundColor = Cesium.Color.WHITE;
  if (this.boundingSphere_) {
    scene.postRender.addEventListener(this.limitCameraToBoundingSphere.bind(this), scene);
  }
  this.ol3d.enableAutoRenderLoop();
};
olcs.contrib.Manager.prototype.limitCameraToBoundingSphere = function() {
  var $jscomp$this = this;
  if (this.boundingSphere_ && !this.blockLimiter_) {
    var scene = this.ol3d.getCesiumScene();
    var camera = scene.camera;
    var position = camera.position;
    var carto = Cesium.Cartographic.fromCartesian(position);
    var ratio = this.limitCameraToBoundingSphereRatio(carto.height);
    if (Cesium.Cartesian3.distance(this.boundingSphere_.center, position) > this.boundingSphere_.radius * ratio) {
      var currentlyFlying = camera.flying;
      if (currentlyFlying === true) {
        return;
      } else {
        this.blockLimiter_ = true;
        var unblockLimiter = function() {
          return $jscomp$this.blockLimiter_ = false;
        };
        camera.flyToBoundingSphere(this.boundingSphere_, {complete:unblockLimiter, cancel:unblockLimiter});
      }
    }
  }
};
olcs.contrib.Manager.prototype.toggle3d = function() {
  var $jscomp$this = this;
  return this.load().then(function(ol3d) {
    var is3DCurrentlyEnabled = ol3d.getEnabled();
    var scene = ol3d.getCesiumScene();
    if (is3DCurrentlyEnabled) {
      goog.asserts.assert($jscomp$this.map);
      return olcs.core.resetToNorthZenith($jscomp$this.map, scene).then(function() {
        ol3d.setEnabled(false);
        $jscomp$this.dispatchEvent("toggle");
      });
    } else {
      ol3d.setEnabled(true);
      $jscomp$this.dispatchEvent("toggle");
      return olcs.core.rotateAroundBottomCenter(scene, $jscomp$this.cesiumInitialTilt_);
    }
  });
};
olcs.contrib.Manager.prototype.set3dWithView = function(lon, lat, elevation, headingDeg, pitchDeg) {
  var $jscomp$this = this;
  return this.load().then(function(ol3d) {
    var is3DCurrentlyEnabled = ol3d.getEnabled();
    var scene = ol3d.getCesiumScene();
    var camera = scene.camera;
    var destination = Cesium.Cartesian3.fromDegrees(lon, lat, elevation);
    var heading = Cesium.Math.toRadians(headingDeg);
    var pitch = Cesium.Math.toRadians(pitchDeg);
    var roll = 0;
    var orientation = {heading:heading, pitch:pitch, roll:roll};
    if (!is3DCurrentlyEnabled) {
      ol3d.setEnabled(true);
      $jscomp$this.dispatchEvent("toggle");
    }
    camera.setView({destination:destination, orientation:orientation});
  });
};
olcs.contrib.Manager.prototype.is3dEnabled = function() {
  return !!this.ol3d && this.ol3d.getEnabled();
};
olcs.contrib.Manager.prototype.getHeading = function() {
  return this.map ? this.map.getView().getRotation() || 0 : 0;
};
olcs.contrib.Manager.prototype.getTiltOnGlobe = function() {
  var scene = this.ol3d.getCesiumScene();
  var tiltOnGlobe = olcs.core.computeSignedTiltAngleOnGlobe(scene);
  return -tiltOnGlobe;
};
olcs.contrib.Manager.prototype.setHeading = function(angle) {
  var scene = this.ol3d.getCesiumScene();
  var bottom = olcs.core.pickBottomPoint(scene);
  if (bottom) {
    olcs.core.setHeadingUsingBottomCenter(scene, angle, bottom);
  }
};
olcs.contrib.Manager.prototype.getOl3d = function() {
  return this.ol3d;
};
olcs.contrib.Manager.prototype.getOlView = function() {
  var view = this.map.getView();
  goog.asserts.assert(view);
  return view;
};
olcs.contrib.Manager.prototype.getCesiumViewMatrix = function() {
  return this.ol3d.getCesiumScene().camera.viewMatrix;
};
olcs.contrib.Manager.prototype.getCesiumScene = function() {
  return this.ol3d.getCesiumScene();
};
olcs.contrib.Manager.prototype.flyToRectangle = function(rectangle, offset) {
  var $jscomp$this = this;
  offset = offset === undefined ? 0 : offset;
  var camera = this.getCesiumScene().camera;
  var destination = camera.getRectangleCameraCoordinates(rectangle);
  var mag = Cesium.Cartesian3.magnitude(destination) + offset;
  Cesium.Cartesian3.normalize(destination, destination);
  Cesium.Cartesian3.multiplyByScalar(destination, mag, destination);
  return new Promise(function(resolve, reject) {
    if (!$jscomp$this.cameraExtentInRadians) {
      reject();
      return;
    }
    camera.flyTo({destination:destination, complete:function() {
      return resolve();
    }, cancel:function() {
      return reject();
    }, endTransform:Cesium.Matrix4.IDENTITY});
  });
};
olcs.contrib.Manager.prototype.getCameraExtentRectangle = function() {
  if (this.cameraExtentInRadians) {
    return new (Function.prototype.bind.apply(Cesium.Rectangle, [null].concat($jscomp.arrayFromIterable(this.cameraExtentInRadians))));
  }
};
goog.provide("olcs.GaKmlSynchronizer");
goog.require("ol");
goog.require("olcs.util");
goog.require("olcs.AbstractSynchronizer");
olcs.GaKmlSynchronizer = function(map, scene, dataSources) {
  this.dataSources_ = dataSources;
  olcs.AbstractSynchronizer.call(this, map, scene);
};
ol.inherits(olcs.GaKmlSynchronizer, olcs.AbstractSynchronizer);
olcs.GaKmlSynchronizer.prototype.createSingleLayerCounterparts = function(olLayerWithParents) {
  var dsP;
  var layer = olcs.util.obj(olLayerWithParents.layer);
  var factory = layer["getCesiumDataSource"];
  if (factory) {
    dsP = factory(this.scene);
  }
  if (!dsP) {
    var id = layer.id;
    var url = layer.url;
    if (!(layer instanceof ol.layer.Layer) || !id || !/^KML/.test(id) || !url || /:\/\/public\./.test(url)) {
      return null;
    }
    var loadParam = url;
    var kml = (layer.getSource().get("rawData") || "") + "";
    if (kml) {
      loadParam = (new DOMParser).parseFromString(kml, "text/xml");
    }
    dsP = Cesium.KmlDataSource.load(loadParam, {camera:this.scene.camera, canvas:this.scene.canvas, clampToGround:true});
  }
  var that = this;
  dsP.then(function(ds) {
    ds.show = layer.getVisible();
    var uid = ol.getUid(layer).toString();
    var listenKeyArray = [];
    listenKeyArray.push(layer.on("change:visible", function(evt) {
      ds.show = evt.target.getVisible();
    }));
    that.olLayerListenKeys[uid].push.apply(that.olLayerListenKeys[uid], [].concat($jscomp.arrayFromIterable(listenKeyArray)));
    if (layer instanceof ol.layer.Vector) {
      layer.getSource().getFeatures().forEach(function(feature) {
        if (ds.entities.getById) {
          var entity = ds.entities.getById(feature.getId());
          if (entity) {
            entity["olFeature"] = feature;
            entity["olLayer"] = layer;
          }
        }
      });
    }
  });
  return [dsP];
};
olcs.GaKmlSynchronizer.prototype.addCesiumObject = function(dsP) {
  this.dataSources_.add(dsP);
};
olcs.GaKmlSynchronizer.prototype.destroyCesiumObject = function(dsP) {
  var that = this;
  dsP.then(function(ds) {
    that.dataSources_.remove(ds, true);
  });
};
olcs.GaKmlSynchronizer.prototype.removeSingleCesiumObject = function(dsP, destroy) {
  var that = this;
  dsP.then(function(ds) {
    that.dataSources_.remove(ds, destroy);
  });
};
olcs.GaKmlSynchronizer.prototype.removeAllCesiumObjects = function(destroy) {
  this.dataSources_.removeAll(destroy);
};
goog.provide("olcs.GaRasterSynchronizer");
goog.require("ol");
goog.require("olcs.util");
goog.require("olcs.RasterSynchronizer");
olcs.GaRasterSynchronizer = function(map, scene) {
  olcs.RasterSynchronizer.call(this, map, scene);
};
ol.inherits(olcs.GaRasterSynchronizer, olcs.RasterSynchronizer);
olcs.GaRasterSynchronizer.prototype.convertLayerToCesiumImageries = function(olLayer, viewProj) {
  if (olLayer instanceof ol.layer.Layer) {
    var source = olLayer.getSource();
    if (source instanceof ol.source.Vector) {
      return null;
    }
  }
  var provider = null;
  var factory = olcs.util.obj(olLayer)["getCesiumImageryProvider"];
  if (!factory) {
    return null;
  }
  provider = factory();
  if (!provider) {
    return null;
  }
  var providers = Array.isArray(provider) ? provider : [provider];
  return providers.map(function(p) {
    return new Cesium.ImageryLayer(p);
  });
};
goog.provide("olcs.GaTileset3dSynchronizer");
goog.require("ol");
goog.require("olcs.util");
goog.require("olcs.AbstractSynchronizer");
olcs.GaTileset3dSynchronizer = function(map, scene) {
  this.primitives_ = new Cesium.PrimitiveCollection;
  scene.primitives.add(this.primitives_);
  olcs.AbstractSynchronizer.call(this, map, scene);
};
ol.inherits(olcs.GaTileset3dSynchronizer, olcs.AbstractSynchronizer);
olcs.GaTileset3dSynchronizer.prototype.createSingleLayerCounterparts = function(olLayerWithParents) {
  var prim;
  var layer = olcs.util.obj(olLayerWithParents.layer);
  var factory = layer["getCesiumTileset3d"];
  if (factory) {
    prim = factory(this.scene);
  }
  if (!prim) {
    return null;
  }
  if (prim) {
    prim.show = layer.getVisible();
    var uid = ol.getUid(layer).toString();
    var listenKeyArray = [];
    listenKeyArray.push(layer.on(["change:visible"], function(e) {
      prim.show = layer.getVisible();
    }));
    this.olLayerListenKeys[uid].push.apply(this.olLayerListenKeys[uid], [].concat($jscomp.arrayFromIterable(listenKeyArray)));
  }
  return [prim];
};
olcs.GaTileset3dSynchronizer.prototype.addCesiumObject = function(prim) {
  if (!this.primitives_.contains(prim)) {
    this.primitives_.add(prim);
  }
};
olcs.GaTileset3dSynchronizer.prototype.destroyCesiumObject = function(prim) {
  if (this.primitives_.contains(prim)) {
    this.primitives_.remove(prim);
  }
};
olcs.GaTileset3dSynchronizer.prototype.removeSingleCesiumObject = function(prim, destroy) {
  if (this.primitives_.contains(prim)) {
    this.primitives_.remove(prim);
  }
};
olcs.GaTileset3dSynchronizer.prototype.removeAllCesiumObjects = function(destroy) {
  this.primitives_.removeAll();
};
goog.provide("olcs.GaVectorSynchronizer");
goog.require("ol");
goog.require("olcs.util");
goog.require("olcs.VectorSynchronizer");
olcs.GaVectorSynchronizer = function(map, scene, opt_converter) {
  olcs.VectorSynchronizer.call(this, map, scene, opt_converter);
};
ol.inherits(olcs.GaVectorSynchronizer, olcs.VectorSynchronizer);
olcs.GaVectorSynchronizer.prototype.createSingleLayerCounterparts = function(olLayerWithParents) {
  var layer = olcs.util.obj(olLayerWithParents).layer;
  var id = layer.id;
  var url = layer.url;
  if (/^KML/.test(id) && url && !/:\/\/public\./.test(url)) {
    return null;
  }
  return olcs.VectorSynchronizer.prototype.createSingleLayerCounterparts.call(this, olLayerWithParents);
};
goog.provide("ol.MapEvent");
goog.require("ol");
goog.require("ol.events.Event");
ol.MapEvent = function(type, map, opt_frameState) {
  ol.events.Event.call(this, type);
  this.map = map;
  this.frameState = opt_frameState !== undefined ? opt_frameState : null;
};
ol.inherits(ol.MapEvent, ol.events.Event);
goog.provide("ol.MapBrowserEvent");
goog.require("ol");
goog.require("ol.MapEvent");
ol.MapBrowserEvent = function(type, map, browserEvent, opt_dragging, opt_frameState) {
  ol.MapEvent.call(this, type, map, opt_frameState);
  this.originalEvent = browserEvent;
  this.pixel = map.getEventPixel(browserEvent);
  this.coordinate = map.getCoordinateFromPixel(this.pixel);
  this.dragging = opt_dragging !== undefined ? opt_dragging : false;
};
ol.inherits(ol.MapBrowserEvent, ol.MapEvent);
ol.MapBrowserEvent.prototype.preventDefault = function() {
  ol.MapEvent.prototype.preventDefault.call(this);
  this.originalEvent.preventDefault();
};
ol.MapBrowserEvent.prototype.stopPropagation = function() {
  ol.MapEvent.prototype.stopPropagation.call(this);
  this.originalEvent.stopPropagation();
};
goog.provide("ol.MapBrowserEventType");
goog.require("ol.events.EventType");
ol.MapBrowserEventType = {SINGLECLICK:"singleclick", CLICK:ol.events.EventType.CLICK, DBLCLICK:ol.events.EventType.DBLCLICK, POINTERDRAG:"pointerdrag", POINTERMOVE:"pointermove", POINTERDOWN:"pointerdown", POINTERUP:"pointerup", POINTEROVER:"pointerover", POINTEROUT:"pointerout", POINTERENTER:"pointerenter", POINTERLEAVE:"pointerleave", POINTERCANCEL:"pointercancel"};
goog.provide("ol.MapBrowserPointerEvent");
goog.require("ol");
goog.require("ol.MapBrowserEvent");
ol.MapBrowserPointerEvent = function(type, map, pointerEvent, opt_dragging, opt_frameState) {
  ol.MapBrowserEvent.call(this, type, map, pointerEvent.originalEvent, opt_dragging, opt_frameState);
  this.pointerEvent = pointerEvent;
};
ol.inherits(ol.MapBrowserPointerEvent, ol.MapBrowserEvent);
goog.provide("ol.pointer.EventType");
ol.pointer.EventType = {POINTERMOVE:"pointermove", POINTERDOWN:"pointerdown", POINTERUP:"pointerup", POINTEROVER:"pointerover", POINTEROUT:"pointerout", POINTERENTER:"pointerenter", POINTERLEAVE:"pointerleave", POINTERCANCEL:"pointercancel"};
goog.provide("ol.pointer.EventSource");
ol.pointer.EventSource = function(dispatcher, mapping) {
  this.dispatcher = dispatcher;
  this.mapping_ = mapping;
};
ol.pointer.EventSource.prototype.getEvents = function() {
  return Object.keys(this.mapping_);
};
ol.pointer.EventSource.prototype.getHandlerForEvent = function(eventType) {
  return this.mapping_[eventType];
};
goog.provide("ol.pointer.MouseSource");
goog.require("ol");
goog.require("ol.pointer.EventSource");
ol.pointer.MouseSource = function(dispatcher) {
  var mapping = {"mousedown":this.mousedown, "mousemove":this.mousemove, "mouseup":this.mouseup, "mouseover":this.mouseover, "mouseout":this.mouseout};
  ol.pointer.EventSource.call(this, dispatcher, mapping);
  this.pointerMap = dispatcher.pointerMap;
  this.lastTouches = [];
};
ol.inherits(ol.pointer.MouseSource, ol.pointer.EventSource);
ol.pointer.MouseSource.POINTER_ID = 1;
ol.pointer.MouseSource.POINTER_TYPE = "mouse";
ol.pointer.MouseSource.DEDUP_DIST = 25;
ol.pointer.MouseSource.prototype.isEventSimulatedFromTouch_ = function(inEvent) {
  var lts = this.lastTouches;
  var x = inEvent.clientX, y = inEvent.clientY;
  for (var i = 0, l = lts.length, t; i < l && (t = lts[i]); i++) {
    var dx = Math.abs(x - t[0]), dy = Math.abs(y - t[1]);
    if (dx <= ol.pointer.MouseSource.DEDUP_DIST && dy <= ol.pointer.MouseSource.DEDUP_DIST) {
      return true;
    }
  }
  return false;
};
ol.pointer.MouseSource.prepareEvent = function(inEvent, dispatcher) {
  var e = dispatcher.cloneEvent(inEvent, inEvent);
  var pd = e.preventDefault;
  e.preventDefault = function() {
    inEvent.preventDefault();
    pd();
  };
  e.pointerId = ol.pointer.MouseSource.POINTER_ID;
  e.isPrimary = true;
  e.pointerType = ol.pointer.MouseSource.POINTER_TYPE;
  return e;
};
ol.pointer.MouseSource.prototype.mousedown = function(inEvent) {
  if (!this.isEventSimulatedFromTouch_(inEvent)) {
    if (ol.pointer.MouseSource.POINTER_ID.toString() in this.pointerMap) {
      this.cancel(inEvent);
    }
    var e = ol.pointer.MouseSource.prepareEvent(inEvent, this.dispatcher);
    this.pointerMap[ol.pointer.MouseSource.POINTER_ID.toString()] = inEvent;
    this.dispatcher.down(e, inEvent);
  }
};
ol.pointer.MouseSource.prototype.mousemove = function(inEvent) {
  if (!this.isEventSimulatedFromTouch_(inEvent)) {
    var e = ol.pointer.MouseSource.prepareEvent(inEvent, this.dispatcher);
    this.dispatcher.move(e, inEvent);
  }
};
ol.pointer.MouseSource.prototype.mouseup = function(inEvent) {
  if (!this.isEventSimulatedFromTouch_(inEvent)) {
    var p = this.pointerMap[ol.pointer.MouseSource.POINTER_ID.toString()];
    if (p && p.button === inEvent.button) {
      var e = ol.pointer.MouseSource.prepareEvent(inEvent, this.dispatcher);
      this.dispatcher.up(e, inEvent);
      this.cleanupMouse();
    }
  }
};
ol.pointer.MouseSource.prototype.mouseover = function(inEvent) {
  if (!this.isEventSimulatedFromTouch_(inEvent)) {
    var e = ol.pointer.MouseSource.prepareEvent(inEvent, this.dispatcher);
    this.dispatcher.enterOver(e, inEvent);
  }
};
ol.pointer.MouseSource.prototype.mouseout = function(inEvent) {
  if (!this.isEventSimulatedFromTouch_(inEvent)) {
    var e = ol.pointer.MouseSource.prepareEvent(inEvent, this.dispatcher);
    this.dispatcher.leaveOut(e, inEvent);
  }
};
ol.pointer.MouseSource.prototype.cancel = function(inEvent) {
  var e = ol.pointer.MouseSource.prepareEvent(inEvent, this.dispatcher);
  this.dispatcher.cancel(e, inEvent);
  this.cleanupMouse();
};
ol.pointer.MouseSource.prototype.cleanupMouse = function() {
  delete this.pointerMap[ol.pointer.MouseSource.POINTER_ID.toString()];
};
goog.provide("ol.pointer.MsSource");
goog.require("ol");
goog.require("ol.pointer.EventSource");
ol.pointer.MsSource = function(dispatcher) {
  var mapping = {"MSPointerDown":this.msPointerDown, "MSPointerMove":this.msPointerMove, "MSPointerUp":this.msPointerUp, "MSPointerOut":this.msPointerOut, "MSPointerOver":this.msPointerOver, "MSPointerCancel":this.msPointerCancel, "MSGotPointerCapture":this.msGotPointerCapture, "MSLostPointerCapture":this.msLostPointerCapture};
  ol.pointer.EventSource.call(this, dispatcher, mapping);
  this.pointerMap = dispatcher.pointerMap;
  this.POINTER_TYPES = ["", "unavailable", "touch", "pen", "mouse"];
};
ol.inherits(ol.pointer.MsSource, ol.pointer.EventSource);
ol.pointer.MsSource.prototype.prepareEvent_ = function(inEvent) {
  var e = inEvent;
  if (typeof inEvent.pointerType === "number") {
    e = this.dispatcher.cloneEvent(inEvent, inEvent);
    e.pointerType = this.POINTER_TYPES[inEvent.pointerType];
  }
  return e;
};
ol.pointer.MsSource.prototype.cleanup = function(pointerId) {
  delete this.pointerMap[pointerId.toString()];
};
ol.pointer.MsSource.prototype.msPointerDown = function(inEvent) {
  this.pointerMap[inEvent.pointerId.toString()] = inEvent;
  var e = this.prepareEvent_(inEvent);
  this.dispatcher.down(e, inEvent);
};
ol.pointer.MsSource.prototype.msPointerMove = function(inEvent) {
  var e = this.prepareEvent_(inEvent);
  this.dispatcher.move(e, inEvent);
};
ol.pointer.MsSource.prototype.msPointerUp = function(inEvent) {
  var e = this.prepareEvent_(inEvent);
  this.dispatcher.up(e, inEvent);
  this.cleanup(inEvent.pointerId);
};
ol.pointer.MsSource.prototype.msPointerOut = function(inEvent) {
  var e = this.prepareEvent_(inEvent);
  this.dispatcher.leaveOut(e, inEvent);
};
ol.pointer.MsSource.prototype.msPointerOver = function(inEvent) {
  var e = this.prepareEvent_(inEvent);
  this.dispatcher.enterOver(e, inEvent);
};
ol.pointer.MsSource.prototype.msPointerCancel = function(inEvent) {
  var e = this.prepareEvent_(inEvent);
  this.dispatcher.cancel(e, inEvent);
  this.cleanup(inEvent.pointerId);
};
ol.pointer.MsSource.prototype.msLostPointerCapture = function(inEvent) {
  var e = this.dispatcher.makeEvent("lostpointercapture", inEvent, inEvent);
  this.dispatcher.dispatchEvent(e);
};
ol.pointer.MsSource.prototype.msGotPointerCapture = function(inEvent) {
  var e = this.dispatcher.makeEvent("gotpointercapture", inEvent, inEvent);
  this.dispatcher.dispatchEvent(e);
};
goog.provide("ol.pointer.NativeSource");
goog.require("ol");
goog.require("ol.pointer.EventSource");
ol.pointer.NativeSource = function(dispatcher) {
  var mapping = {"pointerdown":this.pointerDown, "pointermove":this.pointerMove, "pointerup":this.pointerUp, "pointerout":this.pointerOut, "pointerover":this.pointerOver, "pointercancel":this.pointerCancel, "gotpointercapture":this.gotPointerCapture, "lostpointercapture":this.lostPointerCapture};
  ol.pointer.EventSource.call(this, dispatcher, mapping);
};
ol.inherits(ol.pointer.NativeSource, ol.pointer.EventSource);
ol.pointer.NativeSource.prototype.pointerDown = function(inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
};
ol.pointer.NativeSource.prototype.pointerMove = function(inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
};
ol.pointer.NativeSource.prototype.pointerUp = function(inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
};
ol.pointer.NativeSource.prototype.pointerOut = function(inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
};
ol.pointer.NativeSource.prototype.pointerOver = function(inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
};
ol.pointer.NativeSource.prototype.pointerCancel = function(inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
};
ol.pointer.NativeSource.prototype.lostPointerCapture = function(inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
};
ol.pointer.NativeSource.prototype.gotPointerCapture = function(inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
};
goog.provide("ol.pointer.PointerEvent");
goog.require("ol");
goog.require("ol.events.Event");
ol.pointer.PointerEvent = function(type, originalEvent, opt_eventDict) {
  ol.events.Event.call(this, type);
  this.originalEvent = originalEvent;
  var eventDict = opt_eventDict ? opt_eventDict : {};
  this.buttons = this.getButtons_(eventDict);
  this.pressure = this.getPressure_(eventDict, this.buttons);
  this.bubbles = "bubbles" in eventDict ? eventDict["bubbles"] : false;
  this.cancelable = "cancelable" in eventDict ? eventDict["cancelable"] : false;
  this.view = "view" in eventDict ? eventDict["view"] : null;
  this.detail = "detail" in eventDict ? eventDict["detail"] : null;
  this.screenX = "screenX" in eventDict ? eventDict["screenX"] : 0;
  this.screenY = "screenY" in eventDict ? eventDict["screenY"] : 0;
  this.clientX = "clientX" in eventDict ? eventDict["clientX"] : 0;
  this.clientY = "clientY" in eventDict ? eventDict["clientY"] : 0;
  this.ctrlKey = "ctrlKey" in eventDict ? eventDict["ctrlKey"] : false;
  this.altKey = "altKey" in eventDict ? eventDict["altKey"] : false;
  this.shiftKey = "shiftKey" in eventDict ? eventDict["shiftKey"] : false;
  this.metaKey = "metaKey" in eventDict ? eventDict["metaKey"] : false;
  this.button = "button" in eventDict ? eventDict["button"] : 0;
  this.relatedTarget = "relatedTarget" in eventDict ? eventDict["relatedTarget"] : null;
  this.pointerId = "pointerId" in eventDict ? eventDict["pointerId"] : 0;
  this.width = "width" in eventDict ? eventDict["width"] : 0;
  this.height = "height" in eventDict ? eventDict["height"] : 0;
  this.tiltX = "tiltX" in eventDict ? eventDict["tiltX"] : 0;
  this.tiltY = "tiltY" in eventDict ? eventDict["tiltY"] : 0;
  this.pointerType = "pointerType" in eventDict ? eventDict["pointerType"] : "";
  this.hwTimestamp = "hwTimestamp" in eventDict ? eventDict["hwTimestamp"] : 0;
  this.isPrimary = "isPrimary" in eventDict ? eventDict["isPrimary"] : false;
  if (originalEvent.preventDefault) {
    this.preventDefault = function() {
      originalEvent.preventDefault();
    };
  }
};
ol.inherits(ol.pointer.PointerEvent, ol.events.Event);
ol.pointer.PointerEvent.prototype.getButtons_ = function(eventDict) {
  var buttons;
  if (eventDict.buttons || ol.pointer.PointerEvent.HAS_BUTTONS) {
    buttons = eventDict.buttons;
  } else {
    switch(eventDict.which) {
      case 1:
        buttons = 1;
        break;
      case 2:
        buttons = 4;
        break;
      case 3:
        buttons = 2;
        break;
      default:
        buttons = 0;
    }
  }
  return buttons;
};
ol.pointer.PointerEvent.prototype.getPressure_ = function(eventDict, buttons) {
  var pressure = 0;
  if (eventDict.pressure) {
    pressure = eventDict.pressure;
  } else {
    pressure = buttons ? 0.5 : 0;
  }
  return pressure;
};
ol.pointer.PointerEvent.HAS_BUTTONS = false;
(function() {
  try {
    var ev = new MouseEvent("click", {buttons:1});
    ol.pointer.PointerEvent.HAS_BUTTONS = ev.buttons === 1;
  } catch (e) {
  }
})();
goog.provide("ol.pointer.TouchSource");
goog.require("ol");
goog.require("ol.array");
goog.require("ol.pointer.EventSource");
goog.require("ol.pointer.MouseSource");
ol.pointer.TouchSource = function(dispatcher, mouseSource) {
  var mapping = {"touchstart":this.touchstart, "touchmove":this.touchmove, "touchend":this.touchend, "touchcancel":this.touchcancel};
  ol.pointer.EventSource.call(this, dispatcher, mapping);
  this.pointerMap = dispatcher.pointerMap;
  this.mouseSource = mouseSource;
  this.firstTouchId_ = undefined;
  this.clickCount_ = 0;
  this.resetId_ = undefined;
};
ol.inherits(ol.pointer.TouchSource, ol.pointer.EventSource);
ol.pointer.TouchSource.DEDUP_TIMEOUT = 2500;
ol.pointer.TouchSource.CLICK_COUNT_TIMEOUT = 200;
ol.pointer.TouchSource.POINTER_TYPE = "touch";
ol.pointer.TouchSource.prototype.isPrimaryTouch_ = function(inTouch) {
  return this.firstTouchId_ === inTouch.identifier;
};
ol.pointer.TouchSource.prototype.setPrimaryTouch_ = function(inTouch) {
  var count = Object.keys(this.pointerMap).length;
  if (count === 0 || count === 1 && ol.pointer.MouseSource.POINTER_ID.toString() in this.pointerMap) {
    this.firstTouchId_ = inTouch.identifier;
    this.cancelResetClickCount_();
  }
};
ol.pointer.TouchSource.prototype.removePrimaryPointer_ = function(inPointer) {
  if (inPointer.isPrimary) {
    this.firstTouchId_ = undefined;
    this.resetClickCount_();
  }
};
ol.pointer.TouchSource.prototype.resetClickCount_ = function() {
  this.resetId_ = setTimeout(this.resetClickCountHandler_.bind(this), ol.pointer.TouchSource.CLICK_COUNT_TIMEOUT);
};
ol.pointer.TouchSource.prototype.resetClickCountHandler_ = function() {
  this.clickCount_ = 0;
  this.resetId_ = undefined;
};
ol.pointer.TouchSource.prototype.cancelResetClickCount_ = function() {
  if (this.resetId_ !== undefined) {
    clearTimeout(this.resetId_);
  }
};
ol.pointer.TouchSource.prototype.touchToPointer_ = function(browserEvent, inTouch) {
  var e = this.dispatcher.cloneEvent(browserEvent, inTouch);
  e.pointerId = inTouch.identifier + 2;
  e.bubbles = true;
  e.cancelable = true;
  e.detail = this.clickCount_;
  e.button = 0;
  e.buttons = 1;
  e.width = inTouch.webkitRadiusX || inTouch.radiusX || 0;
  e.height = inTouch.webkitRadiusY || inTouch.radiusY || 0;
  e.pressure = inTouch.webkitForce || inTouch.force || 0.5;
  e.isPrimary = this.isPrimaryTouch_(inTouch);
  e.pointerType = ol.pointer.TouchSource.POINTER_TYPE;
  e.clientX = inTouch.clientX;
  e.clientY = inTouch.clientY;
  e.screenX = inTouch.screenX;
  e.screenY = inTouch.screenY;
  return e;
};
ol.pointer.TouchSource.prototype.processTouches_ = function(inEvent, inFunction) {
  var touches = Array.prototype.slice.call(inEvent.changedTouches);
  var count = touches.length;
  function preventDefault() {
    inEvent.preventDefault();
  }
  var i, pointer;
  for (i = 0; i < count; ++i) {
    pointer = this.touchToPointer_(inEvent, touches[i]);
    pointer.preventDefault = preventDefault;
    inFunction.call(this, inEvent, pointer);
  }
};
ol.pointer.TouchSource.prototype.findTouch_ = function(touchList, searchId) {
  var l = touchList.length;
  var touch;
  for (var i = 0; i < l; i++) {
    touch = touchList[i];
    if (touch.identifier === searchId) {
      return true;
    }
  }
  return false;
};
ol.pointer.TouchSource.prototype.vacuumTouches_ = function(inEvent) {
  var touchList = inEvent.touches;
  var keys = Object.keys(this.pointerMap);
  var count = keys.length;
  if (count >= touchList.length) {
    var d = [];
    var i, key, value;
    for (i = 0; i < count; ++i) {
      key = keys[i];
      value = this.pointerMap[key];
      if (key != ol.pointer.MouseSource.POINTER_ID && !this.findTouch_(touchList, key - 2)) {
        d.push(value.out);
      }
    }
    for (i = 0; i < d.length; ++i) {
      this.cancelOut_(inEvent, d[i]);
    }
  }
};
ol.pointer.TouchSource.prototype.touchstart = function(inEvent) {
  this.vacuumTouches_(inEvent);
  this.setPrimaryTouch_(inEvent.changedTouches[0]);
  this.dedupSynthMouse_(inEvent);
  this.clickCount_++;
  this.processTouches_(inEvent, this.overDown_);
};
ol.pointer.TouchSource.prototype.overDown_ = function(browserEvent, inPointer) {
  this.pointerMap[inPointer.pointerId] = {target:inPointer.target, out:inPointer, outTarget:inPointer.target};
  this.dispatcher.over(inPointer, browserEvent);
  this.dispatcher.enter(inPointer, browserEvent);
  this.dispatcher.down(inPointer, browserEvent);
};
ol.pointer.TouchSource.prototype.touchmove = function(inEvent) {
  inEvent.preventDefault();
  this.processTouches_(inEvent, this.moveOverOut_);
};
ol.pointer.TouchSource.prototype.moveOverOut_ = function(browserEvent, inPointer) {
  var event = inPointer;
  var pointer = this.pointerMap[event.pointerId];
  if (!pointer) {
    return;
  }
  var outEvent = pointer.out;
  var outTarget = pointer.outTarget;
  this.dispatcher.move(event, browserEvent);
  if (outEvent && outTarget !== event.target) {
    outEvent.relatedTarget = event.target;
    event.relatedTarget = outTarget;
    outEvent.target = outTarget;
    if (event.target) {
      this.dispatcher.leaveOut(outEvent, browserEvent);
      this.dispatcher.enterOver(event, browserEvent);
    } else {
      event.target = outTarget;
      event.relatedTarget = null;
      this.cancelOut_(browserEvent, event);
    }
  }
  pointer.out = event;
  pointer.outTarget = event.target;
};
ol.pointer.TouchSource.prototype.touchend = function(inEvent) {
  this.dedupSynthMouse_(inEvent);
  this.processTouches_(inEvent, this.upOut_);
};
ol.pointer.TouchSource.prototype.upOut_ = function(browserEvent, inPointer) {
  this.dispatcher.up(inPointer, browserEvent);
  this.dispatcher.out(inPointer, browserEvent);
  this.dispatcher.leave(inPointer, browserEvent);
  this.cleanUpPointer_(inPointer);
};
ol.pointer.TouchSource.prototype.touchcancel = function(inEvent) {
  this.processTouches_(inEvent, this.cancelOut_);
};
ol.pointer.TouchSource.prototype.cancelOut_ = function(browserEvent, inPointer) {
  this.dispatcher.cancel(inPointer, browserEvent);
  this.dispatcher.out(inPointer, browserEvent);
  this.dispatcher.leave(inPointer, browserEvent);
  this.cleanUpPointer_(inPointer);
};
ol.pointer.TouchSource.prototype.cleanUpPointer_ = function(inPointer) {
  delete this.pointerMap[inPointer.pointerId];
  this.removePrimaryPointer_(inPointer);
};
ol.pointer.TouchSource.prototype.dedupSynthMouse_ = function(inEvent) {
  var lts = this.mouseSource.lastTouches;
  var t = inEvent.changedTouches[0];
  if (this.isPrimaryTouch_(t)) {
    var lt = [t.clientX, t.clientY];
    lts.push(lt);
    setTimeout(function() {
      ol.array.remove(lts, lt);
    }, ol.pointer.TouchSource.DEDUP_TIMEOUT);
  }
};
goog.provide("ol.pointer.PointerEventHandler");
goog.require("ol");
goog.require("ol.events");
goog.require("ol.events.EventTarget");
goog.require("ol.has");
goog.require("ol.pointer.EventType");
goog.require("ol.pointer.MouseSource");
goog.require("ol.pointer.MsSource");
goog.require("ol.pointer.NativeSource");
goog.require("ol.pointer.PointerEvent");
goog.require("ol.pointer.TouchSource");
ol.pointer.PointerEventHandler = function(element) {
  ol.events.EventTarget.call(this);
  this.element_ = element;
  this.pointerMap = {};
  this.eventMap_ = {};
  this.eventSourceList_ = [];
  this.registerSources();
};
ol.inherits(ol.pointer.PointerEventHandler, ol.events.EventTarget);
ol.pointer.PointerEventHandler.prototype.registerSources = function() {
  if (ol.has.POINTER) {
    this.registerSource("native", new ol.pointer.NativeSource(this));
  } else {
    if (ol.has.MSPOINTER) {
      this.registerSource("ms", new ol.pointer.MsSource(this));
    } else {
      var mouseSource = new ol.pointer.MouseSource(this);
      this.registerSource("mouse", mouseSource);
      if (ol.has.TOUCH) {
        this.registerSource("touch", new ol.pointer.TouchSource(this, mouseSource));
      }
    }
  }
  this.register_();
};
ol.pointer.PointerEventHandler.prototype.registerSource = function(name, source) {
  var s = source;
  var newEvents = s.getEvents();
  if (newEvents) {
    newEvents.forEach(function(e) {
      var handler = s.getHandlerForEvent(e);
      if (handler) {
        this.eventMap_[e] = handler.bind(s);
      }
    }, this);
    this.eventSourceList_.push(s);
  }
};
ol.pointer.PointerEventHandler.prototype.register_ = function() {
  var l = this.eventSourceList_.length;
  var eventSource;
  for (var i = 0; i < l; i++) {
    eventSource = this.eventSourceList_[i];
    this.addEvents_(eventSource.getEvents());
  }
};
ol.pointer.PointerEventHandler.prototype.unregister_ = function() {
  var l = this.eventSourceList_.length;
  var eventSource;
  for (var i = 0; i < l; i++) {
    eventSource = this.eventSourceList_[i];
    this.removeEvents_(eventSource.getEvents());
  }
};
ol.pointer.PointerEventHandler.prototype.eventHandler_ = function(inEvent) {
  var type = inEvent.type;
  var handler = this.eventMap_[type];
  if (handler) {
    handler(inEvent);
  }
};
ol.pointer.PointerEventHandler.prototype.addEvents_ = function(events) {
  events.forEach(function(eventName) {
    ol.events.listen(this.element_, eventName, this.eventHandler_, this);
  }, this);
};
ol.pointer.PointerEventHandler.prototype.removeEvents_ = function(events) {
  events.forEach(function(e) {
    ol.events.unlisten(this.element_, e, this.eventHandler_, this);
  }, this);
};
ol.pointer.PointerEventHandler.prototype.cloneEvent = function(event, inEvent) {
  var eventCopy = {}, p;
  for (var i = 0, ii = ol.pointer.PointerEventHandler.CLONE_PROPS.length; i < ii; i++) {
    p = ol.pointer.PointerEventHandler.CLONE_PROPS[i][0];
    eventCopy[p] = event[p] || inEvent[p] || ol.pointer.PointerEventHandler.CLONE_PROPS[i][1];
  }
  return eventCopy;
};
ol.pointer.PointerEventHandler.prototype.down = function(data, event) {
  this.fireEvent(ol.pointer.EventType.POINTERDOWN, data, event);
};
ol.pointer.PointerEventHandler.prototype.move = function(data, event) {
  this.fireEvent(ol.pointer.EventType.POINTERMOVE, data, event);
};
ol.pointer.PointerEventHandler.prototype.up = function(data, event) {
  this.fireEvent(ol.pointer.EventType.POINTERUP, data, event);
};
ol.pointer.PointerEventHandler.prototype.enter = function(data, event) {
  data.bubbles = false;
  this.fireEvent(ol.pointer.EventType.POINTERENTER, data, event);
};
ol.pointer.PointerEventHandler.prototype.leave = function(data, event) {
  data.bubbles = false;
  this.fireEvent(ol.pointer.EventType.POINTERLEAVE, data, event);
};
ol.pointer.PointerEventHandler.prototype.over = function(data, event) {
  data.bubbles = true;
  this.fireEvent(ol.pointer.EventType.POINTEROVER, data, event);
};
ol.pointer.PointerEventHandler.prototype.out = function(data, event) {
  data.bubbles = true;
  this.fireEvent(ol.pointer.EventType.POINTEROUT, data, event);
};
ol.pointer.PointerEventHandler.prototype.cancel = function(data, event) {
  this.fireEvent(ol.pointer.EventType.POINTERCANCEL, data, event);
};
ol.pointer.PointerEventHandler.prototype.leaveOut = function(data, event) {
  this.out(data, event);
  if (!this.contains_(data.target, data.relatedTarget)) {
    this.leave(data, event);
  }
};
ol.pointer.PointerEventHandler.prototype.enterOver = function(data, event) {
  this.over(data, event);
  if (!this.contains_(data.target, data.relatedTarget)) {
    this.enter(data, event);
  }
};
ol.pointer.PointerEventHandler.prototype.contains_ = function(container, contained) {
  if (!container || !contained) {
    return false;
  }
  return container.contains(contained);
};
ol.pointer.PointerEventHandler.prototype.makeEvent = function(inType, data, event) {
  return new ol.pointer.PointerEvent(inType, event, data);
};
ol.pointer.PointerEventHandler.prototype.fireEvent = function(inType, data, event) {
  var e = this.makeEvent(inType, data, event);
  this.dispatchEvent(e);
};
ol.pointer.PointerEventHandler.prototype.fireNativeEvent = function(event) {
  var e = this.makeEvent(event.type, event, event);
  this.dispatchEvent(e);
};
ol.pointer.PointerEventHandler.prototype.wrapMouseEvent = function(eventType, event) {
  var pointerEvent = this.makeEvent(eventType, ol.pointer.MouseSource.prepareEvent(event, this), event);
  return pointerEvent;
};
ol.pointer.PointerEventHandler.prototype.disposeInternal = function() {
  this.unregister_();
  ol.events.EventTarget.prototype.disposeInternal.call(this);
};
ol.pointer.PointerEventHandler.CLONE_PROPS = [["bubbles", false], ["cancelable", false], ["view", null], ["detail", null], ["screenX", 0], ["screenY", 0], ["clientX", 0], ["clientY", 0], ["ctrlKey", false], ["altKey", false], ["shiftKey", false], ["metaKey", false], ["button", 0], ["relatedTarget", null], ["buttons", 0], ["pointerId", 0], ["width", 0], ["height", 0], ["pressure", 0], ["tiltX", 0], ["tiltY", 0], ["pointerType", ""], ["hwTimestamp", 0], ["isPrimary", false], ["type", ""], ["target", 
null], ["currentTarget", null], ["which", 0]];
goog.provide("ol.MapBrowserEventHandler");
goog.require("ol");
goog.require("ol.has");
goog.require("ol.MapBrowserEventType");
goog.require("ol.MapBrowserPointerEvent");
goog.require("ol.events");
goog.require("ol.events.EventTarget");
goog.require("ol.pointer.EventType");
goog.require("ol.pointer.PointerEventHandler");
ol.MapBrowserEventHandler = function(map, moveTolerance) {
  ol.events.EventTarget.call(this);
  this.map_ = map;
  this.clickTimeoutId_ = 0;
  this.dragging_ = false;
  this.dragListenerKeys_ = [];
  this.moveTolerance_ = moveTolerance ? moveTolerance * ol.has.DEVICE_PIXEL_RATIO : ol.has.DEVICE_PIXEL_RATIO;
  this.down_ = null;
  var element = this.map_.getViewport();
  this.activePointers_ = 0;
  this.trackedTouches_ = {};
  this.pointerEventHandler_ = new ol.pointer.PointerEventHandler(element);
  this.documentPointerEventHandler_ = null;
  this.pointerdownListenerKey_ = ol.events.listen(this.pointerEventHandler_, ol.pointer.EventType.POINTERDOWN, this.handlePointerDown_, this);
  this.relayedListenerKey_ = ol.events.listen(this.pointerEventHandler_, ol.pointer.EventType.POINTERMOVE, this.relayEvent_, this);
};
ol.inherits(ol.MapBrowserEventHandler, ol.events.EventTarget);
ol.MapBrowserEventHandler.prototype.emulateClick_ = function(pointerEvent) {
  var newEvent = new ol.MapBrowserPointerEvent(ol.MapBrowserEventType.CLICK, this.map_, pointerEvent);
  this.dispatchEvent(newEvent);
  if (this.clickTimeoutId_ !== 0) {
    clearTimeout(this.clickTimeoutId_);
    this.clickTimeoutId_ = 0;
    newEvent = new ol.MapBrowserPointerEvent(ol.MapBrowserEventType.DBLCLICK, this.map_, pointerEvent);
    this.dispatchEvent(newEvent);
  } else {
    this.clickTimeoutId_ = setTimeout(function() {
      this.clickTimeoutId_ = 0;
      var newEvent = new ol.MapBrowserPointerEvent(ol.MapBrowserEventType.SINGLECLICK, this.map_, pointerEvent);
      this.dispatchEvent(newEvent);
    }.bind(this), 250);
  }
};
ol.MapBrowserEventHandler.prototype.updateActivePointers_ = function(pointerEvent) {
  var event = pointerEvent;
  if (event.type == ol.MapBrowserEventType.POINTERUP || event.type == ol.MapBrowserEventType.POINTERCANCEL) {
    delete this.trackedTouches_[event.pointerId];
  } else {
    if (event.type == ol.MapBrowserEventType.POINTERDOWN) {
      this.trackedTouches_[event.pointerId] = true;
    }
  }
  this.activePointers_ = Object.keys(this.trackedTouches_).length;
};
ol.MapBrowserEventHandler.prototype.handlePointerUp_ = function(pointerEvent) {
  this.updateActivePointers_(pointerEvent);
  var newEvent = new ol.MapBrowserPointerEvent(ol.MapBrowserEventType.POINTERUP, this.map_, pointerEvent);
  this.dispatchEvent(newEvent);
  if (!newEvent.propagationStopped && !this.dragging_ && this.isMouseActionButton_(pointerEvent)) {
    this.emulateClick_(this.down_);
  }
  if (this.activePointers_ === 0) {
    this.dragListenerKeys_.forEach(ol.events.unlistenByKey);
    this.dragListenerKeys_.length = 0;
    this.dragging_ = false;
    this.down_ = null;
    this.documentPointerEventHandler_.dispose();
    this.documentPointerEventHandler_ = null;
  }
};
ol.MapBrowserEventHandler.prototype.isMouseActionButton_ = function(pointerEvent) {
  return pointerEvent.button === 0;
};
ol.MapBrowserEventHandler.prototype.handlePointerDown_ = function(pointerEvent) {
  this.updateActivePointers_(pointerEvent);
  var newEvent = new ol.MapBrowserPointerEvent(ol.MapBrowserEventType.POINTERDOWN, this.map_, pointerEvent);
  this.dispatchEvent(newEvent);
  this.down_ = pointerEvent;
  if (this.dragListenerKeys_.length === 0) {
    this.documentPointerEventHandler_ = new ol.pointer.PointerEventHandler(document);
    this.dragListenerKeys_.push(ol.events.listen(this.documentPointerEventHandler_, ol.MapBrowserEventType.POINTERMOVE, this.handlePointerMove_, this), ol.events.listen(this.documentPointerEventHandler_, ol.MapBrowserEventType.POINTERUP, this.handlePointerUp_, this), ol.events.listen(this.pointerEventHandler_, ol.MapBrowserEventType.POINTERCANCEL, this.handlePointerUp_, this));
  }
};
ol.MapBrowserEventHandler.prototype.handlePointerMove_ = function(pointerEvent) {
  if (this.isMoving_(pointerEvent)) {
    this.dragging_ = true;
    var newEvent = new ol.MapBrowserPointerEvent(ol.MapBrowserEventType.POINTERDRAG, this.map_, pointerEvent, this.dragging_);
    this.dispatchEvent(newEvent);
  }
  pointerEvent.preventDefault();
};
ol.MapBrowserEventHandler.prototype.relayEvent_ = function(pointerEvent) {
  var dragging = !!(this.down_ && this.isMoving_(pointerEvent));
  this.dispatchEvent(new ol.MapBrowserPointerEvent(pointerEvent.type, this.map_, pointerEvent, dragging));
};
ol.MapBrowserEventHandler.prototype.isMoving_ = function(pointerEvent) {
  return Math.abs(pointerEvent.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_;
};
ol.MapBrowserEventHandler.prototype.disposeInternal = function() {
  if (this.relayedListenerKey_) {
    ol.events.unlistenByKey(this.relayedListenerKey_);
    this.relayedListenerKey_ = null;
  }
  if (this.pointerdownListenerKey_) {
    ol.events.unlistenByKey(this.pointerdownListenerKey_);
    this.pointerdownListenerKey_ = null;
  }
  this.dragListenerKeys_.forEach(ol.events.unlistenByKey);
  this.dragListenerKeys_.length = 0;
  if (this.documentPointerEventHandler_) {
    this.documentPointerEventHandler_.dispose();
    this.documentPointerEventHandler_ = null;
  }
  if (this.pointerEventHandler_) {
    this.pointerEventHandler_.dispose();
    this.pointerEventHandler_ = null;
  }
  ol.events.EventTarget.prototype.disposeInternal.call(this);
};
goog.provide("ol.MapProperty");
ol.MapProperty = {LAYERGROUP:"layergroup", SIZE:"size", TARGET:"target", VIEW:"view"};
goog.provide("ol.structs.PriorityQueue");
goog.require("ol.asserts");
goog.require("ol.obj");
ol.structs.PriorityQueue = function(priorityFunction, keyFunction) {
  this.priorityFunction_ = priorityFunction;
  this.keyFunction_ = keyFunction;
  this.elements_ = [];
  this.priorities_ = [];
  this.queuedElements_ = {};
};
ol.structs.PriorityQueue.DROP = Infinity;
ol.structs.PriorityQueue.prototype.clear = function() {
  this.elements_.length = 0;
  this.priorities_.length = 0;
  ol.obj.clear(this.queuedElements_);
};
ol.structs.PriorityQueue.prototype.dequeue = function() {
  var elements = this.elements_;
  var priorities = this.priorities_;
  var element = elements[0];
  if (elements.length == 1) {
    elements.length = 0;
    priorities.length = 0;
  } else {
    elements[0] = elements.pop();
    priorities[0] = priorities.pop();
    this.siftUp_(0);
  }
  var elementKey = this.keyFunction_(element);
  delete this.queuedElements_[elementKey];
  return element;
};
ol.structs.PriorityQueue.prototype.enqueue = function(element) {
  ol.asserts.assert(!(this.keyFunction_(element) in this.queuedElements_), 31);
  var priority = this.priorityFunction_(element);
  if (priority != ol.structs.PriorityQueue.DROP) {
    this.elements_.push(element);
    this.priorities_.push(priority);
    this.queuedElements_[this.keyFunction_(element)] = true;
    this.siftDown_(0, this.elements_.length - 1);
    return true;
  }
  return false;
};
ol.structs.PriorityQueue.prototype.getCount = function() {
  return this.elements_.length;
};
ol.structs.PriorityQueue.prototype.getLeftChildIndex_ = function(index) {
  return index * 2 + 1;
};
ol.structs.PriorityQueue.prototype.getRightChildIndex_ = function(index) {
  return index * 2 + 2;
};
ol.structs.PriorityQueue.prototype.getParentIndex_ = function(index) {
  return index - 1 >> 1;
};
ol.structs.PriorityQueue.prototype.heapify_ = function() {
  var i;
  for (i = (this.elements_.length >> 1) - 1; i >= 0; i--) {
    this.siftUp_(i);
  }
};
ol.structs.PriorityQueue.prototype.isEmpty = function() {
  return this.elements_.length === 0;
};
ol.structs.PriorityQueue.prototype.isKeyQueued = function(key) {
  return key in this.queuedElements_;
};
ol.structs.PriorityQueue.prototype.isQueued = function(element) {
  return this.isKeyQueued(this.keyFunction_(element));
};
ol.structs.PriorityQueue.prototype.siftUp_ = function(index) {
  var elements = this.elements_;
  var priorities = this.priorities_;
  var count = elements.length;
  var element = elements[index];
  var priority = priorities[index];
  var startIndex = index;
  while (index < count >> 1) {
    var lIndex = this.getLeftChildIndex_(index);
    var rIndex = this.getRightChildIndex_(index);
    var smallerChildIndex = rIndex < count && priorities[rIndex] < priorities[lIndex] ? rIndex : lIndex;
    elements[index] = elements[smallerChildIndex];
    priorities[index] = priorities[smallerChildIndex];
    index = smallerChildIndex;
  }
  elements[index] = element;
  priorities[index] = priority;
  this.siftDown_(startIndex, index);
};
ol.structs.PriorityQueue.prototype.siftDown_ = function(startIndex, index) {
  var elements = this.elements_;
  var priorities = this.priorities_;
  var element = elements[index];
  var priority = priorities[index];
  while (index > startIndex) {
    var parentIndex = this.getParentIndex_(index);
    if (priorities[parentIndex] > priority) {
      elements[index] = elements[parentIndex];
      priorities[index] = priorities[parentIndex];
      index = parentIndex;
    } else {
      break;
    }
  }
  elements[index] = element;
  priorities[index] = priority;
};
ol.structs.PriorityQueue.prototype.reprioritize = function() {
  var priorityFunction = this.priorityFunction_;
  var elements = this.elements_;
  var priorities = this.priorities_;
  var index = 0;
  var n = elements.length;
  var element, i, priority;
  for (i = 0; i < n; ++i) {
    element = elements[i];
    priority = priorityFunction(element);
    if (priority == ol.structs.PriorityQueue.DROP) {
      delete this.queuedElements_[this.keyFunction_(element)];
    } else {
      priorities[index] = priority;
      elements[index++] = element;
    }
  }
  elements.length = index;
  priorities.length = index;
  this.heapify_();
};
goog.provide("ol.TileQueue");
goog.require("ol");
goog.require("ol.TileState");
goog.require("ol.events");
goog.require("ol.events.EventType");
goog.require("ol.structs.PriorityQueue");
ol.TileQueue = function(tilePriorityFunction, tileChangeCallback) {
  ol.structs.PriorityQueue.call(this, function(element) {
    return tilePriorityFunction.apply(null, element);
  }, function(element) {
    return element[0].getKey();
  });
  this.tileChangeCallback_ = tileChangeCallback;
  this.tilesLoading_ = 0;
  this.tilesLoadingKeys_ = {};
};
ol.inherits(ol.TileQueue, ol.structs.PriorityQueue);
ol.TileQueue.prototype.enqueue = function(element) {
  var added = ol.structs.PriorityQueue.prototype.enqueue.call(this, element);
  if (added) {
    var tile = element[0];
    ol.events.listen(tile, ol.events.EventType.CHANGE, this.handleTileChange, this);
  }
  return added;
};
ol.TileQueue.prototype.getTilesLoading = function() {
  return this.tilesLoading_;
};
ol.TileQueue.prototype.handleTileChange = function(event) {
  var tile = event.target;
  var state = tile.getState();
  if (state === ol.TileState.LOADED || state === ol.TileState.ERROR || state === ol.TileState.EMPTY || state === ol.TileState.ABORT) {
    ol.events.unlisten(tile, ol.events.EventType.CHANGE, this.handleTileChange, this);
    var tileKey = tile.getKey();
    if (tileKey in this.tilesLoadingKeys_) {
      delete this.tilesLoadingKeys_[tileKey];
      --this.tilesLoading_;
    }
    this.tileChangeCallback_();
  }
};
ol.TileQueue.prototype.loadMoreTiles = function(maxTotalLoading, maxNewLoads) {
  var newLoads = 0;
  var abortedTiles = false;
  var state, tile, tileKey;
  while (this.tilesLoading_ < maxTotalLoading && newLoads < maxNewLoads && this.getCount() > 0) {
    tile = this.dequeue()[0];
    tileKey = tile.getKey();
    state = tile.getState();
    if (state === ol.TileState.ABORT) {
      abortedTiles = true;
    } else {
      if (state === ol.TileState.IDLE && !(tileKey in this.tilesLoadingKeys_)) {
        this.tilesLoadingKeys_[tileKey] = true;
        ++this.tilesLoading_;
        ++newLoads;
        tile.load();
      }
    }
  }
  if (newLoads === 0 && abortedTiles) {
    this.tileChangeCallback_();
  }
};
goog.provide("ol.CenterConstraint");
goog.require("ol.math");
ol.CenterConstraint.createExtent = function(extent) {
  return function(center) {
    if (center) {
      return [ol.math.clamp(center[0], extent[0], extent[2]), ol.math.clamp(center[1], extent[1], extent[3])];
    } else {
      return undefined;
    }
  };
};
ol.CenterConstraint.none = function(center) {
  return center;
};
goog.provide("ol.ResolutionConstraint");
goog.require("ol.array");
goog.require("ol.math");
ol.ResolutionConstraint.createSnapToResolutions = function(resolutions) {
  return function(resolution, delta, direction) {
    if (resolution !== undefined) {
      var z = ol.array.linearFindNearest(resolutions, resolution, direction);
      z = ol.math.clamp(z + delta, 0, resolutions.length - 1);
      var index = Math.floor(z);
      if (z != index && index < resolutions.length - 1) {
        var power = resolutions[index] / resolutions[index + 1];
        return resolutions[index] / Math.pow(power, z - index);
      } else {
        return resolutions[index];
      }
    } else {
      return undefined;
    }
  };
};
ol.ResolutionConstraint.createSnapToPower = function(power, maxResolution, opt_maxLevel) {
  return function(resolution, delta, direction) {
    if (resolution !== undefined) {
      var offset = -direction / 2 + 0.5;
      var oldLevel = Math.floor(Math.log(maxResolution / resolution) / Math.log(power) + offset);
      var newLevel = Math.max(oldLevel + delta, 0);
      if (opt_maxLevel !== undefined) {
        newLevel = Math.min(newLevel, opt_maxLevel);
      }
      return maxResolution / Math.pow(power, newLevel);
    } else {
      return undefined;
    }
  };
};
goog.provide("ol.RotationConstraint");
goog.require("ol.math");
ol.RotationConstraint.disable = function(rotation, delta) {
  if (rotation !== undefined) {
    return 0;
  } else {
    return undefined;
  }
};
ol.RotationConstraint.none = function(rotation, delta) {
  if (rotation !== undefined) {
    return rotation + delta;
  } else {
    return undefined;
  }
};
ol.RotationConstraint.createSnapToN = function(n) {
  var theta = 2 * Math.PI / n;
  return function(rotation, delta) {
    if (rotation !== undefined) {
      rotation = Math.floor((rotation + delta) / theta + 0.5) * theta;
      return rotation;
    } else {
      return undefined;
    }
  };
};
ol.RotationConstraint.createSnapToZero = function(opt_tolerance) {
  var tolerance = opt_tolerance || ol.math.toRadians(5);
  return function(rotation, delta) {
    if (rotation !== undefined) {
      if (Math.abs(rotation + delta) <= tolerance) {
        return 0;
      } else {
        return rotation + delta;
      }
    } else {
      return undefined;
    }
  };
};
goog.provide("ol.ViewHint");
ol.ViewHint = {ANIMATING:0, INTERACTING:1};
goog.provide("ol.ViewProperty");
ol.ViewProperty = {CENTER:"center", RESOLUTION:"resolution", ROTATION:"rotation"};
goog.provide("ol.geom.flat.area");
ol.geom.flat.area.linearRing = function(flatCoordinates, offset, end, stride) {
  var twiceArea = 0;
  var x1 = flatCoordinates[end - stride];
  var y1 = flatCoordinates[end - stride + 1];
  for (; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];
    twiceArea += y1 * x2 - x1 * y2;
    x1 = x2;
    y1 = y2;
  }
  return twiceArea / 2;
};
ol.geom.flat.area.linearRings = function(flatCoordinates, offset, ends, stride) {
  var area = 0;
  var i, ii;
  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    area += ol.geom.flat.area.linearRing(flatCoordinates, offset, end, stride);
    offset = end;
  }
  return area;
};
ol.geom.flat.area.linearRingss = function(flatCoordinates, offset, endss, stride) {
  var area = 0;
  var i, ii;
  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    area += ol.geom.flat.area.linearRings(flatCoordinates, offset, ends, stride);
    offset = ends[ends.length - 1];
  }
  return area;
};
goog.provide("ol.geom.flat.closest");
goog.require("ol.math");
ol.geom.flat.closest.point = function(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {
  var x1 = flatCoordinates[offset1];
  var y1 = flatCoordinates[offset1 + 1];
  var dx = flatCoordinates[offset2] - x1;
  var dy = flatCoordinates[offset2 + 1] - y1;
  var i, offset;
  if (dx === 0 && dy === 0) {
    offset = offset1;
  } else {
    var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      offset = offset2;
    } else {
      if (t > 0) {
        for (i = 0; i < stride; ++i) {
          closestPoint[i] = ol.math.lerp(flatCoordinates[offset1 + i], flatCoordinates[offset2 + i], t);
        }
        closestPoint.length = stride;
        return;
      } else {
        offset = offset1;
      }
    }
  }
  for (i = 0; i < stride; ++i) {
    closestPoint[i] = flatCoordinates[offset + i];
  }
  closestPoint.length = stride;
};
ol.geom.flat.closest.getMaxSquaredDelta = function(flatCoordinates, offset, end, stride, maxSquaredDelta) {
  var x1 = flatCoordinates[offset];
  var y1 = flatCoordinates[offset + 1];
  for (offset += stride; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];
    var squaredDelta = ol.math.squaredDistance(x1, y1, x2, y2);
    if (squaredDelta > maxSquaredDelta) {
      maxSquaredDelta = squaredDelta;
    }
    x1 = x2;
    y1 = y2;
  }
  return maxSquaredDelta;
};
ol.geom.flat.closest.getsMaxSquaredDelta = function(flatCoordinates, offset, ends, stride, maxSquaredDelta) {
  var i, ii;
  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    maxSquaredDelta = ol.geom.flat.closest.getMaxSquaredDelta(flatCoordinates, offset, end, stride, maxSquaredDelta);
    offset = end;
  }
  return maxSquaredDelta;
};
ol.geom.flat.closest.getssMaxSquaredDelta = function(flatCoordinates, offset, endss, stride, maxSquaredDelta) {
  var i, ii;
  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    maxSquaredDelta = ol.geom.flat.closest.getsMaxSquaredDelta(flatCoordinates, offset, ends, stride, maxSquaredDelta);
    offset = ends[ends.length - 1];
  }
  return maxSquaredDelta;
};
ol.geom.flat.closest.getClosestPoint = function(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {
  if (offset == end) {
    return minSquaredDistance;
  }
  var i, squaredDistance;
  if (maxDelta === 0) {
    squaredDistance = ol.math.squaredDistance(x, y, flatCoordinates[offset], flatCoordinates[offset + 1]);
    if (squaredDistance < minSquaredDistance) {
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = flatCoordinates[offset + i];
      }
      closestPoint.length = stride;
      return squaredDistance;
    } else {
      return minSquaredDistance;
    }
  }
  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
  var index = offset + stride;
  while (index < end) {
    ol.geom.flat.closest.point(flatCoordinates, index - stride, index, stride, x, y, tmpPoint);
    squaredDistance = ol.math.squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);
    if (squaredDistance < minSquaredDistance) {
      minSquaredDistance = squaredDistance;
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint[i];
      }
      closestPoint.length = stride;
      index += stride;
    } else {
      index += stride * Math.max((Math.sqrt(squaredDistance) - Math.sqrt(minSquaredDistance)) / maxDelta | 0, 1);
    }
  }
  if (isRing) {
    ol.geom.flat.closest.point(flatCoordinates, end - stride, offset, stride, x, y, tmpPoint);
    squaredDistance = ol.math.squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);
    if (squaredDistance < minSquaredDistance) {
      minSquaredDistance = squaredDistance;
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint[i];
      }
      closestPoint.length = stride;
    }
  }
  return minSquaredDistance;
};
ol.geom.flat.closest.getsClosestPoint = function(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {
  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
  var i, ii;
  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    minSquaredDistance = ol.geom.flat.closest.getClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
    offset = end;
  }
  return minSquaredDistance;
};
ol.geom.flat.closest.getssClosestPoint = function(flatCoordinates, offset, endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {
  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
  var i, ii;
  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    minSquaredDistance = ol.geom.flat.closest.getsClosestPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
    offset = ends[ends.length - 1];
  }
  return minSquaredDistance;
};
goog.provide("ol.geom.flat.inflate");
ol.geom.flat.inflate.coordinates = function(flatCoordinates, offset, end, stride, opt_coordinates) {
  var coordinates = opt_coordinates !== undefined ? opt_coordinates : [];
  var i = 0;
  var j;
  for (j = offset; j < end; j += stride) {
    coordinates[i++] = flatCoordinates.slice(j, j + stride);
  }
  coordinates.length = i;
  return coordinates;
};
ol.geom.flat.inflate.coordinatess = function(flatCoordinates, offset, ends, stride, opt_coordinatess) {
  var coordinatess = opt_coordinatess !== undefined ? opt_coordinatess : [];
  var i = 0;
  var j, jj;
  for (j = 0, jj = ends.length; j < jj; ++j) {
    var end = ends[j];
    coordinatess[i++] = ol.geom.flat.inflate.coordinates(flatCoordinates, offset, end, stride, coordinatess[i]);
    offset = end;
  }
  coordinatess.length = i;
  return coordinatess;
};
ol.geom.flat.inflate.coordinatesss = function(flatCoordinates, offset, endss, stride, opt_coordinatesss) {
  var coordinatesss = opt_coordinatesss !== undefined ? opt_coordinatesss : [];
  var i = 0;
  var j, jj;
  for (j = 0, jj = endss.length; j < jj; ++j) {
    var ends = endss[j];
    coordinatesss[i++] = ol.geom.flat.inflate.coordinatess(flatCoordinates, offset, ends, stride, coordinatesss[i]);
    offset = ends[ends.length - 1];
  }
  coordinatesss.length = i;
  return coordinatesss;
};
goog.provide("ol.geom.flat.simplify");
goog.require("ol.math");
ol.geom.flat.simplify.lineString = function(flatCoordinates, offset, end, stride, squaredTolerance, highQuality, opt_simplifiedFlatCoordinates) {
  var simplifiedFlatCoordinates = opt_simplifiedFlatCoordinates !== undefined ? opt_simplifiedFlatCoordinates : [];
  if (!highQuality) {
    end = ol.geom.flat.simplify.radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);
    flatCoordinates = simplifiedFlatCoordinates;
    offset = 0;
    stride = 2;
  }
  simplifiedFlatCoordinates.length = ol.geom.flat.simplify.douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);
  return simplifiedFlatCoordinates;
};
ol.geom.flat.simplify.douglasPeucker = function(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  var n = (end - offset) / stride;
  if (n < 3) {
    for (; offset < end; offset += stride) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];
    }
    return simplifiedOffset;
  }
  var markers = new Array(n);
  markers[0] = 1;
  markers[n - 1] = 1;
  var stack = [offset, end - stride];
  var index = 0;
  var i;
  while (stack.length > 0) {
    var last = stack.pop();
    var first = stack.pop();
    var maxSquaredDistance = 0;
    var x1 = flatCoordinates[first];
    var y1 = flatCoordinates[first + 1];
    var x2 = flatCoordinates[last];
    var y2 = flatCoordinates[last + 1];
    for (i = first + stride; i < last; i += stride) {
      var x = flatCoordinates[i];
      var y = flatCoordinates[i + 1];
      var squaredDistance = ol.math.squaredSegmentDistance(x, y, x1, y1, x2, y2);
      if (squaredDistance > maxSquaredDistance) {
        index = i;
        maxSquaredDistance = squaredDistance;
      }
    }
    if (maxSquaredDistance > squaredTolerance) {
      markers[(index - offset) / stride] = 1;
      if (first + stride < index) {
        stack.push(first, index);
      }
      if (index + stride < last) {
        stack.push(index, last);
      }
    }
  }
  for (i = 0; i < n; ++i) {
    if (markers[i]) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i * stride];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i * stride + 1];
    }
  }
  return simplifiedOffset;
};
ol.geom.flat.simplify.douglasPeuckers = function(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
  var i, ii;
  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    simplifiedOffset = ol.geom.flat.simplify.douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset);
    simplifiedEnds.push(simplifiedOffset);
    offset = end;
  }
  return simplifiedOffset;
};
ol.geom.flat.simplify.douglasPeuckerss = function(flatCoordinates, offset, endss, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
  var i, ii;
  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    var simplifiedEnds = [];
    simplifiedOffset = ol.geom.flat.simplify.douglasPeuckers(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);
    simplifiedEndss.push(simplifiedEnds);
    offset = ends[ends.length - 1];
  }
  return simplifiedOffset;
};
ol.geom.flat.simplify.radialDistance = function(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  if (end <= offset + stride) {
    for (; offset < end; offset += stride) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];
    }
    return simplifiedOffset;
  }
  var x1 = flatCoordinates[offset];
  var y1 = flatCoordinates[offset + 1];
  simplifiedFlatCoordinates[simplifiedOffset++] = x1;
  simplifiedFlatCoordinates[simplifiedOffset++] = y1;
  var x2 = x1;
  var y2 = y1;
  for (offset += stride; offset < end; offset += stride) {
    x2 = flatCoordinates[offset];
    y2 = flatCoordinates[offset + 1];
    if (ol.math.squaredDistance(x1, y1, x2, y2) > squaredTolerance) {
      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      x1 = x2;
      y1 = y2;
    }
  }
  if (x2 != x1 || y2 != y1) {
    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
  }
  return simplifiedOffset;
};
ol.geom.flat.simplify.snap = function(value, tolerance) {
  return tolerance * Math.round(value / tolerance);
};
ol.geom.flat.simplify.quantize = function(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  if (offset == end) {
    return simplifiedOffset;
  }
  var x1 = ol.geom.flat.simplify.snap(flatCoordinates[offset], tolerance);
  var y1 = ol.geom.flat.simplify.snap(flatCoordinates[offset + 1], tolerance);
  offset += stride;
  simplifiedFlatCoordinates[simplifiedOffset++] = x1;
  simplifiedFlatCoordinates[simplifiedOffset++] = y1;
  var x2, y2;
  do {
    x2 = ol.geom.flat.simplify.snap(flatCoordinates[offset], tolerance);
    y2 = ol.geom.flat.simplify.snap(flatCoordinates[offset + 1], tolerance);
    offset += stride;
    if (offset == end) {
      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      return simplifiedOffset;
    }
  } while (x2 == x1 && y2 == y1);
  while (offset < end) {
    var x3, y3;
    x3 = ol.geom.flat.simplify.snap(flatCoordinates[offset], tolerance);
    y3 = ol.geom.flat.simplify.snap(flatCoordinates[offset + 1], tolerance);
    offset += stride;
    if (x3 == x2 && y3 == y2) {
      continue;
    }
    var dx1 = x2 - x1;
    var dy1 = y2 - y1;
    var dx2 = x3 - x1;
    var dy2 = y3 - y1;
    if (dx1 * dy2 == dy1 * dx2 && (dx1 < 0 && dx2 < dx1 || dx1 == dx2 || dx1 > 0 && dx2 > dx1) && (dy1 < 0 && dy2 < dy1 || dy1 == dy2 || dy1 > 0 && dy2 > dy1)) {
      x2 = x3;
      y2 = y3;
      continue;
    }
    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
    x1 = x2;
    y1 = y2;
    x2 = x3;
    y2 = y3;
  }
  simplifiedFlatCoordinates[simplifiedOffset++] = x2;
  simplifiedFlatCoordinates[simplifiedOffset++] = y2;
  return simplifiedOffset;
};
ol.geom.flat.simplify.quantizes = function(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
  var i, ii;
  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    simplifiedOffset = ol.geom.flat.simplify.quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset);
    simplifiedEnds.push(simplifiedOffset);
    offset = end;
  }
  return simplifiedOffset;
};
ol.geom.flat.simplify.quantizess = function(flatCoordinates, offset, endss, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
  var i, ii;
  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    var simplifiedEnds = [];
    simplifiedOffset = ol.geom.flat.simplify.quantizes(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);
    simplifiedEndss.push(simplifiedEnds);
    offset = ends[ends.length - 1];
  }
  return simplifiedOffset;
};
goog.provide("ol.geom.LinearRing");
goog.require("ol");
goog.require("ol.extent");
goog.require("ol.geom.GeometryLayout");
goog.require("ol.geom.GeometryType");
goog.require("ol.geom.SimpleGeometry");
goog.require("ol.geom.flat.area");
goog.require("ol.geom.flat.closest");
goog.require("ol.geom.flat.deflate");
goog.require("ol.geom.flat.inflate");
goog.require("ol.geom.flat.simplify");
ol.geom.LinearRing = function(coordinates, opt_layout) {
  ol.geom.SimpleGeometry.call(this);
  this.maxDelta_ = -1;
  this.maxDeltaRevision_ = -1;
  this.setCoordinates(coordinates, opt_layout);
};
ol.inherits(ol.geom.LinearRing, ol.geom.SimpleGeometry);
ol.geom.LinearRing.prototype.clone = function() {
  var linearRing = new ol.geom.LinearRing(null);
  linearRing.setFlatCoordinates(this.layout, this.flatCoordinates.slice());
  return linearRing;
};
ol.geom.LinearRing.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {
  if (minSquaredDistance < ol.extent.closestSquaredDistanceXY(this.getExtent(), x, y)) {
    return minSquaredDistance;
  }
  if (this.maxDeltaRevision_ != this.getRevision()) {
    this.maxDelta_ = Math.sqrt(ol.geom.flat.closest.getMaxSquaredDelta(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
    this.maxDeltaRevision_ = this.getRevision();
  }
  return ol.geom.flat.closest.getClosestPoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
};
ol.geom.LinearRing.prototype.getArea = function() {
  return ol.geom.flat.area.linearRing(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
};
ol.geom.LinearRing.prototype.getCoordinates = function() {
  return ol.geom.flat.inflate.coordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
};
ol.geom.LinearRing.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {
  var simplifiedFlatCoordinates = [];
  simplifiedFlatCoordinates.length = ol.geom.flat.simplify.douglasPeucker(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);
  var simplifiedLinearRing = new ol.geom.LinearRing(null);
  simplifiedLinearRing.setFlatCoordinates(ol.geom.GeometryLayout.XY, simplifiedFlatCoordinates);
  return simplifiedLinearRing;
};
ol.geom.LinearRing.prototype.getType = function() {
  return ol.geom.GeometryType.LINEAR_RING;
};
ol.geom.LinearRing.prototype.intersectsExtent = function(extent) {
};
ol.geom.LinearRing.prototype.setCoordinates = function(coordinates, opt_layout) {
  if (!coordinates) {
    this.setFlatCoordinates(ol.geom.GeometryLayout.XY, null);
  } else {
    this.setLayout(opt_layout, coordinates, 1);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = ol.geom.flat.deflate.coordinates(this.flatCoordinates, 0, coordinates, this.stride);
    this.changed();
  }
};
ol.geom.LinearRing.prototype.setFlatCoordinates = function(layout, flatCoordinates) {
  this.setFlatCoordinatesInternal(layout, flatCoordinates);
  this.changed();
};
goog.provide("ol.geom.flat.contains");
goog.require("ol.extent");
ol.geom.flat.contains.linearRingContainsExtent = function(flatCoordinates, offset, end, stride, extent) {
  var outside = ol.extent.forEachCorner(extent, function(coordinate) {
    return !ol.geom.flat.contains.linearRingContainsXY(flatCoordinates, offset, end, stride, coordinate[0], coordinate[1]);
  });
  return !outside;
};
ol.geom.flat.contains.linearRingContainsXY = function(flatCoordinates, offset, end, stride, x, y) {
  var wn = 0;
  var x1 = flatCoordinates[end - stride];
  var y1 = flatCoordinates[end - stride + 1];
  for (; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];
    if (y1 <= y) {
      if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {
        wn++;
      }
    } else {
      if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {
        wn--;
      }
    }
    x1 = x2;
    y1 = y2;
  }
  return wn !== 0;
};
ol.geom.flat.contains.linearRingsContainsXY = function(flatCoordinates, offset, ends, stride, x, y) {
  if (ends.length === 0) {
    return false;
  }
  if (!ol.geom.flat.contains.linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {
    return false;
  }
  var i, ii;
  for (i = 1, ii = ends.length; i < ii; ++i) {
    if (ol.geom.flat.contains.linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)) {
      return false;
    }
  }
  return true;
};
ol.geom.flat.contains.linearRingssContainsXY = function(flatCoordinates, offset, endss, stride, x, y) {
  if (endss.length === 0) {
    return false;
  }
  var i, ii;
  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    if (ol.geom.flat.contains.linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {
      return true;
    }
    offset = ends[ends.length - 1];
  }
  return false;
};
goog.provide("ol.geom.flat.interiorpoint");
goog.require("ol.array");
goog.require("ol.geom.flat.contains");
ol.geom.flat.interiorpoint.linearRings = function(flatCoordinates, offset, ends, stride, flatCenters, flatCentersOffset, opt_dest) {
  var i, ii, x, x1, x2, y1, y2;
  var y = flatCenters[flatCentersOffset + 1];
  var intersections = [];
  for (var r = 0, rr = ends.length; r < rr; ++r) {
    var end = ends[r];
    x1 = flatCoordinates[end - stride];
    y1 = flatCoordinates[end - stride + 1];
    for (i = offset; i < end; i += stride) {
      x2 = flatCoordinates[i];
      y2 = flatCoordinates[i + 1];
      if (y <= y1 && y2 <= y || y1 <= y && y <= y2) {
        x = (y - y1) / (y2 - y1) * (x2 - x1) + x1;
        intersections.push(x);
      }
      x1 = x2;
      y1 = y2;
    }
  }
  var pointX = NaN;
  var maxSegmentLength = -Infinity;
  intersections.sort(ol.array.numberSafeCompareFunction);
  x1 = intersections[0];
  for (i = 1, ii = intersections.length; i < ii; ++i) {
    x2 = intersections[i];
    var segmentLength = Math.abs(x2 - x1);
    if (segmentLength > maxSegmentLength) {
      x = (x1 + x2) / 2;
      if (ol.geom.flat.contains.linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {
        pointX = x;
        maxSegmentLength = segmentLength;
      }
    }
    x1 = x2;
  }
  if (isNaN(pointX)) {
    pointX = flatCenters[flatCentersOffset];
  }
  if (opt_dest) {
    opt_dest.push(pointX, y, maxSegmentLength);
    return opt_dest;
  } else {
    return [pointX, y, maxSegmentLength];
  }
};
ol.geom.flat.interiorpoint.linearRingss = function(flatCoordinates, offset, endss, stride, flatCenters) {
  var interiorPoints = [];
  var i, ii;
  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    interiorPoints = ol.geom.flat.interiorpoint.linearRings(flatCoordinates, offset, ends, stride, flatCenters, 2 * i, interiorPoints);
    offset = ends[ends.length - 1];
  }
  return interiorPoints;
};
goog.provide("ol.geom.flat.segments");
ol.geom.flat.segments.forEach = function(flatCoordinates, offset, end, stride, callback, opt_this) {
  var point1 = [flatCoordinates[offset], flatCoordinates[offset + 1]];
  var point2 = [];
  var ret;
  for (; offset + stride < end; offset += stride) {
    point2[0] = flatCoordinates[offset + stride];
    point2[1] = flatCoordinates[offset + stride + 1];
    ret = callback.call(opt_this, point1, point2);
    if (ret) {
      return ret;
    }
    point1[0] = point2[0];
    point1[1] = point2[1];
  }
  return false;
};
goog.provide("ol.geom.flat.intersectsextent");
goog.require("ol.extent");
goog.require("ol.geom.flat.contains");
goog.require("ol.geom.flat.segments");
ol.geom.flat.intersectsextent.lineString = function(flatCoordinates, offset, end, stride, extent) {
  var coordinatesExtent = ol.extent.extendFlatCoordinates(ol.extent.createEmpty(), flatCoordinates, offset, end, stride);
  if (!ol.extent.intersects(extent, coordinatesExtent)) {
    return false;
  }
  if (ol.extent.containsExtent(extent, coordinatesExtent)) {
    return true;
  }
  if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) {
    return true;
  }
  if (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) {
    return true;
  }
  return ol.geom.flat.segments.forEach(flatCoordinates, offset, end, stride, function(point1, point2) {
    return ol.extent.intersectsSegment(extent, point1, point2);
  });
};
ol.geom.flat.intersectsextent.lineStrings = function(flatCoordinates, offset, ends, stride, extent) {
  var i, ii;
  for (i = 0, ii = ends.length; i < ii; ++i) {
    if (ol.geom.flat.intersectsextent.lineString(flatCoordinates, offset, ends[i], stride, extent)) {
      return true;
    }
    offset = ends[i];
  }
  return false;
};
ol.geom.flat.intersectsextent.linearRing = function(flatCoordinates, offset, end, stride, extent) {
  if (ol.geom.flat.intersectsextent.lineString(flatCoordinates, offset, end, stride, extent)) {
    return true;
  }
  if (ol.geom.flat.contains.linearRingContainsXY(flatCoordinates, offset, end, stride, extent[0], extent[1])) {
    return true;
  }
  if (ol.geom.flat.contains.linearRingContainsXY(flatCoordinates, offset, end, stride, extent[0], extent[3])) {
    return true;
  }
  if (ol.geom.flat.contains.linearRingContainsXY(flatCoordinates, offset, end, stride, extent[2], extent[1])) {
    return true;
  }
  if (ol.geom.flat.contains.linearRingContainsXY(flatCoordinates, offset, end, stride, extent[2], extent[3])) {
    return true;
  }
  return false;
};
ol.geom.flat.intersectsextent.linearRings = function(flatCoordinates, offset, ends, stride, extent) {
  if (!ol.geom.flat.intersectsextent.linearRing(flatCoordinates, offset, ends[0], stride, extent)) {
    return false;
  }
  if (ends.length === 1) {
    return true;
  }
  var i, ii;
  for (i = 1, ii = ends.length; i < ii; ++i) {
    if (ol.geom.flat.contains.linearRingContainsExtent(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {
      return false;
    }
  }
  return true;
};
ol.geom.flat.intersectsextent.linearRingss = function(flatCoordinates, offset, endss, stride, extent) {
  var i, ii;
  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    if (ol.geom.flat.intersectsextent.linearRings(flatCoordinates, offset, ends, stride, extent)) {
      return true;
    }
    offset = ends[ends.length - 1];
  }
  return false;
};
goog.provide("ol.geom.flat.reverse");
ol.geom.flat.reverse.coordinates = function(flatCoordinates, offset, end, stride) {
  while (offset < end - stride) {
    var i;
    for (i = 0; i < stride; ++i) {
      var tmp = flatCoordinates[offset + i];
      flatCoordinates[offset + i] = flatCoordinates[end - stride + i];
      flatCoordinates[end - stride + i] = tmp;
    }
    offset += stride;
    end -= stride;
  }
};
goog.provide("ol.geom.flat.orient");
goog.require("ol.geom.flat.reverse");
ol.geom.flat.orient.linearRingIsClockwise = function(flatCoordinates, offset, end, stride) {
  var edge = 0;
  var x1 = flatCoordinates[end - stride];
  var y1 = flatCoordinates[end - stride + 1];
  for (; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];
    edge += (x2 - x1) * (y2 + y1);
    x1 = x2;
    y1 = y2;
  }
  return edge > 0;
};
ol.geom.flat.orient.linearRingsAreOriented = function(flatCoordinates, offset, ends, stride, opt_right) {
  var right = opt_right !== undefined ? opt_right : false;
  var i, ii;
  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    var isClockwise = ol.geom.flat.orient.linearRingIsClockwise(flatCoordinates, offset, end, stride);
    if (i === 0) {
      if (right && isClockwise || !right && !isClockwise) {
        return false;
      }
    } else {
      if (right && !isClockwise || !right && isClockwise) {
        return false;
      }
    }
    offset = end;
  }
  return true;
};
ol.geom.flat.orient.linearRingssAreOriented = function(flatCoordinates, offset, endss, stride, opt_right) {
  var i, ii;
  for (i = 0, ii = endss.length; i < ii; ++i) {
    if (!ol.geom.flat.orient.linearRingsAreOriented(flatCoordinates, offset, endss[i], stride, opt_right)) {
      return false;
    }
  }
  return true;
};
ol.geom.flat.orient.orientLinearRings = function(flatCoordinates, offset, ends, stride, opt_right) {
  var right = opt_right !== undefined ? opt_right : false;
  var i, ii;
  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    var isClockwise = ol.geom.flat.orient.linearRingIsClockwise(flatCoordinates, offset, end, stride);
    var reverse = i === 0 ? right && isClockwise || !right && !isClockwise : right && !isClockwise || !right && isClockwise;
    if (reverse) {
      ol.geom.flat.reverse.coordinates(flatCoordinates, offset, end, stride);
    }
    offset = end;
  }
  return offset;
};
ol.geom.flat.orient.orientLinearRingss = function(flatCoordinates, offset, endss, stride, opt_right) {
  var i, ii;
  for (i = 0, ii = endss.length; i < ii; ++i) {
    offset = ol.geom.flat.orient.orientLinearRings(flatCoordinates, offset, endss[i], stride, opt_right);
  }
  return offset;
};
goog.provide("ol.geom.Polygon");
goog.require("ol");
goog.require("ol.array");
goog.require("ol.extent");
goog.require("ol.geom.GeometryLayout");
goog.require("ol.geom.GeometryType");
goog.require("ol.geom.LinearRing");
goog.require("ol.geom.Point");
goog.require("ol.geom.SimpleGeometry");
goog.require("ol.geom.flat.area");
goog.require("ol.geom.flat.closest");
goog.require("ol.geom.flat.contains");
goog.require("ol.geom.flat.deflate");
goog.require("ol.geom.flat.inflate");
goog.require("ol.geom.flat.interiorpoint");
goog.require("ol.geom.flat.intersectsextent");
goog.require("ol.geom.flat.orient");
goog.require("ol.geom.flat.simplify");
goog.require("ol.math");
ol.geom.Polygon = function(coordinates, opt_layout) {
  ol.geom.SimpleGeometry.call(this);
  this.ends_ = [];
  this.flatInteriorPointRevision_ = -1;
  this.flatInteriorPoint_ = null;
  this.maxDelta_ = -1;
  this.maxDeltaRevision_ = -1;
  this.orientedRevision_ = -1;
  this.orientedFlatCoordinates_ = null;
  this.setCoordinates(coordinates, opt_layout);
};
ol.inherits(ol.geom.Polygon, ol.geom.SimpleGeometry);
ol.geom.Polygon.prototype.appendLinearRing = function(linearRing) {
  if (!this.flatCoordinates) {
    this.flatCoordinates = linearRing.getFlatCoordinates().slice();
  } else {
    ol.array.extend(this.flatCoordinates, linearRing.getFlatCoordinates());
  }
  this.ends_.push(this.flatCoordinates.length);
  this.changed();
};
ol.geom.Polygon.prototype.clone = function() {
  var polygon = new ol.geom.Polygon(null);
  polygon.setFlatCoordinates(this.layout, this.flatCoordinates.slice(), this.ends_.slice());
  return polygon;
};
ol.geom.Polygon.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {
  if (minSquaredDistance < ol.extent.closestSquaredDistanceXY(this.getExtent(), x, y)) {
    return minSquaredDistance;
  }
  if (this.maxDeltaRevision_ != this.getRevision()) {
    this.maxDelta_ = Math.sqrt(ol.geom.flat.closest.getsMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));
    this.maxDeltaRevision_ = this.getRevision();
  }
  return ol.geom.flat.closest.getsClosestPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
};
ol.geom.Polygon.prototype.containsXY = function(x, y) {
  return ol.geom.flat.contains.linearRingsContainsXY(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, x, y);
};
ol.geom.Polygon.prototype.getArea = function() {
  return ol.geom.flat.area.linearRings(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);
};
ol.geom.Polygon.prototype.getCoordinates = function(opt_right) {
  var flatCoordinates;
  if (opt_right !== undefined) {
    flatCoordinates = this.getOrientedFlatCoordinates().slice();
    ol.geom.flat.orient.orientLinearRings(flatCoordinates, 0, this.ends_, this.stride, opt_right);
  } else {
    flatCoordinates = this.flatCoordinates;
  }
  return ol.geom.flat.inflate.coordinatess(flatCoordinates, 0, this.ends_, this.stride);
};
ol.geom.Polygon.prototype.getEnds = function() {
  return this.ends_;
};
ol.geom.Polygon.prototype.getFlatInteriorPoint = function() {
  if (this.flatInteriorPointRevision_ != this.getRevision()) {
    var flatCenter = ol.extent.getCenter(this.getExtent());
    this.flatInteriorPoint_ = ol.geom.flat.interiorpoint.linearRings(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, flatCenter, 0);
    this.flatInteriorPointRevision_ = this.getRevision();
  }
  return this.flatInteriorPoint_;
};
ol.geom.Polygon.prototype.getInteriorPoint = function() {
  return new ol.geom.Point(this.getFlatInteriorPoint(), ol.geom.GeometryLayout.XYM);
};
ol.geom.Polygon.prototype.getLinearRingCount = function() {
  return this.ends_.length;
};
ol.geom.Polygon.prototype.getLinearRing = function(index) {
  if (index < 0 || this.ends_.length <= index) {
    return null;
  }
  var linearRing = new ol.geom.LinearRing(null);
  linearRing.setFlatCoordinates(this.layout, this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]));
  return linearRing;
};
ol.geom.Polygon.prototype.getLinearRings = function() {
  var layout = this.layout;
  var flatCoordinates = this.flatCoordinates;
  var ends = this.ends_;
  var linearRings = [];
  var offset = 0;
  var i, ii;
  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    var linearRing = new ol.geom.LinearRing(null);
    linearRing.setFlatCoordinates(layout, flatCoordinates.slice(offset, end));
    linearRings.push(linearRing);
    offset = end;
  }
  return linearRings;
};
ol.geom.Polygon.prototype.getOrientedFlatCoordinates = function() {
  if (this.orientedRevision_ != this.getRevision()) {
    var flatCoordinates = this.flatCoordinates;
    if (ol.geom.flat.orient.linearRingsAreOriented(flatCoordinates, 0, this.ends_, this.stride)) {
      this.orientedFlatCoordinates_ = flatCoordinates;
    } else {
      this.orientedFlatCoordinates_ = flatCoordinates.slice();
      this.orientedFlatCoordinates_.length = ol.geom.flat.orient.orientLinearRings(this.orientedFlatCoordinates_, 0, this.ends_, this.stride);
    }
    this.orientedRevision_ = this.getRevision();
  }
  return this.orientedFlatCoordinates_;
};
ol.geom.Polygon.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {
  var simplifiedFlatCoordinates = [];
  var simplifiedEnds = [];
  simplifiedFlatCoordinates.length = ol.geom.flat.simplify.quantizes(this.flatCoordinates, 0, this.ends_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEnds);
  var simplifiedPolygon = new ol.geom.Polygon(null);
  simplifiedPolygon.setFlatCoordinates(ol.geom.GeometryLayout.XY, simplifiedFlatCoordinates, simplifiedEnds);
  return simplifiedPolygon;
};
ol.geom.Polygon.prototype.getType = function() {
  return ol.geom.GeometryType.POLYGON;
};
ol.geom.Polygon.prototype.intersectsExtent = function(extent) {
  return ol.geom.flat.intersectsextent.linearRings(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, extent);
};
ol.geom.Polygon.prototype.setCoordinates = function(coordinates, opt_layout) {
  if (!coordinates) {
    this.setFlatCoordinates(ol.geom.GeometryLayout.XY, null, this.ends_);
  } else {
    this.setLayout(opt_layout, coordinates, 2);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    var ends = ol.geom.flat.deflate.coordinatess(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);
    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
    this.changed();
  }
};
ol.geom.Polygon.prototype.setFlatCoordinates = function(layout, flatCoordinates, ends) {
  this.setFlatCoordinatesInternal(layout, flatCoordinates);
  this.ends_ = ends;
  this.changed();
};
ol.geom.Polygon.circular = function(sphere, center, radius, opt_n) {
  var n = opt_n ? opt_n : 32;
  var flatCoordinates = [];
  var i;
  for (i = 0; i < n; ++i) {
    ol.array.extend(flatCoordinates, sphere.offset(center, radius, 2 * Math.PI * i / n));
  }
  flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);
  var polygon = new ol.geom.Polygon(null);
  polygon.setFlatCoordinates(ol.geom.GeometryLayout.XY, flatCoordinates, [flatCoordinates.length]);
  return polygon;
};
ol.geom.Polygon.fromExtent = function(extent) {
  var minX = extent[0];
  var minY = extent[1];
  var maxX = extent[2];
  var maxY = extent[3];
  var flatCoordinates = [minX, minY, minX, maxY, maxX, maxY, maxX, minY, minX, minY];
  var polygon = new ol.geom.Polygon(null);
  polygon.setFlatCoordinates(ol.geom.GeometryLayout.XY, flatCoordinates, [flatCoordinates.length]);
  return polygon;
};
ol.geom.Polygon.fromCircle = function(circle, opt_sides, opt_angle) {
  var sides = opt_sides ? opt_sides : 32;
  var stride = circle.getStride();
  var layout = circle.getLayout();
  var polygon = new ol.geom.Polygon(null, layout);
  var arrayLength = stride * (sides + 1);
  var flatCoordinates = new Array(arrayLength);
  for (var i = 0; i < arrayLength; i++) {
    flatCoordinates[i] = 0;
  }
  var ends = [flatCoordinates.length];
  polygon.setFlatCoordinates(layout, flatCoordinates, ends);
  ol.geom.Polygon.makeRegular(polygon, circle.getCenter(), circle.getRadius(), opt_angle);
  return polygon;
};
ol.geom.Polygon.makeRegular = function(polygon, center, radius, opt_angle) {
  var flatCoordinates = polygon.getFlatCoordinates();
  var layout = polygon.getLayout();
  var stride = polygon.getStride();
  var ends = polygon.getEnds();
  var sides = flatCoordinates.length / stride - 1;
  var startAngle = opt_angle ? opt_angle : 0;
  var angle, offset;
  for (var i = 0; i <= sides; ++i) {
    offset = i * stride;
    angle = startAngle + ol.math.modulo(i, sides) * 2 * Math.PI / sides;
    flatCoordinates[offset] = center[0] + radius * Math.cos(angle);
    flatCoordinates[offset + 1] = center[1] + radius * Math.sin(angle);
  }
  polygon.setFlatCoordinates(layout, flatCoordinates, ends);
};
goog.provide("ol.View");
goog.require("ol");
goog.require("ol.CenterConstraint");
goog.require("ol.Object");
goog.require("ol.ResolutionConstraint");
goog.require("ol.RotationConstraint");
goog.require("ol.ViewHint");
goog.require("ol.ViewProperty");
goog.require("ol.array");
goog.require("ol.asserts");
goog.require("ol.coordinate");
goog.require("ol.easing");
goog.require("ol.extent");
goog.require("ol.geom.GeometryType");
goog.require("ol.geom.Polygon");
goog.require("ol.geom.SimpleGeometry");
goog.require("ol.math");
goog.require("ol.obj");
goog.require("ol.proj");
goog.require("ol.proj.Units");
ol.View = function(opt_options) {
  ol.Object.call(this);
  var options = ol.obj.assign({}, opt_options);
  this.hints_ = [0, 0];
  this.animations_ = [];
  this.updateAnimationKey_;
  this.updateAnimations_ = this.updateAnimations_.bind(this);
  this.projection_ = ol.proj.createProjection(options.projection, "EPSG:3857");
  this.applyOptions_(options);
};
ol.inherits(ol.View, ol.Object);
ol.View.prototype.applyOptions_ = function(options) {
  var properties = {};
  properties[ol.ViewProperty.CENTER] = options.center !== undefined ? options.center : null;
  var resolutionConstraintInfo = ol.View.createResolutionConstraint_(options);
  this.maxResolution_ = resolutionConstraintInfo.maxResolution;
  this.minResolution_ = resolutionConstraintInfo.minResolution;
  this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;
  this.resolutions_ = options.resolutions;
  this.minZoom_ = resolutionConstraintInfo.minZoom;
  var centerConstraint = ol.View.createCenterConstraint_(options);
  var resolutionConstraint = resolutionConstraintInfo.constraint;
  var rotationConstraint = ol.View.createRotationConstraint_(options);
  this.constraints_ = {center:centerConstraint, resolution:resolutionConstraint, rotation:rotationConstraint};
  if (options.resolution !== undefined) {
    properties[ol.ViewProperty.RESOLUTION] = options.resolution;
  } else {
    if (options.zoom !== undefined) {
      properties[ol.ViewProperty.RESOLUTION] = this.constrainResolution(this.maxResolution_, options.zoom - this.minZoom_);
      if (this.resolutions_) {
        properties[ol.ViewProperty.RESOLUTION] = ol.math.clamp(Number(this.getResolution() || properties[ol.ViewProperty.RESOLUTION]), this.minResolution_, this.maxResolution_);
      }
    }
  }
  properties[ol.ViewProperty.ROTATION] = options.rotation !== undefined ? options.rotation : 0;
  this.setProperties(properties);
  this.options_ = options;
};
ol.View.prototype.getUpdatedOptions_ = function(newOptions) {
  var options = ol.obj.assign({}, this.options_);
  if (options.resolution !== undefined) {
    options.resolution = this.getResolution();
  } else {
    options.zoom = this.getZoom();
  }
  options.center = this.getCenter();
  options.rotation = this.getRotation();
  return ol.obj.assign({}, options, newOptions);
};
ol.View.prototype.animate = function(var_args) {
  var animationCount = arguments.length;
  var callback;
  if (animationCount > 1 && typeof arguments[animationCount - 1] === "function") {
    callback = arguments[animationCount - 1];
    --animationCount;
  }
  if (!this.isDef()) {
    var state = arguments[animationCount - 1];
    if (state.center) {
      this.setCenter(state.center);
    }
    if (state.zoom !== undefined) {
      this.setZoom(state.zoom);
    }
    if (state.rotation !== undefined) {
      this.setRotation(state.rotation);
    }
    if (callback) {
      callback(true);
    }
    return;
  }
  var start = Date.now();
  var center = this.getCenter().slice();
  var resolution = this.getResolution();
  var rotation = this.getRotation();
  var series = [];
  for (var i = 0; i < animationCount; ++i) {
    var options = arguments[i];
    var animation = {start:start, complete:false, anchor:options.anchor, duration:options.duration !== undefined ? options.duration : 1000, easing:options.easing || ol.easing.inAndOut};
    if (options.center) {
      animation.sourceCenter = center;
      animation.targetCenter = options.center;
      center = animation.targetCenter;
    }
    if (options.zoom !== undefined) {
      animation.sourceResolution = resolution;
      animation.targetResolution = this.constrainResolution(this.maxResolution_, options.zoom - this.minZoom_, 0);
      resolution = animation.targetResolution;
    } else {
      if (options.resolution) {
        animation.sourceResolution = resolution;
        animation.targetResolution = options.resolution;
        resolution = animation.targetResolution;
      }
    }
    if (options.rotation !== undefined) {
      animation.sourceRotation = rotation;
      var delta = ol.math.modulo(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;
      animation.targetRotation = rotation + delta;
      rotation = animation.targetRotation;
    }
    animation.callback = callback;
    if (ol.View.isNoopAnimation(animation)) {
      animation.complete = true;
    } else {
      start += animation.duration;
    }
    series.push(animation);
  }
  this.animations_.push(series);
  this.setHint(ol.ViewHint.ANIMATING, 1);
  this.updateAnimations_();
};
ol.View.prototype.getAnimating = function() {
  return this.hints_[ol.ViewHint.ANIMATING] > 0;
};
ol.View.prototype.getInteracting = function() {
  return this.hints_[ol.ViewHint.INTERACTING] > 0;
};
ol.View.prototype.cancelAnimations = function() {
  this.setHint(ol.ViewHint.ANIMATING, -this.hints_[ol.ViewHint.ANIMATING]);
  for (var i = 0, ii = this.animations_.length; i < ii; ++i) {
    var series = this.animations_[i];
    if (series[0].callback) {
      series[0].callback(false);
    }
  }
  this.animations_.length = 0;
};
ol.View.prototype.updateAnimations_ = function() {
  if (this.updateAnimationKey_ !== undefined) {
    cancelAnimationFrame(this.updateAnimationKey_);
    this.updateAnimationKey_ = undefined;
  }
  if (!this.getAnimating()) {
    return;
  }
  var now = Date.now();
  var more = false;
  for (var i = this.animations_.length - 1; i >= 0; --i) {
    var series = this.animations_[i];
    var seriesComplete = true;
    for (var j = 0, jj = series.length; j < jj; ++j) {
      var animation = series[j];
      if (animation.complete) {
        continue;
      }
      var elapsed = now - animation.start;
      var fraction = animation.duration > 0 ? elapsed / animation.duration : 1;
      if (fraction >= 1) {
        animation.complete = true;
        fraction = 1;
      } else {
        seriesComplete = false;
      }
      var progress = animation.easing(fraction);
      if (animation.sourceCenter) {
        var x0 = animation.sourceCenter[0];
        var y0 = animation.sourceCenter[1];
        var x1 = animation.targetCenter[0];
        var y1 = animation.targetCenter[1];
        var x = x0 + progress * (x1 - x0);
        var y = y0 + progress * (y1 - y0);
        this.set(ol.ViewProperty.CENTER, [x, y]);
      }
      if (animation.sourceResolution && animation.targetResolution) {
        var resolution = progress === 1 ? animation.targetResolution : animation.sourceResolution + progress * (animation.targetResolution - animation.sourceResolution);
        if (animation.anchor) {
          this.set(ol.ViewProperty.CENTER, this.calculateCenterZoom(resolution, animation.anchor));
        }
        this.set(ol.ViewProperty.RESOLUTION, resolution);
      }
      if (animation.sourceRotation !== undefined && animation.targetRotation !== undefined) {
        var rotation = progress === 1 ? ol.math.modulo(animation.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : animation.sourceRotation + progress * (animation.targetRotation - animation.sourceRotation);
        if (animation.anchor) {
          this.set(ol.ViewProperty.CENTER, this.calculateCenterRotate(rotation, animation.anchor));
        }
        this.set(ol.ViewProperty.ROTATION, rotation);
      }
      more = true;
      if (!animation.complete) {
        break;
      }
    }
    if (seriesComplete) {
      this.animations_[i] = null;
      this.setHint(ol.ViewHint.ANIMATING, -1);
      var callback = series[0].callback;
      if (callback) {
        callback(true);
      }
    }
  }
  this.animations_ = this.animations_.filter(Boolean);
  if (more && this.updateAnimationKey_ === undefined) {
    this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_);
  }
};
ol.View.prototype.calculateCenterRotate = function(rotation, anchor) {
  var center;
  var currentCenter = this.getCenter();
  if (currentCenter !== undefined) {
    center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];
    ol.coordinate.rotate(center, rotation - this.getRotation());
    ol.coordinate.add(center, anchor);
  }
  return center;
};
ol.View.prototype.calculateCenterZoom = function(resolution, anchor) {
  var center;
  var currentCenter = this.getCenter();
  var currentResolution = this.getResolution();
  if (currentCenter !== undefined && currentResolution !== undefined) {
    var x = anchor[0] - resolution * (anchor[0] - currentCenter[0]) / currentResolution;
    var y = anchor[1] - resolution * (anchor[1] - currentCenter[1]) / currentResolution;
    center = [x, y];
  }
  return center;
};
ol.View.prototype.getSizeFromViewport_ = function() {
  var size = [100, 100];
  var selector = '.ol-viewport[data-view="' + ol.getUid(this) + '"]';
  var element = document.querySelector(selector);
  if (element) {
    var metrics = getComputedStyle(element);
    size[0] = parseInt(metrics.width, 10);
    size[1] = parseInt(metrics.height, 10);
  }
  return size;
};
ol.View.prototype.constrainCenter = function(center) {
  return this.constraints_.center(center);
};
ol.View.prototype.constrainResolution = function(resolution, opt_delta, opt_direction) {
  var delta = opt_delta || 0;
  var direction = opt_direction || 0;
  return this.constraints_.resolution(resolution, delta, direction);
};
ol.View.prototype.constrainRotation = function(rotation, opt_delta) {
  var delta = opt_delta || 0;
  return this.constraints_.rotation(rotation, delta);
};
ol.View.prototype.getCenter = function() {
  return this.get(ol.ViewProperty.CENTER);
};
ol.View.prototype.getConstraints = function() {
  return this.constraints_;
};
ol.View.prototype.getHints = function(opt_hints) {
  if (opt_hints !== undefined) {
    opt_hints[0] = this.hints_[0];
    opt_hints[1] = this.hints_[1];
    return opt_hints;
  } else {
    return this.hints_.slice();
  }
};
ol.View.prototype.calculateExtent = function(opt_size) {
  var size = opt_size || this.getSizeFromViewport_();
  var center = this.getCenter();
  ol.asserts.assert(center, 1);
  var resolution = this.getResolution();
  ol.asserts.assert(resolution !== undefined, 2);
  var rotation = this.getRotation();
  ol.asserts.assert(rotation !== undefined, 3);
  return ol.extent.getForViewAndSize(center, resolution, rotation, size);
};
ol.View.prototype.getMaxResolution = function() {
  return this.maxResolution_;
};
ol.View.prototype.getMinResolution = function() {
  return this.minResolution_;
};
ol.View.prototype.getMaxZoom = function() {
  return this.getZoomForResolution(this.minResolution_);
};
ol.View.prototype.setMaxZoom = function(zoom) {
  this.applyOptions_(this.getUpdatedOptions_({maxZoom:zoom}));
};
ol.View.prototype.getMinZoom = function() {
  return this.getZoomForResolution(this.maxResolution_);
};
ol.View.prototype.setMinZoom = function(zoom) {
  this.applyOptions_(this.getUpdatedOptions_({minZoom:zoom}));
};
ol.View.prototype.getProjection = function() {
  return this.projection_;
};
ol.View.prototype.getResolution = function() {
  return this.get(ol.ViewProperty.RESOLUTION);
};
ol.View.prototype.getResolutions = function() {
  return this.resolutions_;
};
ol.View.prototype.getResolutionForExtent = function(extent, opt_size) {
  var size = opt_size || this.getSizeFromViewport_();
  var xResolution = ol.extent.getWidth(extent) / size[0];
  var yResolution = ol.extent.getHeight(extent) / size[1];
  return Math.max(xResolution, yResolution);
};
ol.View.prototype.getResolutionForValueFunction = function(opt_power) {
  var power = opt_power || 2;
  var maxResolution = this.maxResolution_;
  var minResolution = this.minResolution_;
  var max = Math.log(maxResolution / minResolution) / Math.log(power);
  return function(value) {
    var resolution = maxResolution / Math.pow(power, value * max);
    return resolution;
  };
};
ol.View.prototype.getRotation = function() {
  return this.get(ol.ViewProperty.ROTATION);
};
ol.View.prototype.getValueForResolutionFunction = function(opt_power) {
  var power = opt_power || 2;
  var maxResolution = this.maxResolution_;
  var minResolution = this.minResolution_;
  var max = Math.log(maxResolution / minResolution) / Math.log(power);
  return function(resolution) {
    var value = Math.log(maxResolution / resolution) / Math.log(power) / max;
    return value;
  };
};
ol.View.prototype.getState = function() {
  var center = this.getCenter();
  var projection = this.getProjection();
  var resolution = this.getResolution();
  var rotation = this.getRotation();
  return {center:center.slice(), projection:projection !== undefined ? projection : null, resolution:resolution, rotation:rotation, zoom:this.getZoom()};
};
ol.View.prototype.getZoom = function() {
  var zoom;
  var resolution = this.getResolution();
  if (resolution !== undefined) {
    zoom = this.getZoomForResolution(resolution);
  }
  return zoom;
};
ol.View.prototype.getZoomForResolution = function(resolution) {
  var offset = this.minZoom_ || 0;
  var max, zoomFactor;
  if (this.resolutions_) {
    var nearest = ol.array.linearFindNearest(this.resolutions_, resolution, 1);
    offset = nearest;
    max = this.resolutions_[nearest];
    if (nearest == this.resolutions_.length - 1) {
      zoomFactor = 2;
    } else {
      zoomFactor = max / this.resolutions_[nearest + 1];
    }
  } else {
    max = this.maxResolution_;
    zoomFactor = this.zoomFactor_;
  }
  return offset + Math.log(max / resolution) / Math.log(zoomFactor);
};
ol.View.prototype.getResolutionForZoom = function(zoom) {
  return this.constrainResolution(this.maxResolution_, zoom - this.minZoom_, 0);
};
ol.View.prototype.fit = function(geometryOrExtent, opt_options) {
  var options = opt_options || {};
  var size = options.size;
  if (!size) {
    size = this.getSizeFromViewport_();
  }
  var geometry;
  if (!(geometryOrExtent instanceof ol.geom.SimpleGeometry)) {
    ol.asserts.assert(Array.isArray(geometryOrExtent), 24);
    ol.asserts.assert(!ol.extent.isEmpty(geometryOrExtent), 25);
    geometry = ol.geom.Polygon.fromExtent(geometryOrExtent);
  } else {
    if (geometryOrExtent.getType() === ol.geom.GeometryType.CIRCLE) {
      geometryOrExtent = geometryOrExtent.getExtent();
      geometry = ol.geom.Polygon.fromExtent(geometryOrExtent);
      geometry.rotate(this.getRotation(), ol.extent.getCenter(geometryOrExtent));
    } else {
      geometry = geometryOrExtent;
    }
  }
  var padding = options.padding !== undefined ? options.padding : [0, 0, 0, 0];
  var constrainResolution = options.constrainResolution !== undefined ? options.constrainResolution : true;
  var nearest = options.nearest !== undefined ? options.nearest : false;
  var minResolution;
  if (options.minResolution !== undefined) {
    minResolution = options.minResolution;
  } else {
    if (options.maxZoom !== undefined) {
      minResolution = this.constrainResolution(this.maxResolution_, options.maxZoom - this.minZoom_, 0);
    } else {
      minResolution = 0;
    }
  }
  var coords = geometry.getFlatCoordinates();
  var rotation = this.getRotation();
  var cosAngle = Math.cos(-rotation);
  var sinAngle = Math.sin(-rotation);
  var minRotX = +Infinity;
  var minRotY = +Infinity;
  var maxRotX = -Infinity;
  var maxRotY = -Infinity;
  var stride = geometry.getStride();
  for (var i = 0, ii = coords.length; i < ii; i += stride) {
    var rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;
    var rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;
    minRotX = Math.min(minRotX, rotX);
    minRotY = Math.min(minRotY, rotY);
    maxRotX = Math.max(maxRotX, rotX);
    maxRotY = Math.max(maxRotY, rotY);
  }
  var resolution = this.getResolutionForExtent([minRotX, minRotY, maxRotX, maxRotY], [size[0] - padding[1] - padding[3], size[1] - padding[0] - padding[2]]);
  resolution = isNaN(resolution) ? minResolution : Math.max(resolution, minResolution);
  if (constrainResolution) {
    var constrainedResolution = this.constrainResolution(resolution, 0, 0);
    if (!nearest && constrainedResolution < resolution) {
      constrainedResolution = this.constrainResolution(constrainedResolution, -1, 0);
    }
    resolution = constrainedResolution;
  }
  sinAngle = -sinAngle;
  var centerRotX = (minRotX + maxRotX) / 2;
  var centerRotY = (minRotY + maxRotY) / 2;
  centerRotX += (padding[1] - padding[3]) / 2 * resolution;
  centerRotY += (padding[0] - padding[2]) / 2 * resolution;
  var centerX = centerRotX * cosAngle - centerRotY * sinAngle;
  var centerY = centerRotY * cosAngle + centerRotX * sinAngle;
  var center = [centerX, centerY];
  var callback = options.callback ? options.callback : ol.nullFunction;
  if (options.duration !== undefined) {
    this.animate({resolution:resolution, center:center, duration:options.duration, easing:options.easing}, callback);
  } else {
    this.setResolution(resolution);
    this.setCenter(center);
    setTimeout(callback.bind(undefined, true), 0);
  }
};
ol.View.prototype.centerOn = function(coordinate, size, position) {
  var rotation = this.getRotation();
  var cosAngle = Math.cos(-rotation);
  var sinAngle = Math.sin(-rotation);
  var rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  var rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  var resolution = this.getResolution();
  rotX += (size[0] / 2 - position[0]) * resolution;
  rotY += (position[1] - size[1] / 2) * resolution;
  sinAngle = -sinAngle;
  var centerX = rotX * cosAngle - rotY * sinAngle;
  var centerY = rotY * cosAngle + rotX * sinAngle;
  this.setCenter([centerX, centerY]);
};
ol.View.prototype.isDef = function() {
  return !!this.getCenter() && this.getResolution() !== undefined;
};
ol.View.prototype.rotate = function(rotation, opt_anchor) {
  if (opt_anchor !== undefined) {
    var center = this.calculateCenterRotate(rotation, opt_anchor);
    this.setCenter(center);
  }
  this.setRotation(rotation);
};
ol.View.prototype.setCenter = function(center) {
  this.set(ol.ViewProperty.CENTER, center);
  if (this.getAnimating()) {
    this.cancelAnimations();
  }
};
ol.View.prototype.setHint = function(hint, delta) {
  this.hints_[hint] += delta;
  this.changed();
  return this.hints_[hint];
};
ol.View.prototype.setResolution = function(resolution) {
  this.set(ol.ViewProperty.RESOLUTION, resolution);
  if (this.getAnimating()) {
    this.cancelAnimations();
  }
};
ol.View.prototype.setRotation = function(rotation) {
  this.set(ol.ViewProperty.ROTATION, rotation);
  if (this.getAnimating()) {
    this.cancelAnimations();
  }
};
ol.View.prototype.setZoom = function(zoom) {
  this.setResolution(this.getResolutionForZoom(zoom));
};
ol.View.createCenterConstraint_ = function(options) {
  if (options.extent !== undefined) {
    return ol.CenterConstraint.createExtent(options.extent);
  } else {
    return ol.CenterConstraint.none;
  }
};
ol.View.createResolutionConstraint_ = function(options) {
  var resolutionConstraint;
  var maxResolution;
  var minResolution;
  var defaultMaxZoom = 28;
  var defaultZoomFactor = 2;
  var minZoom = options.minZoom !== undefined ? options.minZoom : ol.DEFAULT_MIN_ZOOM;
  var maxZoom = options.maxZoom !== undefined ? options.maxZoom : defaultMaxZoom;
  var zoomFactor = options.zoomFactor !== undefined ? options.zoomFactor : defaultZoomFactor;
  if (options.resolutions !== undefined) {
    var resolutions = options.resolutions;
    maxResolution = resolutions[minZoom];
    minResolution = resolutions[maxZoom] !== undefined ? resolutions[maxZoom] : resolutions[resolutions.length - 1];
    resolutionConstraint = ol.ResolutionConstraint.createSnapToResolutions(resolutions);
  } else {
    var projection = ol.proj.createProjection(options.projection, "EPSG:3857");
    var extent = projection.getExtent();
    var size = !extent ? 360 * ol.proj.METERS_PER_UNIT[ol.proj.Units.DEGREES] / projection.getMetersPerUnit() : Math.max(ol.extent.getWidth(extent), ol.extent.getHeight(extent));
    var defaultMaxResolution = size / ol.DEFAULT_TILE_SIZE / Math.pow(defaultZoomFactor, ol.DEFAULT_MIN_ZOOM);
    var defaultMinResolution = defaultMaxResolution / Math.pow(defaultZoomFactor, defaultMaxZoom - ol.DEFAULT_MIN_ZOOM);
    maxResolution = options.maxResolution;
    if (maxResolution !== undefined) {
      minZoom = 0;
    } else {
      maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);
    }
    minResolution = options.minResolution;
    if (minResolution === undefined) {
      if (options.maxZoom !== undefined) {
        if (options.maxResolution !== undefined) {
          minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);
        } else {
          minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);
        }
      } else {
        minResolution = defaultMinResolution;
      }
    }
    maxZoom = minZoom + Math.floor(Math.log(maxResolution / minResolution) / Math.log(zoomFactor));
    minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);
    resolutionConstraint = ol.ResolutionConstraint.createSnapToPower(zoomFactor, maxResolution, maxZoom - minZoom);
  }
  return {constraint:resolutionConstraint, maxResolution:maxResolution, minResolution:minResolution, minZoom:minZoom, zoomFactor:zoomFactor};
};
ol.View.createRotationConstraint_ = function(options) {
  var enableRotation = options.enableRotation !== undefined ? options.enableRotation : true;
  if (enableRotation) {
    var constrainRotation = options.constrainRotation;
    if (constrainRotation === undefined || constrainRotation === true) {
      return ol.RotationConstraint.createSnapToZero();
    } else {
      if (constrainRotation === false) {
        return ol.RotationConstraint.none;
      } else {
        if (typeof constrainRotation === "number") {
          return ol.RotationConstraint.createSnapToN(constrainRotation);
        } else {
          return ol.RotationConstraint.none;
        }
      }
    }
  } else {
    return ol.RotationConstraint.disable;
  }
};
ol.View.isNoopAnimation = function(animation) {
  if (animation.sourceCenter && animation.targetCenter) {
    if (!ol.coordinate.equals(animation.sourceCenter, animation.targetCenter)) {
      return false;
    }
  }
  if (animation.sourceResolution !== animation.targetResolution) {
    return false;
  }
  if (animation.sourceRotation !== animation.targetRotation) {
    return false;
  }
  return true;
};
goog.provide("ol.PluginType");
ol.PluginType = {MAP_RENDERER:"MAP_RENDERER", LAYER_RENDERER:"LAYER_RENDERER"};
goog.provide("ol.plugins");
goog.require("ol.PluginType");
ol.plugins.mapRendererPlugins_ = [];
ol.plugins.getMapRendererPlugins = function() {
  return ol.plugins.mapRendererPlugins_;
};
ol.plugins.layerRendererPlugins_ = [];
ol.plugins.getLayerRendererPlugins = function() {
  return ol.plugins.layerRendererPlugins_;
};
ol.plugins.register = function(type, plugin) {
  var plugins;
  switch(type) {
    case ol.PluginType.MAP_RENDERER:
      {
        plugins = ol.plugins.mapRendererPlugins_;
        plugins.push(plugin);
        break;
      }
    case ol.PluginType.LAYER_RENDERER:
      {
        plugins = ol.plugins.layerRendererPlugins_;
        plugins.push(plugin);
        break;
      }
    default:
      {
        throw new Error("Unsupported plugin type: " + type);
      }
  }
};
ol.plugins.registerMultiple = function(type, plugins) {
  for (var i = 0, ii = plugins.length; i < ii; ++i) {
    ol.plugins.register(type, plugins[i]);
  }
};
goog.provide("ol.renderer.Type");
ol.renderer.Type = {CANVAS:"canvas", WEBGL:"webgl"};
goog.provide("ol.PluggableMap");
goog.require("ol");
goog.require("ol.Collection");
goog.require("ol.CollectionEventType");
goog.require("ol.MapBrowserEvent");
goog.require("ol.MapBrowserEventHandler");
goog.require("ol.MapBrowserEventType");
goog.require("ol.MapEvent");
goog.require("ol.MapEventType");
goog.require("ol.MapProperty");
goog.require("ol.Object");
goog.require("ol.ObjectEventType");
goog.require("ol.TileQueue");
goog.require("ol.View");
goog.require("ol.ViewHint");
goog.require("ol.asserts");
goog.require("ol.dom");
goog.require("ol.events");
goog.require("ol.events.Event");
goog.require("ol.events.EventType");
goog.require("ol.extent");
goog.require("ol.functions");
goog.require("ol.has");
goog.require("ol.layer.Group");
goog.require("ol.obj");
goog.require("ol.plugins");
goog.require("ol.renderer.Type");
goog.require("ol.size");
goog.require("ol.structs.PriorityQueue");
goog.require("ol.transform");
ol.PluggableMap = function(options) {
  ol.Object.call(this);
  var optionsInternal = ol.PluggableMap.createOptionsInternal(options);
  this.loadTilesWhileAnimating_ = options.loadTilesWhileAnimating !== undefined ? options.loadTilesWhileAnimating : false;
  this.loadTilesWhileInteracting_ = options.loadTilesWhileInteracting !== undefined ? options.loadTilesWhileInteracting : false;
  this.pixelRatio_ = options.pixelRatio !== undefined ? options.pixelRatio : ol.has.DEVICE_PIXEL_RATIO;
  this.logos_ = optionsInternal.logos;
  this.animationDelayKey_;
  this.animationDelay_ = function() {
    this.animationDelayKey_ = undefined;
    this.renderFrame_.call(this, Date.now());
  }.bind(this);
  this.coordinateToPixelTransform_ = ol.transform.create();
  this.pixelToCoordinateTransform_ = ol.transform.create();
  this.frameIndex_ = 0;
  this.frameState_ = null;
  this.previousExtent_ = null;
  this.viewPropertyListenerKey_ = null;
  this.viewChangeListenerKey_ = null;
  this.layerGroupPropertyListenerKeys_ = null;
  this.viewport_ = document.createElement("DIV");
  this.viewport_.className = "ol-viewport" + (ol.has.TOUCH ? " ol-touch" : "");
  this.viewport_.style.position = "relative";
  this.viewport_.style.overflow = "hidden";
  this.viewport_.style.width = "100%";
  this.viewport_.style.height = "100%";
  this.viewport_.style.msTouchAction = "none";
  this.viewport_.style.touchAction = "none";
  this.overlayContainer_ = document.createElement("DIV");
  this.overlayContainer_.className = "ol-overlaycontainer";
  this.viewport_.appendChild(this.overlayContainer_);
  this.overlayContainerStopEvent_ = document.createElement("DIV");
  this.overlayContainerStopEvent_.className = "ol-overlaycontainer-stopevent";
  var overlayEvents = [ol.events.EventType.CLICK, ol.events.EventType.DBLCLICK, ol.events.EventType.MOUSEDOWN, ol.events.EventType.TOUCHSTART, ol.events.EventType.MSPOINTERDOWN, ol.MapBrowserEventType.POINTERDOWN, ol.events.EventType.MOUSEWHEEL, ol.events.EventType.WHEEL];
  for (var i = 0, ii = overlayEvents.length; i < ii; ++i) {
    ol.events.listen(this.overlayContainerStopEvent_, overlayEvents[i], ol.events.Event.stopPropagation);
  }
  this.viewport_.appendChild(this.overlayContainerStopEvent_);
  this.mapBrowserEventHandler_ = new ol.MapBrowserEventHandler(this, options.moveTolerance);
  for (var key in ol.MapBrowserEventType) {
    ol.events.listen(this.mapBrowserEventHandler_, ol.MapBrowserEventType[key], this.handleMapBrowserEvent, this);
  }
  this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;
  this.keyHandlerKeys_ = null;
  ol.events.listen(this.viewport_, ol.events.EventType.WHEEL, this.handleBrowserEvent, this);
  ol.events.listen(this.viewport_, ol.events.EventType.MOUSEWHEEL, this.handleBrowserEvent, this);
  this.controls = optionsInternal.controls || new ol.Collection;
  this.interactions = optionsInternal.interactions || new ol.Collection;
  this.overlays_ = optionsInternal.overlays;
  this.overlayIdIndex_ = {};
  this.renderer_ = optionsInternal.mapRendererPlugin["create"](this.viewport_, this);
  this.handleResize_;
  this.focus_ = null;
  this.postRenderFunctions_ = [];
  this.tileQueue_ = new ol.TileQueue(this.getTilePriority.bind(this), this.handleTileChange_.bind(this));
  this.skippedFeatureUids_ = {};
  ol.events.listen(this, ol.Object.getChangeEventType(ol.MapProperty.LAYERGROUP), this.handleLayerGroupChanged_, this);
  ol.events.listen(this, ol.Object.getChangeEventType(ol.MapProperty.VIEW), this.handleViewChanged_, this);
  ol.events.listen(this, ol.Object.getChangeEventType(ol.MapProperty.SIZE), this.handleSizeChanged_, this);
  ol.events.listen(this, ol.Object.getChangeEventType(ol.MapProperty.TARGET), this.handleTargetChanged_, this);
  this.setProperties(optionsInternal.values);
  this.controls.forEach(function(control) {
    control.setMap(this);
  }, this);
  ol.events.listen(this.controls, ol.CollectionEventType.ADD, function(event) {
    event.element.setMap(this);
  }, this);
  ol.events.listen(this.controls, ol.CollectionEventType.REMOVE, function(event) {
    event.element.setMap(null);
  }, this);
  this.interactions.forEach(function(interaction) {
    interaction.setMap(this);
  }, this);
  ol.events.listen(this.interactions, ol.CollectionEventType.ADD, function(event) {
    event.element.setMap(this);
  }, this);
  ol.events.listen(this.interactions, ol.CollectionEventType.REMOVE, function(event) {
    event.element.setMap(null);
  }, this);
  this.overlays_.forEach(this.addOverlayInternal_, this);
  ol.events.listen(this.overlays_, ol.CollectionEventType.ADD, function(event) {
    this.addOverlayInternal_(event.element);
  }, this);
  ol.events.listen(this.overlays_, ol.CollectionEventType.REMOVE, function(event) {
    var overlay = event.element;
    var id = overlay.getId();
    if (id !== undefined) {
      delete this.overlayIdIndex_[id.toString()];
    }
    event.element.setMap(null);
  }, this);
};
ol.inherits(ol.PluggableMap, ol.Object);
ol.PluggableMap.prototype.addControl = function(control) {
  this.getControls().push(control);
};
ol.PluggableMap.prototype.addInteraction = function(interaction) {
  this.getInteractions().push(interaction);
};
ol.PluggableMap.prototype.addLayer = function(layer) {
  var layers = this.getLayerGroup().getLayers();
  layers.push(layer);
};
ol.PluggableMap.prototype.addOverlay = function(overlay) {
  this.getOverlays().push(overlay);
};
ol.PluggableMap.prototype.addOverlayInternal_ = function(overlay) {
  var id = overlay.getId();
  if (id !== undefined) {
    this.overlayIdIndex_[id.toString()] = overlay;
  }
  overlay.setMap(this);
};
ol.PluggableMap.prototype.disposeInternal = function() {
  this.mapBrowserEventHandler_.dispose();
  ol.events.unlisten(this.viewport_, ol.events.EventType.WHEEL, this.handleBrowserEvent, this);
  ol.events.unlisten(this.viewport_, ol.events.EventType.MOUSEWHEEL, this.handleBrowserEvent, this);
  if (this.handleResize_ !== undefined) {
    window.removeEventListener(ol.events.EventType.RESIZE, this.handleResize_, false);
    this.handleResize_ = undefined;
  }
  if (this.animationDelayKey_) {
    cancelAnimationFrame(this.animationDelayKey_);
    this.animationDelayKey_ = undefined;
  }
  this.setTarget(null);
  ol.Object.prototype.disposeInternal.call(this);
};
ol.PluggableMap.prototype.forEachFeatureAtPixel = function(pixel, callback, opt_options) {
  if (!this.frameState_) {
    return;
  }
  var coordinate = this.getCoordinateFromPixel(pixel);
  opt_options = opt_options !== undefined ? opt_options : {};
  var hitTolerance = opt_options.hitTolerance !== undefined ? opt_options.hitTolerance * this.frameState_.pixelRatio : 0;
  var layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : ol.functions.TRUE;
  return this.renderer_.forEachFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, callback, null, layerFilter, null);
};
ol.PluggableMap.prototype.getFeaturesAtPixel = function(pixel, opt_options) {
  var features = null;
  this.forEachFeatureAtPixel(pixel, function(feature) {
    if (!features) {
      features = [];
    }
    features.push(feature);
  }, opt_options);
  return features;
};
ol.PluggableMap.prototype.forEachLayerAtPixel = function(pixel, callback, opt_this, opt_layerFilter, opt_this2) {
  if (!this.frameState_) {
    return;
  }
  var thisArg = opt_this !== undefined ? opt_this : null;
  var layerFilter = opt_layerFilter !== undefined ? opt_layerFilter : ol.functions.TRUE;
  var thisArg2 = opt_this2 !== undefined ? opt_this2 : null;
  return this.renderer_.forEachLayerAtPixel(pixel, this.frameState_, callback, thisArg, layerFilter, thisArg2);
};
ol.PluggableMap.prototype.hasFeatureAtPixel = function(pixel, opt_options) {
  if (!this.frameState_) {
    return false;
  }
  var coordinate = this.getCoordinateFromPixel(pixel);
  opt_options = opt_options !== undefined ? opt_options : {};
  var layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : ol.functions.TRUE;
  var hitTolerance = opt_options.hitTolerance !== undefined ? opt_options.hitTolerance * this.frameState_.pixelRatio : 0;
  return this.renderer_.hasFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, layerFilter, null);
};
ol.PluggableMap.prototype.getEventCoordinate = function(event) {
  return this.getCoordinateFromPixel(this.getEventPixel(event));
};
ol.PluggableMap.prototype.getEventPixel = function(event) {
  var viewportPosition = this.viewport_.getBoundingClientRect();
  var eventPosition = event.changedTouches ? event.changedTouches[0] : event;
  return [eventPosition.clientX - viewportPosition.left, eventPosition.clientY - viewportPosition.top];
};
ol.PluggableMap.prototype.getTarget = function() {
  return this.get(ol.MapProperty.TARGET);
};
ol.PluggableMap.prototype.getTargetElement = function() {
  var target = this.getTarget();
  if (target !== undefined) {
    return typeof target === "string" ? document.getElementById(target) : target;
  } else {
    return null;
  }
};
ol.PluggableMap.prototype.getCoordinateFromPixel = function(pixel) {
  var frameState = this.frameState_;
  if (!frameState) {
    return null;
  } else {
    return ol.transform.apply(frameState.pixelToCoordinateTransform, pixel.slice());
  }
};
ol.PluggableMap.prototype.getControls = function() {
  return this.controls;
};
ol.PluggableMap.prototype.getOverlays = function() {
  return this.overlays_;
};
ol.PluggableMap.prototype.getOverlayById = function(id) {
  var overlay = this.overlayIdIndex_[id.toString()];
  return overlay !== undefined ? overlay : null;
};
ol.PluggableMap.prototype.getInteractions = function() {
  return this.interactions;
};
ol.PluggableMap.prototype.getLayerGroup = function() {
  return this.get(ol.MapProperty.LAYERGROUP);
};
ol.PluggableMap.prototype.getLayers = function() {
  var layers = this.getLayerGroup().getLayers();
  return layers;
};
ol.PluggableMap.prototype.getPixelFromCoordinate = function(coordinate) {
  var frameState = this.frameState_;
  if (!frameState) {
    return null;
  } else {
    return ol.transform.apply(frameState.coordinateToPixelTransform, coordinate.slice(0, 2));
  }
};
ol.PluggableMap.prototype.getRenderer = function() {
  return this.renderer_;
};
ol.PluggableMap.prototype.getSize = function() {
  return this.get(ol.MapProperty.SIZE);
};
ol.PluggableMap.prototype.getView = function() {
  return this.get(ol.MapProperty.VIEW);
};
ol.PluggableMap.prototype.getViewport = function() {
  return this.viewport_;
};
ol.PluggableMap.prototype.getOverlayContainer = function() {
  return this.overlayContainer_;
};
ol.PluggableMap.prototype.getOverlayContainerStopEvent = function() {
  return this.overlayContainerStopEvent_;
};
ol.PluggableMap.prototype.getTilePriority = function(tile, tileSourceKey, tileCenter, tileResolution) {
  var frameState = this.frameState_;
  if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {
    return ol.structs.PriorityQueue.DROP;
  }
  if (!frameState.wantedTiles[tileSourceKey][tile.getKey()]) {
    return ol.structs.PriorityQueue.DROP;
  }
  var deltaX = tileCenter[0] - frameState.focus[0];
  var deltaY = tileCenter[1] - frameState.focus[1];
  return 65536 * Math.log(tileResolution) + Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;
};
ol.PluggableMap.prototype.handleBrowserEvent = function(browserEvent, opt_type) {
  var type = opt_type || browserEvent.type;
  var mapBrowserEvent = new ol.MapBrowserEvent(type, this, browserEvent);
  this.handleMapBrowserEvent(mapBrowserEvent);
};
ol.PluggableMap.prototype.handleMapBrowserEvent = function(mapBrowserEvent) {
  if (!this.frameState_) {
    return;
  }
  this.focus_ = mapBrowserEvent.coordinate;
  mapBrowserEvent.frameState = this.frameState_;
  var interactionsArray = this.getInteractions().getArray();
  var i;
  if (this.dispatchEvent(mapBrowserEvent) !== false) {
    for (i = interactionsArray.length - 1; i >= 0; i--) {
      var interaction = interactionsArray[i];
      if (!interaction.getActive()) {
        continue;
      }
      var cont = interaction.handleEvent(mapBrowserEvent);
      if (!cont) {
        break;
      }
    }
  }
};
ol.PluggableMap.prototype.handlePostRender = function() {
  var frameState = this.frameState_;
  var tileQueue = this.tileQueue_;
  if (!tileQueue.isEmpty()) {
    var maxTotalLoading = 16;
    var maxNewLoads = maxTotalLoading;
    if (frameState) {
      var hints = frameState.viewHints;
      if (hints[ol.ViewHint.ANIMATING]) {
        maxTotalLoading = this.loadTilesWhileAnimating_ ? 8 : 0;
        maxNewLoads = 2;
      }
      if (hints[ol.ViewHint.INTERACTING]) {
        maxTotalLoading = this.loadTilesWhileInteracting_ ? 8 : 0;
        maxNewLoads = 2;
      }
    }
    if (tileQueue.getTilesLoading() < maxTotalLoading) {
      tileQueue.reprioritize();
      tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);
    }
  }
  var postRenderFunctions = this.postRenderFunctions_;
  var i, ii;
  for (i = 0, ii = postRenderFunctions.length; i < ii; ++i) {
    postRenderFunctions[i](this, frameState);
  }
  postRenderFunctions.length = 0;
};
ol.PluggableMap.prototype.handleSizeChanged_ = function() {
  this.render();
};
ol.PluggableMap.prototype.handleTargetChanged_ = function() {
  var targetElement;
  if (this.getTarget()) {
    targetElement = this.getTargetElement();
  }
  if (this.keyHandlerKeys_) {
    for (var i = 0, ii = this.keyHandlerKeys_.length; i < ii; ++i) {
      ol.events.unlistenByKey(this.keyHandlerKeys_[i]);
    }
    this.keyHandlerKeys_ = null;
  }
  if (!targetElement) {
    this.renderer_.removeLayerRenderers();
    ol.dom.removeNode(this.viewport_);
    if (this.handleResize_ !== undefined) {
      window.removeEventListener(ol.events.EventType.RESIZE, this.handleResize_, false);
      this.handleResize_ = undefined;
    }
  } else {
    targetElement.appendChild(this.viewport_);
    var keyboardEventTarget = !this.keyboardEventTarget_ ? targetElement : this.keyboardEventTarget_;
    this.keyHandlerKeys_ = [ol.events.listen(keyboardEventTarget, ol.events.EventType.KEYDOWN, this.handleBrowserEvent, this), ol.events.listen(keyboardEventTarget, ol.events.EventType.KEYPRESS, this.handleBrowserEvent, this)];
    if (!this.handleResize_) {
      this.handleResize_ = this.updateSize.bind(this);
      window.addEventListener(ol.events.EventType.RESIZE, this.handleResize_, false);
    }
  }
  this.updateSize();
};
ol.PluggableMap.prototype.handleTileChange_ = function() {
  this.render();
};
ol.PluggableMap.prototype.handleViewPropertyChanged_ = function() {
  this.render();
};
ol.PluggableMap.prototype.handleViewChanged_ = function() {
  if (this.viewPropertyListenerKey_) {
    ol.events.unlistenByKey(this.viewPropertyListenerKey_);
    this.viewPropertyListenerKey_ = null;
  }
  if (this.viewChangeListenerKey_) {
    ol.events.unlistenByKey(this.viewChangeListenerKey_);
    this.viewChangeListenerKey_ = null;
  }
  var view = this.getView();
  if (view) {
    this.viewport_.setAttribute("data-view", ol.getUid(view));
    this.viewPropertyListenerKey_ = ol.events.listen(view, ol.ObjectEventType.PROPERTYCHANGE, this.handleViewPropertyChanged_, this);
    this.viewChangeListenerKey_ = ol.events.listen(view, ol.events.EventType.CHANGE, this.handleViewPropertyChanged_, this);
  }
  this.render();
};
ol.PluggableMap.prototype.handleLayerGroupChanged_ = function() {
  if (this.layerGroupPropertyListenerKeys_) {
    this.layerGroupPropertyListenerKeys_.forEach(ol.events.unlistenByKey);
    this.layerGroupPropertyListenerKeys_ = null;
  }
  var layerGroup = this.getLayerGroup();
  if (layerGroup) {
    this.layerGroupPropertyListenerKeys_ = [ol.events.listen(layerGroup, ol.ObjectEventType.PROPERTYCHANGE, this.render, this), ol.events.listen(layerGroup, ol.events.EventType.CHANGE, this.render, this)];
  }
  this.render();
};
ol.PluggableMap.prototype.isRendered = function() {
  return !!this.frameState_;
};
ol.PluggableMap.prototype.renderSync = function() {
  if (this.animationDelayKey_) {
    cancelAnimationFrame(this.animationDelayKey_);
  }
  this.animationDelay_();
};
ol.PluggableMap.prototype.render = function() {
  if (this.animationDelayKey_ === undefined) {
    this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);
  }
};
ol.PluggableMap.prototype.removeControl = function(control) {
  return this.getControls().remove(control);
};
ol.PluggableMap.prototype.removeInteraction = function(interaction) {
  return this.getInteractions().remove(interaction);
};
ol.PluggableMap.prototype.removeLayer = function(layer) {
  var layers = this.getLayerGroup().getLayers();
  return layers.remove(layer);
};
ol.PluggableMap.prototype.removeOverlay = function(overlay) {
  return this.getOverlays().remove(overlay);
};
ol.PluggableMap.prototype.renderFrame_ = function(time) {
  var i, ii, viewState;
  var size = this.getSize();
  var view = this.getView();
  var extent = ol.extent.createEmpty();
  var previousFrameState = this.frameState_;
  var frameState = null;
  if (size !== undefined && ol.size.hasArea(size) && view && view.isDef()) {
    var viewHints = view.getHints(this.frameState_ ? this.frameState_.viewHints : undefined);
    var layerStatesArray = this.getLayerGroup().getLayerStatesArray();
    var layerStates = {};
    for (i = 0, ii = layerStatesArray.length; i < ii; ++i) {
      layerStates[ol.getUid(layerStatesArray[i].layer)] = layerStatesArray[i];
    }
    viewState = view.getState();
    var center = viewState.center;
    var pixelResolution = viewState.resolution / this.pixelRatio_;
    center[0] = Math.round(center[0] / pixelResolution) * pixelResolution;
    center[1] = Math.round(center[1] / pixelResolution) * pixelResolution;
    frameState = {animate:false, coordinateToPixelTransform:this.coordinateToPixelTransform_, extent:extent, focus:!this.focus_ ? center : this.focus_, index:this.frameIndex_++, layerStates:layerStates, layerStatesArray:layerStatesArray, logos:ol.obj.assign({}, this.logos_), pixelRatio:this.pixelRatio_, pixelToCoordinateTransform:this.pixelToCoordinateTransform_, postRenderFunctions:[], size:size, skippedFeatureUids:this.skippedFeatureUids_, tileQueue:this.tileQueue_, time:time, usedTiles:{}, viewState:viewState, 
    viewHints:viewHints, wantedTiles:{}};
  }
  if (frameState) {
    frameState.extent = ol.extent.getForViewAndSize(viewState.center, viewState.resolution, viewState.rotation, frameState.size, extent);
  }
  this.frameState_ = frameState;
  this.renderer_.renderFrame(frameState);
  if (frameState) {
    if (frameState.animate) {
      this.render();
    }
    Array.prototype.push.apply(this.postRenderFunctions_, frameState.postRenderFunctions);
    if (previousFrameState) {
      var moveStart = !this.previousExtent_ || !ol.extent.isEmpty(this.previousExtent_) && !ol.extent.equals(frameState.extent, this.previousExtent_);
      if (moveStart) {
        this.dispatchEvent(new ol.MapEvent(ol.MapEventType.MOVESTART, this, previousFrameState));
        this.previousExtent_ = ol.extent.createOrUpdateEmpty(this.previousExtent_);
      }
    }
    var idle = this.previousExtent_ && !frameState.viewHints[ol.ViewHint.ANIMATING] && !frameState.viewHints[ol.ViewHint.INTERACTING] && !ol.extent.equals(frameState.extent, this.previousExtent_);
    if (idle) {
      this.dispatchEvent(new ol.MapEvent(ol.MapEventType.MOVEEND, this, frameState));
      ol.extent.clone(frameState.extent, this.previousExtent_);
    }
  }
  this.dispatchEvent(new ol.MapEvent(ol.MapEventType.POSTRENDER, this, frameState));
  setTimeout(this.handlePostRender.bind(this), 0);
};
ol.PluggableMap.prototype.setLayerGroup = function(layerGroup) {
  this.set(ol.MapProperty.LAYERGROUP, layerGroup);
};
ol.PluggableMap.prototype.setSize = function(size) {
  this.set(ol.MapProperty.SIZE, size);
};
ol.PluggableMap.prototype.setTarget = function(target) {
  this.set(ol.MapProperty.TARGET, target);
};
ol.PluggableMap.prototype.setView = function(view) {
  this.set(ol.MapProperty.VIEW, view);
};
ol.PluggableMap.prototype.skipFeature = function(feature) {
  var featureUid = ol.getUid(feature).toString();
  this.skippedFeatureUids_[featureUid] = true;
  this.render();
};
ol.PluggableMap.prototype.updateSize = function() {
  var targetElement = this.getTargetElement();
  if (!targetElement) {
    this.setSize(undefined);
  } else {
    var computedStyle = getComputedStyle(targetElement);
    this.setSize([targetElement.offsetWidth - parseFloat(computedStyle["borderLeftWidth"]) - parseFloat(computedStyle["paddingLeft"]) - parseFloat(computedStyle["paddingRight"]) - parseFloat(computedStyle["borderRightWidth"]), targetElement.offsetHeight - parseFloat(computedStyle["borderTopWidth"]) - parseFloat(computedStyle["paddingTop"]) - parseFloat(computedStyle["paddingBottom"]) - parseFloat(computedStyle["borderBottomWidth"])]);
  }
};
ol.PluggableMap.prototype.unskipFeature = function(feature) {
  var featureUid = ol.getUid(feature).toString();
  delete this.skippedFeatureUids_[featureUid];
  this.render();
};
ol.PluggableMap.DEFAULT_RENDERER_TYPES = [ol.renderer.Type.CANVAS, ol.renderer.Type.WEBGL];
ol.PluggableMap.LOGO_URL = "data:image/png;base64," + "iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAA3NCSVQICAjb4U/gAAAACXBI" + "WXMAAAHGAAABxgEXwfpGAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAA" + "AhNQTFRF////AP//AICAgP//AFVVQECA////K1VVSbbbYL/fJ05idsTYJFtbbcjbJllmZszW" + "WMTOIFhoHlNiZszTa9DdUcHNHlNlV8XRIVdiasrUHlZjIVZjaMnVH1RlIFRkH1RkH1ZlasvY" + "asvXVsPQH1VkacnVa8vWIVZjIFRjVMPQa8rXIVVkXsXRsNveIFVkIFZlIVVj3eDeh6GmbMvX" + "H1ZkIFRka8rWbMvXIFVkIFVjIFVkbMvWH1VjbMvWIFVlbcvWIFVla8vVIFVkbMvWbMvVH1Vk" + 
"bMvWIFVlbcvWIFVkbcvVbMvWjNPbIFVkU8LPwMzNIFVkbczWIFVkbsvWbMvXIFVkRnB8bcvW" + "2+TkW8XRIFVkIlZlJVloJlpoKlxrLl9tMmJwOWd0Omh1RXF8TneCT3iDUHiDU8LPVMLPVcLP" + "VcPQVsPPVsPQV8PQWMTQWsTQW8TQXMXSXsXRX4SNX8bSYMfTYcfTYsfTY8jUZcfSZsnUaIqT" + "acrVasrVa8jTa8rWbI2VbMvWbcvWdJObdcvUdszUd8vVeJaee87Yfc3WgJyjhqGnitDYjaar" + "ldPZnrK2oNbborW5o9bbo9fbpLa6q9ndrL3ArtndscDDutzfu8fJwN7gwt7gxc/QyuHhy+Hi" + "zeHi0NfX0+Pj19zb1+Tj2uXk29/e3uLg3+Lh3+bl4uXj4ufl4+fl5Ofl5ufl5ujm5+jmySDn" + "BAAAAFp0Uk5TAAECAgMEBAYHCA0NDg4UGRogIiMmKSssLzU7PkJJT1JTVFliY2hrdHZ3foSF" + 
"hYeJjY2QkpugqbG1tre5w8zQ09XY3uXn6+zx8vT09vf4+Pj5+fr6/P39/f3+gz7SsAAAAVVJ" + "REFUOMtjYKA7EBDnwCPLrObS1BRiLoJLnte6CQy8FLHLCzs2QUG4FjZ5GbcmBDDjxJBXDWxC" + "Brb8aM4zbkIDzpLYnAcE9VXlJSWlZRU13koIeW57mGx5XjoMZEUqwxWYQaQbSzLSkYGfKFSe" + "0QMsX5WbjgY0YS4MBplemI4BdGBW+DQ11eZiymfqQuXZIjqwyadPNoSZ4L+0FVM6e+oGI6g8" + "a9iKNT3o8kVzNkzRg5lgl7p4wyRUL9Yt2jAxVh6mQCogae6GmflI8p0r13VFWTHBQ0rWPW7a" + "hgWVcPm+9cuLoyy4kCJDzCm6d8PSFoh0zvQNC5OjDJhQopPPJqph1doJBUD5tnkbZiUEqaCn" + "B3bTqLTFG1bPn71kw4b+GFdpLElKIzRxxgYgWNYc5SCENVHKeUaltHdXx0dZ8uBI1hJ2UUDg" + 
"q82CM2MwKeibqAvSO7MCABq0wXEPiqWEAAAAAElFTkSuQmCC";
ol.PluggableMap.createOptionsInternal = function(options) {
  var keyboardEventTarget = null;
  if (options.keyboardEventTarget !== undefined) {
    keyboardEventTarget = typeof options.keyboardEventTarget === "string" ? document.getElementById(options.keyboardEventTarget) : options.keyboardEventTarget;
  }
  var values = {};
  var logos = {};
  if (options.logo === undefined || typeof options.logo === "boolean" && options.logo) {
    logos[ol.PluggableMap.LOGO_URL] = "https://openlayers.org/";
  } else {
    var logo = options.logo;
    if (typeof logo === "string") {
      logos[logo] = "";
    } else {
      if (logo instanceof HTMLElement) {
        logos[ol.getUid(logo).toString()] = logo;
      } else {
        if (logo) {
          ol.asserts.assert(typeof logo.href == "string", 44);
          ol.asserts.assert(typeof logo.src == "string", 45);
          logos[logo.src] = logo.href;
        }
      }
    }
  }
  var layerGroup = options.layers instanceof ol.layer.Group ? options.layers : new ol.layer.Group({layers:options.layers});
  values[ol.MapProperty.LAYERGROUP] = layerGroup;
  values[ol.MapProperty.TARGET] = options.target;
  values[ol.MapProperty.VIEW] = options.view !== undefined ? options.view : new ol.View;
  var rendererTypes;
  if (options.renderer !== undefined) {
    if (Array.isArray(options.renderer)) {
      rendererTypes = options.renderer;
    } else {
      if (typeof options.renderer === "string") {
        rendererTypes = [options.renderer];
      } else {
        ol.asserts.assert(false, 46);
      }
    }
    if (rendererTypes.indexOf("dom") >= 0) {
      rendererTypes = rendererTypes.concat(ol.PluggableMap.DEFAULT_RENDERER_TYPES);
    }
  } else {
    rendererTypes = ol.PluggableMap.DEFAULT_RENDERER_TYPES;
  }
  var mapRendererPlugin;
  var mapRendererPlugins = ol.plugins.getMapRendererPlugins();
  outer: for (var i = 0, ii = rendererTypes.length; i < ii; ++i) {
    var rendererType = rendererTypes[i];
    for (var j = 0, jj = mapRendererPlugins.length; j < jj; ++j) {
      var candidate = mapRendererPlugins[j];
      if (candidate["handles"](rendererType)) {
        mapRendererPlugin = candidate;
        break outer;
      }
    }
  }
  if (!mapRendererPlugin) {
    throw new Error("Unable to create a map renderer for types: " + rendererTypes.join(", "));
  }
  var controls;
  if (options.controls !== undefined) {
    if (Array.isArray(options.controls)) {
      controls = new ol.Collection(options.controls.slice());
    } else {
      ol.asserts.assert(options.controls instanceof ol.Collection, 47);
      controls = options.controls;
    }
  }
  var interactions;
  if (options.interactions !== undefined) {
    if (Array.isArray(options.interactions)) {
      interactions = new ol.Collection(options.interactions.slice());
    } else {
      ol.asserts.assert(options.interactions instanceof ol.Collection, 48);
      interactions = options.interactions;
    }
  }
  var overlays;
  if (options.overlays !== undefined) {
    if (Array.isArray(options.overlays)) {
      overlays = new ol.Collection(options.overlays.slice());
    } else {
      ol.asserts.assert(options.overlays instanceof ol.Collection, 49);
      overlays = options.overlays;
    }
  } else {
    overlays = new ol.Collection;
  }
  return {controls:controls, interactions:interactions, keyboardEventTarget:keyboardEventTarget, logos:logos, overlays:overlays, mapRendererPlugin:mapRendererPlugin, values:values};
};
goog.provide("ol.control.Control");
goog.require("ol");
goog.require("ol.MapEventType");
goog.require("ol.Object");
goog.require("ol.dom");
goog.require("ol.events");
ol.control.Control = function(options) {
  ol.Object.call(this);
  this.element = options.element ? options.element : null;
  this.target_ = null;
  this.map_ = null;
  this.listenerKeys = [];
  this.render = options.render ? options.render : ol.nullFunction;
  if (options.target) {
    this.setTarget(options.target);
  }
};
ol.inherits(ol.control.Control, ol.Object);
ol.control.Control.prototype.disposeInternal = function() {
  ol.dom.removeNode(this.element);
  ol.Object.prototype.disposeInternal.call(this);
};
ol.control.Control.prototype.getMap = function() {
  return this.map_;
};
ol.control.Control.prototype.setMap = function(map) {
  if (this.map_) {
    ol.dom.removeNode(this.element);
  }
  for (var i = 0, ii = this.listenerKeys.length; i < ii; ++i) {
    ol.events.unlistenByKey(this.listenerKeys[i]);
  }
  this.listenerKeys.length = 0;
  this.map_ = map;
  if (this.map_) {
    var target = this.target_ ? this.target_ : map.getOverlayContainerStopEvent();
    target.appendChild(this.element);
    if (this.render !== ol.nullFunction) {
      this.listenerKeys.push(ol.events.listen(map, ol.MapEventType.POSTRENDER, this.render, this));
    }
    map.render();
  }
};
ol.control.Control.prototype.setTarget = function(target) {
  this.target_ = typeof target === "string" ? document.getElementById(target) : target;
};
goog.provide("ol.control.Attribution");
goog.require("ol");
goog.require("ol.array");
goog.require("ol.control.Control");
goog.require("ol.css");
goog.require("ol.dom");
goog.require("ol.events");
goog.require("ol.events.EventType");
goog.require("ol.layer.Layer");
goog.require("ol.obj");
ol.control.Attribution = function(opt_options) {
  var options = opt_options ? opt_options : {};
  this.ulElement_ = document.createElement("UL");
  this.logoLi_ = document.createElement("LI");
  this.ulElement_.appendChild(this.logoLi_);
  this.logoLi_.style.display = "none";
  this.collapsed_ = options.collapsed !== undefined ? options.collapsed : true;
  this.collapsible_ = options.collapsible !== undefined ? options.collapsible : true;
  if (!this.collapsible_) {
    this.collapsed_ = false;
  }
  var className = options.className !== undefined ? options.className : "ol-attribution";
  var tipLabel = options.tipLabel !== undefined ? options.tipLabel : "Attributions";
  var collapseLabel = options.collapseLabel !== undefined ? options.collapseLabel : "\u00bb";
  if (typeof collapseLabel === "string") {
    this.collapseLabel_ = document.createElement("span");
    this.collapseLabel_.textContent = collapseLabel;
  } else {
    this.collapseLabel_ = collapseLabel;
  }
  var label = options.label !== undefined ? options.label : "i";
  if (typeof label === "string") {
    this.label_ = document.createElement("span");
    this.label_.textContent = label;
  } else {
    this.label_ = label;
  }
  var activeLabel = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_;
  var button = document.createElement("button");
  button.setAttribute("type", "button");
  button.title = tipLabel;
  button.appendChild(activeLabel);
  ol.events.listen(button, ol.events.EventType.CLICK, this.handleClick_, this);
  var cssClasses = className + " " + ol.css.CLASS_UNSELECTABLE + " " + ol.css.CLASS_CONTROL + (this.collapsed_ && this.collapsible_ ? " ol-collapsed" : "") + (this.collapsible_ ? "" : " ol-uncollapsible");
  var element = document.createElement("div");
  element.className = cssClasses;
  element.appendChild(this.ulElement_);
  element.appendChild(button);
  var render = options.render ? options.render : ol.control.Attribution.render;
  ol.control.Control.call(this, {element:element, render:render, target:options.target});
  this.renderedAttributions_ = [];
  this.renderedVisible_ = true;
  this.logoElements_ = {};
};
ol.inherits(ol.control.Attribution, ol.control.Control);
ol.control.Attribution.prototype.getSourceAttributions_ = function(frameState) {
  var lookup = {};
  var visibleAttributions = [];
  var layerStatesArray = frameState.layerStatesArray;
  var resolution = frameState.viewState.resolution;
  for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
    var layerState = layerStatesArray[i];
    if (!ol.layer.Layer.visibleAtResolution(layerState, resolution)) {
      continue;
    }
    var source = layerState.layer.getSource();
    if (!source) {
      continue;
    }
    var attributionGetter = source.getAttributions2();
    if (!attributionGetter) {
      continue;
    }
    var attributions = attributionGetter(frameState);
    if (!attributions) {
      continue;
    }
    if (Array.isArray(attributions)) {
      for (var j = 0, jj = attributions.length; j < jj; ++j) {
        if (!(attributions[j] in lookup)) {
          visibleAttributions.push(attributions[j]);
          lookup[attributions[j]] = true;
        }
      }
    } else {
      if (!(attributions in lookup)) {
        visibleAttributions.push(attributions);
        lookup[attributions] = true;
      }
    }
  }
  return visibleAttributions;
};
ol.control.Attribution.render = function(mapEvent) {
  this.updateElement_(mapEvent.frameState);
};
ol.control.Attribution.prototype.updateElement_ = function(frameState) {
  if (!frameState) {
    if (this.renderedVisible_) {
      this.element.style.display = "none";
      this.renderedVisible_ = false;
    }
    return;
  }
  var attributions = this.getSourceAttributions_(frameState);
  if (ol.array.equals(attributions, this.renderedAttributions_)) {
    return;
  }
  while (this.ulElement_.lastChild !== this.logoLi_) {
    this.ulElement_.removeChild(this.ulElement_.lastChild);
  }
  for (var i = 0, ii = attributions.length; i < ii; ++i) {
    var element = document.createElement("LI");
    element.innerHTML = attributions[i];
    this.ulElement_.appendChild(element);
  }
  if (attributions.length === 0 && this.renderedAttributions_.length > 0) {
    this.element.classList.add("ol-logo-only");
  } else {
    if (this.renderedAttributions_.length === 0 && attributions.length > 0) {
      this.element.classList.remove("ol-logo-only");
    }
  }
  var visible = attributions.length > 0 || !ol.obj.isEmpty(frameState.logos);
  if (this.renderedVisible_ != visible) {
    this.element.style.display = visible ? "" : "none";
    this.renderedVisible_ = visible;
  }
  this.renderedAttributions_ = attributions;
  this.insertLogos_(frameState);
};
ol.control.Attribution.prototype.insertLogos_ = function(frameState) {
  var logo;
  var logos = frameState.logos;
  var logoElements = this.logoElements_;
  for (logo in logoElements) {
    if (!(logo in logos)) {
      ol.dom.removeNode(logoElements[logo]);
      delete logoElements[logo];
    }
  }
  var image, logoElement, logoKey;
  for (logoKey in logos) {
    var logoValue = logos[logoKey];
    if (logoValue instanceof HTMLElement) {
      this.logoLi_.appendChild(logoValue);
      logoElements[logoKey] = logoValue;
    }
    if (!(logoKey in logoElements)) {
      image = new Image;
      image.src = logoKey;
      if (logoValue === "") {
        logoElement = image;
      } else {
        logoElement = document.createElement("a");
        logoElement.href = logoValue;
        logoElement.appendChild(image);
      }
      this.logoLi_.appendChild(logoElement);
      logoElements[logoKey] = logoElement;
    }
  }
  this.logoLi_.style.display = !ol.obj.isEmpty(logos) ? "" : "none";
};
ol.control.Attribution.prototype.handleClick_ = function(event) {
  event.preventDefault();
  this.handleToggle_();
};
ol.control.Attribution.prototype.handleToggle_ = function() {
  this.element.classList.toggle("ol-collapsed");
  if (this.collapsed_) {
    ol.dom.replaceNode(this.collapseLabel_, this.label_);
  } else {
    ol.dom.replaceNode(this.label_, this.collapseLabel_);
  }
  this.collapsed_ = !this.collapsed_;
};
ol.control.Attribution.prototype.getCollapsible = function() {
  return this.collapsible_;
};
ol.control.Attribution.prototype.setCollapsible = function(collapsible) {
  if (this.collapsible_ === collapsible) {
    return;
  }
  this.collapsible_ = collapsible;
  this.element.classList.toggle("ol-uncollapsible");
  if (!collapsible && this.collapsed_) {
    this.handleToggle_();
  }
};
ol.control.Attribution.prototype.setCollapsed = function(collapsed) {
  if (!this.collapsible_ || this.collapsed_ === collapsed) {
    return;
  }
  this.handleToggle_();
};
ol.control.Attribution.prototype.getCollapsed = function() {
  return this.collapsed_;
};
goog.provide("ol.control.Rotate");
goog.require("ol.events");
goog.require("ol.events.EventType");
goog.require("ol");
goog.require("ol.control.Control");
goog.require("ol.css");
goog.require("ol.easing");
ol.control.Rotate = function(opt_options) {
  var options = opt_options ? opt_options : {};
  var className = options.className !== undefined ? options.className : "ol-rotate";
  var label = options.label !== undefined ? options.label : "\u21e7";
  this.label_ = null;
  if (typeof label === "string") {
    this.label_ = document.createElement("span");
    this.label_.className = "ol-compass";
    this.label_.textContent = label;
  } else {
    this.label_ = label;
    this.label_.classList.add("ol-compass");
  }
  var tipLabel = options.tipLabel ? options.tipLabel : "Reset rotation";
  var button = document.createElement("button");
  button.className = className + "-reset";
  button.setAttribute("type", "button");
  button.title = tipLabel;
  button.appendChild(this.label_);
  ol.events.listen(button, ol.events.EventType.CLICK, ol.control.Rotate.prototype.handleClick_, this);
  var cssClasses = className + " " + ol.css.CLASS_UNSELECTABLE + " " + ol.css.CLASS_CONTROL;
  var element = document.createElement("div");
  element.className = cssClasses;
  element.appendChild(button);
  var render = options.render ? options.render : ol.control.Rotate.render;
  this.callResetNorth_ = options.resetNorth ? options.resetNorth : undefined;
  ol.control.Control.call(this, {element:element, render:render, target:options.target});
  this.duration_ = options.duration !== undefined ? options.duration : 250;
  this.autoHide_ = options.autoHide !== undefined ? options.autoHide : true;
  this.rotation_ = undefined;
  if (this.autoHide_) {
    this.element.classList.add(ol.css.CLASS_HIDDEN);
  }
};
ol.inherits(ol.control.Rotate, ol.control.Control);
ol.control.Rotate.prototype.handleClick_ = function(event) {
  event.preventDefault();
  if (this.callResetNorth_ !== undefined) {
    this.callResetNorth_();
  } else {
    this.resetNorth_();
  }
};
ol.control.Rotate.prototype.resetNorth_ = function() {
  var map = this.getMap();
  var view = map.getView();
  if (!view) {
    return;
  }
  if (view.getRotation() !== undefined) {
    if (this.duration_ > 0) {
      view.animate({rotation:0, duration:this.duration_, easing:ol.easing.easeOut});
    } else {
      view.setRotation(0);
    }
  }
};
ol.control.Rotate.render = function(mapEvent) {
  var frameState = mapEvent.frameState;
  if (!frameState) {
    return;
  }
  var rotation = frameState.viewState.rotation;
  if (rotation != this.rotation_) {
    var transform = "rotate(" + rotation + "rad)";
    if (this.autoHide_) {
      var contains = this.element.classList.contains(ol.css.CLASS_HIDDEN);
      if (!contains && rotation === 0) {
        this.element.classList.add(ol.css.CLASS_HIDDEN);
      } else {
        if (contains && rotation !== 0) {
          this.element.classList.remove(ol.css.CLASS_HIDDEN);
        }
      }
    }
    this.label_.style.msTransform = transform;
    this.label_.style.webkitTransform = transform;
    this.label_.style.transform = transform;
  }
  this.rotation_ = rotation;
};
goog.provide("ol.control.Zoom");
goog.require("ol");
goog.require("ol.events");
goog.require("ol.events.EventType");
goog.require("ol.control.Control");
goog.require("ol.css");
goog.require("ol.easing");
ol.control.Zoom = function(opt_options) {
  var options = opt_options ? opt_options : {};
  var className = options.className !== undefined ? options.className : "ol-zoom";
  var delta = options.delta !== undefined ? options.delta : 1;
  var zoomInLabel = options.zoomInLabel !== undefined ? options.zoomInLabel : "+";
  var zoomOutLabel = options.zoomOutLabel !== undefined ? options.zoomOutLabel : "\u2212";
  var zoomInTipLabel = options.zoomInTipLabel !== undefined ? options.zoomInTipLabel : "Zoom in";
  var zoomOutTipLabel = options.zoomOutTipLabel !== undefined ? options.zoomOutTipLabel : "Zoom out";
  var inElement = document.createElement("button");
  inElement.className = className + "-in";
  inElement.setAttribute("type", "button");
  inElement.title = zoomInTipLabel;
  inElement.appendChild(typeof zoomInLabel === "string" ? document.createTextNode(zoomInLabel) : zoomInLabel);
  ol.events.listen(inElement, ol.events.EventType.CLICK, ol.control.Zoom.prototype.handleClick_.bind(this, delta));
  var outElement = document.createElement("button");
  outElement.className = className + "-out";
  outElement.setAttribute("type", "button");
  outElement.title = zoomOutTipLabel;
  outElement.appendChild(typeof zoomOutLabel === "string" ? document.createTextNode(zoomOutLabel) : zoomOutLabel);
  ol.events.listen(outElement, ol.events.EventType.CLICK, ol.control.Zoom.prototype.handleClick_.bind(this, -delta));
  var cssClasses = className + " " + ol.css.CLASS_UNSELECTABLE + " " + ol.css.CLASS_CONTROL;
  var element = document.createElement("div");
  element.className = cssClasses;
  element.appendChild(inElement);
  element.appendChild(outElement);
  ol.control.Control.call(this, {element:element, target:options.target});
  this.duration_ = options.duration !== undefined ? options.duration : 250;
};
ol.inherits(ol.control.Zoom, ol.control.Control);
ol.control.Zoom.prototype.handleClick_ = function(delta, event) {
  event.preventDefault();
  this.zoomByDelta_(delta);
};
ol.control.Zoom.prototype.zoomByDelta_ = function(delta) {
  var map = this.getMap();
  var view = map.getView();
  if (!view) {
    return;
  }
  var currentResolution = view.getResolution();
  if (currentResolution) {
    var newResolution = view.constrainResolution(currentResolution, delta);
    if (this.duration_ > 0) {
      if (view.getAnimating()) {
        view.cancelAnimations();
      }
      view.animate({resolution:newResolution, duration:this.duration_, easing:ol.easing.easeOut});
    } else {
      view.setResolution(newResolution);
    }
  }
};
goog.provide("ol.control");
goog.require("ol.Collection");
goog.require("ol.control.Attribution");
goog.require("ol.control.Rotate");
goog.require("ol.control.Zoom");
ol.control.defaults = function(opt_options) {
  var options = opt_options ? opt_options : {};
  var controls = new ol.Collection;
  var zoomControl = options.zoom !== undefined ? options.zoom : true;
  if (zoomControl) {
    controls.push(new ol.control.Zoom(options.zoomOptions));
  }
  var rotateControl = options.rotate !== undefined ? options.rotate : true;
  if (rotateControl) {
    controls.push(new ol.control.Rotate(options.rotateOptions));
  }
  var attributionControl = options.attribution !== undefined ? options.attribution : true;
  if (attributionControl) {
    controls.push(new ol.control.Attribution(options.attributionOptions));
  }
  return controls;
};
goog.provide("ol.Kinetic");
ol.Kinetic = function(decay, minVelocity, delay) {
  this.decay_ = decay;
  this.minVelocity_ = minVelocity;
  this.delay_ = delay;
  this.points_ = [];
  this.angle_ = 0;
  this.initialVelocity_ = 0;
};
ol.Kinetic.prototype.begin = function() {
  this.points_.length = 0;
  this.angle_ = 0;
  this.initialVelocity_ = 0;
};
ol.Kinetic.prototype.update = function(x, y) {
  this.points_.push(x, y, Date.now());
};
ol.Kinetic.prototype.end = function() {
  if (this.points_.length < 6) {
    return false;
  }
  var delay = Date.now() - this.delay_;
  var lastIndex = this.points_.length - 3;
  if (this.points_[lastIndex + 2] < delay) {
    return false;
  }
  var firstIndex = lastIndex - 3;
  while (firstIndex > 0 && this.points_[firstIndex + 2] > delay) {
    firstIndex -= 3;
  }
  var duration = this.points_[lastIndex + 2] - this.points_[firstIndex + 2];
  if (duration < 1000 / 60) {
    return false;
  }
  var dx = this.points_[lastIndex] - this.points_[firstIndex];
  var dy = this.points_[lastIndex + 1] - this.points_[firstIndex + 1];
  this.angle_ = Math.atan2(dy, dx);
  this.initialVelocity_ = Math.sqrt(dx * dx + dy * dy) / duration;
  return this.initialVelocity_ > this.minVelocity_;
};
ol.Kinetic.prototype.getDistance = function() {
  return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
};
ol.Kinetic.prototype.getAngle = function() {
  return this.angle_;
};
goog.provide("ol.interaction.Property");
ol.interaction.Property = {ACTIVE:"active"};
goog.provide("ol.interaction.Interaction");
goog.require("ol");
goog.require("ol.Object");
goog.require("ol.easing");
goog.require("ol.interaction.Property");
goog.require("ol.math");
ol.interaction.Interaction = function(options) {
  ol.Object.call(this);
  this.map_ = null;
  this.setActive(true);
  this.handleEvent = options.handleEvent;
};
ol.inherits(ol.interaction.Interaction, ol.Object);
ol.interaction.Interaction.prototype.getActive = function() {
  return this.get(ol.interaction.Property.ACTIVE);
};
ol.interaction.Interaction.prototype.getMap = function() {
  return this.map_;
};
ol.interaction.Interaction.prototype.setActive = function(active) {
  this.set(ol.interaction.Property.ACTIVE, active);
};
ol.interaction.Interaction.prototype.setMap = function(map) {
  this.map_ = map;
};
ol.interaction.Interaction.pan = function(view, delta, opt_duration) {
  var currentCenter = view.getCenter();
  if (currentCenter) {
    var center = view.constrainCenter([currentCenter[0] + delta[0], currentCenter[1] + delta[1]]);
    if (opt_duration) {
      view.animate({duration:opt_duration, easing:ol.easing.linear, center:center});
    } else {
      view.setCenter(center);
    }
  }
};
ol.interaction.Interaction.rotate = function(view, rotation, opt_anchor, opt_duration) {
  rotation = view.constrainRotation(rotation, 0);
  ol.interaction.Interaction.rotateWithoutConstraints(view, rotation, opt_anchor, opt_duration);
};
ol.interaction.Interaction.rotateWithoutConstraints = function(view, rotation, opt_anchor, opt_duration) {
  if (rotation !== undefined) {
    var currentRotation = view.getRotation();
    var currentCenter = view.getCenter();
    if (currentRotation !== undefined && currentCenter && opt_duration > 0) {
      view.animate({rotation:rotation, anchor:opt_anchor, duration:opt_duration, easing:ol.easing.easeOut});
    } else {
      view.rotate(rotation, opt_anchor);
    }
  }
};
ol.interaction.Interaction.zoom = function(view, resolution, opt_anchor, opt_duration, opt_direction) {
  resolution = view.constrainResolution(resolution, 0, opt_direction);
  ol.interaction.Interaction.zoomWithoutConstraints(view, resolution, opt_anchor, opt_duration);
};
ol.interaction.Interaction.zoomByDelta = function(view, delta, opt_anchor, opt_duration) {
  var currentResolution = view.getResolution();
  var resolution = view.constrainResolution(currentResolution, delta, 0);
  if (resolution !== undefined) {
    var resolutions = view.getResolutions();
    resolution = ol.math.clamp(resolution, view.getMinResolution() || resolutions[resolutions.length - 1], view.getMaxResolution() || resolutions[0]);
  }
  if (opt_anchor && resolution !== undefined && resolution !== currentResolution) {
    var currentCenter = view.getCenter();
    var center = view.calculateCenterZoom(resolution, opt_anchor);
    center = view.constrainCenter(center);
    opt_anchor = [(resolution * currentCenter[0] - currentResolution * center[0]) / (resolution - currentResolution), (resolution * currentCenter[1] - currentResolution * center[1]) / (resolution - currentResolution)];
  }
  ol.interaction.Interaction.zoomWithoutConstraints(view, resolution, opt_anchor, opt_duration);
};
ol.interaction.Interaction.zoomWithoutConstraints = function(view, resolution, opt_anchor, opt_duration) {
  if (resolution) {
    var currentResolution = view.getResolution();
    var currentCenter = view.getCenter();
    if (currentResolution !== undefined && currentCenter && resolution !== currentResolution && opt_duration) {
      view.animate({resolution:resolution, anchor:opt_anchor, duration:opt_duration, easing:ol.easing.easeOut});
    } else {
      if (opt_anchor) {
        var center = view.calculateCenterZoom(resolution, opt_anchor);
        view.setCenter(center);
      }
      view.setResolution(resolution);
    }
  }
};
goog.provide("ol.interaction.DoubleClickZoom");
goog.require("ol");
goog.require("ol.MapBrowserEventType");
goog.require("ol.interaction.Interaction");
ol.interaction.DoubleClickZoom = function(opt_options) {
  var options = opt_options ? opt_options : {};
  this.delta_ = options.delta ? options.delta : 1;
  ol.interaction.Interaction.call(this, {handleEvent:ol.interaction.DoubleClickZoom.handleEvent});
  this.duration_ = options.duration !== undefined ? options.duration : 250;
};
ol.inherits(ol.interaction.DoubleClickZoom, ol.interaction.Interaction);
ol.interaction.DoubleClickZoom.handleEvent = function(mapBrowserEvent) {
  var stopEvent = false;
  var browserEvent = mapBrowserEvent.originalEvent;
  if (mapBrowserEvent.type == ol.MapBrowserEventType.DBLCLICK) {
    var map = mapBrowserEvent.map;
    var anchor = mapBrowserEvent.coordinate;
    var delta = browserEvent.shiftKey ? -this.delta_ : this.delta_;
    var view = map.getView();
    ol.interaction.Interaction.zoomByDelta(view, delta, anchor, this.duration_);
    mapBrowserEvent.preventDefault();
    stopEvent = true;
  }
  return !stopEvent;
};
goog.provide("ol.events.condition");
goog.require("ol.MapBrowserEventType");
goog.require("ol.asserts");
goog.require("ol.functions");
goog.require("ol.has");
ol.events.condition.altKeyOnly = function(mapBrowserEvent) {
  var originalEvent = mapBrowserEvent.originalEvent;
  return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
ol.events.condition.altShiftKeysOnly = function(mapBrowserEvent) {
  var originalEvent = mapBrowserEvent.originalEvent;
  return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
};
ol.events.condition.always = ol.functions.TRUE;
ol.events.condition.click = function(mapBrowserEvent) {
  return mapBrowserEvent.type == ol.MapBrowserEventType.CLICK;
};
ol.events.condition.mouseActionButton = function(mapBrowserEvent) {
  var originalEvent = mapBrowserEvent.originalEvent;
  return originalEvent.button == 0 && !(ol.has.WEBKIT && ol.has.MAC && originalEvent.ctrlKey);
};
ol.events.condition.never = ol.functions.FALSE;
ol.events.condition.pointerMove = function(mapBrowserEvent) {
  return mapBrowserEvent.type == "pointermove";
};
ol.events.condition.singleClick = function(mapBrowserEvent) {
  return mapBrowserEvent.type == ol.MapBrowserEventType.SINGLECLICK;
};
ol.events.condition.doubleClick = function(mapBrowserEvent) {
  return mapBrowserEvent.type == ol.MapBrowserEventType.DBLCLICK;
};
ol.events.condition.noModifierKeys = function(mapBrowserEvent) {
  var originalEvent = mapBrowserEvent.originalEvent;
  return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
ol.events.condition.platformModifierKeyOnly = function(mapBrowserEvent) {
  var originalEvent = mapBrowserEvent.originalEvent;
  return !originalEvent.altKey && (ol.has.MAC ? originalEvent.metaKey : originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
ol.events.condition.shiftKeyOnly = function(mapBrowserEvent) {
  var originalEvent = mapBrowserEvent.originalEvent;
  return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
};
ol.events.condition.targetNotEditable = function(mapBrowserEvent) {
  var target = mapBrowserEvent.originalEvent.target;
  var tagName = target.tagName;
  return tagName !== "INPUT" && tagName !== "SELECT" && tagName !== "TEXTAREA";
};
ol.events.condition.mouseOnly = function(mapBrowserEvent) {
  ol.asserts.assert(mapBrowserEvent.pointerEvent, 56);
  return mapBrowserEvent.pointerEvent.pointerType == "mouse";
};
ol.events.condition.primaryAction = function(mapBrowserEvent) {
  var pointerEvent = mapBrowserEvent.pointerEvent;
  return pointerEvent.isPrimary && pointerEvent.button === 0;
};
goog.provide("ol.interaction.Pointer");
goog.require("ol");
goog.require("ol.functions");
goog.require("ol.MapBrowserEventType");
goog.require("ol.MapBrowserPointerEvent");
goog.require("ol.interaction.Interaction");
goog.require("ol.obj");
ol.interaction.Pointer = function(opt_options) {
  var options = opt_options ? opt_options : {};
  var handleEvent = options.handleEvent ? options.handleEvent : ol.interaction.Pointer.handleEvent;
  ol.interaction.Interaction.call(this, {handleEvent:handleEvent});
  this.handleDownEvent_ = options.handleDownEvent ? options.handleDownEvent : ol.interaction.Pointer.handleDownEvent;
  this.handleDragEvent_ = options.handleDragEvent ? options.handleDragEvent : ol.interaction.Pointer.handleDragEvent;
  this.handleMoveEvent_ = options.handleMoveEvent ? options.handleMoveEvent : ol.interaction.Pointer.handleMoveEvent;
  this.handleUpEvent_ = options.handleUpEvent ? options.handleUpEvent : ol.interaction.Pointer.handleUpEvent;
  this.handlingDownUpSequence = false;
  this.trackedPointers_ = {};
  this.targetPointers = [];
};
ol.inherits(ol.interaction.Pointer, ol.interaction.Interaction);
ol.interaction.Pointer.centroid = function(pointerEvents) {
  var length = pointerEvents.length;
  var clientX = 0;
  var clientY = 0;
  for (var i = 0; i < length; i++) {
    clientX += pointerEvents[i].clientX;
    clientY += pointerEvents[i].clientY;
  }
  return [clientX / length, clientY / length];
};
ol.interaction.Pointer.prototype.isPointerDraggingEvent_ = function(mapBrowserEvent) {
  var type = mapBrowserEvent.type;
  return type === ol.MapBrowserEventType.POINTERDOWN || type === ol.MapBrowserEventType.POINTERDRAG || type === ol.MapBrowserEventType.POINTERUP;
};
ol.interaction.Pointer.prototype.updateTrackedPointers_ = function(mapBrowserEvent) {
  if (this.isPointerDraggingEvent_(mapBrowserEvent)) {
    var event = mapBrowserEvent.pointerEvent;
    var id = event.pointerId.toString();
    if (mapBrowserEvent.type == ol.MapBrowserEventType.POINTERUP) {
      delete this.trackedPointers_[id];
    } else {
      if (mapBrowserEvent.type == ol.MapBrowserEventType.POINTERDOWN) {
        this.trackedPointers_[id] = event;
      } else {
        if (id in this.trackedPointers_) {
          this.trackedPointers_[id] = event;
        }
      }
    }
    this.targetPointers = ol.obj.getValues(this.trackedPointers_);
  }
};
ol.interaction.Pointer.handleDragEvent = ol.nullFunction;
ol.interaction.Pointer.handleUpEvent = ol.functions.FALSE;
ol.interaction.Pointer.handleDownEvent = ol.functions.FALSE;
ol.interaction.Pointer.handleMoveEvent = ol.nullFunction;
ol.interaction.Pointer.handleEvent = function(mapBrowserEvent) {
  if (!(mapBrowserEvent instanceof ol.MapBrowserPointerEvent)) {
    return true;
  }
  var stopEvent = false;
  this.updateTrackedPointers_(mapBrowserEvent);
  if (this.handlingDownUpSequence) {
    if (mapBrowserEvent.type == ol.MapBrowserEventType.POINTERDRAG) {
      this.handleDragEvent_(mapBrowserEvent);
    } else {
      if (mapBrowserEvent.type == ol.MapBrowserEventType.POINTERUP) {
        var handledUp = this.handleUpEvent_(mapBrowserEvent);
        this.handlingDownUpSequence = handledUp && this.targetPointers.length > 0;
      }
    }
  } else {
    if (mapBrowserEvent.type == ol.MapBrowserEventType.POINTERDOWN) {
      var handled = this.handleDownEvent_(mapBrowserEvent);
      this.handlingDownUpSequence = handled;
      stopEvent = this.shouldStopEvent(handled);
    } else {
      if (mapBrowserEvent.type == ol.MapBrowserEventType.POINTERMOVE) {
        this.handleMoveEvent_(mapBrowserEvent);
      }
    }
  }
  return !stopEvent;
};
ol.interaction.Pointer.prototype.shouldStopEvent = function(handled) {
  return handled;
};
goog.provide("ol.interaction.DragPan");
goog.require("ol");
goog.require("ol.ViewHint");
goog.require("ol.coordinate");
goog.require("ol.easing");
goog.require("ol.events.condition");
goog.require("ol.functions");
goog.require("ol.interaction.Pointer");
ol.interaction.DragPan = function(opt_options) {
  ol.interaction.Pointer.call(this, {handleDownEvent:ol.interaction.DragPan.handleDownEvent_, handleDragEvent:ol.interaction.DragPan.handleDragEvent_, handleUpEvent:ol.interaction.DragPan.handleUpEvent_});
  var options = opt_options ? opt_options : {};
  this.kinetic_ = options.kinetic;
  this.lastCentroid = null;
  this.lastPointersCount_;
  this.condition_ = options.condition ? options.condition : ol.events.condition.noModifierKeys;
  this.noKinetic_ = false;
};
ol.inherits(ol.interaction.DragPan, ol.interaction.Pointer);
ol.interaction.DragPan.handleDragEvent_ = function(mapBrowserEvent) {
  var targetPointers = this.targetPointers;
  var centroid = ol.interaction.Pointer.centroid(targetPointers);
  if (targetPointers.length == this.lastPointersCount_) {
    if (this.kinetic_) {
      this.kinetic_.update(centroid[0], centroid[1]);
    }
    if (this.lastCentroid) {
      var deltaX = this.lastCentroid[0] - centroid[0];
      var deltaY = centroid[1] - this.lastCentroid[1];
      var map = mapBrowserEvent.map;
      var view = map.getView();
      var viewState = view.getState();
      var center = [deltaX, deltaY];
      ol.coordinate.scale(center, viewState.resolution);
      ol.coordinate.rotate(center, viewState.rotation);
      ol.coordinate.add(center, viewState.center);
      center = view.constrainCenter(center);
      view.setCenter(center);
    }
  } else {
    if (this.kinetic_) {
      this.kinetic_.begin();
    }
  }
  this.lastCentroid = centroid;
  this.lastPointersCount_ = targetPointers.length;
};
ol.interaction.DragPan.handleUpEvent_ = function(mapBrowserEvent) {
  var map = mapBrowserEvent.map;
  var view = map.getView();
  if (this.targetPointers.length === 0) {
    if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
      var distance = this.kinetic_.getDistance();
      var angle = this.kinetic_.getAngle();
      var center = view.getCenter();
      var centerpx = map.getPixelFromCoordinate(center);
      var dest = map.getCoordinateFromPixel([centerpx[0] - distance * Math.cos(angle), centerpx[1] - distance * Math.sin(angle)]);
      view.animate({center:view.constrainCenter(dest), duration:500, easing:ol.easing.easeOut});
    }
    view.setHint(ol.ViewHint.INTERACTING, -1);
    return false;
  } else {
    if (this.kinetic_) {
      this.kinetic_.begin();
    }
    this.lastCentroid = null;
    return true;
  }
};
ol.interaction.DragPan.handleDownEvent_ = function(mapBrowserEvent) {
  if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {
    var map = mapBrowserEvent.map;
    var view = map.getView();
    this.lastCentroid = null;
    if (!this.handlingDownUpSequence) {
      view.setHint(ol.ViewHint.INTERACTING, 1);
    }
    if (view.getAnimating()) {
      view.setCenter(mapBrowserEvent.frameState.viewState.center);
    }
    if (this.kinetic_) {
      this.kinetic_.begin();
    }
    this.noKinetic_ = this.targetPointers.length > 1;
    return true;
  } else {
    return false;
  }
};
ol.interaction.DragPan.prototype.shouldStopEvent = ol.functions.FALSE;
goog.provide("ol.interaction.DragRotate");
goog.require("ol");
goog.require("ol.RotationConstraint");
goog.require("ol.ViewHint");
goog.require("ol.events.condition");
goog.require("ol.functions");
goog.require("ol.interaction.Interaction");
goog.require("ol.interaction.Pointer");
ol.interaction.DragRotate = function(opt_options) {
  var options = opt_options ? opt_options : {};
  ol.interaction.Pointer.call(this, {handleDownEvent:ol.interaction.DragRotate.handleDownEvent_, handleDragEvent:ol.interaction.DragRotate.handleDragEvent_, handleUpEvent:ol.interaction.DragRotate.handleUpEvent_});
  this.condition_ = options.condition ? options.condition : ol.events.condition.altShiftKeysOnly;
  this.lastAngle_ = undefined;
  this.duration_ = options.duration !== undefined ? options.duration : 250;
};
ol.inherits(ol.interaction.DragRotate, ol.interaction.Pointer);
ol.interaction.DragRotate.handleDragEvent_ = function(mapBrowserEvent) {
  if (!ol.events.condition.mouseOnly(mapBrowserEvent)) {
    return;
  }
  var map = mapBrowserEvent.map;
  var view = map.getView();
  if (view.getConstraints().rotation === ol.RotationConstraint.disable) {
    return;
  }
  var size = map.getSize();
  var offset = mapBrowserEvent.pixel;
  var theta = Math.atan2(size[1] / 2 - offset[1], offset[0] - size[0] / 2);
  if (this.lastAngle_ !== undefined) {
    var delta = theta - this.lastAngle_;
    var rotation = view.getRotation();
    ol.interaction.Interaction.rotateWithoutConstraints(view, rotation - delta);
  }
  this.lastAngle_ = theta;
};
ol.interaction.DragRotate.handleUpEvent_ = function(mapBrowserEvent) {
  if (!ol.events.condition.mouseOnly(mapBrowserEvent)) {
    return true;
  }
  var map = mapBrowserEvent.map;
  var view = map.getView();
  view.setHint(ol.ViewHint.INTERACTING, -1);
  var rotation = view.getRotation();
  ol.interaction.Interaction.rotate(view, rotation, undefined, this.duration_);
  return false;
};
ol.interaction.DragRotate.handleDownEvent_ = function(mapBrowserEvent) {
  if (!ol.events.condition.mouseOnly(mapBrowserEvent)) {
    return false;
  }
  if (ol.events.condition.mouseActionButton(mapBrowserEvent) && this.condition_(mapBrowserEvent)) {
    var map = mapBrowserEvent.map;
    map.getView().setHint(ol.ViewHint.INTERACTING, 1);
    this.lastAngle_ = undefined;
    return true;
  } else {
    return false;
  }
};
ol.interaction.DragRotate.prototype.shouldStopEvent = ol.functions.FALSE;
goog.provide("ol.render.Box");
goog.require("ol");
goog.require("ol.Disposable");
goog.require("ol.geom.Polygon");
ol.render.Box = function(className) {
  this.geometry_ = null;
  this.element_ = document.createElement("div");
  this.element_.style.position = "absolute";
  this.element_.className = "ol-box " + className;
  this.map_ = null;
  this.startPixel_ = null;
  this.endPixel_ = null;
};
ol.inherits(ol.render.Box, ol.Disposable);
ol.render.Box.prototype.disposeInternal = function() {
  this.setMap(null);
};
ol.render.Box.prototype.render_ = function() {
  var startPixel = this.startPixel_;
  var endPixel = this.endPixel_;
  var px = "px";
  var style = this.element_.style;
  style.left = Math.min(startPixel[0], endPixel[0]) + px;
  style.top = Math.min(startPixel[1], endPixel[1]) + px;
  style.width = Math.abs(endPixel[0] - startPixel[0]) + px;
  style.height = Math.abs(endPixel[1] - startPixel[1]) + px;
};
ol.render.Box.prototype.setMap = function(map) {
  if (this.map_) {
    this.map_.getOverlayContainer().removeChild(this.element_);
    var style = this.element_.style;
    style.left = style.top = style.width = style.height = "inherit";
  }
  this.map_ = map;
  if (this.map_) {
    this.map_.getOverlayContainer().appendChild(this.element_);
  }
};
ol.render.Box.prototype.setPixels = function(startPixel, endPixel) {
  this.startPixel_ = startPixel;
  this.endPixel_ = endPixel;
  this.createOrUpdateGeometry();
  this.render_();
};
ol.render.Box.prototype.createOrUpdateGeometry = function() {
  var startPixel = this.startPixel_;
  var endPixel = this.endPixel_;
  var pixels = [startPixel, [startPixel[0], endPixel[1]], endPixel, [endPixel[0], startPixel[1]]];
  var coordinates = pixels.map(this.map_.getCoordinateFromPixel, this.map_);
  coordinates[4] = coordinates[0].slice();
  if (!this.geometry_) {
    this.geometry_ = new ol.geom.Polygon([coordinates]);
  } else {
    this.geometry_.setCoordinates([coordinates]);
  }
};
ol.render.Box.prototype.getGeometry = function() {
  return this.geometry_;
};
goog.provide("ol.interaction.DragBox");
goog.require("ol.events.Event");
goog.require("ol");
goog.require("ol.events.condition");
goog.require("ol.interaction.Pointer");
goog.require("ol.render.Box");
ol.interaction.DragBox = function(opt_options) {
  ol.interaction.Pointer.call(this, {handleDownEvent:ol.interaction.DragBox.handleDownEvent_, handleDragEvent:ol.interaction.DragBox.handleDragEvent_, handleUpEvent:ol.interaction.DragBox.handleUpEvent_});
  var options = opt_options ? opt_options : {};
  this.box_ = new ol.render.Box(options.className || "ol-dragbox");
  this.minArea_ = options.minArea !== undefined ? options.minArea : 64;
  this.startPixel_ = null;
  this.condition_ = options.condition ? options.condition : ol.events.condition.always;
  this.boxEndCondition_ = options.boxEndCondition ? options.boxEndCondition : ol.interaction.DragBox.defaultBoxEndCondition;
};
ol.inherits(ol.interaction.DragBox, ol.interaction.Pointer);
ol.interaction.DragBox.defaultBoxEndCondition = function(mapBrowserEvent, startPixel, endPixel) {
  var width = endPixel[0] - startPixel[0];
  var height = endPixel[1] - startPixel[1];
  return width * width + height * height >= this.minArea_;
};
ol.interaction.DragBox.handleDragEvent_ = function(mapBrowserEvent) {
  if (!ol.events.condition.mouseOnly(mapBrowserEvent)) {
    return;
  }
  this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);
  this.dispatchEvent(new ol.interaction.DragBox.Event(ol.interaction.DragBox.EventType_.BOXDRAG, mapBrowserEvent.coordinate, mapBrowserEvent));
};
ol.interaction.DragBox.prototype.getGeometry = function() {
  return this.box_.getGeometry();
};
ol.interaction.DragBox.prototype.onBoxEnd = ol.nullFunction;
ol.interaction.DragBox.handleUpEvent_ = function(mapBrowserEvent) {
  if (!ol.events.condition.mouseOnly(mapBrowserEvent)) {
    return true;
  }
  this.box_.setMap(null);
  if (this.boxEndCondition_(mapBrowserEvent, this.startPixel_, mapBrowserEvent.pixel)) {
    this.onBoxEnd(mapBrowserEvent);
    this.dispatchEvent(new ol.interaction.DragBox.Event(ol.interaction.DragBox.EventType_.BOXEND, mapBrowserEvent.coordinate, mapBrowserEvent));
  }
  return false;
};
ol.interaction.DragBox.handleDownEvent_ = function(mapBrowserEvent) {
  if (!ol.events.condition.mouseOnly(mapBrowserEvent)) {
    return false;
  }
  if (ol.events.condition.mouseActionButton(mapBrowserEvent) && this.condition_(mapBrowserEvent)) {
    this.startPixel_ = mapBrowserEvent.pixel;
    this.box_.setMap(mapBrowserEvent.map);
    this.box_.setPixels(this.startPixel_, this.startPixel_);
    this.dispatchEvent(new ol.interaction.DragBox.Event(ol.interaction.DragBox.EventType_.BOXSTART, mapBrowserEvent.coordinate, mapBrowserEvent));
    return true;
  } else {
    return false;
  }
};
ol.interaction.DragBox.EventType_ = {BOXSTART:"boxstart", BOXDRAG:"boxdrag", BOXEND:"boxend"};
ol.interaction.DragBox.Event = function(type, coordinate, mapBrowserEvent) {
  ol.events.Event.call(this, type);
  this.coordinate = coordinate;
  this.mapBrowserEvent = mapBrowserEvent;
};
ol.inherits(ol.interaction.DragBox.Event, ol.events.Event);
goog.provide("ol.interaction.DragZoom");
goog.require("ol");
goog.require("ol.easing");
goog.require("ol.events.condition");
goog.require("ol.extent");
goog.require("ol.interaction.DragBox");
ol.interaction.DragZoom = function(opt_options) {
  var options = opt_options ? opt_options : {};
  var condition = options.condition ? options.condition : ol.events.condition.shiftKeyOnly;
  this.duration_ = options.duration !== undefined ? options.duration : 200;
  this.out_ = options.out !== undefined ? options.out : false;
  ol.interaction.DragBox.call(this, {condition:condition, className:options.className || "ol-dragzoom"});
};
ol.inherits(ol.interaction.DragZoom, ol.interaction.DragBox);
ol.interaction.DragZoom.prototype.onBoxEnd = function() {
  var map = this.getMap();
  var view = map.getView();
  var size = map.getSize();
  var extent = this.getGeometry().getExtent();
  if (this.out_) {
    var mapExtent = view.calculateExtent(size);
    var boxPixelExtent = ol.extent.createOrUpdateFromCoordinates([map.getPixelFromCoordinate(ol.extent.getBottomLeft(extent)), map.getPixelFromCoordinate(ol.extent.getTopRight(extent))]);
    var factor = view.getResolutionForExtent(boxPixelExtent, size);
    ol.extent.scaleFromCenter(mapExtent, 1 / factor);
    extent = mapExtent;
  }
  var resolution = view.constrainResolution(view.getResolutionForExtent(extent, size));
  var center = ol.extent.getCenter(extent);
  center = view.constrainCenter(center);
  view.animate({resolution:resolution, center:center, duration:this.duration_, easing:ol.easing.easeOut});
};
goog.provide("ol.events.KeyCode");
ol.events.KeyCode = {LEFT:37, UP:38, RIGHT:39, DOWN:40};
goog.provide("ol.interaction.KeyboardPan");
goog.require("ol");
goog.require("ol.coordinate");
goog.require("ol.events.EventType");
goog.require("ol.events.KeyCode");
goog.require("ol.events.condition");
goog.require("ol.interaction.Interaction");
ol.interaction.KeyboardPan = function(opt_options) {
  ol.interaction.Interaction.call(this, {handleEvent:ol.interaction.KeyboardPan.handleEvent});
  var options = opt_options || {};
  this.defaultCondition_ = function(mapBrowserEvent) {
    return ol.events.condition.noModifierKeys(mapBrowserEvent) && ol.events.condition.targetNotEditable(mapBrowserEvent);
  };
  this.condition_ = options.condition !== undefined ? options.condition : this.defaultCondition_;
  this.duration_ = options.duration !== undefined ? options.duration : 100;
  this.pixelDelta_ = options.pixelDelta !== undefined ? options.pixelDelta : 128;
};
ol.inherits(ol.interaction.KeyboardPan, ol.interaction.Interaction);
ol.interaction.KeyboardPan.handleEvent = function(mapBrowserEvent) {
  var stopEvent = false;
  if (mapBrowserEvent.type == ol.events.EventType.KEYDOWN) {
    var keyEvent = mapBrowserEvent.originalEvent;
    var keyCode = keyEvent.keyCode;
    if (this.condition_(mapBrowserEvent) && (keyCode == ol.events.KeyCode.DOWN || keyCode == ol.events.KeyCode.LEFT || keyCode == ol.events.KeyCode.RIGHT || keyCode == ol.events.KeyCode.UP)) {
      var map = mapBrowserEvent.map;
      var view = map.getView();
      var mapUnitsDelta = view.getResolution() * this.pixelDelta_;
      var deltaX = 0, deltaY = 0;
      if (keyCode == ol.events.KeyCode.DOWN) {
        deltaY = -mapUnitsDelta;
      } else {
        if (keyCode == ol.events.KeyCode.LEFT) {
          deltaX = -mapUnitsDelta;
        } else {
          if (keyCode == ol.events.KeyCode.RIGHT) {
            deltaX = mapUnitsDelta;
          } else {
            deltaY = mapUnitsDelta;
          }
        }
      }
      var delta = [deltaX, deltaY];
      ol.coordinate.rotate(delta, view.getRotation());
      ol.interaction.Interaction.pan(view, delta, this.duration_);
      mapBrowserEvent.preventDefault();
      stopEvent = true;
    }
  }
  return !stopEvent;
};
goog.provide("ol.interaction.KeyboardZoom");
goog.require("ol");
goog.require("ol.events.EventType");
goog.require("ol.events.condition");
goog.require("ol.interaction.Interaction");
ol.interaction.KeyboardZoom = function(opt_options) {
  ol.interaction.Interaction.call(this, {handleEvent:ol.interaction.KeyboardZoom.handleEvent});
  var options = opt_options ? opt_options : {};
  this.condition_ = options.condition ? options.condition : ol.events.condition.targetNotEditable;
  this.delta_ = options.delta ? options.delta : 1;
  this.duration_ = options.duration !== undefined ? options.duration : 100;
};
ol.inherits(ol.interaction.KeyboardZoom, ol.interaction.Interaction);
ol.interaction.KeyboardZoom.handleEvent = function(mapBrowserEvent) {
  var stopEvent = false;
  if (mapBrowserEvent.type == ol.events.EventType.KEYDOWN || mapBrowserEvent.type == ol.events.EventType.KEYPRESS) {
    var keyEvent = mapBrowserEvent.originalEvent;
    var charCode = keyEvent.charCode;
    if (this.condition_(mapBrowserEvent) && (charCode == "+".charCodeAt(0) || charCode == "-".charCodeAt(0))) {
      var map = mapBrowserEvent.map;
      var delta = charCode == "+".charCodeAt(0) ? this.delta_ : -this.delta_;
      var view = map.getView();
      ol.interaction.Interaction.zoomByDelta(view, delta, undefined, this.duration_);
      mapBrowserEvent.preventDefault();
      stopEvent = true;
    }
  }
  return !stopEvent;
};
goog.provide("ol.interaction.MouseWheelZoom");
goog.require("ol");
goog.require("ol.ViewHint");
goog.require("ol.easing");
goog.require("ol.events.EventType");
goog.require("ol.has");
goog.require("ol.interaction.Interaction");
goog.require("ol.math");
ol.interaction.MouseWheelZoom = function(opt_options) {
  ol.interaction.Interaction.call(this, {handleEvent:ol.interaction.MouseWheelZoom.handleEvent});
  var options = opt_options || {};
  this.delta_ = 0;
  this.duration_ = options.duration !== undefined ? options.duration : 250;
  this.timeout_ = options.timeout !== undefined ? options.timeout : 80;
  this.useAnchor_ = options.useAnchor !== undefined ? options.useAnchor : true;
  this.constrainResolution_ = options.constrainResolution || false;
  this.lastAnchor_ = null;
  this.startTime_ = undefined;
  this.timeoutId_ = undefined;
  this.mode_ = undefined;
  this.trackpadEventGap_ = 400;
  this.trackpadTimeoutId_ = undefined;
  this.trackpadDeltaPerZoom_ = 300;
  this.trackpadZoomBuffer_ = 1.5;
};
ol.inherits(ol.interaction.MouseWheelZoom, ol.interaction.Interaction);
ol.interaction.MouseWheelZoom.handleEvent = function(mapBrowserEvent) {
  var type = mapBrowserEvent.type;
  if (type !== ol.events.EventType.WHEEL && type !== ol.events.EventType.MOUSEWHEEL) {
    return true;
  }
  mapBrowserEvent.preventDefault();
  var map = mapBrowserEvent.map;
  var wheelEvent = mapBrowserEvent.originalEvent;
  if (this.useAnchor_) {
    this.lastAnchor_ = mapBrowserEvent.coordinate;
  }
  var delta;
  if (mapBrowserEvent.type == ol.events.EventType.WHEEL) {
    delta = wheelEvent.deltaY;
    if (ol.has.FIREFOX && wheelEvent.deltaMode === WheelEvent.DOM_DELTA_PIXEL) {
      delta /= ol.has.DEVICE_PIXEL_RATIO;
    }
    if (wheelEvent.deltaMode === WheelEvent.DOM_DELTA_LINE) {
      delta *= 40;
    }
  } else {
    if (mapBrowserEvent.type == ol.events.EventType.MOUSEWHEEL) {
      delta = -wheelEvent.wheelDeltaY;
      if (ol.has.SAFARI) {
        delta /= 3;
      }
    }
  }
  if (delta === 0) {
    return false;
  }
  var now = Date.now();
  if (this.startTime_ === undefined) {
    this.startTime_ = now;
  }
  if (!this.mode_ || now - this.startTime_ > this.trackpadEventGap_) {
    this.mode_ = Math.abs(delta) < 4 ? ol.interaction.MouseWheelZoom.Mode_.TRACKPAD : ol.interaction.MouseWheelZoom.Mode_.WHEEL;
  }
  if (this.mode_ === ol.interaction.MouseWheelZoom.Mode_.TRACKPAD) {
    var view = map.getView();
    if (this.trackpadTimeoutId_) {
      clearTimeout(this.trackpadTimeoutId_);
    } else {
      view.setHint(ol.ViewHint.INTERACTING, 1);
    }
    this.trackpadTimeoutId_ = setTimeout(this.decrementInteractingHint_.bind(this), this.trackpadEventGap_);
    var resolution = view.getResolution() * Math.pow(2, delta / this.trackpadDeltaPerZoom_);
    var minResolution = view.getMinResolution();
    var maxResolution = view.getMaxResolution();
    var rebound = 0;
    if (resolution < minResolution) {
      resolution = Math.max(resolution, minResolution / this.trackpadZoomBuffer_);
      rebound = 1;
    } else {
      if (resolution > maxResolution) {
        resolution = Math.min(resolution, maxResolution * this.trackpadZoomBuffer_);
        rebound = -1;
      }
    }
    if (this.lastAnchor_) {
      var center = view.calculateCenterZoom(resolution, this.lastAnchor_);
      view.setCenter(view.constrainCenter(center));
    }
    view.setResolution(resolution);
    if (rebound === 0 && this.constrainResolution_) {
      view.animate({resolution:view.constrainResolution(resolution, delta > 0 ? -1 : 1), easing:ol.easing.easeOut, anchor:this.lastAnchor_, duration:this.duration_});
    }
    if (rebound > 0) {
      view.animate({resolution:minResolution, easing:ol.easing.easeOut, anchor:this.lastAnchor_, duration:500});
    } else {
      if (rebound < 0) {
        view.animate({resolution:maxResolution, easing:ol.easing.easeOut, anchor:this.lastAnchor_, duration:500});
      }
    }
    this.startTime_ = now;
    return false;
  }
  this.delta_ += delta;
  var timeLeft = Math.max(this.timeout_ - (now - this.startTime_), 0);
  clearTimeout(this.timeoutId_);
  this.timeoutId_ = setTimeout(this.handleWheelZoom_.bind(this, map), timeLeft);
  return false;
};
ol.interaction.MouseWheelZoom.prototype.decrementInteractingHint_ = function() {
  this.trackpadTimeoutId_ = undefined;
  var view = this.getMap().getView();
  view.setHint(ol.ViewHint.INTERACTING, -1);
};
ol.interaction.MouseWheelZoom.prototype.handleWheelZoom_ = function(map) {
  var view = map.getView();
  if (view.getAnimating()) {
    view.cancelAnimations();
  }
  var maxDelta = ol.MOUSEWHEELZOOM_MAXDELTA;
  var delta = ol.math.clamp(this.delta_, -maxDelta, maxDelta);
  ol.interaction.Interaction.zoomByDelta(view, -delta, this.lastAnchor_, this.duration_);
  this.mode_ = undefined;
  this.delta_ = 0;
  this.lastAnchor_ = null;
  this.startTime_ = undefined;
  this.timeoutId_ = undefined;
};
ol.interaction.MouseWheelZoom.prototype.setMouseAnchor = function(useAnchor) {
  this.useAnchor_ = useAnchor;
  if (!useAnchor) {
    this.lastAnchor_ = null;
  }
};
ol.interaction.MouseWheelZoom.Mode_ = {TRACKPAD:"trackpad", WHEEL:"wheel"};
goog.provide("ol.interaction.PinchRotate");
goog.require("ol");
goog.require("ol.ViewHint");
goog.require("ol.functions");
goog.require("ol.interaction.Interaction");
goog.require("ol.interaction.Pointer");
goog.require("ol.RotationConstraint");
ol.interaction.PinchRotate = function(opt_options) {
  ol.interaction.Pointer.call(this, {handleDownEvent:ol.interaction.PinchRotate.handleDownEvent_, handleDragEvent:ol.interaction.PinchRotate.handleDragEvent_, handleUpEvent:ol.interaction.PinchRotate.handleUpEvent_});
  var options = opt_options || {};
  this.anchor_ = null;
  this.lastAngle_ = undefined;
  this.rotating_ = false;
  this.rotationDelta_ = 0.0;
  this.threshold_ = options.threshold !== undefined ? options.threshold : 0.3;
  this.duration_ = options.duration !== undefined ? options.duration : 250;
};
ol.inherits(ol.interaction.PinchRotate, ol.interaction.Pointer);
ol.interaction.PinchRotate.handleDragEvent_ = function(mapBrowserEvent) {
  var rotationDelta = 0.0;
  var touch0 = this.targetPointers[0];
  var touch1 = this.targetPointers[1];
  var angle = Math.atan2(touch1.clientY - touch0.clientY, touch1.clientX - touch0.clientX);
  if (this.lastAngle_ !== undefined) {
    var delta = angle - this.lastAngle_;
    this.rotationDelta_ += delta;
    if (!this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_) {
      this.rotating_ = true;
    }
    rotationDelta = delta;
  }
  this.lastAngle_ = angle;
  var map = mapBrowserEvent.map;
  var view = map.getView();
  if (view.getConstraints().rotation === ol.RotationConstraint.disable) {
    return;
  }
  var viewportPosition = map.getViewport().getBoundingClientRect();
  var centroid = ol.interaction.Pointer.centroid(this.targetPointers);
  centroid[0] -= viewportPosition.left;
  centroid[1] -= viewportPosition.top;
  this.anchor_ = map.getCoordinateFromPixel(centroid);
  if (this.rotating_) {
    var rotation = view.getRotation();
    map.render();
    ol.interaction.Interaction.rotateWithoutConstraints(view, rotation + rotationDelta, this.anchor_);
  }
};
ol.interaction.PinchRotate.handleUpEvent_ = function(mapBrowserEvent) {
  if (this.targetPointers.length < 2) {
    var map = mapBrowserEvent.map;
    var view = map.getView();
    view.setHint(ol.ViewHint.INTERACTING, -1);
    if (this.rotating_) {
      var rotation = view.getRotation();
      ol.interaction.Interaction.rotate(view, rotation, this.anchor_, this.duration_);
    }
    return false;
  } else {
    return true;
  }
};
ol.interaction.PinchRotate.handleDownEvent_ = function(mapBrowserEvent) {
  if (this.targetPointers.length >= 2) {
    var map = mapBrowserEvent.map;
    this.anchor_ = null;
    this.lastAngle_ = undefined;
    this.rotating_ = false;
    this.rotationDelta_ = 0.0;
    if (!this.handlingDownUpSequence) {
      map.getView().setHint(ol.ViewHint.INTERACTING, 1);
    }
    return true;
  } else {
    return false;
  }
};
ol.interaction.PinchRotate.prototype.shouldStopEvent = ol.functions.FALSE;
goog.provide("ol.interaction.PinchZoom");
goog.require("ol");
goog.require("ol.ViewHint");
goog.require("ol.functions");
goog.require("ol.interaction.Interaction");
goog.require("ol.interaction.Pointer");
ol.interaction.PinchZoom = function(opt_options) {
  ol.interaction.Pointer.call(this, {handleDownEvent:ol.interaction.PinchZoom.handleDownEvent_, handleDragEvent:ol.interaction.PinchZoom.handleDragEvent_, handleUpEvent:ol.interaction.PinchZoom.handleUpEvent_});
  var options = opt_options ? opt_options : {};
  this.constrainResolution_ = options.constrainResolution || false;
  this.anchor_ = null;
  this.duration_ = options.duration !== undefined ? options.duration : 400;
  this.lastDistance_ = undefined;
  this.lastScaleDelta_ = 1;
};
ol.inherits(ol.interaction.PinchZoom, ol.interaction.Pointer);
ol.interaction.PinchZoom.handleDragEvent_ = function(mapBrowserEvent) {
  var scaleDelta = 1.0;
  var touch0 = this.targetPointers[0];
  var touch1 = this.targetPointers[1];
  var dx = touch0.clientX - touch1.clientX;
  var dy = touch0.clientY - touch1.clientY;
  var distance = Math.sqrt(dx * dx + dy * dy);
  if (this.lastDistance_ !== undefined) {
    scaleDelta = this.lastDistance_ / distance;
  }
  this.lastDistance_ = distance;
  var map = mapBrowserEvent.map;
  var view = map.getView();
  var resolution = view.getResolution();
  var maxResolution = view.getMaxResolution();
  var minResolution = view.getMinResolution();
  var newResolution = resolution * scaleDelta;
  if (newResolution > maxResolution) {
    scaleDelta = maxResolution / resolution;
    newResolution = maxResolution;
  } else {
    if (newResolution < minResolution) {
      scaleDelta = minResolution / resolution;
      newResolution = minResolution;
    }
  }
  if (scaleDelta != 1.0) {
    this.lastScaleDelta_ = scaleDelta;
  }
  var viewportPosition = map.getViewport().getBoundingClientRect();
  var centroid = ol.interaction.Pointer.centroid(this.targetPointers);
  centroid[0] -= viewportPosition.left;
  centroid[1] -= viewportPosition.top;
  this.anchor_ = map.getCoordinateFromPixel(centroid);
  map.render();
  ol.interaction.Interaction.zoomWithoutConstraints(view, newResolution, this.anchor_);
};
ol.interaction.PinchZoom.handleUpEvent_ = function(mapBrowserEvent) {
  if (this.targetPointers.length < 2) {
    var map = mapBrowserEvent.map;
    var view = map.getView();
    view.setHint(ol.ViewHint.INTERACTING, -1);
    var resolution = view.getResolution();
    if (this.constrainResolution_ || resolution < view.getMinResolution() || resolution > view.getMaxResolution()) {
      var direction = this.lastScaleDelta_ - 1;
      ol.interaction.Interaction.zoom(view, resolution, this.anchor_, this.duration_, direction);
    }
    return false;
  } else {
    return true;
  }
};
ol.interaction.PinchZoom.handleDownEvent_ = function(mapBrowserEvent) {
  if (this.targetPointers.length >= 2) {
    var map = mapBrowserEvent.map;
    this.anchor_ = null;
    this.lastDistance_ = undefined;
    this.lastScaleDelta_ = 1;
    if (!this.handlingDownUpSequence) {
      map.getView().setHint(ol.ViewHint.INTERACTING, 1);
    }
    return true;
  } else {
    return false;
  }
};
ol.interaction.PinchZoom.prototype.shouldStopEvent = ol.functions.FALSE;
goog.provide("ol.interaction");
goog.require("ol.Collection");
goog.require("ol.Kinetic");
goog.require("ol.interaction.DoubleClickZoom");
goog.require("ol.interaction.DragPan");
goog.require("ol.interaction.DragRotate");
goog.require("ol.interaction.DragZoom");
goog.require("ol.interaction.KeyboardPan");
goog.require("ol.interaction.KeyboardZoom");
goog.require("ol.interaction.MouseWheelZoom");
goog.require("ol.interaction.PinchRotate");
goog.require("ol.interaction.PinchZoom");
ol.interaction.defaults = function(opt_options) {
  var options = opt_options ? opt_options : {};
  var interactions = new ol.Collection;
  var kinetic = new ol.Kinetic(-0.005, 0.05, 100);
  var altShiftDragRotate = options.altShiftDragRotate !== undefined ? options.altShiftDragRotate : true;
  if (altShiftDragRotate) {
    interactions.push(new ol.interaction.DragRotate);
  }
  var doubleClickZoom = options.doubleClickZoom !== undefined ? options.doubleClickZoom : true;
  if (doubleClickZoom) {
    interactions.push(new ol.interaction.DoubleClickZoom({delta:options.zoomDelta, duration:options.zoomDuration}));
  }
  var dragPan = options.dragPan !== undefined ? options.dragPan : true;
  if (dragPan) {
    interactions.push(new ol.interaction.DragPan({kinetic:kinetic}));
  }
  var pinchRotate = options.pinchRotate !== undefined ? options.pinchRotate : true;
  if (pinchRotate) {
    interactions.push(new ol.interaction.PinchRotate);
  }
  var pinchZoom = options.pinchZoom !== undefined ? options.pinchZoom : true;
  if (pinchZoom) {
    interactions.push(new ol.interaction.PinchZoom({constrainResolution:options.constrainResolution, duration:options.zoomDuration}));
  }
  var keyboard = options.keyboard !== undefined ? options.keyboard : true;
  if (keyboard) {
    interactions.push(new ol.interaction.KeyboardPan);
    interactions.push(new ol.interaction.KeyboardZoom({delta:options.zoomDelta, duration:options.zoomDuration}));
  }
  var mouseWheelZoom = options.mouseWheelZoom !== undefined ? options.mouseWheelZoom : true;
  if (mouseWheelZoom) {
    interactions.push(new ol.interaction.MouseWheelZoom({constrainResolution:options.constrainResolution, duration:options.zoomDuration}));
  }
  var shiftDragZoom = options.shiftDragZoom !== undefined ? options.shiftDragZoom : true;
  if (shiftDragZoom) {
    interactions.push(new ol.interaction.DragZoom({duration:options.zoomDuration}));
  }
  return interactions;
};
goog.provide("ol.ImageCanvas");
goog.require("ol");
goog.require("ol.ImageBase");
goog.require("ol.ImageState");
ol.ImageCanvas = function(extent, resolution, pixelRatio, canvas, opt_loader) {
  this.loader_ = opt_loader !== undefined ? opt_loader : null;
  var state = opt_loader !== undefined ? ol.ImageState.IDLE : ol.ImageState.LOADED;
  ol.ImageBase.call(this, extent, resolution, pixelRatio, state);
  this.canvas_ = canvas;
  this.error_ = null;
};
ol.inherits(ol.ImageCanvas, ol.ImageBase);
ol.ImageCanvas.prototype.getError = function() {
  return this.error_;
};
ol.ImageCanvas.prototype.handleLoad_ = function(err) {
  if (err) {
    this.error_ = err;
    this.state = ol.ImageState.ERROR;
  } else {
    this.state = ol.ImageState.LOADED;
  }
  this.changed();
};
ol.ImageCanvas.prototype.load = function() {
  if (this.state == ol.ImageState.IDLE) {
    this.state = ol.ImageState.LOADING;
    this.changed();
    this.loader_(this.handleLoad_.bind(this));
  }
};
ol.ImageCanvas.prototype.getImage = function() {
  return this.canvas_;
};
goog.provide("ol.render.Event");
goog.require("ol");
goog.require("ol.events.Event");
ol.render.Event = function(type, opt_vectorContext, opt_frameState, opt_context, opt_glContext) {
  ol.events.Event.call(this, type);
  this.vectorContext = opt_vectorContext;
  this.frameState = opt_frameState;
  this.context = opt_context;
  this.glContext = opt_glContext;
};
ol.inherits(ol.render.Event, ol.events.Event);
goog.provide("ol.render.VectorContext");
ol.render.VectorContext = function() {
};
ol.render.VectorContext.prototype.drawCustom = function(geometry, feature, renderer) {
};
ol.render.VectorContext.prototype.drawGeometry = function(geometry) {
};
ol.render.VectorContext.prototype.setStyle = function(style) {
};
ol.render.VectorContext.prototype.drawCircle = function(circleGeometry, feature) {
};
ol.render.VectorContext.prototype.drawFeature = function(feature, style) {
};
ol.render.VectorContext.prototype.drawGeometryCollection = function(geometryCollectionGeometry, feature) {
};
ol.render.VectorContext.prototype.drawLineString = function(lineStringGeometry, feature) {
};
ol.render.VectorContext.prototype.drawMultiLineString = function(multiLineStringGeometry, feature) {
};
ol.render.VectorContext.prototype.drawMultiPoint = function(multiPointGeometry, feature) {
};
ol.render.VectorContext.prototype.drawMultiPolygon = function(multiPolygonGeometry, feature) {
};
ol.render.VectorContext.prototype.drawPoint = function(pointGeometry, feature) {
};
ol.render.VectorContext.prototype.drawPolygon = function(polygonGeometry, feature) {
};
ol.render.VectorContext.prototype.drawText = function(geometry, feature) {
};
ol.render.VectorContext.prototype.setFillStrokeStyle = function(fillStyle, strokeStyle) {
};
ol.render.VectorContext.prototype.setImageStyle = function(imageStyle, opt_declutterGroup) {
};
ol.render.VectorContext.prototype.setTextStyle = function(textStyle, opt_declutterGroup) {
};
goog.provide("ol.render.canvas.Immediate");
goog.require("ol");
goog.require("ol.array");
goog.require("ol.colorlike");
goog.require("ol.extent");
goog.require("ol.geom.GeometryType");
goog.require("ol.geom.SimpleGeometry");
goog.require("ol.geom.flat.transform");
goog.require("ol.has");
goog.require("ol.render.VectorContext");
goog.require("ol.render.canvas");
goog.require("ol.transform");
ol.render.canvas.Immediate = function(context, pixelRatio, extent, transform, viewRotation) {
  ol.render.VectorContext.call(this);
  this.context_ = context;
  this.pixelRatio_ = pixelRatio;
  this.extent_ = extent;
  this.transform_ = transform;
  this.viewRotation_ = viewRotation;
  this.contextFillState_ = null;
  this.contextStrokeState_ = null;
  this.contextTextState_ = null;
  this.fillState_ = null;
  this.strokeState_ = null;
  this.image_ = null;
  this.imageAnchorX_ = 0;
  this.imageAnchorY_ = 0;
  this.imageHeight_ = 0;
  this.imageOpacity_ = 0;
  this.imageOriginX_ = 0;
  this.imageOriginY_ = 0;
  this.imageRotateWithView_ = false;
  this.imageRotation_ = 0;
  this.imageScale_ = 0;
  this.imageSnapToPixel_ = false;
  this.imageWidth_ = 0;
  this.text_ = "";
  this.textOffsetX_ = 0;
  this.textOffsetY_ = 0;
  this.textRotateWithView_ = false;
  this.textRotation_ = 0;
  this.textScale_ = 0;
  this.textFillState_ = null;
  this.textStrokeState_ = null;
  this.textState_ = null;
  this.pixelCoordinates_ = [];
  this.tmpLocalTransform_ = ol.transform.create();
};
ol.inherits(ol.render.canvas.Immediate, ol.render.VectorContext);
ol.render.canvas.Immediate.prototype.drawImages_ = function(flatCoordinates, offset, end, stride) {
  if (!this.image_) {
    return;
  }
  var pixelCoordinates = ol.geom.flat.transform.transform2D(flatCoordinates, offset, end, 2, this.transform_, this.pixelCoordinates_);
  var context = this.context_;
  var localTransform = this.tmpLocalTransform_;
  var alpha = context.globalAlpha;
  if (this.imageOpacity_ != 1) {
    context.globalAlpha = alpha * this.imageOpacity_;
  }
  var rotation = this.imageRotation_;
  if (this.imageRotateWithView_) {
    rotation += this.viewRotation_;
  }
  var i, ii;
  for (i = 0, ii = pixelCoordinates.length; i < ii; i += 2) {
    var x = pixelCoordinates[i] - this.imageAnchorX_;
    var y = pixelCoordinates[i + 1] - this.imageAnchorY_;
    if (this.imageSnapToPixel_) {
      x = Math.round(x);
      y = Math.round(y);
    }
    if (rotation !== 0 || this.imageScale_ != 1) {
      var centerX = x + this.imageAnchorX_;
      var centerY = y + this.imageAnchorY_;
      ol.transform.compose(localTransform, centerX, centerY, this.imageScale_, this.imageScale_, rotation, -centerX, -centerY);
      context.setTransform.apply(context, localTransform);
    }
    context.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, x, y, this.imageWidth_, this.imageHeight_);
  }
  if (rotation !== 0 || this.imageScale_ != 1) {
    context.setTransform(1, 0, 0, 1, 0, 0);
  }
  if (this.imageOpacity_ != 1) {
    context.globalAlpha = alpha;
  }
};
ol.render.canvas.Immediate.prototype.drawText_ = function(flatCoordinates, offset, end, stride) {
  if (!this.textState_ || this.text_ === "") {
    return;
  }
  if (this.textFillState_) {
    this.setContextFillState_(this.textFillState_);
  }
  if (this.textStrokeState_) {
    this.setContextStrokeState_(this.textStrokeState_);
  }
  this.setContextTextState_(this.textState_);
  var pixelCoordinates = ol.geom.flat.transform.transform2D(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
  var context = this.context_;
  var rotation = this.textRotation_;
  if (this.textRotateWithView_) {
    rotation += this.viewRotation_;
  }
  for (; offset < end; offset += stride) {
    var x = pixelCoordinates[offset] + this.textOffsetX_;
    var y = pixelCoordinates[offset + 1] + this.textOffsetY_;
    if (rotation !== 0 || this.textScale_ != 1) {
      var localTransform = ol.transform.compose(this.tmpLocalTransform_, x, y, this.textScale_, this.textScale_, rotation, -x, -y);
      context.setTransform.apply(context, localTransform);
    }
    if (this.textStrokeState_) {
      context.strokeText(this.text_, x, y);
    }
    if (this.textFillState_) {
      context.fillText(this.text_, x, y);
    }
  }
  if (rotation !== 0 || this.textScale_ != 1) {
    context.setTransform(1, 0, 0, 1, 0, 0);
  }
};
ol.render.canvas.Immediate.prototype.moveToLineTo_ = function(flatCoordinates, offset, end, stride, close) {
  var context = this.context_;
  var pixelCoordinates = ol.geom.flat.transform.transform2D(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
  context.moveTo(pixelCoordinates[0], pixelCoordinates[1]);
  var length = pixelCoordinates.length;
  if (close) {
    length -= 2;
  }
  for (var i = 2; i < length; i += 2) {
    context.lineTo(pixelCoordinates[i], pixelCoordinates[i + 1]);
  }
  if (close) {
    context.closePath();
  }
  return end;
};
ol.render.canvas.Immediate.prototype.drawRings_ = function(flatCoordinates, offset, ends, stride) {
  var i, ii;
  for (i = 0, ii = ends.length; i < ii; ++i) {
    offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, true);
  }
  return offset;
};
ol.render.canvas.Immediate.prototype.drawCircle = function(geometry) {
  if (!ol.extent.intersects(this.extent_, geometry.getExtent())) {
    return;
  }
  if (this.fillState_ || this.strokeState_) {
    if (this.fillState_) {
      this.setContextFillState_(this.fillState_);
    }
    if (this.strokeState_) {
      this.setContextStrokeState_(this.strokeState_);
    }
    var pixelCoordinates = ol.geom.SimpleGeometry.transform2D(geometry, this.transform_, this.pixelCoordinates_);
    var dx = pixelCoordinates[2] - pixelCoordinates[0];
    var dy = pixelCoordinates[3] - pixelCoordinates[1];
    var radius = Math.sqrt(dx * dx + dy * dy);
    var context = this.context_;
    context.beginPath();
    context.arc(pixelCoordinates[0], pixelCoordinates[1], radius, 0, 2 * Math.PI);
    if (this.fillState_) {
      context.fill();
    }
    if (this.strokeState_) {
      context.stroke();
    }
  }
  if (this.text_ !== "") {
    this.drawText_(geometry.getCenter(), 0, 2, 2);
  }
};
ol.render.canvas.Immediate.prototype.setStyle = function(style) {
  this.setFillStrokeStyle(style.getFill(), style.getStroke());
  this.setImageStyle(style.getImage());
  this.setTextStyle(style.getText());
};
ol.render.canvas.Immediate.prototype.drawGeometry = function(geometry) {
  var type = geometry.getType();
  switch(type) {
    case ol.geom.GeometryType.POINT:
      this.drawPoint(geometry);
      break;
    case ol.geom.GeometryType.LINE_STRING:
      this.drawLineString(geometry);
      break;
    case ol.geom.GeometryType.POLYGON:
      this.drawPolygon(geometry);
      break;
    case ol.geom.GeometryType.MULTI_POINT:
      this.drawMultiPoint(geometry);
      break;
    case ol.geom.GeometryType.MULTI_LINE_STRING:
      this.drawMultiLineString(geometry);
      break;
    case ol.geom.GeometryType.MULTI_POLYGON:
      this.drawMultiPolygon(geometry);
      break;
    case ol.geom.GeometryType.GEOMETRY_COLLECTION:
      this.drawGeometryCollection(geometry);
      break;
    case ol.geom.GeometryType.CIRCLE:
      this.drawCircle(geometry);
      break;
    default:
  }
};
ol.render.canvas.Immediate.prototype.drawFeature = function(feature, style) {
  var geometry = style.getGeometryFunction()(feature);
  if (!geometry || !ol.extent.intersects(this.extent_, geometry.getExtent())) {
    return;
  }
  this.setStyle(style);
  this.drawGeometry(geometry);
};
ol.render.canvas.Immediate.prototype.drawGeometryCollection = function(geometry) {
  var geometries = geometry.getGeometriesArray();
  var i, ii;
  for (i = 0, ii = geometries.length; i < ii; ++i) {
    this.drawGeometry(geometries[i]);
  }
};
ol.render.canvas.Immediate.prototype.drawPoint = function(geometry) {
  var flatCoordinates = geometry.getFlatCoordinates();
  var stride = geometry.getStride();
  if (this.image_) {
    this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
  }
  if (this.text_ !== "") {
    this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
  }
};
ol.render.canvas.Immediate.prototype.drawMultiPoint = function(geometry) {
  var flatCoordinates = geometry.getFlatCoordinates();
  var stride = geometry.getStride();
  if (this.image_) {
    this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
  }
  if (this.text_ !== "") {
    this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
  }
};
ol.render.canvas.Immediate.prototype.drawLineString = function(geometry) {
  if (!ol.extent.intersects(this.extent_, geometry.getExtent())) {
    return;
  }
  if (this.strokeState_) {
    this.setContextStrokeState_(this.strokeState_);
    var context = this.context_;
    var flatCoordinates = geometry.getFlatCoordinates();
    context.beginPath();
    this.moveToLineTo_(flatCoordinates, 0, flatCoordinates.length, geometry.getStride(), false);
    context.stroke();
  }
  if (this.text_ !== "") {
    var flatMidpoint = geometry.getFlatMidpoint();
    this.drawText_(flatMidpoint, 0, 2, 2);
  }
};
ol.render.canvas.Immediate.prototype.drawMultiLineString = function(geometry) {
  var geometryExtent = geometry.getExtent();
  if (!ol.extent.intersects(this.extent_, geometryExtent)) {
    return;
  }
  if (this.strokeState_) {
    this.setContextStrokeState_(this.strokeState_);
    var context = this.context_;
    var flatCoordinates = geometry.getFlatCoordinates();
    var offset = 0;
    var ends = geometry.getEnds();
    var stride = geometry.getStride();
    context.beginPath();
    var i, ii;
    for (i = 0, ii = ends.length; i < ii; ++i) {
      offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, false);
    }
    context.stroke();
  }
  if (this.text_ !== "") {
    var flatMidpoints = geometry.getFlatMidpoints();
    this.drawText_(flatMidpoints, 0, flatMidpoints.length, 2);
  }
};
ol.render.canvas.Immediate.prototype.drawPolygon = function(geometry) {
  if (!ol.extent.intersects(this.extent_, geometry.getExtent())) {
    return;
  }
  if (this.strokeState_ || this.fillState_) {
    if (this.fillState_) {
      this.setContextFillState_(this.fillState_);
    }
    if (this.strokeState_) {
      this.setContextStrokeState_(this.strokeState_);
    }
    var context = this.context_;
    context.beginPath();
    this.drawRings_(geometry.getOrientedFlatCoordinates(), 0, geometry.getEnds(), geometry.getStride());
    if (this.fillState_) {
      context.fill();
    }
    if (this.strokeState_) {
      context.stroke();
    }
  }
  if (this.text_ !== "") {
    var flatInteriorPoint = geometry.getFlatInteriorPoint();
    this.drawText_(flatInteriorPoint, 0, 2, 2);
  }
};
ol.render.canvas.Immediate.prototype.drawMultiPolygon = function(geometry) {
  if (!ol.extent.intersects(this.extent_, geometry.getExtent())) {
    return;
  }
  if (this.strokeState_ || this.fillState_) {
    if (this.fillState_) {
      this.setContextFillState_(this.fillState_);
    }
    if (this.strokeState_) {
      this.setContextStrokeState_(this.strokeState_);
    }
    var context = this.context_;
    var flatCoordinates = geometry.getOrientedFlatCoordinates();
    var offset = 0;
    var endss = geometry.getEndss();
    var stride = geometry.getStride();
    var i, ii;
    context.beginPath();
    for (i = 0, ii = endss.length; i < ii; ++i) {
      var ends = endss[i];
      offset = this.drawRings_(flatCoordinates, offset, ends, stride);
    }
    if (this.fillState_) {
      context.fill();
    }
    if (this.strokeState_) {
      context.stroke();
    }
  }
  if (this.text_ !== "") {
    var flatInteriorPoints = geometry.getFlatInteriorPoints();
    this.drawText_(flatInteriorPoints, 0, flatInteriorPoints.length, 2);
  }
};
ol.render.canvas.Immediate.prototype.setContextFillState_ = function(fillState) {
  var context = this.context_;
  var contextFillState = this.contextFillState_;
  if (!contextFillState) {
    context.fillStyle = fillState.fillStyle;
    this.contextFillState_ = {fillStyle:fillState.fillStyle};
  } else {
    if (contextFillState.fillStyle != fillState.fillStyle) {
      contextFillState.fillStyle = context.fillStyle = fillState.fillStyle;
    }
  }
};
ol.render.canvas.Immediate.prototype.setContextStrokeState_ = function(strokeState) {
  var context = this.context_;
  var contextStrokeState = this.contextStrokeState_;
  if (!contextStrokeState) {
    context.lineCap = strokeState.lineCap;
    if (ol.has.CANVAS_LINE_DASH) {
      context.setLineDash(strokeState.lineDash);
      context.lineDashOffset = strokeState.lineDashOffset;
    }
    context.lineJoin = strokeState.lineJoin;
    context.lineWidth = strokeState.lineWidth;
    context.miterLimit = strokeState.miterLimit;
    context.strokeStyle = strokeState.strokeStyle;
    this.contextStrokeState_ = {lineCap:strokeState.lineCap, lineDash:strokeState.lineDash, lineDashOffset:strokeState.lineDashOffset, lineJoin:strokeState.lineJoin, lineWidth:strokeState.lineWidth, miterLimit:strokeState.miterLimit, strokeStyle:strokeState.strokeStyle};
  } else {
    if (contextStrokeState.lineCap != strokeState.lineCap) {
      contextStrokeState.lineCap = context.lineCap = strokeState.lineCap;
    }
    if (ol.has.CANVAS_LINE_DASH) {
      if (!ol.array.equals(contextStrokeState.lineDash, strokeState.lineDash)) {
        context.setLineDash(contextStrokeState.lineDash = strokeState.lineDash);
      }
      if (contextStrokeState.lineDashOffset != strokeState.lineDashOffset) {
        contextStrokeState.lineDashOffset = context.lineDashOffset = strokeState.lineDashOffset;
      }
    }
    if (contextStrokeState.lineJoin != strokeState.lineJoin) {
      contextStrokeState.lineJoin = context.lineJoin = strokeState.lineJoin;
    }
    if (contextStrokeState.lineWidth != strokeState.lineWidth) {
      contextStrokeState.lineWidth = context.lineWidth = strokeState.lineWidth;
    }
    if (contextStrokeState.miterLimit != strokeState.miterLimit) {
      contextStrokeState.miterLimit = context.miterLimit = strokeState.miterLimit;
    }
    if (contextStrokeState.strokeStyle != strokeState.strokeStyle) {
      contextStrokeState.strokeStyle = context.strokeStyle = strokeState.strokeStyle;
    }
  }
};
ol.render.canvas.Immediate.prototype.setContextTextState_ = function(textState) {
  var context = this.context_;
  var contextTextState = this.contextTextState_;
  var textAlign = textState.textAlign ? textState.textAlign : ol.render.canvas.defaultTextAlign;
  if (!contextTextState) {
    context.font = textState.font;
    context.textAlign = textAlign;
    context.textBaseline = textState.textBaseline;
    this.contextTextState_ = {font:textState.font, textAlign:textAlign, textBaseline:textState.textBaseline};
  } else {
    if (contextTextState.font != textState.font) {
      contextTextState.font = context.font = textState.font;
    }
    if (contextTextState.textAlign != textAlign) {
      contextTextState.textAlign = textAlign;
    }
    if (contextTextState.textBaseline != textState.textBaseline) {
      contextTextState.textBaseline = context.textBaseline = textState.textBaseline;
    }
  }
};
ol.render.canvas.Immediate.prototype.setFillStrokeStyle = function(fillStyle, strokeStyle) {
  if (!fillStyle) {
    this.fillState_ = null;
  } else {
    var fillStyleColor = fillStyle.getColor();
    this.fillState_ = {fillStyle:ol.colorlike.asColorLike(fillStyleColor ? fillStyleColor : ol.render.canvas.defaultFillStyle)};
  }
  if (!strokeStyle) {
    this.strokeState_ = null;
  } else {
    var strokeStyleColor = strokeStyle.getColor();
    var strokeStyleLineCap = strokeStyle.getLineCap();
    var strokeStyleLineDash = strokeStyle.getLineDash();
    var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
    var strokeStyleLineJoin = strokeStyle.getLineJoin();
    var strokeStyleWidth = strokeStyle.getWidth();
    var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
    this.strokeState_ = {lineCap:strokeStyleLineCap !== undefined ? strokeStyleLineCap : ol.render.canvas.defaultLineCap, lineDash:strokeStyleLineDash ? strokeStyleLineDash : ol.render.canvas.defaultLineDash, lineDashOffset:strokeStyleLineDashOffset ? strokeStyleLineDashOffset : ol.render.canvas.defaultLineDashOffset, lineJoin:strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : ol.render.canvas.defaultLineJoin, lineWidth:this.pixelRatio_ * (strokeStyleWidth !== undefined ? strokeStyleWidth : 
    ol.render.canvas.defaultLineWidth), miterLimit:strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : ol.render.canvas.defaultMiterLimit, strokeStyle:ol.colorlike.asColorLike(strokeStyleColor ? strokeStyleColor : ol.render.canvas.defaultStrokeStyle)};
  }
};
ol.render.canvas.Immediate.prototype.setImageStyle = function(imageStyle) {
  if (!imageStyle) {
    this.image_ = null;
  } else {
    var imageAnchor = imageStyle.getAnchor();
    var imageImage = imageStyle.getImage(1);
    var imageOrigin = imageStyle.getOrigin();
    var imageSize = imageStyle.getSize();
    this.imageAnchorX_ = imageAnchor[0];
    this.imageAnchorY_ = imageAnchor[1];
    this.imageHeight_ = imageSize[1];
    this.image_ = imageImage;
    this.imageOpacity_ = imageStyle.getOpacity();
    this.imageOriginX_ = imageOrigin[0];
    this.imageOriginY_ = imageOrigin[1];
    this.imageRotateWithView_ = imageStyle.getRotateWithView();
    this.imageRotation_ = imageStyle.getRotation();
    this.imageScale_ = imageStyle.getScale() * this.pixelRatio_;
    this.imageSnapToPixel_ = imageStyle.getSnapToPixel();
    this.imageWidth_ = imageSize[0];
  }
};
ol.render.canvas.Immediate.prototype.setTextStyle = function(textStyle) {
  if (!textStyle) {
    this.text_ = "";
  } else {
    var textFillStyle = textStyle.getFill();
    if (!textFillStyle) {
      this.textFillState_ = null;
    } else {
      var textFillStyleColor = textFillStyle.getColor();
      this.textFillState_ = {fillStyle:ol.colorlike.asColorLike(textFillStyleColor ? textFillStyleColor : ol.render.canvas.defaultFillStyle)};
    }
    var textStrokeStyle = textStyle.getStroke();
    if (!textStrokeStyle) {
      this.textStrokeState_ = null;
    } else {
      var textStrokeStyleColor = textStrokeStyle.getColor();
      var textStrokeStyleLineCap = textStrokeStyle.getLineCap();
      var textStrokeStyleLineDash = textStrokeStyle.getLineDash();
      var textStrokeStyleLineDashOffset = textStrokeStyle.getLineDashOffset();
      var textStrokeStyleLineJoin = textStrokeStyle.getLineJoin();
      var textStrokeStyleWidth = textStrokeStyle.getWidth();
      var textStrokeStyleMiterLimit = textStrokeStyle.getMiterLimit();
      this.textStrokeState_ = {lineCap:textStrokeStyleLineCap !== undefined ? textStrokeStyleLineCap : ol.render.canvas.defaultLineCap, lineDash:textStrokeStyleLineDash ? textStrokeStyleLineDash : ol.render.canvas.defaultLineDash, lineDashOffset:textStrokeStyleLineDashOffset ? textStrokeStyleLineDashOffset : ol.render.canvas.defaultLineDashOffset, lineJoin:textStrokeStyleLineJoin !== undefined ? textStrokeStyleLineJoin : ol.render.canvas.defaultLineJoin, lineWidth:textStrokeStyleWidth !== undefined ? 
      textStrokeStyleWidth : ol.render.canvas.defaultLineWidth, miterLimit:textStrokeStyleMiterLimit !== undefined ? textStrokeStyleMiterLimit : ol.render.canvas.defaultMiterLimit, strokeStyle:ol.colorlike.asColorLike(textStrokeStyleColor ? textStrokeStyleColor : ol.render.canvas.defaultStrokeStyle)};
    }
    var textFont = textStyle.getFont();
    var textOffsetX = textStyle.getOffsetX();
    var textOffsetY = textStyle.getOffsetY();
    var textRotateWithView = textStyle.getRotateWithView();
    var textRotation = textStyle.getRotation();
    var textScale = textStyle.getScale();
    var textText = textStyle.getText();
    var textTextAlign = textStyle.getTextAlign();
    var textTextBaseline = textStyle.getTextBaseline();
    this.textState_ = {font:textFont !== undefined ? textFont : ol.render.canvas.defaultFont, textAlign:textTextAlign !== undefined ? textTextAlign : ol.render.canvas.defaultTextAlign, textBaseline:textTextBaseline !== undefined ? textTextBaseline : ol.render.canvas.defaultTextBaseline};
    this.text_ = textText !== undefined ? textText : "";
    this.textOffsetX_ = textOffsetX !== undefined ? this.pixelRatio_ * textOffsetX : 0;
    this.textOffsetY_ = textOffsetY !== undefined ? this.pixelRatio_ * textOffsetY : 0;
    this.textRotateWithView_ = textRotateWithView !== undefined ? textRotateWithView : false;
    this.textRotation_ = textRotation !== undefined ? textRotation : 0;
    this.textScale_ = this.pixelRatio_ * (textScale !== undefined ? textScale : 1);
  }
};
goog.provide("ol.renderer.Layer");
goog.require("ol");
goog.require("ol.ImageState");
goog.require("ol.Observable");
goog.require("ol.TileState");
goog.require("ol.asserts");
goog.require("ol.events");
goog.require("ol.events.EventType");
goog.require("ol.functions");
goog.require("ol.source.State");
ol.renderer.Layer = function(layer) {
  ol.Observable.call(this);
  this.layer_ = layer;
};
ol.inherits(ol.renderer.Layer, ol.Observable);
ol.renderer.Layer.prototype.forEachFeatureAtCoordinate = ol.nullFunction;
ol.renderer.Layer.prototype.hasFeatureAtCoordinate = ol.functions.FALSE;
ol.renderer.Layer.prototype.createLoadedTileFinder = function(source, projection, tiles) {
  return function(zoom, tileRange) {
    function callback(tile) {
      if (!tiles[zoom]) {
        tiles[zoom] = {};
      }
      tiles[zoom][tile.tileCoord.toString()] = tile;
    }
    return source.forEachLoadedTile(projection, zoom, tileRange, callback);
  };
};
ol.renderer.Layer.prototype.getLayer = function() {
  return this.layer_;
};
ol.renderer.Layer.prototype.handleImageChange_ = function(event) {
  var image = event.target;
  if (image.getState() === ol.ImageState.LOADED) {
    this.renderIfReadyAndVisible();
  }
};
ol.renderer.Layer.prototype.loadImage = function(image) {
  var imageState = image.getState();
  if (imageState != ol.ImageState.LOADED && imageState != ol.ImageState.ERROR) {
    ol.events.listen(image, ol.events.EventType.CHANGE, this.handleImageChange_, this);
  }
  if (imageState == ol.ImageState.IDLE) {
    image.load();
    imageState = image.getState();
  }
  return imageState == ol.ImageState.LOADED;
};
ol.renderer.Layer.prototype.renderIfReadyAndVisible = function() {
  var layer = this.getLayer();
  if (layer.getVisible() && layer.getSourceState() == ol.source.State.READY) {
    this.changed();
  }
};
ol.renderer.Layer.prototype.scheduleExpireCache = function(frameState, tileSource) {
  if (tileSource.canExpireCache()) {
    var postRenderFunction = function(tileSource, map, frameState) {
      var tileSourceKey = ol.getUid(tileSource).toString();
      if (tileSourceKey in frameState.usedTiles) {
        tileSource.expireCache(frameState.viewState.projection, frameState.usedTiles[tileSourceKey]);
      }
    }.bind(null, tileSource);
    frameState.postRenderFunctions.push(postRenderFunction);
  }
};
ol.renderer.Layer.prototype.updateLogos = function(frameState, source) {
  var logo = source.getLogo();
  if (logo !== undefined) {
    if (typeof logo === "string") {
      frameState.logos[logo] = "";
    } else {
      if (logo) {
        ol.asserts.assert(typeof logo.href == "string", 44);
        ol.asserts.assert(typeof logo.src == "string", 45);
        frameState.logos[logo.src] = logo.href;
      }
    }
  }
};
ol.renderer.Layer.prototype.updateUsedTiles = function(usedTiles, tileSource, z, tileRange) {
  var tileSourceKey = ol.getUid(tileSource).toString();
  var zKey = z.toString();
  if (tileSourceKey in usedTiles) {
    if (zKey in usedTiles[tileSourceKey]) {
      usedTiles[tileSourceKey][zKey].extend(tileRange);
    } else {
      usedTiles[tileSourceKey][zKey] = tileRange;
    }
  } else {
    usedTiles[tileSourceKey] = {};
    usedTiles[tileSourceKey][zKey] = tileRange;
  }
};
ol.renderer.Layer.prototype.manageTilePyramid = function(frameState, tileSource, tileGrid, pixelRatio, projection, extent, currentZ, preload, opt_tileCallback, opt_this) {
  var tileSourceKey = ol.getUid(tileSource).toString();
  if (!(tileSourceKey in frameState.wantedTiles)) {
    frameState.wantedTiles[tileSourceKey] = {};
  }
  var wantedTiles = frameState.wantedTiles[tileSourceKey];
  var tileQueue = frameState.tileQueue;
  var minZoom = tileGrid.getMinZoom();
  var tile, tileRange, tileResolution, x, y, z;
  for (z = minZoom; z <= currentZ; ++z) {
    tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);
    tileResolution = tileGrid.getResolution(z);
    for (x = tileRange.minX; x <= tileRange.maxX; ++x) {
      for (y = tileRange.minY; y <= tileRange.maxY; ++y) {
        if (currentZ - z <= preload) {
          tile = tileSource.getTile(z, x, y, pixelRatio, projection);
          if (tile.getState() == ol.TileState.IDLE) {
            wantedTiles[tile.getKey()] = true;
            if (!tileQueue.isKeyQueued(tile.getKey())) {
              tileQueue.enqueue([tile, tileSourceKey, tileGrid.getTileCoordCenter(tile.tileCoord), tileResolution]);
            }
          }
          if (opt_tileCallback !== undefined) {
            opt_tileCallback.call(opt_this, tile);
          }
        } else {
          tileSource.useTile(z, x, y, projection);
        }
      }
    }
  }
};
goog.provide("ol.renderer.canvas.Layer");
goog.require("ol");
goog.require("ol.extent");
goog.require("ol.functions");
goog.require("ol.render.Event");
goog.require("ol.render.EventType");
goog.require("ol.render.canvas");
goog.require("ol.render.canvas.Immediate");
goog.require("ol.renderer.Layer");
goog.require("ol.transform");
ol.renderer.canvas.Layer = function(layer) {
  ol.renderer.Layer.call(this, layer);
  this.renderedResolution;
  this.transform_ = ol.transform.create();
};
ol.inherits(ol.renderer.canvas.Layer, ol.renderer.Layer);
ol.renderer.canvas.Layer.prototype.clip = function(context, frameState, extent) {
  var pixelRatio = frameState.pixelRatio;
  var width = frameState.size[0] * pixelRatio;
  var height = frameState.size[1] * pixelRatio;
  var rotation = frameState.viewState.rotation;
  var topLeft = ol.extent.getTopLeft(extent);
  var topRight = ol.extent.getTopRight(extent);
  var bottomRight = ol.extent.getBottomRight(extent);
  var bottomLeft = ol.extent.getBottomLeft(extent);
  ol.transform.apply(frameState.coordinateToPixelTransform, topLeft);
  ol.transform.apply(frameState.coordinateToPixelTransform, topRight);
  ol.transform.apply(frameState.coordinateToPixelTransform, bottomRight);
  ol.transform.apply(frameState.coordinateToPixelTransform, bottomLeft);
  context.save();
  ol.render.canvas.rotateAtOffset(context, -rotation, width / 2, height / 2);
  context.beginPath();
  context.moveTo(topLeft[0] * pixelRatio, topLeft[1] * pixelRatio);
  context.lineTo(topRight[0] * pixelRatio, topRight[1] * pixelRatio);
  context.lineTo(bottomRight[0] * pixelRatio, bottomRight[1] * pixelRatio);
  context.lineTo(bottomLeft[0] * pixelRatio, bottomLeft[1] * pixelRatio);
  context.clip();
  ol.render.canvas.rotateAtOffset(context, rotation, width / 2, height / 2);
};
ol.renderer.canvas.Layer.prototype.dispatchComposeEvent_ = function(type, context, frameState, opt_transform) {
  var layer = this.getLayer();
  if (layer.hasListener(type)) {
    var width = frameState.size[0] * frameState.pixelRatio;
    var height = frameState.size[1] * frameState.pixelRatio;
    var rotation = frameState.viewState.rotation;
    ol.render.canvas.rotateAtOffset(context, -rotation, width / 2, height / 2);
    var transform = opt_transform !== undefined ? opt_transform : this.getTransform(frameState, 0);
    var render = new ol.render.canvas.Immediate(context, frameState.pixelRatio, frameState.extent, transform, frameState.viewState.rotation);
    var composeEvent = new ol.render.Event(type, render, frameState, context, null);
    layer.dispatchEvent(composeEvent);
    ol.render.canvas.rotateAtOffset(context, rotation, width / 2, height / 2);
  }
};
ol.renderer.canvas.Layer.prototype.forEachLayerAtCoordinate = function(coordinate, frameState, callback, thisArg) {
  var hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, 0, ol.functions.TRUE, this);
  if (hasFeature) {
    return callback.call(thisArg, this.getLayer(), null);
  } else {
    return undefined;
  }
};
ol.renderer.canvas.Layer.prototype.postCompose = function(context, frameState, layerState, opt_transform) {
  this.dispatchComposeEvent_(ol.render.EventType.POSTCOMPOSE, context, frameState, opt_transform);
};
ol.renderer.canvas.Layer.prototype.preCompose = function(context, frameState, opt_transform) {
  this.dispatchComposeEvent_(ol.render.EventType.PRECOMPOSE, context, frameState, opt_transform);
};
ol.renderer.canvas.Layer.prototype.dispatchRenderEvent = function(context, frameState, opt_transform) {
  this.dispatchComposeEvent_(ol.render.EventType.RENDER, context, frameState, opt_transform);
};
ol.renderer.canvas.Layer.prototype.getTransform = function(frameState, offsetX) {
  var viewState = frameState.viewState;
  var pixelRatio = frameState.pixelRatio;
  var dx1 = pixelRatio * frameState.size[0] / 2;
  var dy1 = pixelRatio * frameState.size[1] / 2;
  var sx = pixelRatio / viewState.resolution;
  var sy = -sx;
  var angle = -viewState.rotation;
  var dx2 = -viewState.center[0] + offsetX;
  var dy2 = -viewState.center[1];
  return ol.transform.compose(this.transform_, dx1, dy1, sx, sy, angle, dx2, dy2);
};
ol.renderer.canvas.Layer.prototype.composeFrame = function(frameState, layerState, context) {
};
ol.renderer.canvas.Layer.prototype.prepareFrame = function(frameState, layerState) {
};
goog.provide("ol.renderer.canvas.IntermediateCanvas");
goog.require("ol");
goog.require("ol.coordinate");
goog.require("ol.dom");
goog.require("ol.extent");
goog.require("ol.renderer.canvas.Layer");
goog.require("ol.transform");
ol.renderer.canvas.IntermediateCanvas = function(layer) {
  ol.renderer.canvas.Layer.call(this, layer);
  this.coordinateToCanvasPixelTransform = ol.transform.create();
  this.hitCanvasContext_ = null;
};
ol.inherits(ol.renderer.canvas.IntermediateCanvas, ol.renderer.canvas.Layer);
ol.renderer.canvas.IntermediateCanvas.prototype.composeFrame = function(frameState, layerState, context) {
  this.preCompose(context, frameState);
  var image = this.getImage();
  if (image) {
    var extent = layerState.extent;
    var clipped = extent !== undefined && !ol.extent.containsExtent(extent, frameState.extent) && ol.extent.intersects(extent, frameState.extent);
    if (clipped) {
      this.clip(context, frameState, extent);
    }
    var imageTransform = this.getImageTransform();
    var alpha = context.globalAlpha;
    context.globalAlpha = layerState.opacity;
    var dx = imageTransform[4];
    var dy = imageTransform[5];
    var dw = image.width * imageTransform[0];
    var dh = image.height * imageTransform[3];
    context.drawImage(image, 0, 0, +image.width, +image.height, Math.round(dx), Math.round(dy), Math.round(dw), Math.round(dh));
    context.globalAlpha = alpha;
    if (clipped) {
      context.restore();
    }
  }
  this.postCompose(context, frameState, layerState);
};
ol.renderer.canvas.IntermediateCanvas.prototype.getImage = function() {
};
ol.renderer.canvas.IntermediateCanvas.prototype.getImageTransform = function() {
};
ol.renderer.canvas.IntermediateCanvas.prototype.forEachFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, callback, thisArg) {
  var layer = this.getLayer();
  var source = layer.getSource();
  var resolution = frameState.viewState.resolution;
  var rotation = frameState.viewState.rotation;
  var skippedFeatureUids = frameState.skippedFeatureUids;
  return source.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, skippedFeatureUids, function(feature) {
    return callback.call(thisArg, feature, layer);
  });
};
ol.renderer.canvas.IntermediateCanvas.prototype.forEachLayerAtCoordinate = function(coordinate, frameState, callback, thisArg) {
  if (!this.getImage()) {
    return undefined;
  }
  if (this.getLayer().getSource().forEachFeatureAtCoordinate !== ol.nullFunction) {
    return ol.renderer.canvas.Layer.prototype.forEachLayerAtCoordinate.apply(this, arguments);
  } else {
    var pixel = ol.transform.apply(this.coordinateToCanvasPixelTransform, coordinate.slice());
    ol.coordinate.scale(pixel, frameState.viewState.resolution / this.renderedResolution);
    if (!this.hitCanvasContext_) {
      this.hitCanvasContext_ = ol.dom.createCanvasContext2D(1, 1);
    }
    this.hitCanvasContext_.clearRect(0, 0, 1, 1);
    this.hitCanvasContext_.drawImage(this.getImage(), pixel[0], pixel[1], 1, 1, 0, 0, 1, 1);
    var imageData = this.hitCanvasContext_.getImageData(0, 0, 1, 1).data;
    if (imageData[3] > 0) {
      return callback.call(thisArg, this.getLayer(), imageData);
    } else {
      return undefined;
    }
  }
};
goog.provide("ol.renderer.canvas.ImageLayer");
goog.require("ol");
goog.require("ol.ImageCanvas");
goog.require("ol.LayerType");
goog.require("ol.ViewHint");
goog.require("ol.array");
goog.require("ol.extent");
goog.require("ol.layer.VectorRenderType");
goog.require("ol.obj");
goog.require("ol.plugins");
goog.require("ol.renderer.Type");
goog.require("ol.renderer.canvas.IntermediateCanvas");
goog.require("ol.transform");
ol.renderer.canvas.ImageLayer = function(imageLayer) {
  ol.renderer.canvas.IntermediateCanvas.call(this, imageLayer);
  this.image_ = null;
  this.imageTransform_ = ol.transform.create();
  this.skippedFeatures_ = [];
  this.vectorRenderer_ = null;
};
ol.inherits(ol.renderer.canvas.ImageLayer, ol.renderer.canvas.IntermediateCanvas);
ol.renderer.canvas.ImageLayer["handles"] = function(type, layer) {
  return type === ol.renderer.Type.CANVAS && (layer.getType() === ol.LayerType.IMAGE || layer.getType() === ol.LayerType.VECTOR && layer.getRenderMode() === ol.layer.VectorRenderType.IMAGE);
};
ol.renderer.canvas.ImageLayer["create"] = function(mapRenderer, layer) {
  var renderer = new ol.renderer.canvas.ImageLayer(layer);
  if (layer.getType() === ol.LayerType.VECTOR) {
    var candidates = ol.plugins.getLayerRendererPlugins();
    for (var i = 0, ii = candidates.length; i < ii; ++i) {
      var candidate = candidates[i];
      if (candidate !== ol.renderer.canvas.ImageLayer && candidate["handles"](ol.renderer.Type.CANVAS, layer)) {
        renderer.setVectorRenderer(candidate["create"](mapRenderer, layer));
      }
    }
  }
  return renderer;
};
ol.renderer.canvas.ImageLayer.prototype.getImage = function() {
  return !this.image_ ? null : this.image_.getImage();
};
ol.renderer.canvas.ImageLayer.prototype.getImageTransform = function() {
  return this.imageTransform_;
};
ol.renderer.canvas.ImageLayer.prototype.prepareFrame = function(frameState, layerState) {
  var pixelRatio = frameState.pixelRatio;
  var size = frameState.size;
  var viewState = frameState.viewState;
  var viewCenter = viewState.center;
  var viewResolution = viewState.resolution;
  var image;
  var imageLayer = this.getLayer();
  var imageSource = imageLayer.getSource();
  var hints = frameState.viewHints;
  var renderedExtent = frameState.extent;
  if (layerState.extent !== undefined) {
    renderedExtent = ol.extent.getIntersection(renderedExtent, layerState.extent);
  }
  if (!hints[ol.ViewHint.ANIMATING] && !hints[ol.ViewHint.INTERACTING] && !ol.extent.isEmpty(renderedExtent)) {
    var projection = viewState.projection;
    if (!ol.ENABLE_RASTER_REPROJECTION) {
      var sourceProjection = imageSource.getProjection();
      if (sourceProjection) {
        projection = sourceProjection;
      }
    }
    var vectorRenderer = this.vectorRenderer_;
    if (vectorRenderer) {
      var context = vectorRenderer.context;
      var imageFrameState = ol.obj.assign({}, frameState, {size:[ol.extent.getWidth(renderedExtent) / viewResolution, ol.extent.getHeight(renderedExtent) / viewResolution], viewState:ol.obj.assign({}, frameState.viewState, {rotation:0})});
      var skippedFeatures = Object.keys(imageFrameState.skippedFeatureUids).sort();
      if (vectorRenderer.prepareFrame(imageFrameState, layerState) && (vectorRenderer.replayGroupChanged || !ol.array.equals(skippedFeatures, this.skippedFeatures_))) {
        context.canvas.width = imageFrameState.size[0] * pixelRatio;
        context.canvas.height = imageFrameState.size[1] * pixelRatio;
        vectorRenderer.composeFrame(imageFrameState, layerState, context);
        this.image_ = new ol.ImageCanvas(renderedExtent, viewResolution, pixelRatio, context.canvas);
        this.skippedFeatures_ = skippedFeatures;
      }
    } else {
      image = imageSource.getImage(renderedExtent, viewResolution, pixelRatio, projection);
      if (image) {
        var loaded = this.loadImage(image);
        if (loaded) {
          this.image_ = image;
        }
      }
    }
  }
  if (this.image_) {
    image = this.image_;
    var imageExtent = image.getExtent();
    var imageResolution = image.getResolution();
    var imagePixelRatio = image.getPixelRatio();
    var scale = pixelRatio * imageResolution / (viewResolution * imagePixelRatio);
    var transform = ol.transform.compose(this.imageTransform_, pixelRatio * size[0] / 2, pixelRatio * size[1] / 2, scale, scale, 0, imagePixelRatio * (imageExtent[0] - viewCenter[0]) / imageResolution, imagePixelRatio * (viewCenter[1] - imageExtent[3]) / imageResolution);
    ol.transform.compose(this.coordinateToCanvasPixelTransform, pixelRatio * size[0] / 2 - transform[4], pixelRatio * size[1] / 2 - transform[5], pixelRatio / viewResolution, -pixelRatio / viewResolution, 0, -viewCenter[0], -viewCenter[1]);
    this.updateLogos(frameState, imageSource);
    this.renderedResolution = imageResolution * pixelRatio / imagePixelRatio;
  }
  return !!this.image_;
};
ol.renderer.canvas.ImageLayer.prototype.forEachFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, callback, thisArg) {
  if (this.vectorRenderer_) {
    return this.vectorRenderer_.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, thisArg);
  } else {
    return ol.renderer.canvas.IntermediateCanvas.prototype.forEachFeatureAtCoordinate.call(this, coordinate, frameState, hitTolerance, callback, thisArg);
  }
};
ol.renderer.canvas.ImageLayer.prototype.setVectorRenderer = function(renderer) {
  this.vectorRenderer_ = renderer;
};
goog.provide("ol.renderer.Map");
goog.require("ol");
goog.require("ol.Disposable");
goog.require("ol.events");
goog.require("ol.events.EventType");
goog.require("ol.extent");
goog.require("ol.functions");
goog.require("ol.layer.Layer");
goog.require("ol.plugins");
goog.require("ol.style");
goog.require("ol.transform");
ol.renderer.Map = function(container, map) {
  ol.Disposable.call(this);
  this.map_ = map;
  this.layerRenderers_ = {};
  this.layerRendererListeners_ = {};
};
ol.inherits(ol.renderer.Map, ol.Disposable);
ol.renderer.Map.prototype.calculateMatrices2D = function(frameState) {
  var viewState = frameState.viewState;
  var coordinateToPixelTransform = frameState.coordinateToPixelTransform;
  var pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;
  ol.transform.compose(coordinateToPixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / viewState.resolution, -1 / viewState.resolution, -viewState.rotation, -viewState.center[0], -viewState.center[1]);
  ol.transform.invert(ol.transform.setFromArray(pixelToCoordinateTransform, coordinateToPixelTransform));
};
ol.renderer.Map.prototype.removeLayerRenderers = function() {
  for (var key in this.layerRenderers_) {
    this.removeLayerRendererByKey_(key).dispose();
  }
};
ol.renderer.Map.expireIconCache_ = function(map, frameState) {
  var cache = ol.style.iconImageCache;
  cache.expire();
};
ol.renderer.Map.prototype.forEachFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, callback, thisArg, layerFilter, thisArg2) {
  var result;
  var viewState = frameState.viewState;
  var viewResolution = viewState.resolution;
  function forEachFeatureAtCoordinate(feature, layer) {
    var key = ol.getUid(feature).toString();
    var managed = frameState.layerStates[ol.getUid(layer)].managed;
    if (!(key in frameState.skippedFeatureUids && !managed)) {
      return callback.call(thisArg, feature, managed ? layer : null);
    }
  }
  var projection = viewState.projection;
  var translatedCoordinate = coordinate;
  if (projection.canWrapX()) {
    var projectionExtent = projection.getExtent();
    var worldWidth = ol.extent.getWidth(projectionExtent);
    var x = coordinate[0];
    if (x < projectionExtent[0] || x > projectionExtent[2]) {
      var worldsAway = Math.ceil((projectionExtent[0] - x) / worldWidth);
      translatedCoordinate = [x + worldWidth * worldsAway, coordinate[1]];
    }
  }
  var layerStates = frameState.layerStatesArray;
  var numLayers = layerStates.length;
  var i;
  for (i = numLayers - 1; i >= 0; --i) {
    var layerState = layerStates[i];
    var layer = layerState.layer;
    if (ol.layer.Layer.visibleAtResolution(layerState, viewResolution) && layerFilter.call(thisArg2, layer)) {
      var layerRenderer = this.getLayerRenderer(layer);
      if (layer.getSource()) {
        result = layerRenderer.forEachFeatureAtCoordinate(layer.getSource().getWrapX() ? translatedCoordinate : coordinate, frameState, hitTolerance, forEachFeatureAtCoordinate, thisArg);
      }
      if (result) {
        return result;
      }
    }
  }
  return undefined;
};
ol.renderer.Map.prototype.forEachLayerAtPixel = function(pixel, frameState, callback, thisArg, layerFilter, thisArg2) {
};
ol.renderer.Map.prototype.hasFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, layerFilter, thisArg) {
  var hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, ol.functions.TRUE, this, layerFilter, thisArg);
  return hasFeature !== undefined;
};
ol.renderer.Map.prototype.getLayerRenderer = function(layer) {
  var layerKey = ol.getUid(layer).toString();
  if (layerKey in this.layerRenderers_) {
    return this.layerRenderers_[layerKey];
  } else {
    var layerRendererPlugins = ol.plugins.getLayerRendererPlugins();
    var renderer;
    var type = this.getType();
    for (var i = 0, ii = layerRendererPlugins.length; i < ii; ++i) {
      var plugin = layerRendererPlugins[i];
      if (plugin["handles"](type, layer)) {
        renderer = plugin["create"](this, layer);
        break;
      }
    }
    if (renderer) {
      this.layerRenderers_[layerKey] = renderer;
      this.layerRendererListeners_[layerKey] = ol.events.listen(renderer, ol.events.EventType.CHANGE, this.handleLayerRendererChange_, this);
    } else {
      throw new Error("Unable to create renderer for layer: " + layer.getType());
    }
    return renderer;
  }
};
ol.renderer.Map.prototype.getLayerRendererByKey = function(layerKey) {
  return this.layerRenderers_[layerKey];
};
ol.renderer.Map.prototype.getLayerRenderers = function() {
  return this.layerRenderers_;
};
ol.renderer.Map.prototype.getMap = function() {
  return this.map_;
};
ol.renderer.Map.prototype.getType = function() {
};
ol.renderer.Map.prototype.handleLayerRendererChange_ = function() {
  this.map_.render();
};
ol.renderer.Map.prototype.removeLayerRendererByKey_ = function(layerKey) {
  var layerRenderer = this.layerRenderers_[layerKey];
  delete this.layerRenderers_[layerKey];
  ol.events.unlistenByKey(this.layerRendererListeners_[layerKey]);
  delete this.layerRendererListeners_[layerKey];
  return layerRenderer;
};
ol.renderer.Map.prototype.renderFrame = ol.nullFunction;
ol.renderer.Map.prototype.removeUnusedLayerRenderers_ = function(map, frameState) {
  var layerKey;
  for (layerKey in this.layerRenderers_) {
    if (!frameState || !(layerKey in frameState.layerStates)) {
      this.removeLayerRendererByKey_(layerKey).dispose();
    }
  }
};
ol.renderer.Map.prototype.scheduleExpireIconCache = function(frameState) {
  frameState.postRenderFunctions.push(ol.renderer.Map.expireIconCache_);
};
ol.renderer.Map.prototype.scheduleRemoveUnusedLayerRenderers = function(frameState) {
  var layerKey;
  for (layerKey in this.layerRenderers_) {
    if (!(layerKey in frameState.layerStates)) {
      frameState.postRenderFunctions.push(this.removeUnusedLayerRenderers_.bind(this));
      return;
    }
  }
};
ol.renderer.Map.sortByZIndex = function(state1, state2) {
  return state1.zIndex - state2.zIndex;
};
goog.provide("ol.renderer.canvas.Map");
goog.require("ol.transform");
goog.require("ol");
goog.require("ol.array");
goog.require("ol.css");
goog.require("ol.dom");
goog.require("ol.layer.Layer");
goog.require("ol.render.Event");
goog.require("ol.render.EventType");
goog.require("ol.render.canvas");
goog.require("ol.render.canvas.Immediate");
goog.require("ol.renderer.Map");
goog.require("ol.renderer.Type");
goog.require("ol.source.State");
ol.renderer.canvas.Map = function(container, map) {
  ol.renderer.Map.call(this, container, map);
  this.context_ = ol.dom.createCanvasContext2D();
  this.canvas_ = this.context_.canvas;
  this.canvas_.style.width = "100%";
  this.canvas_.style.height = "100%";
  this.canvas_.style.display = "block";
  this.canvas_.className = ol.css.CLASS_UNSELECTABLE;
  container.insertBefore(this.canvas_, container.childNodes[0] || null);
  this.renderedVisible_ = true;
  this.transform_ = ol.transform.create();
};
ol.inherits(ol.renderer.canvas.Map, ol.renderer.Map);
ol.renderer.canvas.Map["handles"] = function(type) {
  return type === ol.renderer.Type.CANVAS;
};
ol.renderer.canvas.Map["create"] = function(container, map) {
  return new ol.renderer.canvas.Map(container, map);
};
ol.renderer.canvas.Map.prototype.dispatchComposeEvent_ = function(type, frameState) {
  var map = this.getMap();
  var context = this.context_;
  if (map.hasListener(type)) {
    var extent = frameState.extent;
    var pixelRatio = frameState.pixelRatio;
    var viewState = frameState.viewState;
    var rotation = viewState.rotation;
    var transform = this.getTransform(frameState);
    var vectorContext = new ol.render.canvas.Immediate(context, pixelRatio, extent, transform, rotation);
    var composeEvent = new ol.render.Event(type, vectorContext, frameState, context, null);
    map.dispatchEvent(composeEvent);
  }
};
ol.renderer.canvas.Map.prototype.getTransform = function(frameState) {
  var viewState = frameState.viewState;
  var dx1 = this.canvas_.width / 2;
  var dy1 = this.canvas_.height / 2;
  var sx = frameState.pixelRatio / viewState.resolution;
  var sy = -sx;
  var angle = -viewState.rotation;
  var dx2 = -viewState.center[0];
  var dy2 = -viewState.center[1];
  return ol.transform.compose(this.transform_, dx1, dy1, sx, sy, angle, dx2, dy2);
};
ol.renderer.canvas.Map.prototype.getType = function() {
  return ol.renderer.Type.CANVAS;
};
ol.renderer.canvas.Map.prototype.renderFrame = function(frameState) {
  if (!frameState) {
    if (this.renderedVisible_) {
      this.canvas_.style.display = "none";
      this.renderedVisible_ = false;
    }
    return;
  }
  var context = this.context_;
  var pixelRatio = frameState.pixelRatio;
  var width = Math.round(frameState.size[0] * pixelRatio);
  var height = Math.round(frameState.size[1] * pixelRatio);
  if (this.canvas_.width != width || this.canvas_.height != height) {
    this.canvas_.width = width;
    this.canvas_.height = height;
  } else {
    context.clearRect(0, 0, width, height);
  }
  var rotation = frameState.viewState.rotation;
  this.calculateMatrices2D(frameState);
  this.dispatchComposeEvent_(ol.render.EventType.PRECOMPOSE, frameState);
  var layerStatesArray = frameState.layerStatesArray;
  ol.array.stableSort(layerStatesArray, ol.renderer.Map.sortByZIndex);
  if (rotation) {
    context.save();
    ol.render.canvas.rotateAtOffset(context, rotation, width / 2, height / 2);
  }
  var viewResolution = frameState.viewState.resolution;
  var i, ii, layer, layerRenderer, layerState;
  for (i = 0, ii = layerStatesArray.length; i < ii; ++i) {
    layerState = layerStatesArray[i];
    layer = layerState.layer;
    layerRenderer = this.getLayerRenderer(layer);
    if (!ol.layer.Layer.visibleAtResolution(layerState, viewResolution) || layerState.sourceState != ol.source.State.READY) {
      continue;
    }
    if (layerRenderer.prepareFrame(frameState, layerState)) {
      layerRenderer.composeFrame(frameState, layerState, context);
    }
  }
  if (rotation) {
    context.restore();
  }
  this.dispatchComposeEvent_(ol.render.EventType.POSTCOMPOSE, frameState);
  if (!this.renderedVisible_) {
    this.canvas_.style.display = "";
    this.renderedVisible_ = true;
  }
  this.scheduleRemoveUnusedLayerRenderers(frameState);
  this.scheduleExpireIconCache(frameState);
};
ol.renderer.canvas.Map.prototype.forEachLayerAtPixel = function(pixel, frameState, callback, thisArg, layerFilter, thisArg2) {
  var result;
  var viewState = frameState.viewState;
  var viewResolution = viewState.resolution;
  var layerStates = frameState.layerStatesArray;
  var numLayers = layerStates.length;
  var coordinate = ol.transform.apply(frameState.pixelToCoordinateTransform, pixel.slice());
  var i;
  for (i = numLayers - 1; i >= 0; --i) {
    var layerState = layerStates[i];
    var layer = layerState.layer;
    if (ol.layer.Layer.visibleAtResolution(layerState, viewResolution) && layerFilter.call(thisArg2, layer)) {
      var layerRenderer = this.getLayerRenderer(layer);
      result = layerRenderer.forEachLayerAtCoordinate(coordinate, frameState, callback, thisArg);
      if (result) {
        return result;
      }
    }
  }
  return undefined;
};
goog.provide("ol.renderer.canvas.TileLayer");
goog.require("ol");
goog.require("ol.LayerType");
goog.require("ol.TileRange");
goog.require("ol.TileState");
goog.require("ol.ViewHint");
goog.require("ol.dom");
goog.require("ol.extent");
goog.require("ol.renderer.Type");
goog.require("ol.renderer.canvas.IntermediateCanvas");
goog.require("ol.transform");
ol.renderer.canvas.TileLayer = function(tileLayer) {
  ol.renderer.canvas.IntermediateCanvas.call(this, tileLayer);
  this.context = this.context === null ? null : ol.dom.createCanvasContext2D();
  this.oversampling_;
  this.renderedExtent_ = null;
  this.renderedRevision;
  this.renderedTiles = [];
  this.tmpExtent = ol.extent.createEmpty();
  this.tmpTileRange_ = new ol.TileRange(0, 0, 0, 0);
  this.imageTransform_ = ol.transform.create();
  this.zDirection = 0;
};
ol.inherits(ol.renderer.canvas.TileLayer, ol.renderer.canvas.IntermediateCanvas);
ol.renderer.canvas.TileLayer["handles"] = function(type, layer) {
  return type === ol.renderer.Type.CANVAS && layer.getType() === ol.LayerType.TILE;
};
ol.renderer.canvas.TileLayer["create"] = function(mapRenderer, layer) {
  return new ol.renderer.canvas.TileLayer(layer);
};
ol.renderer.canvas.TileLayer.prototype.isDrawableTile_ = function(tile) {
  var tileState = tile.getState();
  var useInterimTilesOnError = this.getLayer().getUseInterimTilesOnError();
  return tileState == ol.TileState.LOADED || tileState == ol.TileState.EMPTY || tileState == ol.TileState.ERROR && !useInterimTilesOnError;
};
ol.renderer.canvas.TileLayer.prototype.prepareFrame = function(frameState, layerState) {
  var pixelRatio = frameState.pixelRatio;
  var size = frameState.size;
  var viewState = frameState.viewState;
  var projection = viewState.projection;
  var viewResolution = viewState.resolution;
  var viewCenter = viewState.center;
  var tileLayer = this.getLayer();
  var tileSource = tileLayer.getSource();
  var sourceRevision = tileSource.getRevision();
  var tileGrid = tileSource.getTileGridForProjection(projection);
  var z = tileGrid.getZForResolution(viewResolution, this.zDirection);
  var tileResolution = tileGrid.getResolution(z);
  var oversampling = Math.round(viewResolution / tileResolution) || 1;
  var extent = frameState.extent;
  if (layerState.extent !== undefined) {
    extent = ol.extent.getIntersection(extent, layerState.extent);
  }
  if (ol.extent.isEmpty(extent)) {
    return false;
  }
  var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
  var imageExtent = tileGrid.getTileRangeExtent(z, tileRange);
  var tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);
  var tilesToDrawByZ = {};
  tilesToDrawByZ[z] = {};
  var findLoadedTiles = this.createLoadedTileFinder(tileSource, projection, tilesToDrawByZ);
  var tmpExtent = this.tmpExtent;
  var tmpTileRange = this.tmpTileRange_;
  var newTiles = false;
  var tile, x, y;
  for (x = tileRange.minX; x <= tileRange.maxX; ++x) {
    for (y = tileRange.minY; y <= tileRange.maxY; ++y) {
      tile = tileSource.getTile(z, x, y, pixelRatio, projection);
      if (tile.getState() == ol.TileState.ERROR) {
        if (!tileLayer.getUseInterimTilesOnError()) {
          tile.setState(ol.TileState.LOADED);
        } else {
          if (tileLayer.getPreload() > 0) {
            newTiles = true;
          }
        }
      }
      if (!this.isDrawableTile_(tile)) {
        tile = tile.getInterimTile();
      }
      if (this.isDrawableTile_(tile)) {
        var uid = ol.getUid(this);
        if (tile.getState() == ol.TileState.LOADED) {
          tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;
          var inTransition = tile.inTransition(uid);
          if (!newTiles && (inTransition || this.renderedTiles.indexOf(tile) === -1)) {
            newTiles = true;
          }
        }
        if (tile.getAlpha(uid, frameState.time) === 1) {
          continue;
        }
      }
      var childTileRange = tileGrid.getTileCoordChildTileRange(tile.tileCoord, tmpTileRange, tmpExtent);
      var covered = false;
      if (childTileRange) {
        covered = findLoadedTiles(z + 1, childTileRange);
      }
      if (!covered) {
        tileGrid.forEachTileCoordParentTileRange(tile.tileCoord, findLoadedTiles, null, tmpTileRange, tmpExtent);
      }
    }
  }
  var renderedResolution = tileResolution * pixelRatio / tilePixelRatio * oversampling;
  var hints = frameState.viewHints;
  var animatingOrInteracting = hints[ol.ViewHint.ANIMATING] || hints[ol.ViewHint.INTERACTING];
  if (!(this.renderedResolution && Date.now() - frameState.time > 16 && animatingOrInteracting) && (newTiles || !(this.renderedExtent_ && ol.extent.containsExtent(this.renderedExtent_, extent)) || this.renderedRevision != sourceRevision || oversampling != this.oversampling_ || !animatingOrInteracting && renderedResolution != this.renderedResolution)) {
    var context = this.context;
    if (context) {
      var tilePixelSize = tileSource.getTilePixelSize(z, pixelRatio, projection);
      var width = Math.round(tileRange.getWidth() * tilePixelSize[0] / oversampling);
      var height = Math.round(tileRange.getHeight() * tilePixelSize[1] / oversampling);
      var canvas = context.canvas;
      if (canvas.width != width || canvas.height != height) {
        this.oversampling_ = oversampling;
        canvas.width = width;
        canvas.height = height;
      } else {
        if (this.renderedExtent_ && !ol.extent.equals(imageExtent, this.renderedExtent_)) {
          context.clearRect(0, 0, width, height);
        }
        oversampling = this.oversampling_;
      }
    }
    this.renderedTiles.length = 0;
    var zs = Object.keys(tilesToDrawByZ).map(Number);
    zs.sort(function(a, b) {
      if (a === z) {
        return 1;
      } else {
        if (b === z) {
          return -1;
        } else {
          return a > b ? 1 : a < b ? -1 : 0;
        }
      }
    });
    var currentResolution, currentScale, currentTilePixelSize, currentZ, i, ii;
    var tileExtent, tileGutter, tilesToDraw, w, h;
    for (i = 0, ii = zs.length; i < ii; ++i) {
      currentZ = zs[i];
      currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);
      currentResolution = tileGrid.getResolution(currentZ);
      currentScale = currentResolution / tileResolution;
      tileGutter = tilePixelRatio * tileSource.getGutter(projection);
      tilesToDraw = tilesToDrawByZ[currentZ];
      for (var tileCoordKey in tilesToDraw) {
        tile = tilesToDraw[tileCoordKey];
        tileExtent = tileGrid.getTileCoordExtent(tile.getTileCoord(), tmpExtent);
        x = (tileExtent[0] - imageExtent[0]) / tileResolution * tilePixelRatio / oversampling;
        y = (imageExtent[3] - tileExtent[3]) / tileResolution * tilePixelRatio / oversampling;
        w = currentTilePixelSize[0] * currentScale / oversampling;
        h = currentTilePixelSize[1] * currentScale / oversampling;
        this.drawTileImage(tile, frameState, layerState, x, y, w, h, tileGutter, z === currentZ);
        this.renderedTiles.push(tile);
      }
    }
    this.renderedRevision = sourceRevision;
    this.renderedResolution = tileResolution * pixelRatio / tilePixelRatio * oversampling;
    this.renderedExtent_ = imageExtent;
  }
  var scale = this.renderedResolution / viewResolution;
  var transform = ol.transform.compose(this.imageTransform_, pixelRatio * size[0] / 2, pixelRatio * size[1] / 2, scale, scale, 0, (this.renderedExtent_[0] - viewCenter[0]) / this.renderedResolution * pixelRatio, (viewCenter[1] - this.renderedExtent_[3]) / this.renderedResolution * pixelRatio);
  ol.transform.compose(this.coordinateToCanvasPixelTransform, pixelRatio * size[0] / 2 - transform[4], pixelRatio * size[1] / 2 - transform[5], pixelRatio / viewResolution, -pixelRatio / viewResolution, 0, -viewCenter[0], -viewCenter[1]);
  this.updateUsedTiles(frameState.usedTiles, tileSource, z, tileRange);
  this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, z, tileLayer.getPreload());
  this.scheduleExpireCache(frameState, tileSource);
  this.updateLogos(frameState, tileSource);
  return this.renderedTiles.length > 0;
};
ol.renderer.canvas.TileLayer.prototype.drawTileImage = function(tile, frameState, layerState, x, y, w, h, gutter, transition) {
  var image = tile.getImage(this.getLayer());
  if (!image) {
    return;
  }
  var uid = ol.getUid(this);
  var alpha = transition ? tile.getAlpha(uid, frameState.time) : 1;
  if (alpha === 1 && !this.getLayer().getSource().getOpaque(frameState.viewState.projection)) {
    this.context.clearRect(x, y, w, h);
  }
  var alphaChanged = alpha !== this.context.globalAlpha;
  if (alphaChanged) {
    this.context.save();
    this.context.globalAlpha = alpha;
  }
  this.context.drawImage(image, gutter, gutter, image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);
  if (alphaChanged) {
    this.context.restore();
  }
  if (alpha !== 1) {
    frameState.animate = true;
  } else {
    if (transition) {
      tile.endTransition(uid);
    }
  }
};
ol.renderer.canvas.TileLayer.prototype.getImage = function() {
  var context = this.context;
  return context ? context.canvas : null;
};
ol.renderer.canvas.TileLayer.prototype.getLayer;
ol.renderer.canvas.TileLayer.prototype.getImageTransform = function() {
  return this.imageTransform_;
};
goog.provide("ol.render.ReplayGroup");
ol.render.ReplayGroup = function() {
};
ol.render.ReplayGroup.prototype.getReplay = function(zIndex, replayType) {
};
ol.render.ReplayGroup.prototype.isEmpty = function() {
};
goog.provide("ol.render.ReplayType");
ol.render.ReplayType = {CIRCLE:"Circle", DEFAULT:"Default", IMAGE:"Image", LINE_STRING:"LineString", POLYGON:"Polygon", TEXT:"Text"};
goog.provide("ol.geom.flat.length");
ol.geom.flat.length.lineString = function(flatCoordinates, offset, end, stride) {
  var x1 = flatCoordinates[offset];
  var y1 = flatCoordinates[offset + 1];
  var length = 0;
  var i;
  for (i = offset + stride; i < end; i += stride) {
    var x2 = flatCoordinates[i];
    var y2 = flatCoordinates[i + 1];
    length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    x1 = x2;
    y1 = y2;
  }
  return length;
};
ol.geom.flat.length.linearRing = function(flatCoordinates, offset, end, stride) {
  var perimeter = ol.geom.flat.length.lineString(flatCoordinates, offset, end, stride);
  var dx = flatCoordinates[end - stride] - flatCoordinates[offset];
  var dy = flatCoordinates[end - stride + 1] - flatCoordinates[offset + 1];
  perimeter += Math.sqrt(dx * dx + dy * dy);
  return perimeter;
};
goog.provide("ol.geom.flat.textpath");
goog.require("ol.math");
ol.geom.flat.textpath.lineString = function(flatCoordinates, offset, end, stride, text, measure, startM, maxAngle) {
  var result = [];
  var reverse = flatCoordinates[offset] > flatCoordinates[end - stride];
  var numChars = text.length;
  var x1 = flatCoordinates[offset];
  var y1 = flatCoordinates[offset + 1];
  offset += stride;
  var x2 = flatCoordinates[offset];
  var y2 = flatCoordinates[offset + 1];
  var segmentM = 0;
  var segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
  var chunk = "";
  var chunkLength = 0;
  var data, index, previousAngle;
  for (var i = 0; i < numChars; ++i) {
    index = reverse ? numChars - i - 1 : i;
    var char = text.charAt(index);
    chunk = reverse ? char + chunk : chunk + char;
    var charLength = measure(chunk) - chunkLength;
    chunkLength += charLength;
    var charM = startM + charLength / 2;
    while (offset < end - stride && segmentM + segmentLength < charM) {
      x1 = x2;
      y1 = y2;
      offset += stride;
      x2 = flatCoordinates[offset];
      y2 = flatCoordinates[offset + 1];
      segmentM += segmentLength;
      segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
    }
    var segmentPos = charM - segmentM;
    var angle = Math.atan2(y2 - y1, x2 - x1);
    if (reverse) {
      angle += angle > 0 ? -Math.PI : Math.PI;
    }
    if (previousAngle !== undefined) {
      var delta = angle - previousAngle;
      delta += delta > Math.PI ? -2 * Math.PI : delta < -Math.PI ? 2 * Math.PI : 0;
      if (Math.abs(delta) > maxAngle) {
        return null;
      }
    }
    var interpolate = segmentPos / segmentLength;
    var x = ol.math.lerp(x1, x2, interpolate);
    var y = ol.math.lerp(y1, y2, interpolate);
    if (previousAngle == angle) {
      if (reverse) {
        data[0] = x;
        data[1] = y;
        data[2] = charLength / 2;
      }
      data[4] = chunk;
    } else {
      chunk = char;
      chunkLength = charLength;
      data = [x, y, charLength / 2, angle, chunk];
      if (reverse) {
        result.unshift(data);
      } else {
        result.push(data);
      }
      previousAngle = angle;
    }
    startM += charLength;
  }
  return result;
};
goog.provide("ol.render.canvas.Instruction");
ol.render.canvas.Instruction = {BEGIN_GEOMETRY:0, BEGIN_PATH:1, CIRCLE:2, CLOSE_PATH:3, CUSTOM:4, DRAW_CHARS:5, DRAW_IMAGE:6, END_GEOMETRY:7, FILL:8, MOVE_TO_LINE_TO:9, SET_FILL_STYLE:10, SET_STROKE_STYLE:11, STROKE:12};
goog.provide("ol.render.replay");
goog.require("ol.render.ReplayType");
ol.render.replay.ORDER = [ol.render.ReplayType.POLYGON, ol.render.ReplayType.CIRCLE, ol.render.ReplayType.LINE_STRING, ol.render.ReplayType.IMAGE, ol.render.ReplayType.TEXT, ol.render.ReplayType.DEFAULT];
ol.render.replay.TEXT_ALIGN = {};
ol.render.replay.TEXT_ALIGN["left"] = 0;
ol.render.replay.TEXT_ALIGN["end"] = 0;
ol.render.replay.TEXT_ALIGN["center"] = 0.5;
ol.render.replay.TEXT_ALIGN["right"] = 1;
ol.render.replay.TEXT_ALIGN["start"] = 1;
ol.render.replay.TEXT_ALIGN["top"] = 0;
ol.render.replay.TEXT_ALIGN["middle"] = 0.5;
ol.render.replay.TEXT_ALIGN["hanging"] = 0.2;
ol.render.replay.TEXT_ALIGN["alphabetic"] = 0.8;
ol.render.replay.TEXT_ALIGN["ideographic"] = 0.8;
ol.render.replay.TEXT_ALIGN["bottom"] = 1;
goog.provide("ol.render.canvas.Replay");
goog.require("ol");
goog.require("ol.array");
goog.require("ol.colorlike");
goog.require("ol.extent");
goog.require("ol.extent.Relationship");
goog.require("ol.geom.GeometryType");
goog.require("ol.geom.flat.inflate");
goog.require("ol.geom.flat.length");
goog.require("ol.geom.flat.textpath");
goog.require("ol.geom.flat.transform");
goog.require("ol.has");
goog.require("ol.obj");
goog.require("ol.render.VectorContext");
goog.require("ol.render.canvas");
goog.require("ol.render.canvas.Instruction");
goog.require("ol.render.replay");
goog.require("ol.transform");
ol.render.canvas.Replay = function(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {
  ol.render.VectorContext.call(this);
  this.declutterTree = declutterTree;
  this.tmpExtent_ = ol.extent.createEmpty();
  this.tolerance = tolerance;
  this.maxExtent = maxExtent;
  this.overlaps = overlaps;
  this.pixelRatio = pixelRatio;
  this.maxLineWidth = 0;
  this.resolution = resolution;
  this.fillOrigin_;
  this.beginGeometryInstruction1_ = null;
  this.beginGeometryInstruction2_ = null;
  this.bufferedMaxExtent_ = null;
  this.instructions = [];
  this.coordinates = [];
  this.coordinateCache_ = {};
  this.renderedTransform_ = ol.transform.create();
  this.hitDetectionInstructions = [];
  this.pixelCoordinates_ = null;
  this.state = {};
  this.viewRotation_ = 0;
  this.tmpLocalTransform_ = ol.transform.create();
  this.resetTransform_ = ol.transform.create();
};
ol.inherits(ol.render.canvas.Replay, ol.render.VectorContext);
ol.render.canvas.Replay.prototype.replayTextBackground_ = function(context, p1, p2, p3, p4, fillInstruction, strokeInstruction) {
  context.beginPath();
  context.moveTo.apply(context, p1);
  context.lineTo.apply(context, p2);
  context.lineTo.apply(context, p3);
  context.lineTo.apply(context, p4);
  context.lineTo.apply(context, p1);
  if (fillInstruction) {
    this.fillOrigin_ = fillInstruction[2];
    this.fill_(context);
  }
  if (strokeInstruction) {
    this.setStrokeStyle_(context, strokeInstruction);
    context.stroke();
  }
};
ol.render.canvas.Replay.prototype.replayImage_ = function(context, x, y, image, anchorX, anchorY, declutterGroup, height, opacity, originX, originY, rotation, scale, snapToPixel, width, padding, fillInstruction, strokeInstruction) {
  var fillStroke = fillInstruction || strokeInstruction;
  var localTransform = this.tmpLocalTransform_;
  anchorX *= scale;
  anchorY *= scale;
  x -= anchorX;
  y -= anchorY;
  if (snapToPixel) {
    x = Math.round(x);
    y = Math.round(y);
  }
  var w = width + originX > image.width ? image.width - originX : width;
  var h = height + originY > image.height ? image.height - originY : height;
  var box = this.tmpExtent_;
  var boxW = padding[3] + w * scale + padding[1];
  var boxH = padding[0] + h * scale + padding[2];
  var boxX = x - padding[3];
  var boxY = y - padding[0];
  var p1;
  var p2;
  var p3;
  var p4;
  if (fillStroke || rotation !== 0) {
    p1 = [boxX, boxY];
    p2 = [boxX + boxW, boxY];
    p3 = [boxX + boxW, boxY + boxH];
    p4 = [boxX, boxY + boxH];
  }
  var transform = null;
  if (rotation !== 0) {
    var centerX = x + anchorX;
    var centerY = y + anchorY;
    transform = ol.transform.compose(localTransform, centerX, centerY, 1, 1, rotation, -centerX, -centerY);
    ol.extent.createOrUpdateEmpty(box);
    ol.extent.extendCoordinate(box, ol.transform.apply(localTransform, p1));
    ol.extent.extendCoordinate(box, ol.transform.apply(localTransform, p2));
    ol.extent.extendCoordinate(box, ol.transform.apply(localTransform, p3));
    ol.extent.extendCoordinate(box, ol.transform.apply(localTransform, p4));
  } else {
    ol.extent.createOrUpdate(boxX, boxY, boxX + boxW, boxY + boxH, box);
  }
  var canvas = context.canvas;
  var intersects = box[0] <= canvas.width && box[2] >= 0 && box[1] <= canvas.height && box[3] >= 0;
  if (declutterGroup) {
    if (!intersects && declutterGroup[4] == 1) {
      return;
    }
    ol.extent.extend(declutterGroup, box);
    var declutterArgs = intersects ? [context, transform ? transform.slice(0) : null, opacity, image, originX, originY, w, h, x, y, scale] : null;
    if (declutterArgs && fillStroke) {
      declutterArgs.push(fillInstruction, strokeInstruction, p1, p2, p3, p4);
    }
    declutterGroup.push(declutterArgs);
  } else {
    if (intersects) {
      if (fillStroke) {
        this.replayTextBackground_(context, p1, p2, p3, p4, fillInstruction, strokeInstruction);
      }
      ol.render.canvas.drawImage(context, transform, opacity, image, originX, originY, w, h, x, y, scale);
    }
  }
};
ol.render.canvas.Replay.prototype.applyPixelRatio = function(dashArray) {
  var pixelRatio = this.pixelRatio;
  return pixelRatio == 1 ? dashArray : dashArray.map(function(dash) {
    return dash * pixelRatio;
  });
};
ol.render.canvas.Replay.prototype.appendFlatCoordinates = function(flatCoordinates, offset, end, stride, closed, skipFirst) {
  var myEnd = this.coordinates.length;
  var extent = this.getBufferedMaxExtent();
  if (skipFirst) {
    offset += stride;
  }
  var lastCoord = [flatCoordinates[offset], flatCoordinates[offset + 1]];
  var nextCoord = [NaN, NaN];
  var skipped = true;
  var i, lastRel, nextRel;
  for (i = offset + stride; i < end; i += stride) {
    nextCoord[0] = flatCoordinates[i];
    nextCoord[1] = flatCoordinates[i + 1];
    nextRel = ol.extent.coordinateRelationship(extent, nextCoord);
    if (nextRel !== lastRel) {
      if (skipped) {
        this.coordinates[myEnd++] = lastCoord[0];
        this.coordinates[myEnd++] = lastCoord[1];
      }
      this.coordinates[myEnd++] = nextCoord[0];
      this.coordinates[myEnd++] = nextCoord[1];
      skipped = false;
    } else {
      if (nextRel === ol.extent.Relationship.INTERSECTING) {
        this.coordinates[myEnd++] = nextCoord[0];
        this.coordinates[myEnd++] = nextCoord[1];
        skipped = false;
      } else {
        skipped = true;
      }
    }
    lastCoord[0] = nextCoord[0];
    lastCoord[1] = nextCoord[1];
    lastRel = nextRel;
  }
  if (closed && skipped || i === offset + stride) {
    this.coordinates[myEnd++] = lastCoord[0];
    this.coordinates[myEnd++] = lastCoord[1];
  }
  return myEnd;
};
ol.render.canvas.Replay.prototype.drawCustomCoordinates_ = function(flatCoordinates, offset, ends, stride, replayEnds) {
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    var replayEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);
    replayEnds.push(replayEnd);
    offset = end;
  }
  return offset;
};
ol.render.canvas.Replay.prototype.drawCustom = function(geometry, feature, renderer) {
  this.beginGeometry(geometry, feature);
  var type = geometry.getType();
  var stride = geometry.getStride();
  var replayBegin = this.coordinates.length;
  var flatCoordinates, replayEnd, replayEnds, replayEndss;
  var offset;
  if (type == ol.geom.GeometryType.MULTI_POLYGON) {
    geometry = geometry;
    flatCoordinates = geometry.getOrientedFlatCoordinates();
    replayEndss = [];
    var endss = geometry.getEndss();
    offset = 0;
    for (var i = 0, ii = endss.length; i < ii; ++i) {
      var myEnds = [];
      offset = this.drawCustomCoordinates_(flatCoordinates, offset, endss[i], stride, myEnds);
      replayEndss.push(myEnds);
    }
    this.instructions.push([ol.render.canvas.Instruction.CUSTOM, replayBegin, replayEndss, geometry, renderer, ol.geom.flat.inflate.coordinatesss]);
  } else {
    if (type == ol.geom.GeometryType.POLYGON || type == ol.geom.GeometryType.MULTI_LINE_STRING) {
      replayEnds = [];
      flatCoordinates = type == ol.geom.GeometryType.POLYGON ? geometry.getOrientedFlatCoordinates() : geometry.getFlatCoordinates();
      offset = this.drawCustomCoordinates_(flatCoordinates, 0, geometry.getEnds(), stride, replayEnds);
      this.instructions.push([ol.render.canvas.Instruction.CUSTOM, replayBegin, replayEnds, geometry, renderer, ol.geom.flat.inflate.coordinatess]);
    } else {
      if (type == ol.geom.GeometryType.LINE_STRING || type == ol.geom.GeometryType.MULTI_POINT) {
        flatCoordinates = geometry.getFlatCoordinates();
        replayEnd = this.appendFlatCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);
        this.instructions.push([ol.render.canvas.Instruction.CUSTOM, replayBegin, replayEnd, geometry, renderer, ol.geom.flat.inflate.coordinates]);
      } else {
        if (type == ol.geom.GeometryType.POINT) {
          flatCoordinates = geometry.getFlatCoordinates();
          this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);
          replayEnd = this.coordinates.length;
          this.instructions.push([ol.render.canvas.Instruction.CUSTOM, replayBegin, replayEnd, geometry, renderer]);
        }
      }
    }
  }
  this.endGeometry(geometry, feature);
};
ol.render.canvas.Replay.prototype.beginGeometry = function(geometry, feature) {
  this.beginGeometryInstruction1_ = [ol.render.canvas.Instruction.BEGIN_GEOMETRY, feature, 0];
  this.instructions.push(this.beginGeometryInstruction1_);
  this.beginGeometryInstruction2_ = [ol.render.canvas.Instruction.BEGIN_GEOMETRY, feature, 0];
  this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
};
ol.render.canvas.Replay.prototype.fill_ = function(context) {
  if (this.fillOrigin_) {
    var origin = ol.transform.apply(this.renderedTransform_, this.fillOrigin_.slice());
    context.translate(origin[0], origin[1]);
    context.rotate(this.viewRotation_);
  }
  context.fill();
  if (this.fillOrigin_) {
    context.setTransform.apply(context, ol.render.canvas.resetTransform_);
  }
};
ol.render.canvas.Replay.prototype.setStrokeStyle_ = function(context, instruction) {
  context.strokeStyle = instruction[1];
  context.lineWidth = instruction[2];
  context.lineCap = instruction[3];
  context.lineJoin = instruction[4];
  context.miterLimit = instruction[5];
  if (ol.has.CANVAS_LINE_DASH) {
    context.lineDashOffset = instruction[7];
    context.setLineDash(instruction[6]);
  }
};
ol.render.canvas.Replay.prototype.renderDeclutter_ = function(declutterGroup, feature) {
  if (declutterGroup && declutterGroup.length > 5) {
    var groupCount = declutterGroup[4];
    if (groupCount == 1 || groupCount == declutterGroup.length - 5) {
      var box = {minX:declutterGroup[0], minY:declutterGroup[1], maxX:declutterGroup[2], maxY:declutterGroup[3], value:feature};
      if (!this.declutterTree.collides(box)) {
        this.declutterTree.insert(box);
        var drawImage = ol.render.canvas.drawImage;
        for (var j = 5, jj = declutterGroup.length; j < jj; ++j) {
          var declutterData = declutterGroup[j];
          if (declutterData) {
            if (declutterData.length > 11) {
              this.replayTextBackground_(declutterData[0], declutterData[13], declutterData[14], declutterData[15], declutterData[16], declutterData[11], declutterData[12]);
            }
            drawImage.apply(undefined, declutterData);
          }
        }
      }
      declutterGroup.length = 5;
      ol.extent.createOrUpdateEmpty(declutterGroup);
    }
  }
};
ol.render.canvas.Replay.prototype.replay_ = function(context, transform, skippedFeaturesHash, instructions, featureCallback, opt_hitExtent) {
  var pixelCoordinates;
  if (this.pixelCoordinates_ && ol.array.equals(transform, this.renderedTransform_)) {
    pixelCoordinates = this.pixelCoordinates_;
  } else {
    if (!this.pixelCoordinates_) {
      this.pixelCoordinates_ = [];
    }
    pixelCoordinates = ol.geom.flat.transform.transform2D(this.coordinates, 0, this.coordinates.length, 2, transform, this.pixelCoordinates_);
    ol.transform.setFromArray(this.renderedTransform_, transform);
  }
  var skipFeatures = !ol.obj.isEmpty(skippedFeaturesHash);
  var i = 0;
  var ii = instructions.length;
  var d = 0;
  var dd;
  var anchorX, anchorY, prevX, prevY, roundX, roundY, declutterGroup, image;
  var pendingFill = 0;
  var pendingStroke = 0;
  var lastFillInstruction = null;
  var lastStrokeInstruction = null;
  var coordinateCache = this.coordinateCache_;
  var viewRotation = this.viewRotation_;
  var state = {context:context, pixelRatio:this.pixelRatio, resolution:this.resolution, rotation:viewRotation};
  var batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;
  while (i < ii) {
    var instruction = instructions[i];
    var type = instruction[0];
    var feature, x, y;
    switch(type) {
      case ol.render.canvas.Instruction.BEGIN_GEOMETRY:
        feature = instruction[1];
        if (skipFeatures && skippedFeaturesHash[ol.getUid(feature).toString()] || !feature.getGeometry()) {
          i = instruction[2];
        } else {
          if (opt_hitExtent !== undefined && !ol.extent.intersects(opt_hitExtent, feature.getGeometry().getExtent())) {
            i = instruction[2] + 1;
          } else {
            ++i;
          }
        }
        break;
      case ol.render.canvas.Instruction.BEGIN_PATH:
        if (pendingFill > batchSize) {
          this.fill_(context);
          pendingFill = 0;
        }
        if (pendingStroke > batchSize) {
          context.stroke();
          pendingStroke = 0;
        }
        if (!pendingFill && !pendingStroke) {
          context.beginPath();
          prevX = prevY = NaN;
        }
        ++i;
        break;
      case ol.render.canvas.Instruction.CIRCLE:
        d = instruction[1];
        var x1 = pixelCoordinates[d];
        var y1 = pixelCoordinates[d + 1];
        var x2 = pixelCoordinates[d + 2];
        var y2 = pixelCoordinates[d + 3];
        var dx = x2 - x1;
        var dy = y2 - y1;
        var r = Math.sqrt(dx * dx + dy * dy);
        context.moveTo(x1 + r, y1);
        context.arc(x1, y1, r, 0, 2 * Math.PI, true);
        ++i;
        break;
      case ol.render.canvas.Instruction.CLOSE_PATH:
        context.closePath();
        ++i;
        break;
      case ol.render.canvas.Instruction.CUSTOM:
        d = instruction[1];
        dd = instruction[2];
        var geometry = instruction[3];
        var renderer = instruction[4];
        var fn = instruction.length == 6 ? instruction[5] : undefined;
        state.geometry = geometry;
        state.feature = feature;
        if (!(i in coordinateCache)) {
          coordinateCache[i] = [];
        }
        var coords = coordinateCache[i];
        if (fn) {
          fn(pixelCoordinates, d, dd, 2, coords);
        } else {
          coords[0] = pixelCoordinates[d];
          coords[1] = pixelCoordinates[d + 1];
          coords.length = 2;
        }
        renderer(coords, state);
        ++i;
        break;
      case ol.render.canvas.Instruction.DRAW_IMAGE:
        d = instruction[1];
        dd = instruction[2];
        image = instruction[3];
        anchorX = instruction[4];
        anchorY = instruction[5];
        declutterGroup = featureCallback ? null : instruction[6];
        var height = instruction[7];
        var opacity = instruction[8];
        var originX = instruction[9];
        var originY = instruction[10];
        var rotateWithView = instruction[11];
        var rotation = instruction[12];
        var scale = instruction[13];
        var snapToPixel = instruction[14];
        var width = instruction[15];
        var padding, backgroundFill, backgroundStroke;
        if (instruction.length > 16) {
          padding = instruction[16];
          backgroundFill = instruction[17];
          backgroundStroke = instruction[18];
        } else {
          padding = ol.render.canvas.defaultPadding;
          backgroundFill = backgroundStroke = false;
        }
        if (rotateWithView) {
          rotation += viewRotation;
        }
        for (; d < dd; d += 2) {
          this.replayImage_(context, pixelCoordinates[d], pixelCoordinates[d + 1], image, anchorX, anchorY, declutterGroup, height, opacity, originX, originY, rotation, scale, snapToPixel, width, padding, backgroundFill ? lastFillInstruction : null, backgroundStroke ? lastStrokeInstruction : null);
        }
        this.renderDeclutter_(declutterGroup, feature);
        ++i;
        break;
      case ol.render.canvas.Instruction.DRAW_CHARS:
        var begin = instruction[1];
        var end = instruction[2];
        var baseline = instruction[3];
        declutterGroup = featureCallback ? null : instruction[4];
        var overflow = instruction[5];
        var fillKey = instruction[6];
        var maxAngle = instruction[7];
        var measure = instruction[8];
        var offsetY = instruction[9];
        var strokeKey = instruction[10];
        var strokeWidth = instruction[11];
        var text = instruction[12];
        var textKey = instruction[13];
        var textScale = instruction[14];
        var pathLength = ol.geom.flat.length.lineString(pixelCoordinates, begin, end, 2);
        var textLength = measure(text);
        if (overflow || textLength <= pathLength) {
          var textAlign = this.textStates[textKey].textAlign;
          var startM = (pathLength - textLength) * ol.render.replay.TEXT_ALIGN[textAlign];
          var parts = ol.geom.flat.textpath.lineString(pixelCoordinates, begin, end, 2, text, measure, startM, maxAngle);
          if (parts) {
            var c, cc, chars, label, part;
            if (strokeKey) {
              for (c = 0, cc = parts.length; c < cc; ++c) {
                part = parts[c];
                chars = part[4];
                label = this.getImage(chars, textKey, "", strokeKey);
                anchorX = part[2] + strokeWidth;
                anchorY = baseline * label.height + (0.5 - baseline) * 2 * strokeWidth - offsetY;
                this.replayImage_(context, part[0], part[1], label, anchorX, anchorY, declutterGroup, label.height, 1, 0, 0, part[3], textScale, false, label.width, ol.render.canvas.defaultPadding, null, null);
              }
            }
            if (fillKey) {
              for (c = 0, cc = parts.length; c < cc; ++c) {
                part = parts[c];
                chars = part[4];
                label = this.getImage(chars, textKey, fillKey, "");
                anchorX = part[2];
                anchorY = baseline * label.height - offsetY;
                this.replayImage_(context, part[0], part[1], label, anchorX, anchorY, declutterGroup, label.height, 1, 0, 0, part[3], textScale, false, label.width, ol.render.canvas.defaultPadding, null, null);
              }
            }
          }
        }
        this.renderDeclutter_(declutterGroup, feature);
        ++i;
        break;
      case ol.render.canvas.Instruction.END_GEOMETRY:
        if (featureCallback !== undefined) {
          feature = instruction[1];
          var result = featureCallback(feature);
          if (result) {
            return result;
          }
        }
        ++i;
        break;
      case ol.render.canvas.Instruction.FILL:
        if (batchSize) {
          pendingFill++;
        } else {
          this.fill_(context);
        }
        ++i;
        break;
      case ol.render.canvas.Instruction.MOVE_TO_LINE_TO:
        d = instruction[1];
        dd = instruction[2];
        x = pixelCoordinates[d];
        y = pixelCoordinates[d + 1];
        roundX = x + 0.5 | 0;
        roundY = y + 0.5 | 0;
        if (roundX !== prevX || roundY !== prevY) {
          context.moveTo(x, y);
          prevX = roundX;
          prevY = roundY;
        }
        for (d += 2; d < dd; d += 2) {
          x = pixelCoordinates[d];
          y = pixelCoordinates[d + 1];
          roundX = x + 0.5 | 0;
          roundY = y + 0.5 | 0;
          if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {
            context.lineTo(x, y);
            prevX = roundX;
            prevY = roundY;
          }
        }
        ++i;
        break;
      case ol.render.canvas.Instruction.SET_FILL_STYLE:
        lastFillInstruction = instruction;
        this.fillOrigin_ = instruction[2];
        if (pendingFill) {
          this.fill_(context);
          pendingFill = 0;
          if (pendingStroke) {
            context.stroke();
            pendingStroke = 0;
          }
        }
        context.fillStyle = instruction[1];
        ++i;
        break;
      case ol.render.canvas.Instruction.SET_STROKE_STYLE:
        lastStrokeInstruction = instruction;
        if (pendingStroke) {
          context.stroke();
          pendingStroke = 0;
        }
        this.setStrokeStyle_(context, instruction);
        ++i;
        break;
      case ol.render.canvas.Instruction.STROKE:
        if (batchSize) {
          pendingStroke++;
        } else {
          context.stroke();
        }
        ++i;
        break;
      default:
        ++i;
        break;
    }
  }
  if (pendingFill) {
    this.fill_(context);
  }
  if (pendingStroke) {
    context.stroke();
  }
  return undefined;
};
ol.render.canvas.Replay.prototype.replay = function(context, transform, viewRotation, skippedFeaturesHash) {
  this.viewRotation_ = viewRotation;
  this.replay_(context, transform, skippedFeaturesHash, this.instructions, undefined, undefined);
};
ol.render.canvas.Replay.prototype.replayHitDetection = function(context, transform, viewRotation, skippedFeaturesHash, opt_featureCallback, opt_hitExtent) {
  this.viewRotation_ = viewRotation;
  return this.replay_(context, transform, skippedFeaturesHash, this.hitDetectionInstructions, opt_featureCallback, opt_hitExtent);
};
ol.render.canvas.Replay.prototype.reverseHitDetectionInstructions = function() {
  var hitDetectionInstructions = this.hitDetectionInstructions;
  hitDetectionInstructions.reverse();
  var i;
  var n = hitDetectionInstructions.length;
  var instruction;
  var type;
  var begin = -1;
  for (i = 0; i < n; ++i) {
    instruction = hitDetectionInstructions[i];
    type = instruction[0];
    if (type == ol.render.canvas.Instruction.END_GEOMETRY) {
      begin = i;
    } else {
      if (type == ol.render.canvas.Instruction.BEGIN_GEOMETRY) {
        instruction[2] = i;
        ol.array.reverseSubArray(this.hitDetectionInstructions, begin, i);
        begin = -1;
      }
    }
  }
};
ol.render.canvas.Replay.prototype.setFillStrokeStyle = function(fillStyle, strokeStyle) {
  var state = this.state;
  if (fillStyle) {
    var fillStyleColor = fillStyle.getColor();
    state.fillStyle = ol.colorlike.asColorLike(fillStyleColor ? fillStyleColor : ol.render.canvas.defaultFillStyle);
  } else {
    state.fillStyle = undefined;
  }
  if (strokeStyle) {
    var strokeStyleColor = strokeStyle.getColor();
    state.strokeStyle = ol.colorlike.asColorLike(strokeStyleColor ? strokeStyleColor : ol.render.canvas.defaultStrokeStyle);
    var strokeStyleLineCap = strokeStyle.getLineCap();
    state.lineCap = strokeStyleLineCap !== undefined ? strokeStyleLineCap : ol.render.canvas.defaultLineCap;
    var strokeStyleLineDash = strokeStyle.getLineDash();
    state.lineDash = strokeStyleLineDash ? strokeStyleLineDash.slice() : ol.render.canvas.defaultLineDash;
    var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
    state.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : ol.render.canvas.defaultLineDashOffset;
    var strokeStyleLineJoin = strokeStyle.getLineJoin();
    state.lineJoin = strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : ol.render.canvas.defaultLineJoin;
    var strokeStyleWidth = strokeStyle.getWidth();
    state.lineWidth = strokeStyleWidth !== undefined ? strokeStyleWidth : ol.render.canvas.defaultLineWidth;
    var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
    state.miterLimit = strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : ol.render.canvas.defaultMiterLimit;
    if (state.lineWidth > this.maxLineWidth) {
      this.maxLineWidth = state.lineWidth;
      this.bufferedMaxExtent_ = null;
    }
  } else {
    state.strokeStyle = undefined;
    state.lineCap = undefined;
    state.lineDash = null;
    state.lineDashOffset = undefined;
    state.lineJoin = undefined;
    state.lineWidth = undefined;
    state.miterLimit = undefined;
  }
};
ol.render.canvas.Replay.prototype.applyFill = function(state, geometry) {
  var fillStyle = state.fillStyle;
  var fillInstruction = [ol.render.canvas.Instruction.SET_FILL_STYLE, fillStyle];
  if (typeof fillStyle !== "string") {
    var fillExtent = geometry.getExtent();
    fillInstruction.push([fillExtent[0], fillExtent[3]]);
  }
  this.instructions.push(fillInstruction);
};
ol.render.canvas.Replay.prototype.applyStroke = function(state) {
  this.instructions.push([ol.render.canvas.Instruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth * this.pixelRatio, state.lineCap, state.lineJoin, state.miterLimit, this.applyPixelRatio(state.lineDash), state.lineDashOffset * this.pixelRatio]);
};
ol.render.canvas.Replay.prototype.updateFillStyle = function(state, applyFill, geometry) {
  var fillStyle = state.fillStyle;
  if (typeof fillStyle !== "string" || state.currentFillStyle != fillStyle) {
    applyFill.call(this, state, geometry);
    state.currentFillStyle = fillStyle;
  }
};
ol.render.canvas.Replay.prototype.updateStrokeStyle = function(state, applyStroke) {
  var strokeStyle = state.strokeStyle;
  var lineCap = state.lineCap;
  var lineDash = state.lineDash;
  var lineDashOffset = state.lineDashOffset;
  var lineJoin = state.lineJoin;
  var lineWidth = state.lineWidth;
  var miterLimit = state.miterLimit;
  if (state.currentStrokeStyle != strokeStyle || state.currentLineCap != lineCap || lineDash != state.currentLineDash && !ol.array.equals(state.currentLineDash, lineDash) || state.currentLineDashOffset != lineDashOffset || state.currentLineJoin != lineJoin || state.currentLineWidth != lineWidth || state.currentMiterLimit != miterLimit) {
    applyStroke.call(this, state);
    state.currentStrokeStyle = strokeStyle;
    state.currentLineCap = lineCap;
    state.currentLineDash = lineDash;
    state.currentLineDashOffset = lineDashOffset;
    state.currentLineJoin = lineJoin;
    state.currentLineWidth = lineWidth;
    state.currentMiterLimit = miterLimit;
  }
};
ol.render.canvas.Replay.prototype.endGeometry = function(geometry, feature) {
  this.beginGeometryInstruction1_[2] = this.instructions.length;
  this.beginGeometryInstruction1_ = null;
  this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;
  this.beginGeometryInstruction2_ = null;
  var endGeometryInstruction = [ol.render.canvas.Instruction.END_GEOMETRY, feature];
  this.instructions.push(endGeometryInstruction);
  this.hitDetectionInstructions.push(endGeometryInstruction);
};
ol.render.canvas.Replay.prototype.finish = ol.nullFunction;
ol.render.canvas.Replay.prototype.getBufferedMaxExtent = function() {
  if (!this.bufferedMaxExtent_) {
    this.bufferedMaxExtent_ = ol.extent.clone(this.maxExtent);
    if (this.maxLineWidth > 0) {
      var width = this.resolution * (this.maxLineWidth + 1) / 2;
      ol.extent.buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);
    }
  }
  return this.bufferedMaxExtent_;
};
goog.provide("ol.render.canvas.ImageReplay");
goog.require("ol");
goog.require("ol.render.canvas.Instruction");
goog.require("ol.render.canvas.Replay");
ol.render.canvas.ImageReplay = function(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {
  ol.render.canvas.Replay.call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);
  this.declutterGroup_ = null;
  this.hitDetectionImage_ = null;
  this.image_ = null;
  this.anchorX_ = undefined;
  this.anchorY_ = undefined;
  this.height_ = undefined;
  this.opacity_ = undefined;
  this.originX_ = undefined;
  this.originY_ = undefined;
  this.rotateWithView_ = undefined;
  this.rotation_ = undefined;
  this.scale_ = undefined;
  this.snapToPixel_ = undefined;
  this.width_ = undefined;
};
ol.inherits(ol.render.canvas.ImageReplay, ol.render.canvas.Replay);
ol.render.canvas.ImageReplay.prototype.drawCoordinates_ = function(flatCoordinates, offset, end, stride) {
  return this.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);
};
ol.render.canvas.ImageReplay.prototype.drawPoint = function(pointGeometry, feature) {
  if (!this.image_) {
    return;
  }
  this.beginGeometry(pointGeometry, feature);
  var flatCoordinates = pointGeometry.getFlatCoordinates();
  var stride = pointGeometry.getStride();
  var myBegin = this.coordinates.length;
  var myEnd = this.drawCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
  this.instructions.push([ol.render.canvas.Instruction.DRAW_IMAGE, myBegin, myEnd, this.image_, this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_ * this.pixelRatio, this.snapToPixel_, this.width_]);
  this.hitDetectionInstructions.push([ol.render.canvas.Instruction.DRAW_IMAGE, myBegin, myEnd, this.hitDetectionImage_, this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_, this.snapToPixel_, this.width_]);
  this.endGeometry(pointGeometry, feature);
};
ol.render.canvas.ImageReplay.prototype.drawMultiPoint = function(multiPointGeometry, feature) {
  if (!this.image_) {
    return;
  }
  this.beginGeometry(multiPointGeometry, feature);
  var flatCoordinates = multiPointGeometry.getFlatCoordinates();
  var stride = multiPointGeometry.getStride();
  var myBegin = this.coordinates.length;
  var myEnd = this.drawCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
  this.instructions.push([ol.render.canvas.Instruction.DRAW_IMAGE, myBegin, myEnd, this.image_, this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_ * this.pixelRatio, this.snapToPixel_, this.width_]);
  this.hitDetectionInstructions.push([ol.render.canvas.Instruction.DRAW_IMAGE, myBegin, myEnd, this.hitDetectionImage_, this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_, this.snapToPixel_, this.width_]);
  this.endGeometry(multiPointGeometry, feature);
};
ol.render.canvas.ImageReplay.prototype.finish = function() {
  this.reverseHitDetectionInstructions();
  this.anchorX_ = undefined;
  this.anchorY_ = undefined;
  this.hitDetectionImage_ = null;
  this.image_ = null;
  this.height_ = undefined;
  this.scale_ = undefined;
  this.opacity_ = undefined;
  this.originX_ = undefined;
  this.originY_ = undefined;
  this.rotateWithView_ = undefined;
  this.rotation_ = undefined;
  this.snapToPixel_ = undefined;
  this.width_ = undefined;
};
ol.render.canvas.ImageReplay.prototype.setImageStyle = function(imageStyle, declutterGroup) {
  var anchor = imageStyle.getAnchor();
  var size = imageStyle.getSize();
  var hitDetectionImage = imageStyle.getHitDetectionImage(1);
  var image = imageStyle.getImage(1);
  var origin = imageStyle.getOrigin();
  this.anchorX_ = anchor[0];
  this.anchorY_ = anchor[1];
  this.declutterGroup_ = declutterGroup;
  this.hitDetectionImage_ = hitDetectionImage;
  this.image_ = image;
  this.height_ = size[1];
  this.opacity_ = imageStyle.getOpacity();
  this.originX_ = origin[0];
  this.originY_ = origin[1];
  this.rotateWithView_ = imageStyle.getRotateWithView();
  this.rotation_ = imageStyle.getRotation();
  this.scale_ = imageStyle.getScale();
  this.snapToPixel_ = imageStyle.getSnapToPixel();
  this.width_ = size[0];
};
goog.provide("ol.render.canvas.LineStringReplay");
goog.require("ol");
goog.require("ol.render.canvas.Instruction");
goog.require("ol.render.canvas.Replay");
ol.render.canvas.LineStringReplay = function(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {
  ol.render.canvas.Replay.call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);
};
ol.inherits(ol.render.canvas.LineStringReplay, ol.render.canvas.Replay);
ol.render.canvas.LineStringReplay.prototype.drawFlatCoordinates_ = function(flatCoordinates, offset, end, stride) {
  var myBegin = this.coordinates.length;
  var myEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);
  var moveToLineToInstruction = [ol.render.canvas.Instruction.MOVE_TO_LINE_TO, myBegin, myEnd];
  this.instructions.push(moveToLineToInstruction);
  this.hitDetectionInstructions.push(moveToLineToInstruction);
  return end;
};
ol.render.canvas.LineStringReplay.prototype.drawLineString = function(lineStringGeometry, feature) {
  var state = this.state;
  var strokeStyle = state.strokeStyle;
  var lineWidth = state.lineWidth;
  if (strokeStyle === undefined || lineWidth === undefined) {
    return;
  }
  this.updateStrokeStyle(state, this.applyStroke);
  this.beginGeometry(lineStringGeometry, feature);
  this.hitDetectionInstructions.push([ol.render.canvas.Instruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset], [ol.render.canvas.Instruction.BEGIN_PATH]);
  var flatCoordinates = lineStringGeometry.getFlatCoordinates();
  var stride = lineStringGeometry.getStride();
  this.drawFlatCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
  this.hitDetectionInstructions.push([ol.render.canvas.Instruction.STROKE]);
  this.endGeometry(lineStringGeometry, feature);
};
ol.render.canvas.LineStringReplay.prototype.drawMultiLineString = function(multiLineStringGeometry, feature) {
  var state = this.state;
  var strokeStyle = state.strokeStyle;
  var lineWidth = state.lineWidth;
  if (strokeStyle === undefined || lineWidth === undefined) {
    return;
  }
  this.updateStrokeStyle(state, this.applyStroke);
  this.beginGeometry(multiLineStringGeometry, feature);
  this.hitDetectionInstructions.push([ol.render.canvas.Instruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset], [ol.render.canvas.Instruction.BEGIN_PATH]);
  var ends = multiLineStringGeometry.getEnds();
  var flatCoordinates = multiLineStringGeometry.getFlatCoordinates();
  var stride = multiLineStringGeometry.getStride();
  var offset = 0;
  var i, ii;
  for (i = 0, ii = ends.length; i < ii; ++i) {
    offset = this.drawFlatCoordinates_(flatCoordinates, offset, ends[i], stride);
  }
  this.hitDetectionInstructions.push([ol.render.canvas.Instruction.STROKE]);
  this.endGeometry(multiLineStringGeometry, feature);
};
ol.render.canvas.LineStringReplay.prototype.finish = function() {
  var state = this.state;
  if (state.lastStroke != undefined && state.lastStroke != this.coordinates.length) {
    this.instructions.push([ol.render.canvas.Instruction.STROKE]);
  }
  this.reverseHitDetectionInstructions();
  this.state = null;
};
ol.render.canvas.LineStringReplay.prototype.applyStroke = function(state) {
  if (state.lastStroke != undefined && state.lastStroke != this.coordinates.length) {
    this.instructions.push([ol.render.canvas.Instruction.STROKE]);
    state.lastStroke = this.coordinates.length;
  }
  state.lastStroke = 0;
  ol.render.canvas.Replay.prototype.applyStroke.call(this, state);
  this.instructions.push([ol.render.canvas.Instruction.BEGIN_PATH]);
};
goog.provide("ol.render.canvas.PolygonReplay");
goog.require("ol");
goog.require("ol.color");
goog.require("ol.geom.flat.simplify");
goog.require("ol.render.canvas");
goog.require("ol.render.canvas.Instruction");
goog.require("ol.render.canvas.Replay");
ol.render.canvas.PolygonReplay = function(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {
  ol.render.canvas.Replay.call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);
};
ol.inherits(ol.render.canvas.PolygonReplay, ol.render.canvas.Replay);
ol.render.canvas.PolygonReplay.prototype.drawFlatCoordinatess_ = function(flatCoordinates, offset, ends, stride) {
  var state = this.state;
  var fill = state.fillStyle !== undefined;
  var stroke = state.strokeStyle != undefined;
  var numEnds = ends.length;
  var beginPathInstruction = [ol.render.canvas.Instruction.BEGIN_PATH];
  this.instructions.push(beginPathInstruction);
  this.hitDetectionInstructions.push(beginPathInstruction);
  for (var i = 0; i < numEnds; ++i) {
    var end = ends[i];
    var myBegin = this.coordinates.length;
    var myEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, true, !stroke);
    var moveToLineToInstruction = [ol.render.canvas.Instruction.MOVE_TO_LINE_TO, myBegin, myEnd];
    this.instructions.push(moveToLineToInstruction);
    this.hitDetectionInstructions.push(moveToLineToInstruction);
    if (stroke) {
      var closePathInstruction = [ol.render.canvas.Instruction.CLOSE_PATH];
      this.instructions.push(closePathInstruction);
      this.hitDetectionInstructions.push(closePathInstruction);
    }
    offset = end;
  }
  var fillInstruction = [ol.render.canvas.Instruction.FILL];
  this.hitDetectionInstructions.push(fillInstruction);
  if (fill) {
    this.instructions.push(fillInstruction);
  }
  if (stroke) {
    var strokeInstruction = [ol.render.canvas.Instruction.STROKE];
    this.instructions.push(strokeInstruction);
    this.hitDetectionInstructions.push(strokeInstruction);
  }
  return offset;
};
ol.render.canvas.PolygonReplay.prototype.drawCircle = function(circleGeometry, feature) {
  var state = this.state;
  var fillStyle = state.fillStyle;
  var strokeStyle = state.strokeStyle;
  if (fillStyle === undefined && strokeStyle === undefined) {
    return;
  }
  this.setFillStrokeStyles_(circleGeometry);
  this.beginGeometry(circleGeometry, feature);
  this.hitDetectionInstructions.push([ol.render.canvas.Instruction.SET_FILL_STYLE, ol.color.asString(ol.render.canvas.defaultFillStyle)]);
  if (state.strokeStyle !== undefined) {
    this.hitDetectionInstructions.push([ol.render.canvas.Instruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);
  }
  var flatCoordinates = circleGeometry.getFlatCoordinates();
  var stride = circleGeometry.getStride();
  var myBegin = this.coordinates.length;
  this.appendFlatCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);
  var beginPathInstruction = [ol.render.canvas.Instruction.BEGIN_PATH];
  var circleInstruction = [ol.render.canvas.Instruction.CIRCLE, myBegin];
  this.instructions.push(beginPathInstruction, circleInstruction);
  this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);
  var fillInstruction = [ol.render.canvas.Instruction.FILL];
  this.hitDetectionInstructions.push(fillInstruction);
  if (state.fillStyle !== undefined) {
    this.instructions.push(fillInstruction);
  }
  if (state.strokeStyle !== undefined) {
    var strokeInstruction = [ol.render.canvas.Instruction.STROKE];
    this.instructions.push(strokeInstruction);
    this.hitDetectionInstructions.push(strokeInstruction);
  }
  this.endGeometry(circleGeometry, feature);
};
ol.render.canvas.PolygonReplay.prototype.drawPolygon = function(polygonGeometry, feature) {
  var state = this.state;
  this.setFillStrokeStyles_(polygonGeometry);
  this.beginGeometry(polygonGeometry, feature);
  this.hitDetectionInstructions.push([ol.render.canvas.Instruction.SET_FILL_STYLE, ol.color.asString(ol.render.canvas.defaultFillStyle)]);
  if (state.strokeStyle !== undefined) {
    this.hitDetectionInstructions.push([ol.render.canvas.Instruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);
  }
  var ends = polygonGeometry.getEnds();
  var flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();
  var stride = polygonGeometry.getStride();
  this.drawFlatCoordinatess_(flatCoordinates, 0, ends, stride);
  this.endGeometry(polygonGeometry, feature);
};
ol.render.canvas.PolygonReplay.prototype.drawMultiPolygon = function(multiPolygonGeometry, feature) {
  var state = this.state;
  var fillStyle = state.fillStyle;
  var strokeStyle = state.strokeStyle;
  if (fillStyle === undefined && strokeStyle === undefined) {
    return;
  }
  this.setFillStrokeStyles_(multiPolygonGeometry);
  this.beginGeometry(multiPolygonGeometry, feature);
  this.hitDetectionInstructions.push([ol.render.canvas.Instruction.SET_FILL_STYLE, ol.color.asString(ol.render.canvas.defaultFillStyle)]);
  if (state.strokeStyle !== undefined) {
    this.hitDetectionInstructions.push([ol.render.canvas.Instruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);
  }
  var endss = multiPolygonGeometry.getEndss();
  var flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();
  var stride = multiPolygonGeometry.getStride();
  var offset = 0;
  var i, ii;
  for (i = 0, ii = endss.length; i < ii; ++i) {
    offset = this.drawFlatCoordinatess_(flatCoordinates, offset, endss[i], stride);
  }
  this.endGeometry(multiPolygonGeometry, feature);
};
ol.render.canvas.PolygonReplay.prototype.finish = function() {
  this.reverseHitDetectionInstructions();
  this.state = null;
  var tolerance = this.tolerance;
  if (tolerance !== 0) {
    var coordinates = this.coordinates;
    var i, ii;
    for (i = 0, ii = coordinates.length; i < ii; ++i) {
      coordinates[i] = ol.geom.flat.simplify.snap(coordinates[i], tolerance);
    }
  }
};
ol.render.canvas.PolygonReplay.prototype.setFillStrokeStyles_ = function(geometry) {
  var state = this.state;
  var fillStyle = state.fillStyle;
  if (fillStyle !== undefined) {
    this.updateFillStyle(state, this.applyFill, geometry);
  }
  if (state.strokeStyle !== undefined) {
    this.updateStrokeStyle(state, this.applyStroke);
  }
};
goog.provide("ol.geom.flat.straightchunk");
ol.geom.flat.straightchunk.lineString = function(maxAngle, flatCoordinates, offset, end, stride) {
  var chunkStart = offset;
  var chunkEnd = offset;
  var chunkM = 0;
  var m = 0;
  var start = offset;
  var acos, i, m12, m23, x1, y1, x12, y12, x23, y23;
  for (i = offset; i < end; i += stride) {
    var x2 = flatCoordinates[i];
    var y2 = flatCoordinates[i + 1];
    if (x1 !== undefined) {
      x23 = x2 - x1;
      y23 = y2 - y1;
      m23 = Math.sqrt(x23 * x23 + y23 * y23);
      if (x12 !== undefined) {
        m += m12;
        acos = Math.acos((x12 * x23 + y12 * y23) / (m12 * m23));
        if (acos > maxAngle) {
          if (m > chunkM) {
            chunkM = m;
            chunkStart = start;
            chunkEnd = i;
          }
          m = 0;
          start = i - stride;
        }
      }
      m12 = m23;
      x12 = x23;
      y12 = y23;
    }
    x1 = x2;
    y1 = y2;
  }
  m += m23;
  return m > chunkM ? [start, i] : [chunkStart, chunkEnd];
};
goog.provide("ol.style.TextPlacement");
ol.style.TextPlacement = {POINT:"point", LINE:"line"};
goog.provide("ol.render.canvas.TextReplay");
goog.require("ol");
goog.require("ol.colorlike");
goog.require("ol.dom");
goog.require("ol.extent");
goog.require("ol.geom.flat.straightchunk");
goog.require("ol.geom.GeometryType");
goog.require("ol.has");
goog.require("ol.render.canvas");
goog.require("ol.render.canvas.Instruction");
goog.require("ol.render.canvas.Replay");
goog.require("ol.render.replay");
goog.require("ol.style.TextPlacement");
ol.render.canvas.TextReplay = function(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {
  ol.render.canvas.Replay.call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);
  this.declutterGroup_;
  this.labels_ = null;
  this.text_ = "";
  this.textOffsetX_ = 0;
  this.textOffsetY_ = 0;
  this.textRotateWithView_ = undefined;
  this.textRotation_ = 0;
  this.textFillState_ = null;
  this.fillStates = {};
  this.textStrokeState_ = null;
  this.strokeStates = {};
  this.textState_ = {};
  this.textStates = {};
  this.textKey_ = "";
  this.fillKey_ = "";
  this.strokeKey_ = "";
  this.widths_ = {};
  var labelCache = ol.render.canvas.labelCache;
  labelCache.prune();
};
ol.inherits(ol.render.canvas.TextReplay, ol.render.canvas.Replay);
ol.render.canvas.TextReplay.measureTextWidths = function(font, lines, widths) {
  var numLines = lines.length;
  var width = 0;
  var currentWidth, i;
  for (i = 0; i < numLines; ++i) {
    currentWidth = ol.render.canvas.measureTextWidth(font, lines[i]);
    width = Math.max(width, currentWidth);
    widths.push(currentWidth);
  }
  return width;
};
ol.render.canvas.TextReplay.prototype.drawText = function(geometry, feature) {
  var fillState = this.textFillState_;
  var strokeState = this.textStrokeState_;
  var textState = this.textState_;
  if (this.text_ === "" || !textState || !fillState && !strokeState) {
    return;
  }
  var begin = this.coordinates.length;
  var geometryType = geometry.getType();
  var flatCoordinates = null;
  var end = 2;
  var stride = 2;
  var i, ii;
  if (textState.placement === ol.style.TextPlacement.LINE) {
    if (!ol.extent.intersects(this.getBufferedMaxExtent(), geometry.getExtent())) {
      return;
    }
    var ends;
    flatCoordinates = geometry.getFlatCoordinates();
    stride = geometry.getStride();
    if (geometryType == ol.geom.GeometryType.LINE_STRING) {
      ends = [flatCoordinates.length];
    } else {
      if (geometryType == ol.geom.GeometryType.MULTI_LINE_STRING) {
        ends = geometry.getEnds();
      } else {
        if (geometryType == ol.geom.GeometryType.POLYGON) {
          ends = geometry.getEnds().slice(0, 1);
        } else {
          if (geometryType == ol.geom.GeometryType.MULTI_POLYGON) {
            var endss = geometry.getEndss();
            ends = [];
            for (i = 0, ii = endss.length; i < ii; ++i) {
              ends.push(endss[i][0]);
            }
          }
        }
      }
    }
    this.beginGeometry(geometry, feature);
    var textAlign = textState.textAlign;
    var flatOffset = 0;
    var flatEnd;
    for (var o = 0, oo = ends.length; o < oo; ++o) {
      if (textAlign == undefined) {
        var range = ol.geom.flat.straightchunk.lineString(textState.maxAngle, flatCoordinates, flatOffset, ends[o], stride);
        flatOffset = range[0];
        flatEnd = range[1];
      } else {
        flatEnd = ends[o];
      }
      for (i = flatOffset; i < flatEnd; i += stride) {
        this.coordinates.push(flatCoordinates[i], flatCoordinates[i + 1]);
      }
      end = this.coordinates.length;
      flatOffset = ends[o];
      this.drawChars_(begin, end, this.declutterGroup_);
      begin = end;
    }
    this.endGeometry(geometry, feature);
  } else {
    var label = this.getImage(this.text_, this.textKey_, this.fillKey_, this.strokeKey_);
    var width = label.width / this.pixelRatio;
    switch(geometryType) {
      case ol.geom.GeometryType.POINT:
      case ol.geom.GeometryType.MULTI_POINT:
        flatCoordinates = geometry.getFlatCoordinates();
        end = flatCoordinates.length;
        break;
      case ol.geom.GeometryType.LINE_STRING:
        flatCoordinates = geometry.getFlatMidpoint();
        break;
      case ol.geom.GeometryType.CIRCLE:
        flatCoordinates = geometry.getCenter();
        break;
      case ol.geom.GeometryType.MULTI_LINE_STRING:
        flatCoordinates = geometry.getFlatMidpoints();
        end = flatCoordinates.length;
        break;
      case ol.geom.GeometryType.POLYGON:
        flatCoordinates = geometry.getFlatInteriorPoint();
        if (!textState.overflow && flatCoordinates[2] / this.resolution < width) {
          return;
        }
        stride = 3;
        break;
      case ol.geom.GeometryType.MULTI_POLYGON:
        var interiorPoints = geometry.getFlatInteriorPoints();
        flatCoordinates = [];
        for (i = 0, ii = interiorPoints.length; i < ii; i += 3) {
          if (textState.overflow || interiorPoints[i + 2] / this.resolution >= width) {
            flatCoordinates.push(interiorPoints[i], interiorPoints[i + 1]);
          }
        }
        end = flatCoordinates.length;
        if (end == 0) {
          return;
        }
        break;
      default:
    }
    end = this.appendFlatCoordinates(flatCoordinates, 0, end, stride, false, false);
    this.beginGeometry(geometry, feature);
    if (textState.backgroundFill || textState.backgroundStroke) {
      this.setFillStrokeStyle(textState.backgroundFill, textState.backgroundStroke);
      this.updateFillStyle(this.state, this.applyFill, geometry);
      this.updateStrokeStyle(this.state, this.applyStroke);
    }
    this.drawTextImage_(label, begin, end);
    this.endGeometry(geometry, feature);
  }
};
ol.render.canvas.TextReplay.prototype.getImage = function(text, textKey, fillKey, strokeKey) {
  var label;
  var key = strokeKey + textKey + text + fillKey + this.pixelRatio;
  var labelCache = ol.render.canvas.labelCache;
  if (!labelCache.containsKey(key)) {
    var strokeState = strokeKey ? this.strokeStates[strokeKey] || this.textStrokeState_ : null;
    var fillState = fillKey ? this.fillStates[fillKey] || this.textFillState_ : null;
    var textState = this.textStates[textKey] || this.textState_;
    var pixelRatio = this.pixelRatio;
    var scale = textState.scale * pixelRatio;
    var align = ol.render.replay.TEXT_ALIGN[textState.textAlign || ol.render.canvas.defaultTextAlign];
    var strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;
    var lines = text.split("\n");
    var numLines = lines.length;
    var widths = [];
    var width = ol.render.canvas.TextReplay.measureTextWidths(textState.font, lines, widths);
    var lineHeight = ol.render.canvas.measureTextHeight(textState.font);
    var height = lineHeight * numLines;
    var renderWidth = width + strokeWidth;
    var context = ol.dom.createCanvasContext2D(Math.ceil(renderWidth * scale), Math.ceil((height + strokeWidth) * scale));
    label = context.canvas;
    labelCache.set(key, label);
    if (scale != 1) {
      context.scale(scale, scale);
    }
    context.font = textState.font;
    if (strokeKey) {
      context.strokeStyle = strokeState.strokeStyle;
      context.lineWidth = strokeWidth * (ol.has.SAFARI ? scale : 1);
      context.lineCap = strokeState.lineCap;
      context.lineJoin = strokeState.lineJoin;
      context.miterLimit = strokeState.miterLimit;
      if (ol.has.CANVAS_LINE_DASH && strokeState.lineDash.length) {
        context.setLineDash(strokeState.lineDash);
        context.lineDashOffset = strokeState.lineDashOffset;
      }
    }
    if (fillKey) {
      context.fillStyle = fillState.fillStyle;
    }
    context.textBaseline = "middle";
    context.textAlign = "center";
    var leftRight = 0.5 - align;
    var x = align * label.width / scale + leftRight * strokeWidth;
    var i;
    if (strokeKey) {
      for (i = 0; i < numLines; ++i) {
        context.strokeText(lines[i], x + leftRight * widths[i], 0.5 * (strokeWidth + lineHeight) + i * lineHeight);
      }
    }
    if (fillKey) {
      for (i = 0; i < numLines; ++i) {
        context.fillText(lines[i], x + leftRight * widths[i], 0.5 * (strokeWidth + lineHeight) + i * lineHeight);
      }
    }
  }
  return labelCache.get(key);
};
ol.render.canvas.TextReplay.prototype.drawTextImage_ = function(label, begin, end) {
  var textState = this.textState_;
  var strokeState = this.textStrokeState_;
  var pixelRatio = this.pixelRatio;
  var align = ol.render.replay.TEXT_ALIGN[textState.textAlign || ol.render.canvas.defaultTextAlign];
  var baseline = ol.render.replay.TEXT_ALIGN[textState.textBaseline];
  var strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;
  var anchorX = align * label.width / pixelRatio + 2 * (0.5 - align) * strokeWidth;
  var anchorY = baseline * label.height / pixelRatio + 2 * (0.5 - baseline) * strokeWidth;
  this.instructions.push([ol.render.canvas.Instruction.DRAW_IMAGE, begin, end, label, (anchorX - this.textOffsetX_) * pixelRatio, (anchorY - this.textOffsetY_) * pixelRatio, this.declutterGroup_, label.height, 1, 0, 0, this.textRotateWithView_, this.textRotation_, 1, true, label.width, textState.padding == ol.render.canvas.defaultPadding ? ol.render.canvas.defaultPadding : textState.padding.map(function(p) {
    return p * pixelRatio;
  }), !!textState.backgroundFill, !!textState.backgroundStroke]);
  this.hitDetectionInstructions.push([ol.render.canvas.Instruction.DRAW_IMAGE, begin, end, label, (anchorX - this.textOffsetX_) * pixelRatio, (anchorY - this.textOffsetY_) * pixelRatio, this.declutterGroup_, label.height, 1, 0, 0, this.textRotateWithView_, this.textRotation_, 1 / pixelRatio, true, label.width, textState.padding, !!textState.backgroundFill, !!textState.backgroundStroke]);
};
ol.render.canvas.TextReplay.prototype.drawChars_ = function(begin, end, declutterGroup) {
  var strokeState = this.textStrokeState_;
  var textState = this.textState_;
  var fillState = this.textFillState_;
  var strokeKey = this.strokeKey_;
  if (strokeState) {
    if (!(strokeKey in this.strokeStates)) {
      this.strokeStates[strokeKey] = {strokeStyle:strokeState.strokeStyle, lineCap:strokeState.lineCap, lineDashOffset:strokeState.lineDashOffset, lineWidth:strokeState.lineWidth, lineJoin:strokeState.lineJoin, miterLimit:strokeState.miterLimit, lineDash:strokeState.lineDash};
    }
  }
  var textKey = this.textKey_;
  if (!(this.textKey_ in this.textStates)) {
    this.textStates[this.textKey_] = {font:textState.font, textAlign:textState.textAlign || ol.render.canvas.defaultTextAlign, scale:textState.scale};
  }
  var fillKey = this.fillKey_;
  if (fillState) {
    if (!(fillKey in this.fillStates)) {
      this.fillStates[fillKey] = {fillStyle:fillState.fillStyle};
    }
  }
  var pixelRatio = this.pixelRatio;
  var baseline = ol.render.replay.TEXT_ALIGN[textState.textBaseline];
  var offsetY = this.textOffsetY_ * pixelRatio;
  var text = this.text_;
  var font = textState.font;
  var textScale = textState.scale;
  var strokeWidth = strokeState ? strokeState.lineWidth * textScale / 2 : 0;
  var widths = this.widths_[font];
  if (!widths) {
    this.widths_[font] = widths = {};
  }
  this.instructions.push([ol.render.canvas.Instruction.DRAW_CHARS, begin, end, baseline, declutterGroup, textState.overflow, fillKey, textState.maxAngle, function(text) {
    var width = widths[text];
    if (!width) {
      width = widths[text] = ol.render.canvas.measureTextWidth(font, text);
    }
    return width * textScale * pixelRatio;
  }, offsetY, strokeKey, strokeWidth * pixelRatio, text, textKey, 1]);
  this.hitDetectionInstructions.push([ol.render.canvas.Instruction.DRAW_CHARS, begin, end, baseline, declutterGroup, textState.overflow, fillKey, textState.maxAngle, function(text) {
    var width = widths[text];
    if (!width) {
      width = widths[text] = ol.render.canvas.measureTextWidth(font, text);
    }
    return width * textScale;
  }, offsetY, strokeKey, strokeWidth, text, textKey, 1 / pixelRatio]);
};
ol.render.canvas.TextReplay.prototype.setTextStyle = function(textStyle, declutterGroup) {
  var textState, fillState, strokeState;
  if (!textStyle) {
    this.text_ = "";
  } else {
    this.declutterGroup_ = declutterGroup;
    var textFillStyle = textStyle.getFill();
    if (!textFillStyle) {
      fillState = this.textFillState_ = null;
    } else {
      fillState = this.textFillState_;
      if (!fillState) {
        fillState = this.textFillState_ = {};
      }
      fillState.fillStyle = ol.colorlike.asColorLike(textFillStyle.getColor() || ol.render.canvas.defaultFillStyle);
    }
    var textStrokeStyle = textStyle.getStroke();
    if (!textStrokeStyle) {
      strokeState = this.textStrokeState_ = null;
    } else {
      strokeState = this.textStrokeState_;
      if (!strokeState) {
        strokeState = this.textStrokeState_ = {};
      }
      var lineDash = textStrokeStyle.getLineDash();
      var lineDashOffset = textStrokeStyle.getLineDashOffset();
      var lineWidth = textStrokeStyle.getWidth();
      var miterLimit = textStrokeStyle.getMiterLimit();
      strokeState.lineCap = textStrokeStyle.getLineCap() || ol.render.canvas.defaultLineCap;
      strokeState.lineDash = lineDash ? lineDash.slice() : ol.render.canvas.defaultLineDash;
      strokeState.lineDashOffset = lineDashOffset === undefined ? ol.render.canvas.defaultLineDashOffset : lineDashOffset;
      strokeState.lineJoin = textStrokeStyle.getLineJoin() || ol.render.canvas.defaultLineJoin;
      strokeState.lineWidth = lineWidth === undefined ? ol.render.canvas.defaultLineWidth : lineWidth;
      strokeState.miterLimit = miterLimit === undefined ? ol.render.canvas.defaultMiterLimit : miterLimit;
      strokeState.strokeStyle = ol.colorlike.asColorLike(textStrokeStyle.getColor() || ol.render.canvas.defaultStrokeStyle);
    }
    textState = this.textState_;
    var font = textStyle.getFont() || ol.render.canvas.defaultFont;
    ol.render.canvas.checkFont(font);
    var textScale = textStyle.getScale();
    textState.overflow = textStyle.getOverflow();
    textState.font = font;
    textState.maxAngle = textStyle.getMaxAngle();
    textState.placement = textStyle.getPlacement();
    textState.textAlign = textStyle.getTextAlign();
    textState.textBaseline = textStyle.getTextBaseline() || ol.render.canvas.defaultTextBaseline;
    textState.backgroundFill = textStyle.getBackgroundFill();
    textState.backgroundStroke = textStyle.getBackgroundStroke();
    textState.padding = textStyle.getPadding() || ol.render.canvas.defaultPadding;
    textState.scale = textScale === undefined ? 1 : textScale;
    var textOffsetX = textStyle.getOffsetX();
    var textOffsetY = textStyle.getOffsetY();
    var textRotateWithView = textStyle.getRotateWithView();
    var textRotation = textStyle.getRotation();
    this.text_ = textStyle.getText() || "";
    this.textOffsetX_ = textOffsetX === undefined ? 0 : textOffsetX;
    this.textOffsetY_ = textOffsetY === undefined ? 0 : textOffsetY;
    this.textRotateWithView_ = textRotateWithView === undefined ? false : textRotateWithView;
    this.textRotation_ = textRotation === undefined ? 0 : textRotation;
    this.strokeKey_ = strokeState ? (typeof strokeState.strokeStyle == "string" ? strokeState.strokeStyle : ol.getUid(strokeState.strokeStyle)) + strokeState.lineCap + strokeState.lineDashOffset + "|" + strokeState.lineWidth + strokeState.lineJoin + strokeState.miterLimit + "[" + strokeState.lineDash.join() + "]" : "";
    this.textKey_ = textState.font + textState.scale + (textState.textAlign || "?");
    this.fillKey_ = fillState ? typeof fillState.fillStyle == "string" ? fillState.fillStyle : "|" + ol.getUid(fillState.fillStyle) : "";
  }
};
goog.provide("ol.render.canvas.ReplayGroup");
goog.require("ol");
goog.require("ol.array");
goog.require("ol.dom");
goog.require("ol.extent");
goog.require("ol.geom.flat.transform");
goog.require("ol.obj");
goog.require("ol.render.ReplayGroup");
goog.require("ol.render.ReplayType");
goog.require("ol.render.canvas.Replay");
goog.require("ol.render.canvas.ImageReplay");
goog.require("ol.render.canvas.LineStringReplay");
goog.require("ol.render.canvas.PolygonReplay");
goog.require("ol.render.canvas.TextReplay");
goog.require("ol.render.replay");
goog.require("ol.transform");
ol.render.canvas.ReplayGroup = function(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree, opt_renderBuffer) {
  ol.render.ReplayGroup.call(this);
  this.declutterTree_ = declutterTree;
  this.declutterGroup_ = null;
  this.tolerance_ = tolerance;
  this.maxExtent_ = maxExtent;
  this.overlaps_ = overlaps;
  this.pixelRatio_ = pixelRatio;
  this.resolution_ = resolution;
  this.renderBuffer_ = opt_renderBuffer;
  this.replaysByZIndex_ = {};
  this.hitDetectionContext_ = ol.dom.createCanvasContext2D(1, 1);
  this.hitDetectionTransform_ = ol.transform.create();
};
ol.inherits(ol.render.canvas.ReplayGroup, ol.render.ReplayGroup);
ol.render.canvas.ReplayGroup.circleArrayCache_ = {0:[[true]]};
ol.render.canvas.ReplayGroup.fillCircleArrayRowToMiddle_ = function(array, x, y) {
  var i;
  var radius = Math.floor(array.length / 2);
  if (x >= radius) {
    for (i = radius; i < x; i++) {
      array[i][y] = true;
    }
  } else {
    if (x < radius) {
      for (i = x + 1; i < radius; i++) {
        array[i][y] = true;
      }
    }
  }
};
ol.render.canvas.ReplayGroup.getCircleArray_ = function(radius) {
  if (ol.render.canvas.ReplayGroup.circleArrayCache_[radius] !== undefined) {
    return ol.render.canvas.ReplayGroup.circleArrayCache_[radius];
  }
  var arraySize = radius * 2 + 1;
  var arr = new Array(arraySize);
  for (var i = 0; i < arraySize; i++) {
    arr[i] = new Array(arraySize);
  }
  var x = radius;
  var y = 0;
  var error = 0;
  while (x >= y) {
    ol.render.canvas.ReplayGroup.fillCircleArrayRowToMiddle_(arr, radius + x, radius + y);
    ol.render.canvas.ReplayGroup.fillCircleArrayRowToMiddle_(arr, radius + y, radius + x);
    ol.render.canvas.ReplayGroup.fillCircleArrayRowToMiddle_(arr, radius - y, radius + x);
    ol.render.canvas.ReplayGroup.fillCircleArrayRowToMiddle_(arr, radius - x, radius + y);
    ol.render.canvas.ReplayGroup.fillCircleArrayRowToMiddle_(arr, radius - x, radius - y);
    ol.render.canvas.ReplayGroup.fillCircleArrayRowToMiddle_(arr, radius - y, radius - x);
    ol.render.canvas.ReplayGroup.fillCircleArrayRowToMiddle_(arr, radius + y, radius - x);
    ol.render.canvas.ReplayGroup.fillCircleArrayRowToMiddle_(arr, radius + x, radius - y);
    y++;
    error += 1 + 2 * y;
    if (2 * (error - x) + 1 > 0) {
      x -= 1;
      error += 1 - 2 * x;
    }
  }
  ol.render.canvas.ReplayGroup.circleArrayCache_[radius] = arr;
  return arr;
};
ol.render.canvas.ReplayGroup.replayDeclutter = function(declutterReplays, context, rotation) {
  var zs = Object.keys(declutterReplays).map(Number).sort(ol.array.numberSafeCompareFunction);
  var skippedFeatureUids = {};
  for (var z = 0, zz = zs.length; z < zz; ++z) {
    var replayData = declutterReplays[zs[z].toString()];
    for (var i = 0, ii = replayData.length; i < ii;) {
      var replay = replayData[i++];
      var transform = replayData[i++];
      replay.replay(context, transform, rotation, skippedFeatureUids);
    }
  }
};
ol.render.canvas.ReplayGroup.prototype.addDeclutter = function(group) {
  var declutter = null;
  if (this.declutterTree_) {
    if (group) {
      declutter = this.declutterGroup_;
      declutter[4]++;
    } else {
      declutter = this.declutterGroup_ = ol.extent.createEmpty();
      declutter.push(1);
    }
  }
  return declutter;
};
ol.render.canvas.ReplayGroup.prototype.clip = function(context, transform) {
  var flatClipCoords = this.getClipCoords(transform);
  context.beginPath();
  context.moveTo(flatClipCoords[0], flatClipCoords[1]);
  context.lineTo(flatClipCoords[2], flatClipCoords[3]);
  context.lineTo(flatClipCoords[4], flatClipCoords[5]);
  context.lineTo(flatClipCoords[6], flatClipCoords[7]);
  context.clip();
};
ol.render.canvas.ReplayGroup.prototype.hasReplays = function(replays) {
  for (var zIndex in this.replaysByZIndex_) {
    var candidates = this.replaysByZIndex_[zIndex];
    for (var i = 0, ii = replays.length; i < ii; ++i) {
      if (replays[i] in candidates) {
        return true;
      }
    }
  }
  return false;
};
ol.render.canvas.ReplayGroup.prototype.finish = function() {
  var zKey;
  for (zKey in this.replaysByZIndex_) {
    var replays = this.replaysByZIndex_[zKey];
    var replayKey;
    for (replayKey in replays) {
      replays[replayKey].finish();
    }
  }
};
ol.render.canvas.ReplayGroup.prototype.forEachFeatureAtCoordinate = function(coordinate, resolution, rotation, hitTolerance, skippedFeaturesHash, callback, declutterReplays) {
  hitTolerance = Math.round(hitTolerance);
  var contextSize = hitTolerance * 2 + 1;
  var transform = ol.transform.compose(this.hitDetectionTransform_, hitTolerance + 0.5, hitTolerance + 0.5, 1 / resolution, -1 / resolution, -rotation, -coordinate[0], -coordinate[1]);
  var context = this.hitDetectionContext_;
  if (context.canvas.width !== contextSize || context.canvas.height !== contextSize) {
    context.canvas.width = contextSize;
    context.canvas.height = contextSize;
  } else {
    context.clearRect(0, 0, contextSize, contextSize);
  }
  var hitExtent;
  if (this.renderBuffer_ !== undefined) {
    hitExtent = ol.extent.createEmpty();
    ol.extent.extendCoordinate(hitExtent, coordinate);
    ol.extent.buffer(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);
  }
  var mask = ol.render.canvas.ReplayGroup.getCircleArray_(hitTolerance);
  var declutteredFeatures;
  if (this.declutterTree_) {
    declutteredFeatures = this.declutterTree_.all().map(function(entry) {
      return entry.value;
    });
  }
  var replayType;
  function featureCallback(feature) {
    var imageData = context.getImageData(0, 0, contextSize, contextSize).data;
    for (var i = 0; i < contextSize; i++) {
      for (var j = 0; j < contextSize; j++) {
        if (mask[i][j]) {
          if (imageData[(j * contextSize + i) * 4 + 3] > 0) {
            var result;
            if (!(declutteredFeatures && (replayType == ol.render.ReplayType.IMAGE || replayType == ol.render.ReplayType.TEXT)) || declutteredFeatures.indexOf(feature) !== -1) {
              result = callback(feature);
            }
            if (result) {
              return result;
            } else {
              context.clearRect(0, 0, contextSize, contextSize);
              return undefined;
            }
          }
        }
      }
    }
  }
  var zs = Object.keys(this.replaysByZIndex_).map(Number);
  zs.sort(ol.array.numberSafeCompareFunction);
  var i, j, replays, replay, result;
  for (i = zs.length - 1; i >= 0; --i) {
    var zIndexKey = zs[i].toString();
    replays = this.replaysByZIndex_[zIndexKey];
    for (j = ol.render.replay.ORDER.length - 1; j >= 0; --j) {
      replayType = ol.render.replay.ORDER[j];
      replay = replays[replayType];
      if (replay !== undefined) {
        if (declutterReplays && (replayType == ol.render.ReplayType.IMAGE || replayType == ol.render.ReplayType.TEXT)) {
          var declutter = declutterReplays[zIndexKey];
          if (!declutter) {
            declutterReplays[zIndexKey] = [replay, transform.slice(0)];
          } else {
            declutter.push(replay, transform.slice(0));
          }
        } else {
          result = replay.replayHitDetection(context, transform, rotation, skippedFeaturesHash, featureCallback, hitExtent);
          if (result) {
            return result;
          }
        }
      }
    }
  }
  return undefined;
};
ol.render.canvas.ReplayGroup.prototype.getClipCoords = function(transform) {
  var maxExtent = this.maxExtent_;
  var minX = maxExtent[0];
  var minY = maxExtent[1];
  var maxX = maxExtent[2];
  var maxY = maxExtent[3];
  var flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];
  ol.geom.flat.transform.transform2D(flatClipCoords, 0, 8, 2, transform, flatClipCoords);
  return flatClipCoords;
};
ol.render.canvas.ReplayGroup.prototype.getReplay = function(zIndex, replayType) {
  var zIndexKey = zIndex !== undefined ? zIndex.toString() : "0";
  var replays = this.replaysByZIndex_[zIndexKey];
  if (replays === undefined) {
    replays = {};
    this.replaysByZIndex_[zIndexKey] = replays;
  }
  var replay = replays[replayType];
  if (replay === undefined) {
    var Constructor = ol.render.canvas.ReplayGroup.BATCH_CONSTRUCTORS_[replayType];
    replay = new Constructor(this.tolerance_, this.maxExtent_, this.resolution_, this.pixelRatio_, this.overlaps_, this.declutterTree_);
    replays[replayType] = replay;
  }
  return replay;
};
ol.render.canvas.ReplayGroup.prototype.getReplays = function() {
  return this.replaysByZIndex_;
};
ol.render.canvas.ReplayGroup.prototype.isEmpty = function() {
  return ol.obj.isEmpty(this.replaysByZIndex_);
};
ol.render.canvas.ReplayGroup.prototype.replay = function(context, transform, viewRotation, skippedFeaturesHash, opt_replayTypes, opt_declutterReplays) {
  var zs = Object.keys(this.replaysByZIndex_).map(Number);
  zs.sort(ol.array.numberSafeCompareFunction);
  context.save();
  this.clip(context, transform);
  var replayTypes = opt_replayTypes ? opt_replayTypes : ol.render.replay.ORDER;
  var i, ii, j, jj, replays, replay;
  for (i = 0, ii = zs.length; i < ii; ++i) {
    var zIndexKey = zs[i].toString();
    replays = this.replaysByZIndex_[zIndexKey];
    for (j = 0, jj = replayTypes.length; j < jj; ++j) {
      var replayType = replayTypes[j];
      replay = replays[replayType];
      if (replay !== undefined) {
        if (opt_declutterReplays && (replayType == ol.render.ReplayType.IMAGE || replayType == ol.render.ReplayType.TEXT)) {
          var declutter = opt_declutterReplays[zIndexKey];
          if (!declutter) {
            opt_declutterReplays[zIndexKey] = [replay, transform.slice(0)];
          } else {
            declutter.push(replay, transform.slice(0));
          }
        } else {
          replay.replay(context, transform, viewRotation, skippedFeaturesHash);
        }
      }
    }
  }
  context.restore();
};
ol.render.canvas.ReplayGroup.BATCH_CONSTRUCTORS_ = {"Circle":ol.render.canvas.PolygonReplay, "Default":ol.render.canvas.Replay, "Image":ol.render.canvas.ImageReplay, "LineString":ol.render.canvas.LineStringReplay, "Polygon":ol.render.canvas.PolygonReplay, "Text":ol.render.canvas.TextReplay};
goog.provide("ol.renderer.vector");
goog.require("ol");
goog.require("ol.ImageState");
goog.require("ol.geom.GeometryType");
goog.require("ol.render.ReplayType");
ol.renderer.vector.defaultOrder = function(feature1, feature2) {
  return ol.getUid(feature1) - ol.getUid(feature2);
};
ol.renderer.vector.getSquaredTolerance = function(resolution, pixelRatio) {
  var tolerance = ol.renderer.vector.getTolerance(resolution, pixelRatio);
  return tolerance * tolerance;
};
ol.renderer.vector.getTolerance = function(resolution, pixelRatio) {
  return ol.SIMPLIFY_TOLERANCE * resolution / pixelRatio;
};
ol.renderer.vector.renderCircleGeometry_ = function(replayGroup, geometry, style, feature) {
  var fillStyle = style.getFill();
  var strokeStyle = style.getStroke();
  if (fillStyle || strokeStyle) {
    var circleReplay = replayGroup.getReplay(style.getZIndex(), ol.render.ReplayType.CIRCLE);
    circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    circleReplay.drawCircle(geometry, feature);
  }
  var textStyle = style.getText();
  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), ol.render.ReplayType.TEXT);
    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));
    textReplay.drawText(geometry, feature);
  }
};
ol.renderer.vector.renderFeature = function(replayGroup, feature, style, squaredTolerance, listener, thisArg) {
  var loading = false;
  var imageStyle, imageState;
  imageStyle = style.getImage();
  if (imageStyle) {
    imageState = imageStyle.getImageState();
    if (imageState == ol.ImageState.LOADED || imageState == ol.ImageState.ERROR) {
      imageStyle.unlistenImageChange(listener, thisArg);
    } else {
      if (imageState == ol.ImageState.IDLE) {
        imageStyle.load();
      }
      imageState = imageStyle.getImageState();
      imageStyle.listenImageChange(listener, thisArg);
      loading = true;
    }
  }
  ol.renderer.vector.renderFeature_(replayGroup, feature, style, squaredTolerance);
  return loading;
};
ol.renderer.vector.renderFeature_ = function(replayGroup, feature, style, squaredTolerance) {
  var geometry = style.getGeometryFunction()(feature);
  if (!geometry) {
    return;
  }
  var simplifiedGeometry = geometry.getSimplifiedGeometry(squaredTolerance);
  var renderer = style.getRenderer();
  if (renderer) {
    ol.renderer.vector.renderGeometry_(replayGroup, simplifiedGeometry, style, feature);
  } else {
    var geometryRenderer = ol.renderer.vector.GEOMETRY_RENDERERS_[simplifiedGeometry.getType()];
    geometryRenderer(replayGroup, simplifiedGeometry, style, feature);
  }
};
ol.renderer.vector.renderGeometry_ = function(replayGroup, geometry, style, feature) {
  if (geometry.getType() == ol.geom.GeometryType.GEOMETRY_COLLECTION) {
    var geometries = geometry.getGeometries();
    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      ol.renderer.vector.renderGeometry_(replayGroup, geometries[i], style, feature);
    }
    return;
  }
  var replay = replayGroup.getReplay(style.getZIndex(), ol.render.ReplayType.DEFAULT);
  replay.drawCustom(geometry, feature, style.getRenderer());
};
ol.renderer.vector.renderGeometryCollectionGeometry_ = function(replayGroup, geometry, style, feature) {
  var geometries = geometry.getGeometriesArray();
  var i, ii;
  for (i = 0, ii = geometries.length; i < ii; ++i) {
    var geometryRenderer = ol.renderer.vector.GEOMETRY_RENDERERS_[geometries[i].getType()];
    geometryRenderer(replayGroup, geometries[i], style, feature);
  }
};
ol.renderer.vector.renderLineStringGeometry_ = function(replayGroup, geometry, style, feature) {
  var strokeStyle = style.getStroke();
  if (strokeStyle) {
    var lineStringReplay = replayGroup.getReplay(style.getZIndex(), ol.render.ReplayType.LINE_STRING);
    lineStringReplay.setFillStrokeStyle(null, strokeStyle);
    lineStringReplay.drawLineString(geometry, feature);
  }
  var textStyle = style.getText();
  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), ol.render.ReplayType.TEXT);
    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));
    textReplay.drawText(geometry, feature);
  }
};
ol.renderer.vector.renderMultiLineStringGeometry_ = function(replayGroup, geometry, style, feature) {
  var strokeStyle = style.getStroke();
  if (strokeStyle) {
    var lineStringReplay = replayGroup.getReplay(style.getZIndex(), ol.render.ReplayType.LINE_STRING);
    lineStringReplay.setFillStrokeStyle(null, strokeStyle);
    lineStringReplay.drawMultiLineString(geometry, feature);
  }
  var textStyle = style.getText();
  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), ol.render.ReplayType.TEXT);
    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));
    textReplay.drawText(geometry, feature);
  }
};
ol.renderer.vector.renderMultiPolygonGeometry_ = function(replayGroup, geometry, style, feature) {
  var fillStyle = style.getFill();
  var strokeStyle = style.getStroke();
  if (strokeStyle || fillStyle) {
    var polygonReplay = replayGroup.getReplay(style.getZIndex(), ol.render.ReplayType.POLYGON);
    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    polygonReplay.drawMultiPolygon(geometry, feature);
  }
  var textStyle = style.getText();
  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), ol.render.ReplayType.TEXT);
    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));
    textReplay.drawText(geometry, feature);
  }
};
ol.renderer.vector.renderPointGeometry_ = function(replayGroup, geometry, style, feature) {
  var imageStyle = style.getImage();
  if (imageStyle) {
    if (imageStyle.getImageState() != ol.ImageState.LOADED) {
      return;
    }
    var imageReplay = replayGroup.getReplay(style.getZIndex(), ol.render.ReplayType.IMAGE);
    imageReplay.setImageStyle(imageStyle, replayGroup.addDeclutter(false));
    imageReplay.drawPoint(geometry, feature);
  }
  var textStyle = style.getText();
  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), ol.render.ReplayType.TEXT);
    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(!!imageStyle));
    textReplay.drawText(geometry, feature);
  }
};
ol.renderer.vector.renderMultiPointGeometry_ = function(replayGroup, geometry, style, feature) {
  var imageStyle = style.getImage();
  if (imageStyle) {
    if (imageStyle.getImageState() != ol.ImageState.LOADED) {
      return;
    }
    var imageReplay = replayGroup.getReplay(style.getZIndex(), ol.render.ReplayType.IMAGE);
    imageReplay.setImageStyle(imageStyle, replayGroup.addDeclutter(false));
    imageReplay.drawMultiPoint(geometry, feature);
  }
  var textStyle = style.getText();
  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), ol.render.ReplayType.TEXT);
    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(!!imageStyle));
    textReplay.drawText(geometry, feature);
  }
};
ol.renderer.vector.renderPolygonGeometry_ = function(replayGroup, geometry, style, feature) {
  var fillStyle = style.getFill();
  var strokeStyle = style.getStroke();
  if (fillStyle || strokeStyle) {
    var polygonReplay = replayGroup.getReplay(style.getZIndex(), ol.render.ReplayType.POLYGON);
    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    polygonReplay.drawPolygon(geometry, feature);
  }
  var textStyle = style.getText();
  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), ol.render.ReplayType.TEXT);
    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));
    textReplay.drawText(geometry, feature);
  }
};
ol.renderer.vector.GEOMETRY_RENDERERS_ = {"Point":ol.renderer.vector.renderPointGeometry_, "LineString":ol.renderer.vector.renderLineStringGeometry_, "Polygon":ol.renderer.vector.renderPolygonGeometry_, "MultiPoint":ol.renderer.vector.renderMultiPointGeometry_, "MultiLineString":ol.renderer.vector.renderMultiLineStringGeometry_, "MultiPolygon":ol.renderer.vector.renderMultiPolygonGeometry_, "GeometryCollection":ol.renderer.vector.renderGeometryCollectionGeometry_, "Circle":ol.renderer.vector.renderCircleGeometry_};
goog.provide("ol.renderer.canvas.VectorLayer");
goog.require("ol");
goog.require("ol.LayerType");
goog.require("ol.ViewHint");
goog.require("ol.dom");
goog.require("ol.events");
goog.require("ol.events.EventType");
goog.require("ol.ext.rbush");
goog.require("ol.extent");
goog.require("ol.render.EventType");
goog.require("ol.render.canvas");
goog.require("ol.render.canvas.ReplayGroup");
goog.require("ol.renderer.Type");
goog.require("ol.renderer.canvas.Layer");
goog.require("ol.renderer.vector");
ol.renderer.canvas.VectorLayer = function(vectorLayer) {
  ol.renderer.canvas.Layer.call(this, vectorLayer);
  this.declutterTree_ = vectorLayer.getDeclutter() ? ol.ext.rbush(9) : null;
  this.dirty_ = false;
  this.renderedRevision_ = -1;
  this.renderedResolution_ = NaN;
  this.renderedExtent_ = ol.extent.createEmpty();
  this.renderedRenderOrder_ = null;
  this.replayGroup_ = null;
  this.replayGroupChanged = true;
  this.context = ol.dom.createCanvasContext2D();
  ol.events.listen(ol.render.canvas.labelCache, ol.events.EventType.CLEAR, this.handleFontsChanged_, this);
};
ol.inherits(ol.renderer.canvas.VectorLayer, ol.renderer.canvas.Layer);
ol.renderer.canvas.VectorLayer["handles"] = function(type, layer) {
  return type === ol.renderer.Type.CANVAS && layer.getType() === ol.LayerType.VECTOR;
};
ol.renderer.canvas.VectorLayer["create"] = function(mapRenderer, layer) {
  return new ol.renderer.canvas.VectorLayer(layer);
};
ol.renderer.canvas.VectorLayer.prototype.disposeInternal = function() {
  ol.events.unlisten(ol.render.canvas.labelCache, ol.events.EventType.CLEAR, this.handleFontsChanged_, this);
  ol.renderer.canvas.Layer.prototype.disposeInternal.call(this);
};
ol.renderer.canvas.VectorLayer.prototype.composeFrame = function(frameState, layerState, context) {
  var extent = frameState.extent;
  var pixelRatio = frameState.pixelRatio;
  var skippedFeatureUids = layerState.managed ? frameState.skippedFeatureUids : {};
  var viewState = frameState.viewState;
  var projection = viewState.projection;
  var rotation = viewState.rotation;
  var projectionExtent = projection.getExtent();
  var vectorSource = this.getLayer().getSource();
  var transform = this.getTransform(frameState, 0);
  this.preCompose(context, frameState, transform);
  var clipExtent = layerState.extent;
  var clipped = clipExtent !== undefined;
  if (clipped) {
    this.clip(context, frameState, clipExtent);
  }
  var replayGroup = this.replayGroup_;
  if (replayGroup && !replayGroup.isEmpty()) {
    if (this.declutterTree_) {
      this.declutterTree_.clear();
    }
    var layer = this.getLayer();
    var drawOffsetX = 0;
    var drawOffsetY = 0;
    var replayContext;
    var transparentLayer = layerState.opacity !== 1;
    var hasRenderListeners = layer.hasListener(ol.render.EventType.RENDER);
    if (transparentLayer || hasRenderListeners) {
      var drawWidth = context.canvas.width;
      var drawHeight = context.canvas.height;
      if (rotation) {
        var drawSize = Math.round(Math.sqrt(drawWidth * drawWidth + drawHeight * drawHeight));
        drawOffsetX = (drawSize - drawWidth) / 2;
        drawOffsetY = (drawSize - drawHeight) / 2;
        drawWidth = drawHeight = drawSize;
      }
      this.context.canvas.width = drawWidth;
      this.context.canvas.height = drawHeight;
      replayContext = this.context;
    } else {
      replayContext = context;
    }
    var alpha = replayContext.globalAlpha;
    if (!transparentLayer) {
      replayContext.globalAlpha = layerState.opacity;
    }
    if (replayContext != context) {
      replayContext.translate(drawOffsetX, drawOffsetY);
    }
    var width = frameState.size[0] * pixelRatio;
    var height = frameState.size[1] * pixelRatio;
    ol.render.canvas.rotateAtOffset(replayContext, -rotation, width / 2, height / 2);
    replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids);
    if (vectorSource.getWrapX() && projection.canWrapX() && !ol.extent.containsExtent(projectionExtent, extent)) {
      var startX = extent[0];
      var worldWidth = ol.extent.getWidth(projectionExtent);
      var world = 0;
      var offsetX;
      while (startX < projectionExtent[0]) {
        --world;
        offsetX = worldWidth * world;
        transform = this.getTransform(frameState, offsetX);
        replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids);
        startX += worldWidth;
      }
      world = 0;
      startX = extent[2];
      while (startX > projectionExtent[2]) {
        ++world;
        offsetX = worldWidth * world;
        transform = this.getTransform(frameState, offsetX);
        replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids);
        startX -= worldWidth;
      }
      transform = this.getTransform(frameState, 0);
    }
    ol.render.canvas.rotateAtOffset(replayContext, rotation, width / 2, height / 2);
    if (replayContext != context) {
      if (hasRenderListeners) {
        this.dispatchRenderEvent(replayContext, frameState, transform);
      }
      if (transparentLayer) {
        var mainContextAlpha = context.globalAlpha;
        context.globalAlpha = layerState.opacity;
        context.drawImage(replayContext.canvas, -drawOffsetX, -drawOffsetY);
        context.globalAlpha = mainContextAlpha;
      } else {
        context.drawImage(replayContext.canvas, -drawOffsetX, -drawOffsetY);
      }
      replayContext.translate(-drawOffsetX, -drawOffsetY);
    }
    if (!transparentLayer) {
      replayContext.globalAlpha = alpha;
    }
  }
  if (clipped) {
    context.restore();
  }
  this.postCompose(context, frameState, layerState, transform);
};
ol.renderer.canvas.VectorLayer.prototype.forEachFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, callback, thisArg) {
  if (!this.replayGroup_) {
    return undefined;
  } else {
    var resolution = frameState.viewState.resolution;
    var rotation = frameState.viewState.rotation;
    var layer = this.getLayer();
    var features = {};
    var result = this.replayGroup_.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, {}, function(feature) {
      var key = ol.getUid(feature).toString();
      if (!(key in features)) {
        features[key] = true;
        return callback.call(thisArg, feature, layer);
      }
    }, null);
    return result;
  }
};
ol.renderer.canvas.VectorLayer.prototype.handleFontsChanged_ = function(event) {
  var layer = this.getLayer();
  if (layer.getVisible() && this.replayGroup_) {
    layer.changed();
  }
};
ol.renderer.canvas.VectorLayer.prototype.handleStyleImageChange_ = function(event) {
  this.renderIfReadyAndVisible();
};
ol.renderer.canvas.VectorLayer.prototype.prepareFrame = function(frameState, layerState) {
  var vectorLayer = this.getLayer();
  var vectorSource = vectorLayer.getSource();
  this.updateLogos(frameState, vectorSource);
  var animating = frameState.viewHints[ol.ViewHint.ANIMATING];
  var interacting = frameState.viewHints[ol.ViewHint.INTERACTING];
  var updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();
  var updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();
  if (!this.dirty_ && (!updateWhileAnimating && animating) || !updateWhileInteracting && interacting) {
    return true;
  }
  var frameStateExtent = frameState.extent;
  var viewState = frameState.viewState;
  var projection = viewState.projection;
  var resolution = viewState.resolution;
  var pixelRatio = frameState.pixelRatio;
  var vectorLayerRevision = vectorLayer.getRevision();
  var vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();
  var vectorLayerRenderOrder = vectorLayer.getRenderOrder();
  if (vectorLayerRenderOrder === undefined) {
    vectorLayerRenderOrder = ol.renderer.vector.defaultOrder;
  }
  var extent = ol.extent.buffer(frameStateExtent, vectorLayerRenderBuffer * resolution);
  var projectionExtent = viewState.projection.getExtent();
  if (vectorSource.getWrapX() && viewState.projection.canWrapX() && !ol.extent.containsExtent(projectionExtent, frameState.extent)) {
    var worldWidth = ol.extent.getWidth(projectionExtent);
    var buffer = Math.max(ol.extent.getWidth(extent) / 2, worldWidth);
    extent[0] = projectionExtent[0] - buffer;
    extent[2] = projectionExtent[2] + buffer;
  }
  if (!this.dirty_ && this.renderedResolution_ == resolution && this.renderedRevision_ == vectorLayerRevision && this.renderedRenderOrder_ == vectorLayerRenderOrder && ol.extent.containsExtent(this.renderedExtent_, extent)) {
    this.replayGroupChanged = false;
    return true;
  }
  this.replayGroup_ = null;
  this.dirty_ = false;
  var replayGroup = new ol.render.canvas.ReplayGroup(ol.renderer.vector.getTolerance(resolution, pixelRatio), extent, resolution, pixelRatio, vectorSource.getOverlaps(), this.declutterTree_, vectorLayer.getRenderBuffer());
  vectorSource.loadFeatures(extent, resolution, projection);
  var renderFeature = function(feature) {
    var styles;
    var styleFunction = feature.getStyleFunction();
    if (styleFunction) {
      styles = styleFunction.call(feature, resolution);
    } else {
      styleFunction = vectorLayer.getStyleFunction();
      if (styleFunction) {
        styles = styleFunction(feature, resolution);
      }
    }
    if (styles) {
      var dirty = this.renderFeature(feature, resolution, pixelRatio, styles, replayGroup);
      this.dirty_ = this.dirty_ || dirty;
    }
  }.bind(this);
  if (vectorLayerRenderOrder) {
    var features = [];
    vectorSource.forEachFeatureInExtent(extent, function(feature) {
      features.push(feature);
    }, this);
    features.sort(vectorLayerRenderOrder);
    for (var i = 0, ii = features.length; i < ii; ++i) {
      renderFeature(features[i]);
    }
  } else {
    vectorSource.forEachFeatureInExtent(extent, renderFeature, this);
  }
  replayGroup.finish();
  this.renderedResolution_ = resolution;
  this.renderedRevision_ = vectorLayerRevision;
  this.renderedRenderOrder_ = vectorLayerRenderOrder;
  this.renderedExtent_ = extent;
  this.replayGroup_ = replayGroup;
  this.replayGroupChanged = true;
  return true;
};
ol.renderer.canvas.VectorLayer.prototype.renderFeature = function(feature, resolution, pixelRatio, styles, replayGroup) {
  if (!styles) {
    return false;
  }
  var loading = false;
  if (Array.isArray(styles)) {
    for (var i = 0, ii = styles.length; i < ii; ++i) {
      loading = ol.renderer.vector.renderFeature(replayGroup, feature, styles[i], ol.renderer.vector.getSquaredTolerance(resolution, pixelRatio), this.handleStyleImageChange_, this) || loading;
    }
  } else {
    loading = ol.renderer.vector.renderFeature(replayGroup, feature, styles, ol.renderer.vector.getSquaredTolerance(resolution, pixelRatio), this.handleStyleImageChange_, this);
  }
  return loading;
};
goog.provide("ol.layer.VectorTileRenderType");
ol.layer.VectorTileRenderType = {IMAGE:"image", HYBRID:"hybrid", VECTOR:"vector"};
goog.provide("ol.renderer.canvas.VectorTileLayer");
goog.require("ol");
goog.require("ol.LayerType");
goog.require("ol.TileState");
goog.require("ol.dom");
goog.require("ol.events");
goog.require("ol.events.EventType");
goog.require("ol.ext.rbush");
goog.require("ol.extent");
goog.require("ol.layer.VectorTileRenderType");
goog.require("ol.proj");
goog.require("ol.proj.Units");
goog.require("ol.render.ReplayType");
goog.require("ol.render.canvas");
goog.require("ol.render.canvas.ReplayGroup");
goog.require("ol.render.replay");
goog.require("ol.renderer.Type");
goog.require("ol.renderer.canvas.TileLayer");
goog.require("ol.renderer.vector");
goog.require("ol.transform");
ol.renderer.canvas.VectorTileLayer = function(layer) {
  this.context = null;
  ol.renderer.canvas.TileLayer.call(this, layer);
  this.declutterTree_ = layer.getDeclutter() ? ol.ext.rbush(9) : null;
  this.dirty_ = false;
  this.renderedLayerRevision_;
  this.tmpTransform_ = ol.transform.create();
  this.zDirection = layer.getRenderMode() == ol.layer.VectorTileRenderType.VECTOR ? 1 : 0;
  ol.events.listen(ol.render.canvas.labelCache, ol.events.EventType.CLEAR, this.handleFontsChanged_, this);
};
ol.inherits(ol.renderer.canvas.VectorTileLayer, ol.renderer.canvas.TileLayer);
ol.renderer.canvas.VectorTileLayer["handles"] = function(type, layer) {
  return type === ol.renderer.Type.CANVAS && layer.getType() === ol.LayerType.VECTOR_TILE;
};
ol.renderer.canvas.VectorTileLayer["create"] = function(mapRenderer, layer) {
  return new ol.renderer.canvas.VectorTileLayer(layer);
};
ol.renderer.canvas.VectorTileLayer.IMAGE_REPLAYS = {"image":[ol.render.ReplayType.POLYGON, ol.render.ReplayType.CIRCLE, ol.render.ReplayType.LINE_STRING, ol.render.ReplayType.IMAGE, ol.render.ReplayType.TEXT], "hybrid":[ol.render.ReplayType.POLYGON, ol.render.ReplayType.LINE_STRING]};
ol.renderer.canvas.VectorTileLayer.VECTOR_REPLAYS = {"image":[ol.render.ReplayType.DEFAULT], "hybrid":[ol.render.ReplayType.IMAGE, ol.render.ReplayType.TEXT, ol.render.ReplayType.DEFAULT], "vector":ol.render.replay.ORDER};
ol.renderer.canvas.VectorTileLayer.prototype.disposeInternal = function() {
  ol.events.unlisten(ol.render.canvas.labelCache, ol.events.EventType.CLEAR, this.handleFontsChanged_, this);
  ol.renderer.canvas.TileLayer.prototype.disposeInternal.call(this);
};
ol.renderer.canvas.VectorTileLayer.prototype.prepareFrame = function(frameState, layerState) {
  var layer = this.getLayer();
  var layerRevision = layer.getRevision();
  if (this.renderedLayerRevision_ != layerRevision) {
    this.renderedTiles.length = 0;
    var renderMode = layer.getRenderMode();
    if (!this.context && renderMode != ol.layer.VectorTileRenderType.VECTOR) {
      this.context = ol.dom.createCanvasContext2D();
    }
    if (this.context && renderMode == ol.layer.VectorTileRenderType.VECTOR) {
      this.context = null;
    }
  }
  this.renderedLayerRevision_ = layerRevision;
  return ol.renderer.canvas.TileLayer.prototype.prepareFrame.apply(this, arguments);
};
ol.renderer.canvas.VectorTileLayer.prototype.createReplayGroup_ = function(tile, frameState) {
  var layer = this.getLayer();
  var pixelRatio = frameState.pixelRatio;
  var projection = frameState.viewState.projection;
  var revision = layer.getRevision();
  var renderOrder = layer.getRenderOrder() || null;
  var replayState = tile.getReplayState(layer);
  if (!replayState.dirty && replayState.renderedRevision == revision && replayState.renderedRenderOrder == renderOrder) {
    return;
  }
  var source = layer.getSource();
  var sourceTileGrid = source.getTileGrid();
  var tileGrid = source.getTileGridForProjection(projection);
  var resolution = tileGrid.getResolution(tile.tileCoord[0]);
  var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);
  var zIndexKeys = {};
  for (var t = 0, tt = tile.tileKeys.length; t < tt; ++t) {
    var sourceTile = tile.getTile(tile.tileKeys[t]);
    if (sourceTile.getState() == ol.TileState.ERROR) {
      continue;
    }
    var sourceTileCoord = sourceTile.tileCoord;
    var sourceTileExtent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);
    var sharedExtent = ol.extent.getIntersection(tileExtent, sourceTileExtent);
    var bufferedExtent = ol.extent.equals(sourceTileExtent, sharedExtent) ? null : ol.extent.buffer(sharedExtent, layer.getRenderBuffer() * resolution);
    var tileProjection = sourceTile.getProjection();
    var reproject = false;
    if (!ol.proj.equivalent(projection, tileProjection)) {
      reproject = true;
      sourceTile.setProjection(projection);
    }
    replayState.dirty = false;
    var replayGroup = new ol.render.canvas.ReplayGroup(0, sharedExtent, resolution, pixelRatio, source.getOverlaps(), this.declutterTree_, layer.getRenderBuffer());
    var squaredTolerance = ol.renderer.vector.getSquaredTolerance(resolution, pixelRatio);
    var renderFeature = function(feature) {
      var styles;
      var styleFunction = feature.getStyleFunction();
      if (styleFunction) {
        styles = styleFunction.call(feature, resolution);
      } else {
        styleFunction = layer.getStyleFunction();
        if (styleFunction) {
          styles = styleFunction(feature, resolution);
        }
      }
      if (styles) {
        var dirty = this.renderFeature(feature, squaredTolerance, styles, replayGroup);
        this.dirty_ = this.dirty_ || dirty;
        replayState.dirty = replayState.dirty || dirty;
      }
    };
    var features = sourceTile.getFeatures();
    if (renderOrder && renderOrder !== replayState.renderedRenderOrder) {
      features.sort(renderOrder);
    }
    var feature;
    for (var i = 0, ii = features.length; i < ii; ++i) {
      feature = features[i];
      if (reproject) {
        if (tileProjection.getUnits() == ol.proj.Units.TILE_PIXELS) {
          tileProjection.setWorldExtent(sourceTileExtent);
          tileProjection.setExtent(sourceTile.getExtent());
        }
        feature.getGeometry().transform(tileProjection, projection);
      }
      if (!bufferedExtent || ol.extent.intersects(bufferedExtent, feature.getGeometry().getExtent())) {
        renderFeature.call(this, feature);
      }
    }
    replayGroup.finish();
    for (var r in replayGroup.getReplays()) {
      zIndexKeys[r] = true;
    }
    sourceTile.setReplayGroup(layer, tile.tileCoord.toString(), replayGroup);
  }
  replayState.renderedRevision = revision;
  replayState.renderedRenderOrder = renderOrder;
};
ol.renderer.canvas.VectorTileLayer.prototype.drawTileImage = function(tile, frameState, layerState, x, y, w, h, gutter, transition) {
  var vectorImageTile = tile;
  this.createReplayGroup_(vectorImageTile, frameState);
  if (this.context) {
    this.renderTileImage_(vectorImageTile, frameState, layerState);
    ol.renderer.canvas.TileLayer.prototype.drawTileImage.apply(this, arguments);
  }
};
ol.renderer.canvas.VectorTileLayer.prototype.forEachFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, callback, thisArg) {
  var resolution = frameState.viewState.resolution;
  var rotation = frameState.viewState.rotation;
  hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;
  var layer = this.getLayer();
  var features = {};
  var renderedTiles = this.renderedTiles;
  var source = layer.getSource();
  var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);
  var bufferedExtent, found;
  var i, ii, replayGroup;
  var tile, tileCoord, tileExtent;
  for (i = 0, ii = renderedTiles.length; i < ii; ++i) {
    tile = renderedTiles[i];
    tileCoord = tile.wrappedTileCoord;
    tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);
    bufferedExtent = ol.extent.buffer(tileExtent, hitTolerance * resolution, bufferedExtent);
    if (!ol.extent.containsCoordinate(bufferedExtent, coordinate)) {
      continue;
    }
    for (var t = 0, tt = tile.tileKeys.length; t < tt; ++t) {
      var sourceTile = tile.getTile(tile.tileKeys[t]);
      if (sourceTile.getState() == ol.TileState.ERROR) {
        continue;
      }
      replayGroup = sourceTile.getReplayGroup(layer, tile.tileCoord.toString());
      found = found || replayGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, {}, function(feature) {
        var key = ol.getUid(feature).toString();
        if (!(key in features)) {
          features[key] = true;
          return callback.call(thisArg, feature, layer);
        }
      }, null);
    }
  }
  return found;
};
ol.renderer.canvas.VectorTileLayer.prototype.getReplayTransform_ = function(tile, frameState) {
  var layer = this.getLayer();
  var source = layer.getSource();
  var tileGrid = source.getTileGrid();
  var tileCoord = tile.tileCoord;
  var tileResolution = tileGrid.getResolution(tileCoord[0]);
  var viewState = frameState.viewState;
  var pixelRatio = frameState.pixelRatio;
  var renderResolution = viewState.resolution / pixelRatio;
  var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);
  var center = viewState.center;
  var origin = ol.extent.getTopLeft(tileExtent);
  var size = frameState.size;
  var offsetX = Math.round(pixelRatio * size[0] / 2);
  var offsetY = Math.round(pixelRatio * size[1] / 2);
  return ol.transform.compose(this.tmpTransform_, offsetX, offsetY, tileResolution / renderResolution, tileResolution / renderResolution, viewState.rotation, (origin[0] - center[0]) / tileResolution, (center[1] - origin[1]) / tileResolution);
};
ol.renderer.canvas.VectorTileLayer.prototype.handleFontsChanged_ = function(event) {
  var layer = this.getLayer();
  if (layer.getVisible() && this.renderedLayerRevision_ !== undefined) {
    layer.changed();
  }
};
ol.renderer.canvas.VectorTileLayer.prototype.handleStyleImageChange_ = function(event) {
  this.renderIfReadyAndVisible();
};
ol.renderer.canvas.VectorTileLayer.prototype.postCompose = function(context, frameState, layerState) {
  var layer = this.getLayer();
  var declutterReplays = layer.getDeclutter() ? {} : null;
  var source = layer.getSource();
  var renderMode = layer.getRenderMode();
  var replayTypes = ol.renderer.canvas.VectorTileLayer.VECTOR_REPLAYS[renderMode];
  var pixelRatio = frameState.pixelRatio;
  var rotation = frameState.viewState.rotation;
  var size = frameState.size;
  var offsetX, offsetY;
  if (rotation) {
    offsetX = Math.round(pixelRatio * size[0] / 2);
    offsetY = Math.round(pixelRatio * size[1] / 2);
    ol.render.canvas.rotateAtOffset(context, -rotation, offsetX, offsetY);
  }
  if (declutterReplays) {
    this.declutterTree_.clear();
  }
  var tiles = this.renderedTiles;
  var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);
  var clips = [];
  var zs = [];
  for (var i = tiles.length - 1; i >= 0; --i) {
    var tile = tiles[i];
    if (tile.getState() == ol.TileState.ABORT) {
      continue;
    }
    var tileCoord = tile.tileCoord;
    var worldOffset = tileGrid.getTileCoordExtent(tileCoord)[0] - tileGrid.getTileCoordExtent(tile.wrappedTileCoord)[0];
    var transform = undefined;
    for (var t = 0, tt = tile.tileKeys.length; t < tt; ++t) {
      var sourceTile = tile.getTile(tile.tileKeys[t]);
      if (sourceTile.getState() == ol.TileState.ERROR) {
        continue;
      }
      var replayGroup = sourceTile.getReplayGroup(layer, tileCoord.toString());
      if (renderMode != ol.layer.VectorTileRenderType.VECTOR && !replayGroup.hasReplays(replayTypes)) {
        continue;
      }
      if (!transform) {
        transform = this.getTransform(frameState, worldOffset);
      }
      var currentZ = sourceTile.tileCoord[0];
      var currentClip = replayGroup.getClipCoords(transform);
      context.save();
      context.globalAlpha = layerState.opacity;
      for (var j = 0, jj = clips.length; j < jj; ++j) {
        var clip = clips[j];
        if (currentZ < zs[j]) {
          context.beginPath();
          context.moveTo(currentClip[0], currentClip[1]);
          context.lineTo(currentClip[2], currentClip[3]);
          context.lineTo(currentClip[4], currentClip[5]);
          context.lineTo(currentClip[6], currentClip[7]);
          context.moveTo(clip[6], clip[7]);
          context.lineTo(clip[4], clip[5]);
          context.lineTo(clip[2], clip[3]);
          context.lineTo(clip[0], clip[1]);
          context.clip();
        }
      }
      replayGroup.replay(context, transform, rotation, {}, replayTypes, declutterReplays);
      context.restore();
      clips.push(currentClip);
      zs.push(currentZ);
    }
  }
  if (declutterReplays) {
    ol.render.canvas.ReplayGroup.replayDeclutter(declutterReplays, context, rotation);
  }
  if (rotation) {
    ol.render.canvas.rotateAtOffset(context, rotation, offsetX, offsetY);
  }
  ol.renderer.canvas.TileLayer.prototype.postCompose.apply(this, arguments);
};
ol.renderer.canvas.VectorTileLayer.prototype.renderFeature = function(feature, squaredTolerance, styles, replayGroup) {
  if (!styles) {
    return false;
  }
  var loading = false;
  if (Array.isArray(styles)) {
    for (var i = 0, ii = styles.length; i < ii; ++i) {
      loading = ol.renderer.vector.renderFeature(replayGroup, feature, styles[i], squaredTolerance, this.handleStyleImageChange_, this) || loading;
    }
  } else {
    loading = ol.renderer.vector.renderFeature(replayGroup, feature, styles, squaredTolerance, this.handleStyleImageChange_, this);
  }
  return loading;
};
ol.renderer.canvas.VectorTileLayer.prototype.renderTileImage_ = function(tile, frameState, layerState) {
  var layer = this.getLayer();
  var replayState = tile.getReplayState(layer);
  var revision = layer.getRevision();
  var replays = ol.renderer.canvas.VectorTileLayer.IMAGE_REPLAYS[layer.getRenderMode()];
  if (replays && replayState.renderedTileRevision !== revision) {
    replayState.renderedTileRevision = revision;
    var tileCoord = tile.wrappedTileCoord;
    var z = tileCoord[0];
    var pixelRatio = frameState.pixelRatio;
    var source = layer.getSource();
    var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);
    var resolution = tileGrid.getResolution(z);
    var context = tile.getContext(layer);
    var size = source.getTilePixelSize(z, pixelRatio, frameState.viewState.projection);
    context.canvas.width = size[0];
    context.canvas.height = size[1];
    var tileExtent = tileGrid.getTileCoordExtent(tileCoord);
    for (var i = 0, ii = tile.tileKeys.length; i < ii; ++i) {
      var sourceTile = tile.getTile(tile.tileKeys[i]);
      if (sourceTile.getState() == ol.TileState.ERROR) {
        continue;
      }
      var pixelScale = pixelRatio / resolution;
      var transform = ol.transform.reset(this.tmpTransform_);
      ol.transform.scale(transform, pixelScale, -pixelScale);
      ol.transform.translate(transform, -tileExtent[0], -tileExtent[3]);
      var replayGroup = sourceTile.getReplayGroup(layer, tile.tileCoord.toString());
      replayGroup.replay(context, transform, 0, {}, replays);
    }
  }
};
goog.provide("ol.CanvasMap");
goog.require("ol");
goog.require("ol.PluggableMap");
goog.require("ol.PluginType");
goog.require("ol.control");
goog.require("ol.interaction");
goog.require("ol.obj");
goog.require("ol.plugins");
goog.require("ol.renderer.canvas.ImageLayer");
goog.require("ol.renderer.canvas.Map");
goog.require("ol.renderer.canvas.TileLayer");
goog.require("ol.renderer.canvas.VectorLayer");
goog.require("ol.renderer.canvas.VectorTileLayer");
ol.plugins.register(ol.PluginType.MAP_RENDERER, ol.renderer.canvas.Map);
ol.plugins.registerMultiple(ol.PluginType.LAYER_RENDERER, [ol.renderer.canvas.ImageLayer, ol.renderer.canvas.TileLayer, ol.renderer.canvas.VectorLayer, ol.renderer.canvas.VectorTileLayer]);
ol.CanvasMap = function(options) {
  options = ol.obj.assign({}, options);
  delete options.renderer;
  if (!options.controls) {
    options.controls = ol.control.defaults();
  }
  if (!options.interactions) {
    options.interactions = ol.interaction.defaults();
  }
  ol.PluggableMap.call(this, options);
};
ol.inherits(ol.CanvasMap, ol.PluggableMap);
goog.provide("ol.control.FullScreen");
goog.require("ol");
goog.require("ol.control.Control");
goog.require("ol.css");
goog.require("ol.dom");
goog.require("ol.events");
goog.require("ol.events.EventType");
ol.control.FullScreen = function(opt_options) {
  var options = opt_options ? opt_options : {};
  this.cssClassName_ = options.className !== undefined ? options.className : "ol-full-screen";
  var label = options.label !== undefined ? options.label : "\u2922";
  this.labelNode_ = typeof label === "string" ? document.createTextNode(label) : label;
  var labelActive = options.labelActive !== undefined ? options.labelActive : "\u00d7";
  this.labelActiveNode_ = typeof labelActive === "string" ? document.createTextNode(labelActive) : labelActive;
  var tipLabel = options.tipLabel ? options.tipLabel : "Toggle full-screen";
  var button = document.createElement("button");
  button.className = this.cssClassName_ + "-" + ol.control.FullScreen.isFullScreen();
  button.setAttribute("type", "button");
  button.title = tipLabel;
  button.appendChild(this.labelNode_);
  ol.events.listen(button, ol.events.EventType.CLICK, this.handleClick_, this);
  var cssClasses = this.cssClassName_ + " " + ol.css.CLASS_UNSELECTABLE + " " + ol.css.CLASS_CONTROL + " " + (!ol.control.FullScreen.isFullScreenSupported() ? ol.css.CLASS_UNSUPPORTED : "");
  var element = document.createElement("div");
  element.className = cssClasses;
  element.appendChild(button);
  ol.control.Control.call(this, {element:element, target:options.target});
  this.keys_ = options.keys !== undefined ? options.keys : false;
  this.source_ = options.source;
};
ol.inherits(ol.control.FullScreen, ol.control.Control);
ol.control.FullScreen.prototype.handleClick_ = function(event) {
  event.preventDefault();
  this.handleFullScreen_();
};
ol.control.FullScreen.prototype.handleFullScreen_ = function() {
  if (!ol.control.FullScreen.isFullScreenSupported()) {
    return;
  }
  var map = this.getMap();
  if (!map) {
    return;
  }
  if (ol.control.FullScreen.isFullScreen()) {
    ol.control.FullScreen.exitFullScreen();
  } else {
    var element;
    if (this.source_) {
      element = typeof this.source_ === "string" ? document.getElementById(this.source_) : this.source_;
    } else {
      element = map.getTargetElement();
    }
    if (this.keys_) {
      ol.control.FullScreen.requestFullScreenWithKeys(element);
    } else {
      ol.control.FullScreen.requestFullScreen(element);
    }
  }
};
ol.control.FullScreen.prototype.handleFullScreenChange_ = function() {
  var button = this.element.firstElementChild;
  var map = this.getMap();
  if (ol.control.FullScreen.isFullScreen()) {
    button.className = this.cssClassName_ + "-true";
    ol.dom.replaceNode(this.labelActiveNode_, this.labelNode_);
  } else {
    button.className = this.cssClassName_ + "-false";
    ol.dom.replaceNode(this.labelNode_, this.labelActiveNode_);
  }
  if (map) {
    map.updateSize();
  }
};
ol.control.FullScreen.prototype.setMap = function(map) {
  ol.control.Control.prototype.setMap.call(this, map);
  if (map) {
    this.listenerKeys.push(ol.events.listen(document, ol.control.FullScreen.getChangeType_(), this.handleFullScreenChange_, this));
  }
};
ol.control.FullScreen.isFullScreenSupported = function() {
  var body = document.body;
  return !!(body.webkitRequestFullscreen || body.mozRequestFullScreen && document.mozFullScreenEnabled || body.msRequestFullscreen && document.msFullscreenEnabled || body.requestFullscreen && document.fullscreenEnabled);
};
ol.control.FullScreen.isFullScreen = function() {
  return !!(document.webkitIsFullScreen || document.mozFullScreen || document.msFullscreenElement || document.fullscreenElement);
};
ol.control.FullScreen.requestFullScreen = function(element) {
  if (element.requestFullscreen) {
    element.requestFullscreen();
  } else {
    if (element.msRequestFullscreen) {
      element.msRequestFullscreen();
    } else {
      if (element.mozRequestFullScreen) {
        element.mozRequestFullScreen();
      } else {
        if (element.webkitRequestFullscreen) {
          element.webkitRequestFullscreen();
        }
      }
    }
  }
};
ol.control.FullScreen.requestFullScreenWithKeys = function(element) {
  if (element.mozRequestFullScreenWithKeys) {
    element.mozRequestFullScreenWithKeys();
  } else {
    if (element.webkitRequestFullscreen) {
      element.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
    } else {
      ol.control.FullScreen.requestFullScreen(element);
    }
  }
};
ol.control.FullScreen.exitFullScreen = function() {
  if (document.exitFullscreen) {
    document.exitFullscreen();
  } else {
    if (document.msExitFullscreen) {
      document.msExitFullscreen();
    } else {
      if (document.mozCancelFullScreen) {
        document.mozCancelFullScreen();
      } else {
        if (document.webkitExitFullscreen) {
          document.webkitExitFullscreen();
        }
      }
    }
  }
};
ol.control.FullScreen.getChangeType_ = function() {
  var changeType;
  return function() {
    if (!changeType) {
      var body = document.body;
      if (body.webkitRequestFullscreen) {
        changeType = "webkitfullscreenchange";
      } else {
        if (body.mozRequestFullScreen) {
          changeType = "mozfullscreenchange";
        } else {
          if (body.msRequestFullscreen) {
            changeType = "MSFullscreenChange";
          } else {
            if (body.requestFullscreen) {
              changeType = "fullscreenchange";
            }
          }
        }
      }
    }
    return changeType;
  };
}();
goog.provide("ol.control.MousePosition");
goog.require("ol");
goog.require("ol.events");
goog.require("ol.events.EventType");
goog.require("ol.Object");
goog.require("ol.control.Control");
goog.require("ol.proj");
ol.control.MousePosition = function(opt_options) {
  var options = opt_options ? opt_options : {};
  var element = document.createElement("DIV");
  element.className = options.className !== undefined ? options.className : "ol-mouse-position";
  var render = options.render ? options.render : ol.control.MousePosition.render;
  ol.control.Control.call(this, {element:element, render:render, target:options.target});
  ol.events.listen(this, ol.Object.getChangeEventType(ol.control.MousePosition.Property_.PROJECTION), this.handleProjectionChanged_, this);
  if (options.coordinateFormat) {
    this.setCoordinateFormat(options.coordinateFormat);
  }
  if (options.projection) {
    this.setProjection(options.projection);
  }
  this.undefinedHTML_ = options.undefinedHTML !== undefined ? options.undefinedHTML : "";
  this.renderedHTML_ = element.innerHTML;
  this.mapProjection_ = null;
  this.transform_ = null;
  this.lastMouseMovePixel_ = null;
};
ol.inherits(ol.control.MousePosition, ol.control.Control);
ol.control.MousePosition.render = function(mapEvent) {
  var frameState = mapEvent.frameState;
  if (!frameState) {
    this.mapProjection_ = null;
  } else {
    if (this.mapProjection_ != frameState.viewState.projection) {
      this.mapProjection_ = frameState.viewState.projection;
      this.transform_ = null;
    }
  }
  this.updateHTML_(this.lastMouseMovePixel_);
};
ol.control.MousePosition.prototype.handleProjectionChanged_ = function() {
  this.transform_ = null;
};
ol.control.MousePosition.prototype.getCoordinateFormat = function() {
  return this.get(ol.control.MousePosition.Property_.COORDINATE_FORMAT);
};
ol.control.MousePosition.prototype.getProjection = function() {
  return this.get(ol.control.MousePosition.Property_.PROJECTION);
};
ol.control.MousePosition.prototype.handleMouseMove = function(event) {
  var map = this.getMap();
  this.lastMouseMovePixel_ = map.getEventPixel(event);
  this.updateHTML_(this.lastMouseMovePixel_);
};
ol.control.MousePosition.prototype.handleMouseOut = function(event) {
  this.updateHTML_(null);
  this.lastMouseMovePixel_ = null;
};
ol.control.MousePosition.prototype.setMap = function(map) {
  ol.control.Control.prototype.setMap.call(this, map);
  if (map) {
    var viewport = map.getViewport();
    this.listenerKeys.push(ol.events.listen(viewport, ol.events.EventType.MOUSEMOVE, this.handleMouseMove, this), ol.events.listen(viewport, ol.events.EventType.MOUSEOUT, this.handleMouseOut, this));
  }
};
ol.control.MousePosition.prototype.setCoordinateFormat = function(format) {
  this.set(ol.control.MousePosition.Property_.COORDINATE_FORMAT, format);
};
ol.control.MousePosition.prototype.setProjection = function(projection) {
  this.set(ol.control.MousePosition.Property_.PROJECTION, ol.proj.get(projection));
};
ol.control.MousePosition.prototype.updateHTML_ = function(pixel) {
  var html = this.undefinedHTML_;
  if (pixel && this.mapProjection_) {
    if (!this.transform_) {
      var projection = this.getProjection();
      if (projection) {
        this.transform_ = ol.proj.getTransformFromProjections(this.mapProjection_, projection);
      } else {
        this.transform_ = ol.proj.identityTransform;
      }
    }
    var map = this.getMap();
    var coordinate = map.getCoordinateFromPixel(pixel);
    if (coordinate) {
      this.transform_(coordinate, coordinate);
      var coordinateFormat = this.getCoordinateFormat();
      if (coordinateFormat) {
        html = coordinateFormat(coordinate);
      } else {
        html = coordinate.toString();
      }
    }
  }
  if (!this.renderedHTML_ || html != this.renderedHTML_) {
    this.element.innerHTML = html;
    this.renderedHTML_ = html;
  }
};
ol.control.MousePosition.Property_ = {PROJECTION:"projection", COORDINATE_FORMAT:"coordinateFormat"};
goog.provide("ol.control.OverviewMap");
goog.require("ol");
goog.require("ol.Collection");
goog.require("ol.PluggableMap");
goog.require("ol.MapEventType");
goog.require("ol.MapProperty");
goog.require("ol.Object");
goog.require("ol.ObjectEventType");
goog.require("ol.Overlay");
goog.require("ol.OverlayPositioning");
goog.require("ol.ViewProperty");
goog.require("ol.control.Control");
goog.require("ol.coordinate");
goog.require("ol.css");
goog.require("ol.dom");
goog.require("ol.events");
goog.require("ol.events.EventType");
goog.require("ol.extent");
ol.control.OverviewMap = function(opt_options) {
  var options = opt_options ? opt_options : {};
  this.collapsed_ = options.collapsed !== undefined ? options.collapsed : true;
  this.collapsible_ = options.collapsible !== undefined ? options.collapsible : true;
  if (!this.collapsible_) {
    this.collapsed_ = false;
  }
  var className = options.className !== undefined ? options.className : "ol-overviewmap";
  var tipLabel = options.tipLabel !== undefined ? options.tipLabel : "Overview map";
  var collapseLabel = options.collapseLabel !== undefined ? options.collapseLabel : "\u00ab";
  if (typeof collapseLabel === "string") {
    this.collapseLabel_ = document.createElement("span");
    this.collapseLabel_.textContent = collapseLabel;
  } else {
    this.collapseLabel_ = collapseLabel;
  }
  var label = options.label !== undefined ? options.label : "\u00bb";
  if (typeof label === "string") {
    this.label_ = document.createElement("span");
    this.label_.textContent = label;
  } else {
    this.label_ = label;
  }
  var activeLabel = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_;
  var button = document.createElement("button");
  button.setAttribute("type", "button");
  button.title = tipLabel;
  button.appendChild(activeLabel);
  ol.events.listen(button, ol.events.EventType.CLICK, this.handleClick_, this);
  this.ovmapDiv_ = document.createElement("DIV");
  this.ovmapDiv_.className = "ol-overviewmap-map";
  this.ovmap_ = new ol.PluggableMap({controls:new ol.Collection, interactions:new ol.Collection, view:options.view});
  var ovmap = this.ovmap_;
  if (options.layers) {
    options.layers.forEach(function(layer) {
      ovmap.addLayer(layer);
    }, this);
  }
  var box = document.createElement("DIV");
  box.className = "ol-overviewmap-box";
  box.style.boxSizing = "border-box";
  this.boxOverlay_ = new ol.Overlay({position:[0, 0], positioning:ol.OverlayPositioning.BOTTOM_LEFT, element:box});
  this.ovmap_.addOverlay(this.boxOverlay_);
  var cssClasses = className + " " + ol.css.CLASS_UNSELECTABLE + " " + ol.css.CLASS_CONTROL + (this.collapsed_ && this.collapsible_ ? " ol-collapsed" : "") + (this.collapsible_ ? "" : " ol-uncollapsible");
  var element = document.createElement("div");
  element.className = cssClasses;
  element.appendChild(this.ovmapDiv_);
  element.appendChild(button);
  var render = options.render ? options.render : ol.control.OverviewMap.render;
  ol.control.Control.call(this, {element:element, render:render, target:options.target});
  var scope = this;
  var overlay = this.boxOverlay_;
  var overlayBox = this.boxOverlay_.getElement();
  var computeDesiredMousePosition = function(mousePosition) {
    return {clientX:mousePosition.clientX - overlayBox.offsetWidth / 2, clientY:mousePosition.clientY + overlayBox.offsetHeight / 2};
  };
  var move = function(event) {
    var coordinates = ovmap.getEventCoordinate(computeDesiredMousePosition(event));
    overlay.setPosition(coordinates);
  };
  var endMoving = function(event) {
    var coordinates = ovmap.getEventCoordinate(event);
    scope.getMap().getView().setCenter(coordinates);
    window.removeEventListener("mousemove", move);
    window.removeEventListener("mouseup", endMoving);
  };
  overlayBox.addEventListener("mousedown", function() {
    window.addEventListener("mousemove", move);
    window.addEventListener("mouseup", endMoving);
  });
};
ol.inherits(ol.control.OverviewMap, ol.control.Control);
ol.control.OverviewMap.prototype.setMap = function(map) {
  var oldMap = this.getMap();
  if (map === oldMap) {
    return;
  }
  if (oldMap) {
    var oldView = oldMap.getView();
    if (oldView) {
      this.unbindView_(oldView);
    }
    this.ovmap_.setTarget(null);
  }
  ol.control.Control.prototype.setMap.call(this, map);
  if (map) {
    this.ovmap_.setTarget(this.ovmapDiv_);
    this.listenerKeys.push(ol.events.listen(map, ol.ObjectEventType.PROPERTYCHANGE, this.handleMapPropertyChange_, this));
    if (this.ovmap_.getLayers().getLength() === 0) {
      this.ovmap_.setLayerGroup(map.getLayerGroup());
    }
    var view = map.getView();
    if (view) {
      this.bindView_(view);
      if (view.isDef()) {
        this.ovmap_.updateSize();
        this.resetExtent_();
      }
    }
  }
};
ol.control.OverviewMap.prototype.handleMapPropertyChange_ = function(event) {
  if (event.key === ol.MapProperty.VIEW) {
    var oldView = event.oldValue;
    if (oldView) {
      this.unbindView_(oldView);
    }
    var newView = this.getMap().getView();
    this.bindView_(newView);
  }
};
ol.control.OverviewMap.prototype.bindView_ = function(view) {
  ol.events.listen(view, ol.Object.getChangeEventType(ol.ViewProperty.ROTATION), this.handleRotationChanged_, this);
};
ol.control.OverviewMap.prototype.unbindView_ = function(view) {
  ol.events.unlisten(view, ol.Object.getChangeEventType(ol.ViewProperty.ROTATION), this.handleRotationChanged_, this);
};
ol.control.OverviewMap.prototype.handleRotationChanged_ = function() {
  this.ovmap_.getView().setRotation(this.getMap().getView().getRotation());
};
ol.control.OverviewMap.render = function(mapEvent) {
  this.validateExtent_();
  this.updateBox_();
};
ol.control.OverviewMap.prototype.validateExtent_ = function() {
  var map = this.getMap();
  var ovmap = this.ovmap_;
  if (!map.isRendered() || !ovmap.isRendered()) {
    return;
  }
  var mapSize = map.getSize();
  var view = map.getView();
  var extent = view.calculateExtent(mapSize);
  var ovmapSize = ovmap.getSize();
  var ovview = ovmap.getView();
  var ovextent = ovview.calculateExtent(ovmapSize);
  var topLeftPixel = ovmap.getPixelFromCoordinate(ol.extent.getTopLeft(extent));
  var bottomRightPixel = ovmap.getPixelFromCoordinate(ol.extent.getBottomRight(extent));
  var boxWidth = Math.abs(topLeftPixel[0] - bottomRightPixel[0]);
  var boxHeight = Math.abs(topLeftPixel[1] - bottomRightPixel[1]);
  var ovmapWidth = ovmapSize[0];
  var ovmapHeight = ovmapSize[1];
  if (boxWidth < ovmapWidth * ol.OVERVIEWMAP_MIN_RATIO || boxHeight < ovmapHeight * ol.OVERVIEWMAP_MIN_RATIO || boxWidth > ovmapWidth * ol.OVERVIEWMAP_MAX_RATIO || boxHeight > ovmapHeight * ol.OVERVIEWMAP_MAX_RATIO) {
    this.resetExtent_();
  } else {
    if (!ol.extent.containsExtent(ovextent, extent)) {
      this.recenter_();
    }
  }
};
ol.control.OverviewMap.prototype.resetExtent_ = function() {
  if (ol.OVERVIEWMAP_MAX_RATIO === 0 || ol.OVERVIEWMAP_MIN_RATIO === 0) {
    return;
  }
  var map = this.getMap();
  var ovmap = this.ovmap_;
  var mapSize = map.getSize();
  var view = map.getView();
  var extent = view.calculateExtent(mapSize);
  var ovview = ovmap.getView();
  var steps = Math.log(ol.OVERVIEWMAP_MAX_RATIO / ol.OVERVIEWMAP_MIN_RATIO) / Math.LN2;
  var ratio = 1 / (Math.pow(2, steps / 2) * ol.OVERVIEWMAP_MIN_RATIO);
  ol.extent.scaleFromCenter(extent, ratio);
  ovview.fit(extent);
};
ol.control.OverviewMap.prototype.recenter_ = function() {
  var map = this.getMap();
  var ovmap = this.ovmap_;
  var view = map.getView();
  var ovview = ovmap.getView();
  ovview.setCenter(view.getCenter());
};
ol.control.OverviewMap.prototype.updateBox_ = function() {
  var map = this.getMap();
  var ovmap = this.ovmap_;
  if (!map.isRendered() || !ovmap.isRendered()) {
    return;
  }
  var mapSize = map.getSize();
  var view = map.getView();
  var ovview = ovmap.getView();
  var rotation = view.getRotation();
  var overlay = this.boxOverlay_;
  var box = this.boxOverlay_.getElement();
  var extent = view.calculateExtent(mapSize);
  var ovresolution = ovview.getResolution();
  var bottomLeft = ol.extent.getBottomLeft(extent);
  var topRight = ol.extent.getTopRight(extent);
  var rotateBottomLeft = this.calculateCoordinateRotate_(rotation, bottomLeft);
  overlay.setPosition(rotateBottomLeft);
  if (box) {
    box.style.width = Math.abs((bottomLeft[0] - topRight[0]) / ovresolution) + "px";
    box.style.height = Math.abs((topRight[1] - bottomLeft[1]) / ovresolution) + "px";
  }
};
ol.control.OverviewMap.prototype.calculateCoordinateRotate_ = function(rotation, coordinate) {
  var coordinateRotate;
  var map = this.getMap();
  var view = map.getView();
  var currentCenter = view.getCenter();
  if (currentCenter) {
    coordinateRotate = [coordinate[0] - currentCenter[0], coordinate[1] - currentCenter[1]];
    ol.coordinate.rotate(coordinateRotate, rotation);
    ol.coordinate.add(coordinateRotate, currentCenter);
  }
  return coordinateRotate;
};
ol.control.OverviewMap.prototype.handleClick_ = function(event) {
  event.preventDefault();
  this.handleToggle_();
};
ol.control.OverviewMap.prototype.handleToggle_ = function() {
  this.element.classList.toggle("ol-collapsed");
  if (this.collapsed_) {
    ol.dom.replaceNode(this.collapseLabel_, this.label_);
  } else {
    ol.dom.replaceNode(this.label_, this.collapseLabel_);
  }
  this.collapsed_ = !this.collapsed_;
  var ovmap = this.ovmap_;
  if (!this.collapsed_ && !ovmap.isRendered()) {
    ovmap.updateSize();
    this.resetExtent_();
    ol.events.listenOnce(ovmap, ol.MapEventType.POSTRENDER, function(event) {
      this.updateBox_();
    }, this);
  }
};
ol.control.OverviewMap.prototype.getCollapsible = function() {
  return this.collapsible_;
};
ol.control.OverviewMap.prototype.setCollapsible = function(collapsible) {
  if (this.collapsible_ === collapsible) {
    return;
  }
  this.collapsible_ = collapsible;
  this.element.classList.toggle("ol-uncollapsible");
  if (!collapsible && this.collapsed_) {
    this.handleToggle_();
  }
};
ol.control.OverviewMap.prototype.setCollapsed = function(collapsed) {
  if (!this.collapsible_ || this.collapsed_ === collapsed) {
    return;
  }
  this.handleToggle_();
};
ol.control.OverviewMap.prototype.getCollapsed = function() {
  return this.collapsed_;
};
ol.control.OverviewMap.prototype.getOverviewMap = function() {
  return this.ovmap_;
};
goog.provide("ol.control.ScaleLineUnits");
ol.control.ScaleLineUnits = {DEGREES:"degrees", IMPERIAL:"imperial", NAUTICAL:"nautical", METRIC:"metric", US:"us"};
goog.provide("ol.control.ScaleLine");
goog.require("ol");
goog.require("ol.Object");
goog.require("ol.asserts");
goog.require("ol.control.Control");
goog.require("ol.control.ScaleLineUnits");
goog.require("ol.css");
goog.require("ol.events");
goog.require("ol.proj");
goog.require("ol.proj.Units");
ol.control.ScaleLine = function(opt_options) {
  var options = opt_options ? opt_options : {};
  var className = options.className !== undefined ? options.className : "ol-scale-line";
  this.innerElement_ = document.createElement("DIV");
  this.innerElement_.className = className + "-inner";
  this.element_ = document.createElement("DIV");
  this.element_.className = className + " " + ol.css.CLASS_UNSELECTABLE;
  this.element_.appendChild(this.innerElement_);
  this.viewState_ = null;
  this.minWidth_ = options.minWidth !== undefined ? options.minWidth : 64;
  this.renderedVisible_ = false;
  this.renderedWidth_ = undefined;
  this.renderedHTML_ = "";
  var render = options.render ? options.render : ol.control.ScaleLine.render;
  ol.control.Control.call(this, {element:this.element_, render:render, target:options.target});
  ol.events.listen(this, ol.Object.getChangeEventType(ol.control.ScaleLine.Property_.UNITS), this.handleUnitsChanged_, this);
  this.setUnits(options.units || ol.control.ScaleLineUnits.METRIC);
};
ol.inherits(ol.control.ScaleLine, ol.control.Control);
ol.control.ScaleLine.LEADING_DIGITS = [1, 2, 5];
ol.control.ScaleLine.prototype.getUnits = function() {
  return this.get(ol.control.ScaleLine.Property_.UNITS);
};
ol.control.ScaleLine.render = function(mapEvent) {
  var frameState = mapEvent.frameState;
  if (!frameState) {
    this.viewState_ = null;
  } else {
    this.viewState_ = frameState.viewState;
  }
  this.updateElement_();
};
ol.control.ScaleLine.prototype.handleUnitsChanged_ = function() {
  this.updateElement_();
};
ol.control.ScaleLine.prototype.setUnits = function(units) {
  this.set(ol.control.ScaleLine.Property_.UNITS, units);
};
ol.control.ScaleLine.prototype.updateElement_ = function() {
  var viewState = this.viewState_;
  if (!viewState) {
    if (this.renderedVisible_) {
      this.element_.style.display = "none";
      this.renderedVisible_ = false;
    }
    return;
  }
  var center = viewState.center;
  var projection = viewState.projection;
  var units = this.getUnits();
  var pointResolutionUnits = units == ol.control.ScaleLineUnits.DEGREES ? ol.proj.Units.DEGREES : ol.proj.Units.METERS;
  var pointResolution = ol.proj.getPointResolution(projection, viewState.resolution, center, pointResolutionUnits);
  if (units != ol.control.ScaleLineUnits.DEGREES) {
    pointResolution *= projection.getMetersPerUnit();
  }
  var nominalCount = this.minWidth_ * pointResolution;
  var suffix = "";
  if (units == ol.control.ScaleLineUnits.DEGREES) {
    var metersPerDegree = ol.proj.METERS_PER_UNIT[ol.proj.Units.DEGREES];
    if (projection.getUnits() == ol.proj.Units.DEGREES) {
      nominalCount *= metersPerDegree;
    } else {
      pointResolution /= metersPerDegree;
    }
    if (nominalCount < metersPerDegree / 60) {
      suffix = "\u2033";
      pointResolution *= 3600;
    } else {
      if (nominalCount < metersPerDegree) {
        suffix = "\u2032";
        pointResolution *= 60;
      } else {
        suffix = "\u00b0";
      }
    }
  } else {
    if (units == ol.control.ScaleLineUnits.IMPERIAL) {
      if (nominalCount < 0.9144) {
        suffix = "in";
        pointResolution /= 0.0254;
      } else {
        if (nominalCount < 1609.344) {
          suffix = "ft";
          pointResolution /= 0.3048;
        } else {
          suffix = "mi";
          pointResolution /= 1609.344;
        }
      }
    } else {
      if (units == ol.control.ScaleLineUnits.NAUTICAL) {
        pointResolution /= 1852;
        suffix = "nm";
      } else {
        if (units == ol.control.ScaleLineUnits.METRIC) {
          if (nominalCount < 0.001) {
            suffix = "\u03bcm";
            pointResolution *= 1000000;
          } else {
            if (nominalCount < 1) {
              suffix = "mm";
              pointResolution *= 1000;
            } else {
              if (nominalCount < 1000) {
                suffix = "m";
              } else {
                suffix = "km";
                pointResolution /= 1000;
              }
            }
          }
        } else {
          if (units == ol.control.ScaleLineUnits.US) {
            if (nominalCount < 0.9144) {
              suffix = "in";
              pointResolution *= 39.37;
            } else {
              if (nominalCount < 1609.344) {
                suffix = "ft";
                pointResolution /= 0.30480061;
              } else {
                suffix = "mi";
                pointResolution /= 1609.3472;
              }
            }
          } else {
            ol.asserts.assert(false, 33);
          }
        }
      }
    }
  }
  var i = 3 * Math.floor(Math.log(this.minWidth_ * pointResolution) / Math.log(10));
  var count, width;
  while (true) {
    count = ol.control.ScaleLine.LEADING_DIGITS[(i % 3 + 3) % 3] * Math.pow(10, Math.floor(i / 3));
    width = Math.round(count / pointResolution);
    if (isNaN(width)) {
      this.element_.style.display = "none";
      this.renderedVisible_ = false;
      return;
    } else {
      if (width >= this.minWidth_) {
        break;
      }
    }
    ++i;
  }
  var html = count + " " + suffix;
  if (this.renderedHTML_ != html) {
    this.innerElement_.innerHTML = html;
    this.renderedHTML_ = html;
  }
  if (this.renderedWidth_ != width) {
    this.innerElement_.style.width = width + "px";
    this.renderedWidth_ = width;
  }
  if (!this.renderedVisible_) {
    this.element_.style.display = "";
    this.renderedVisible_ = true;
  }
};
ol.control.ScaleLine.Property_ = {UNITS:"units"};
goog.provide("ol.control.ZoomSlider");
goog.require("ol");
goog.require("ol.ViewHint");
goog.require("ol.control.Control");
goog.require("ol.css");
goog.require("ol.easing");
goog.require("ol.events");
goog.require("ol.events.Event");
goog.require("ol.events.EventType");
goog.require("ol.math");
goog.require("ol.pointer.EventType");
goog.require("ol.pointer.PointerEventHandler");
ol.control.ZoomSlider = function(opt_options) {
  var options = opt_options ? opt_options : {};
  this.currentResolution_ = undefined;
  this.direction_ = ol.control.ZoomSlider.Direction_.VERTICAL;
  this.dragging_;
  this.heightLimit_ = 0;
  this.widthLimit_ = 0;
  this.previousX_;
  this.previousY_;
  this.thumbSize_ = null;
  this.sliderInitialized_ = false;
  this.duration_ = options.duration !== undefined ? options.duration : 200;
  var className = options.className !== undefined ? options.className : "ol-zoomslider";
  var thumbElement = document.createElement("button");
  thumbElement.setAttribute("type", "button");
  thumbElement.className = className + "-thumb " + ol.css.CLASS_UNSELECTABLE;
  var containerElement = document.createElement("div");
  containerElement.className = className + " " + ol.css.CLASS_UNSELECTABLE + " " + ol.css.CLASS_CONTROL;
  containerElement.appendChild(thumbElement);
  this.dragger_ = new ol.pointer.PointerEventHandler(containerElement);
  ol.events.listen(this.dragger_, ol.pointer.EventType.POINTERDOWN, this.handleDraggerStart_, this);
  ol.events.listen(this.dragger_, ol.pointer.EventType.POINTERMOVE, this.handleDraggerDrag_, this);
  ol.events.listen(this.dragger_, ol.pointer.EventType.POINTERUP, this.handleDraggerEnd_, this);
  ol.events.listen(containerElement, ol.events.EventType.CLICK, this.handleContainerClick_, this);
  ol.events.listen(thumbElement, ol.events.EventType.CLICK, ol.events.Event.stopPropagation);
  var render = options.render ? options.render : ol.control.ZoomSlider.render;
  ol.control.Control.call(this, {element:containerElement, render:render});
};
ol.inherits(ol.control.ZoomSlider, ol.control.Control);
ol.control.ZoomSlider.prototype.disposeInternal = function() {
  this.dragger_.dispose();
  ol.control.Control.prototype.disposeInternal.call(this);
};
ol.control.ZoomSlider.Direction_ = {VERTICAL:0, HORIZONTAL:1};
ol.control.ZoomSlider.prototype.setMap = function(map) {
  ol.control.Control.prototype.setMap.call(this, map);
  if (map) {
    map.render();
  }
};
ol.control.ZoomSlider.prototype.initSlider_ = function() {
  var container = this.element;
  var containerSize = {width:container.offsetWidth, height:container.offsetHeight};
  var thumb = container.firstElementChild;
  var computedStyle = getComputedStyle(thumb);
  var thumbWidth = thumb.offsetWidth + parseFloat(computedStyle["marginRight"]) + parseFloat(computedStyle["marginLeft"]);
  var thumbHeight = thumb.offsetHeight + parseFloat(computedStyle["marginTop"]) + parseFloat(computedStyle["marginBottom"]);
  this.thumbSize_ = [thumbWidth, thumbHeight];
  if (containerSize.width > containerSize.height) {
    this.direction_ = ol.control.ZoomSlider.Direction_.HORIZONTAL;
    this.widthLimit_ = containerSize.width - thumbWidth;
  } else {
    this.direction_ = ol.control.ZoomSlider.Direction_.VERTICAL;
    this.heightLimit_ = containerSize.height - thumbHeight;
  }
  this.sliderInitialized_ = true;
};
ol.control.ZoomSlider.render = function(mapEvent) {
  if (!mapEvent.frameState) {
    return;
  }
  if (!this.sliderInitialized_) {
    this.initSlider_();
  }
  var res = mapEvent.frameState.viewState.resolution;
  if (res !== this.currentResolution_) {
    this.currentResolution_ = res;
    this.setThumbPosition_(res);
  }
};
ol.control.ZoomSlider.prototype.handleContainerClick_ = function(event) {
  var view = this.getMap().getView();
  var relativePosition = this.getRelativePosition_(event.offsetX - this.thumbSize_[0] / 2, event.offsetY - this.thumbSize_[1] / 2);
  var resolution = this.getResolutionForPosition_(relativePosition);
  view.animate({resolution:view.constrainResolution(resolution), duration:this.duration_, easing:ol.easing.easeOut});
};
ol.control.ZoomSlider.prototype.handleDraggerStart_ = function(event) {
  if (!this.dragging_ && event.originalEvent.target === this.element.firstElementChild) {
    this.getMap().getView().setHint(ol.ViewHint.INTERACTING, 1);
    this.previousX_ = event.clientX;
    this.previousY_ = event.clientY;
    this.dragging_ = true;
  }
};
ol.control.ZoomSlider.prototype.handleDraggerDrag_ = function(event) {
  if (this.dragging_) {
    var element = this.element.firstElementChild;
    var deltaX = event.clientX - this.previousX_ + parseInt(element.style.left, 10);
    var deltaY = event.clientY - this.previousY_ + parseInt(element.style.top, 10);
    var relativePosition = this.getRelativePosition_(deltaX, deltaY);
    this.currentResolution_ = this.getResolutionForPosition_(relativePosition);
    this.getMap().getView().setResolution(this.currentResolution_);
    this.setThumbPosition_(this.currentResolution_);
    this.previousX_ = event.clientX;
    this.previousY_ = event.clientY;
  }
};
ol.control.ZoomSlider.prototype.handleDraggerEnd_ = function(event) {
  if (this.dragging_) {
    var view = this.getMap().getView();
    view.setHint(ol.ViewHint.INTERACTING, -1);
    view.animate({resolution:view.constrainResolution(this.currentResolution_), duration:this.duration_, easing:ol.easing.easeOut});
    this.dragging_ = false;
    this.previousX_ = undefined;
    this.previousY_ = undefined;
  }
};
ol.control.ZoomSlider.prototype.setThumbPosition_ = function(res) {
  var position = this.getPositionForResolution_(res);
  var thumb = this.element.firstElementChild;
  if (this.direction_ == ol.control.ZoomSlider.Direction_.HORIZONTAL) {
    thumb.style.left = this.widthLimit_ * position + "px";
  } else {
    thumb.style.top = this.heightLimit_ * position + "px";
  }
};
ol.control.ZoomSlider.prototype.getRelativePosition_ = function(x, y) {
  var amount;
  if (this.direction_ === ol.control.ZoomSlider.Direction_.HORIZONTAL) {
    amount = x / this.widthLimit_;
  } else {
    amount = y / this.heightLimit_;
  }
  return ol.math.clamp(amount, 0, 1);
};
ol.control.ZoomSlider.prototype.getResolutionForPosition_ = function(position) {
  var fn = this.getMap().getView().getResolutionForValueFunction();
  return fn(1 - position);
};
ol.control.ZoomSlider.prototype.getPositionForResolution_ = function(res) {
  var fn = this.getMap().getView().getValueForResolutionFunction();
  return 1 - fn(res);
};
goog.provide("ol.control.ZoomToExtent");
goog.require("ol");
goog.require("ol.events");
goog.require("ol.events.EventType");
goog.require("ol.control.Control");
goog.require("ol.css");
ol.control.ZoomToExtent = function(opt_options) {
  var options = opt_options ? opt_options : {};
  this.extent = options.extent ? options.extent : null;
  var className = options.className !== undefined ? options.className : "ol-zoom-extent";
  var label = options.label !== undefined ? options.label : "E";
  var tipLabel = options.tipLabel !== undefined ? options.tipLabel : "Fit to extent";
  var button = document.createElement("button");
  button.setAttribute("type", "button");
  button.title = tipLabel;
  button.appendChild(typeof label === "string" ? document.createTextNode(label) : label);
  ol.events.listen(button, ol.events.EventType.CLICK, this.handleClick_, this);
  var cssClasses = className + " " + ol.css.CLASS_UNSELECTABLE + " " + ol.css.CLASS_CONTROL;
  var element = document.createElement("div");
  element.className = cssClasses;
  element.appendChild(button);
  ol.control.Control.call(this, {element:element, target:options.target});
};
ol.inherits(ol.control.ZoomToExtent, ol.control.Control);
ol.control.ZoomToExtent.prototype.handleClick_ = function(event) {
  event.preventDefault();
  this.handleZoomToExtent();
};
ol.control.ZoomToExtent.prototype.handleZoomToExtent = function() {
  var map = this.getMap();
  var view = map.getView();
  var extent = !this.extent ? view.getProjection().getExtent() : this.extent;
  view.fit(extent);
};
goog.provide("ol.DeviceOrientation");
goog.require("ol.events");
goog.require("ol");
goog.require("ol.Object");
goog.require("ol.has");
goog.require("ol.math");
ol.DeviceOrientation = function(opt_options) {
  ol.Object.call(this);
  var options = opt_options ? opt_options : {};
  this.listenerKey_ = null;
  ol.events.listen(this, ol.Object.getChangeEventType(ol.DeviceOrientation.Property_.TRACKING), this.handleTrackingChanged_, this);
  this.setTracking(options.tracking !== undefined ? options.tracking : false);
};
ol.inherits(ol.DeviceOrientation, ol.Object);
ol.DeviceOrientation.prototype.disposeInternal = function() {
  this.setTracking(false);
  ol.Object.prototype.disposeInternal.call(this);
};
ol.DeviceOrientation.prototype.orientationChange_ = function(originalEvent) {
  var event = originalEvent;
  if (event.alpha !== null) {
    var alpha = ol.math.toRadians(event.alpha);
    this.set(ol.DeviceOrientation.Property_.ALPHA, alpha);
    if (typeof event.absolute === "boolean" && event.absolute) {
      this.set(ol.DeviceOrientation.Property_.HEADING, alpha);
    } else {
      if (typeof event.webkitCompassHeading === "number" && event.webkitCompassAccuracy != -1) {
        var heading = ol.math.toRadians(event.webkitCompassHeading);
        this.set(ol.DeviceOrientation.Property_.HEADING, heading);
      }
    }
  }
  if (event.beta !== null) {
    this.set(ol.DeviceOrientation.Property_.BETA, ol.math.toRadians(event.beta));
  }
  if (event.gamma !== null) {
    this.set(ol.DeviceOrientation.Property_.GAMMA, ol.math.toRadians(event.gamma));
  }
  this.changed();
};
ol.DeviceOrientation.prototype.getAlpha = function() {
  return this.get(ol.DeviceOrientation.Property_.ALPHA);
};
ol.DeviceOrientation.prototype.getBeta = function() {
  return this.get(ol.DeviceOrientation.Property_.BETA);
};
ol.DeviceOrientation.prototype.getGamma = function() {
  return this.get(ol.DeviceOrientation.Property_.GAMMA);
};
ol.DeviceOrientation.prototype.getHeading = function() {
  return this.get(ol.DeviceOrientation.Property_.HEADING);
};
ol.DeviceOrientation.prototype.getTracking = function() {
  return this.get(ol.DeviceOrientation.Property_.TRACKING);
};
ol.DeviceOrientation.prototype.handleTrackingChanged_ = function() {
  if (ol.has.DEVICE_ORIENTATION) {
    var tracking = this.getTracking();
    if (tracking && !this.listenerKey_) {
      this.listenerKey_ = ol.events.listen(window, "deviceorientation", this.orientationChange_, this);
    } else {
      if (!tracking && this.listenerKey_ !== null) {
        ol.events.unlistenByKey(this.listenerKey_);
        this.listenerKey_ = null;
      }
    }
  }
};
ol.DeviceOrientation.prototype.setTracking = function(tracking) {
  this.set(ol.DeviceOrientation.Property_.TRACKING, tracking);
};
ol.DeviceOrientation.Property_ = {ALPHA:"alpha", BETA:"beta", GAMMA:"gamma", HEADING:"heading", TRACKING:"tracking"};
goog.provide("ol.format.Feature");
goog.require("ol.geom.Geometry");
goog.require("ol.obj");
goog.require("ol.proj");
ol.format.Feature = function() {
  this.defaultDataProjection = null;
  this.defaultFeatureProjection = null;
};
ol.format.Feature.prototype.getReadOptions = function(source, opt_options) {
  var options;
  if (opt_options) {
    options = {dataProjection:opt_options.dataProjection ? opt_options.dataProjection : this.readProjection(source), featureProjection:opt_options.featureProjection};
  }
  return this.adaptOptions(options);
};
ol.format.Feature.prototype.adaptOptions = function(options) {
  return ol.obj.assign({dataProjection:this.defaultDataProjection, featureProjection:this.defaultFeatureProjection}, options);
};
ol.format.Feature.prototype.getLastExtent = function() {
  return null;
};
ol.format.Feature.prototype.getType = function() {
};
ol.format.Feature.prototype.readFeature = function(source, opt_options) {
};
ol.format.Feature.prototype.readFeatures = function(source, opt_options) {
};
ol.format.Feature.prototype.readGeometry = function(source, opt_options) {
};
ol.format.Feature.prototype.readProjection = function(source) {
};
ol.format.Feature.prototype.writeFeature = function(feature, opt_options) {
};
ol.format.Feature.prototype.writeFeatures = function(features, opt_options) {
};
ol.format.Feature.prototype.writeGeometry = function(geometry, opt_options) {
};
ol.format.Feature.transformWithOptions = function(geometry, write, opt_options) {
  var featureProjection = opt_options ? ol.proj.get(opt_options.featureProjection) : null;
  var dataProjection = opt_options ? ol.proj.get(opt_options.dataProjection) : null;
  var transformed;
  if (featureProjection && dataProjection && !ol.proj.equivalent(featureProjection, dataProjection)) {
    if (geometry instanceof ol.geom.Geometry) {
      transformed = (write ? geometry.clone() : geometry).transform(write ? featureProjection : dataProjection, write ? dataProjection : featureProjection);
    } else {
      transformed = ol.proj.transformExtent(geometry, dataProjection, featureProjection);
    }
  } else {
    transformed = geometry;
  }
  if (write && opt_options && opt_options.decimals !== undefined) {
    var power = Math.pow(10, opt_options.decimals);
    var transform = function(coordinates) {
      for (var i = 0, ii = coordinates.length; i < ii; ++i) {
        coordinates[i] = Math.round(coordinates[i] * power) / power;
      }
      return coordinates;
    };
    if (transformed === geometry) {
      transformed = transformed.clone();
    }
    transformed.applyTransform(transform);
  }
  return transformed;
};
goog.provide("ol.format.JSONFeature");
goog.require("ol");
goog.require("ol.format.Feature");
goog.require("ol.format.FormatType");
ol.format.JSONFeature = function() {
  ol.format.Feature.call(this);
};
ol.inherits(ol.format.JSONFeature, ol.format.Feature);
ol.format.JSONFeature.prototype.getObject_ = function(source) {
  if (typeof source === "string") {
    var object = JSON.parse(source);
    return object ? object : null;
  } else {
    if (source !== null) {
      return source;
    } else {
      return null;
    }
  }
};
ol.format.JSONFeature.prototype.getType = function() {
  return ol.format.FormatType.JSON;
};
ol.format.JSONFeature.prototype.readFeature = function(source, opt_options) {
  return this.readFeatureFromObject(this.getObject_(source), this.getReadOptions(source, opt_options));
};
ol.format.JSONFeature.prototype.readFeatures = function(source, opt_options) {
  return this.readFeaturesFromObject(this.getObject_(source), this.getReadOptions(source, opt_options));
};
ol.format.JSONFeature.prototype.readFeatureFromObject = function(object, opt_options) {
};
ol.format.JSONFeature.prototype.readFeaturesFromObject = function(object, opt_options) {
};
ol.format.JSONFeature.prototype.readGeometry = function(source, opt_options) {
  return this.readGeometryFromObject(this.getObject_(source), this.getReadOptions(source, opt_options));
};
ol.format.JSONFeature.prototype.readGeometryFromObject = function(object, opt_options) {
};
ol.format.JSONFeature.prototype.readProjection = function(source) {
  return this.readProjectionFromObject(this.getObject_(source));
};
ol.format.JSONFeature.prototype.readProjectionFromObject = function(object) {
};
ol.format.JSONFeature.prototype.writeFeature = function(feature, opt_options) {
  return JSON.stringify(this.writeFeatureObject(feature, opt_options));
};
ol.format.JSONFeature.prototype.writeFeatureObject = function(feature, opt_options) {
};
ol.format.JSONFeature.prototype.writeFeatures = function(features, opt_options) {
  return JSON.stringify(this.writeFeaturesObject(features, opt_options));
};
ol.format.JSONFeature.prototype.writeFeaturesObject = function(features, opt_options) {
};
ol.format.JSONFeature.prototype.writeGeometry = function(geometry, opt_options) {
  return JSON.stringify(this.writeGeometryObject(geometry, opt_options));
};
ol.format.JSONFeature.prototype.writeGeometryObject = function(geometry, opt_options) {
};
goog.provide("ol.geom.flat.interpolate");
goog.require("ol.array");
goog.require("ol.math");
ol.geom.flat.interpolate.lineString = function(flatCoordinates, offset, end, stride, fraction, opt_dest) {
  var pointX = NaN;
  var pointY = NaN;
  var n = (end - offset) / stride;
  if (n === 1) {
    pointX = flatCoordinates[offset];
    pointY = flatCoordinates[offset + 1];
  } else {
    if (n == 2) {
      pointX = (1 - fraction) * flatCoordinates[offset] + fraction * flatCoordinates[offset + stride];
      pointY = (1 - fraction) * flatCoordinates[offset + 1] + fraction * flatCoordinates[offset + stride + 1];
    } else {
      if (n !== 0) {
        var x1 = flatCoordinates[offset];
        var y1 = flatCoordinates[offset + 1];
        var length = 0;
        var cumulativeLengths = [0];
        var i;
        for (i = offset + stride; i < end; i += stride) {
          var x2 = flatCoordinates[i];
          var y2 = flatCoordinates[i + 1];
          length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
          cumulativeLengths.push(length);
          x1 = x2;
          y1 = y2;
        }
        var target = fraction * length;
        var index = ol.array.binarySearch(cumulativeLengths, target);
        if (index < 0) {
          var t = (target - cumulativeLengths[-index - 2]) / (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);
          var o = offset + (-index - 2) * stride;
          pointX = ol.math.lerp(flatCoordinates[o], flatCoordinates[o + stride], t);
          pointY = ol.math.lerp(flatCoordinates[o + 1], flatCoordinates[o + stride + 1], t);
        } else {
          pointX = flatCoordinates[offset + index * stride];
          pointY = flatCoordinates[offset + index * stride + 1];
        }
      }
    }
  }
  if (opt_dest) {
    opt_dest[0] = pointX;
    opt_dest[1] = pointY;
    return opt_dest;
  } else {
    return [pointX, pointY];
  }
};
ol.geom.flat.interpolate.lineStringCoordinateAtM = function(flatCoordinates, offset, end, stride, m, extrapolate) {
  if (end == offset) {
    return null;
  }
  var coordinate;
  if (m < flatCoordinates[offset + stride - 1]) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(offset, offset + stride);
      coordinate[stride - 1] = m;
      return coordinate;
    } else {
      return null;
    }
  } else {
    if (flatCoordinates[end - 1] < m) {
      if (extrapolate) {
        coordinate = flatCoordinates.slice(end - stride, end);
        coordinate[stride - 1] = m;
        return coordinate;
      } else {
        return null;
      }
    }
  }
  if (m == flatCoordinates[offset + stride - 1]) {
    return flatCoordinates.slice(offset, offset + stride);
  }
  var lo = offset / stride;
  var hi = end / stride;
  while (lo < hi) {
    var mid = lo + hi >> 1;
    if (m < flatCoordinates[(mid + 1) * stride - 1]) {
      hi = mid;
    } else {
      lo = mid + 1;
    }
  }
  var m0 = flatCoordinates[lo * stride - 1];
  if (m == m0) {
    return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);
  }
  var m1 = flatCoordinates[(lo + 1) * stride - 1];
  var t = (m - m0) / (m1 - m0);
  coordinate = [];
  var i;
  for (i = 0; i < stride - 1; ++i) {
    coordinate.push(ol.math.lerp(flatCoordinates[(lo - 1) * stride + i], flatCoordinates[lo * stride + i], t));
  }
  coordinate.push(m);
  return coordinate;
};
ol.geom.flat.interpolate.lineStringsCoordinateAtM = function(flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {
  if (interpolate) {
    return ol.geom.flat.interpolate.lineStringCoordinateAtM(flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);
  }
  var coordinate;
  if (m < flatCoordinates[stride - 1]) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(0, stride);
      coordinate[stride - 1] = m;
      return coordinate;
    } else {
      return null;
    }
  }
  if (flatCoordinates[flatCoordinates.length - 1] < m) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(flatCoordinates.length - stride);
      coordinate[stride - 1] = m;
      return coordinate;
    } else {
      return null;
    }
  }
  var i, ii;
  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    if (offset == end) {
      continue;
    }
    if (m < flatCoordinates[offset + stride - 1]) {
      return null;
    } else {
      if (m <= flatCoordinates[end - 1]) {
        return ol.geom.flat.interpolate.lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, false);
      }
    }
    offset = end;
  }
  return null;
};
goog.provide("ol.geom.LineString");
goog.require("ol");
goog.require("ol.array");
goog.require("ol.extent");
goog.require("ol.geom.GeometryLayout");
goog.require("ol.geom.GeometryType");
goog.require("ol.geom.SimpleGeometry");
goog.require("ol.geom.flat.closest");
goog.require("ol.geom.flat.deflate");
goog.require("ol.geom.flat.inflate");
goog.require("ol.geom.flat.interpolate");
goog.require("ol.geom.flat.intersectsextent");
goog.require("ol.geom.flat.length");
goog.require("ol.geom.flat.segments");
goog.require("ol.geom.flat.simplify");
ol.geom.LineString = function(coordinates, opt_layout) {
  ol.geom.SimpleGeometry.call(this);
  this.flatMidpoint_ = null;
  this.flatMidpointRevision_ = -1;
  this.maxDelta_ = -1;
  this.maxDeltaRevision_ = -1;
  this.setCoordinates(coordinates, opt_layout);
};
ol.inherits(ol.geom.LineString, ol.geom.SimpleGeometry);
ol.geom.LineString.prototype.appendCoordinate = function(coordinate) {
  if (!this.flatCoordinates) {
    this.flatCoordinates = coordinate.slice();
  } else {
    ol.array.extend(this.flatCoordinates, coordinate);
  }
  this.changed();
};
ol.geom.LineString.prototype.clone = function() {
  var lineString = new ol.geom.LineString(null);
  lineString.setFlatCoordinates(this.layout, this.flatCoordinates.slice());
  return lineString;
};
ol.geom.LineString.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {
  if (minSquaredDistance < ol.extent.closestSquaredDistanceXY(this.getExtent(), x, y)) {
    return minSquaredDistance;
  }
  if (this.maxDeltaRevision_ != this.getRevision()) {
    this.maxDelta_ = Math.sqrt(ol.geom.flat.closest.getMaxSquaredDelta(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
    this.maxDeltaRevision_ = this.getRevision();
  }
  return ol.geom.flat.closest.getClosestPoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);
};
ol.geom.LineString.prototype.forEachSegment = function(callback, opt_this) {
  return ol.geom.flat.segments.forEach(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, callback, opt_this);
};
ol.geom.LineString.prototype.getCoordinateAtM = function(m, opt_extrapolate) {
  if (this.layout != ol.geom.GeometryLayout.XYM && this.layout != ol.geom.GeometryLayout.XYZM) {
    return null;
  }
  var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;
  return ol.geom.flat.interpolate.lineStringCoordinateAtM(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, m, extrapolate);
};
ol.geom.LineString.prototype.getCoordinates = function() {
  return ol.geom.flat.inflate.coordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
};
ol.geom.LineString.prototype.getCoordinateAt = function(fraction, opt_dest) {
  return ol.geom.flat.interpolate.lineString(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, fraction, opt_dest);
};
ol.geom.LineString.prototype.getLength = function() {
  return ol.geom.flat.length.lineString(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
};
ol.geom.LineString.prototype.getFlatMidpoint = function() {
  if (this.flatMidpointRevision_ != this.getRevision()) {
    this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_);
    this.flatMidpointRevision_ = this.getRevision();
  }
  return this.flatMidpoint_;
};
ol.geom.LineString.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {
  var simplifiedFlatCoordinates = [];
  simplifiedFlatCoordinates.length = ol.geom.flat.simplify.douglasPeucker(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);
  var simplifiedLineString = new ol.geom.LineString(null);
  simplifiedLineString.setFlatCoordinates(ol.geom.GeometryLayout.XY, simplifiedFlatCoordinates);
  return simplifiedLineString;
};
ol.geom.LineString.prototype.getType = function() {
  return ol.geom.GeometryType.LINE_STRING;
};
ol.geom.LineString.prototype.intersectsExtent = function(extent) {
  return ol.geom.flat.intersectsextent.lineString(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);
};
ol.geom.LineString.prototype.setCoordinates = function(coordinates, opt_layout) {
  if (!coordinates) {
    this.setFlatCoordinates(ol.geom.GeometryLayout.XY, null);
  } else {
    this.setLayout(opt_layout, coordinates, 1);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = ol.geom.flat.deflate.coordinates(this.flatCoordinates, 0, coordinates, this.stride);
    this.changed();
  }
};
ol.geom.LineString.prototype.setFlatCoordinates = function(layout, flatCoordinates) {
  this.setFlatCoordinatesInternal(layout, flatCoordinates);
  this.changed();
};
goog.provide("ol.geom.MultiLineString");
goog.require("ol");
goog.require("ol.array");
goog.require("ol.extent");
goog.require("ol.geom.GeometryLayout");
goog.require("ol.geom.GeometryType");
goog.require("ol.geom.LineString");
goog.require("ol.geom.SimpleGeometry");
goog.require("ol.geom.flat.closest");
goog.require("ol.geom.flat.deflate");
goog.require("ol.geom.flat.inflate");
goog.require("ol.geom.flat.interpolate");
goog.require("ol.geom.flat.intersectsextent");
goog.require("ol.geom.flat.simplify");
ol.geom.MultiLineString = function(coordinates, opt_layout) {
  ol.geom.SimpleGeometry.call(this);
  this.ends_ = [];
  this.maxDelta_ = -1;
  this.maxDeltaRevision_ = -1;
  this.setCoordinates(coordinates, opt_layout);
};
ol.inherits(ol.geom.MultiLineString, ol.geom.SimpleGeometry);
ol.geom.MultiLineString.prototype.appendLineString = function(lineString) {
  if (!this.flatCoordinates) {
    this.flatCoordinates = lineString.getFlatCoordinates().slice();
  } else {
    ol.array.extend(this.flatCoordinates, lineString.getFlatCoordinates().slice());
  }
  this.ends_.push(this.flatCoordinates.length);
  this.changed();
};
ol.geom.MultiLineString.prototype.clone = function() {
  var multiLineString = new ol.geom.MultiLineString(null);
  multiLineString.setFlatCoordinates(this.layout, this.flatCoordinates.slice(), this.ends_.slice());
  return multiLineString;
};
ol.geom.MultiLineString.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {
  if (minSquaredDistance < ol.extent.closestSquaredDistanceXY(this.getExtent(), x, y)) {
    return minSquaredDistance;
  }
  if (this.maxDeltaRevision_ != this.getRevision()) {
    this.maxDelta_ = Math.sqrt(ol.geom.flat.closest.getsMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));
    this.maxDeltaRevision_ = this.getRevision();
  }
  return ol.geom.flat.closest.getsClosestPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);
};
ol.geom.MultiLineString.prototype.getCoordinateAtM = function(m, opt_extrapolate, opt_interpolate) {
  if (this.layout != ol.geom.GeometryLayout.XYM && this.layout != ol.geom.GeometryLayout.XYZM || this.flatCoordinates.length === 0) {
    return null;
  }
  var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;
  var interpolate = opt_interpolate !== undefined ? opt_interpolate : false;
  return ol.geom.flat.interpolate.lineStringsCoordinateAtM(this.flatCoordinates, 0, this.ends_, this.stride, m, extrapolate, interpolate);
};
ol.geom.MultiLineString.prototype.getCoordinates = function() {
  return ol.geom.flat.inflate.coordinatess(this.flatCoordinates, 0, this.ends_, this.stride);
};
ol.geom.MultiLineString.prototype.getEnds = function() {
  return this.ends_;
};
ol.geom.MultiLineString.prototype.getLineString = function(index) {
  if (index < 0 || this.ends_.length <= index) {
    return null;
  }
  var lineString = new ol.geom.LineString(null);
  lineString.setFlatCoordinates(this.layout, this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]));
  return lineString;
};
ol.geom.MultiLineString.prototype.getLineStrings = function() {
  var flatCoordinates = this.flatCoordinates;
  var ends = this.ends_;
  var layout = this.layout;
  var lineStrings = [];
  var offset = 0;
  var i, ii;
  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    var lineString = new ol.geom.LineString(null);
    lineString.setFlatCoordinates(layout, flatCoordinates.slice(offset, end));
    lineStrings.push(lineString);
    offset = end;
  }
  return lineStrings;
};
ol.geom.MultiLineString.prototype.getFlatMidpoints = function() {
  var midpoints = [];
  var flatCoordinates = this.flatCoordinates;
  var offset = 0;
  var ends = this.ends_;
  var stride = this.stride;
  var i, ii;
  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    var midpoint = ol.geom.flat.interpolate.lineString(flatCoordinates, offset, end, stride, 0.5);
    ol.array.extend(midpoints, midpoint);
    offset = end;
  }
  return midpoints;
};
ol.geom.MultiLineString.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {
  var simplifiedFlatCoordinates = [];
  var simplifiedEnds = [];
  simplifiedFlatCoordinates.length = ol.geom.flat.simplify.douglasPeuckers(this.flatCoordinates, 0, this.ends_, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0, simplifiedEnds);
  var simplifiedMultiLineString = new ol.geom.MultiLineString(null);
  simplifiedMultiLineString.setFlatCoordinates(ol.geom.GeometryLayout.XY, simplifiedFlatCoordinates, simplifiedEnds);
  return simplifiedMultiLineString;
};
ol.geom.MultiLineString.prototype.getType = function() {
  return ol.geom.GeometryType.MULTI_LINE_STRING;
};
ol.geom.MultiLineString.prototype.intersectsExtent = function(extent) {
  return ol.geom.flat.intersectsextent.lineStrings(this.flatCoordinates, 0, this.ends_, this.stride, extent);
};
ol.geom.MultiLineString.prototype.setCoordinates = function(coordinates, opt_layout) {
  if (!coordinates) {
    this.setFlatCoordinates(ol.geom.GeometryLayout.XY, null, this.ends_);
  } else {
    this.setLayout(opt_layout, coordinates, 2);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    var ends = ol.geom.flat.deflate.coordinatess(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);
    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
    this.changed();
  }
};
ol.geom.MultiLineString.prototype.setFlatCoordinates = function(layout, flatCoordinates, ends) {
  this.setFlatCoordinatesInternal(layout, flatCoordinates);
  this.ends_ = ends;
  this.changed();
};
ol.geom.MultiLineString.prototype.setLineStrings = function(lineStrings) {
  var layout = this.getLayout();
  var flatCoordinates = [];
  var ends = [];
  var i, ii;
  for (i = 0, ii = lineStrings.length; i < ii; ++i) {
    var lineString = lineStrings[i];
    if (i === 0) {
      layout = lineString.getLayout();
    }
    ol.array.extend(flatCoordinates, lineString.getFlatCoordinates());
    ends.push(flatCoordinates.length);
  }
  this.setFlatCoordinates(layout, flatCoordinates, ends);
};
goog.provide("ol.geom.MultiPoint");
goog.require("ol");
goog.require("ol.array");
goog.require("ol.extent");
goog.require("ol.geom.GeometryLayout");
goog.require("ol.geom.GeometryType");
goog.require("ol.geom.Point");
goog.require("ol.geom.SimpleGeometry");
goog.require("ol.geom.flat.deflate");
goog.require("ol.geom.flat.inflate");
goog.require("ol.math");
ol.geom.MultiPoint = function(coordinates, opt_layout) {
  ol.geom.SimpleGeometry.call(this);
  this.setCoordinates(coordinates, opt_layout);
};
ol.inherits(ol.geom.MultiPoint, ol.geom.SimpleGeometry);
ol.geom.MultiPoint.prototype.appendPoint = function(point) {
  if (!this.flatCoordinates) {
    this.flatCoordinates = point.getFlatCoordinates().slice();
  } else {
    ol.array.extend(this.flatCoordinates, point.getFlatCoordinates());
  }
  this.changed();
};
ol.geom.MultiPoint.prototype.clone = function() {
  var multiPoint = new ol.geom.MultiPoint(null);
  multiPoint.setFlatCoordinates(this.layout, this.flatCoordinates.slice());
  return multiPoint;
};
ol.geom.MultiPoint.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {
  if (minSquaredDistance < ol.extent.closestSquaredDistanceXY(this.getExtent(), x, y)) {
    return minSquaredDistance;
  }
  var flatCoordinates = this.flatCoordinates;
  var stride = this.stride;
  var i, ii, j;
  for (i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
    var squaredDistance = ol.math.squaredDistance(x, y, flatCoordinates[i], flatCoordinates[i + 1]);
    if (squaredDistance < minSquaredDistance) {
      minSquaredDistance = squaredDistance;
      for (j = 0; j < stride; ++j) {
        closestPoint[j] = flatCoordinates[i + j];
      }
      closestPoint.length = stride;
    }
  }
  return minSquaredDistance;
};
ol.geom.MultiPoint.prototype.getCoordinates = function() {
  return ol.geom.flat.inflate.coordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
};
ol.geom.MultiPoint.prototype.getPoint = function(index) {
  var n = !this.flatCoordinates ? 0 : this.flatCoordinates.length / this.stride;
  if (index < 0 || n <= index) {
    return null;
  }
  var point = new ol.geom.Point(null);
  point.setFlatCoordinates(this.layout, this.flatCoordinates.slice(index * this.stride, (index + 1) * this.stride));
  return point;
};
ol.geom.MultiPoint.prototype.getPoints = function() {
  var flatCoordinates = this.flatCoordinates;
  var layout = this.layout;
  var stride = this.stride;
  var points = [];
  var i, ii;
  for (i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
    var point = new ol.geom.Point(null);
    point.setFlatCoordinates(layout, flatCoordinates.slice(i, i + stride));
    points.push(point);
  }
  return points;
};
ol.geom.MultiPoint.prototype.getType = function() {
  return ol.geom.GeometryType.MULTI_POINT;
};
ol.geom.MultiPoint.prototype.intersectsExtent = function(extent) {
  var flatCoordinates = this.flatCoordinates;
  var stride = this.stride;
  var i, ii, x, y;
  for (i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
    x = flatCoordinates[i];
    y = flatCoordinates[i + 1];
    if (ol.extent.containsXY(extent, x, y)) {
      return true;
    }
  }
  return false;
};
ol.geom.MultiPoint.prototype.setCoordinates = function(coordinates, opt_layout) {
  if (!coordinates) {
    this.setFlatCoordinates(ol.geom.GeometryLayout.XY, null);
  } else {
    this.setLayout(opt_layout, coordinates, 1);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = ol.geom.flat.deflate.coordinates(this.flatCoordinates, 0, coordinates, this.stride);
    this.changed();
  }
};
ol.geom.MultiPoint.prototype.setFlatCoordinates = function(layout, flatCoordinates) {
  this.setFlatCoordinatesInternal(layout, flatCoordinates);
  this.changed();
};
goog.provide("ol.geom.flat.center");
goog.require("ol.extent");
ol.geom.flat.center.linearRingss = function(flatCoordinates, offset, endss, stride) {
  var flatCenters = [];
  var i, ii;
  var extent = ol.extent.createEmpty();
  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    extent = ol.extent.createOrUpdateFromFlatCoordinates(flatCoordinates, offset, ends[0], stride);
    flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);
    offset = ends[ends.length - 1];
  }
  return flatCenters;
};
goog.provide("ol.geom.MultiPolygon");
goog.require("ol");
goog.require("ol.array");
goog.require("ol.extent");
goog.require("ol.geom.GeometryLayout");
goog.require("ol.geom.GeometryType");
goog.require("ol.geom.MultiPoint");
goog.require("ol.geom.Polygon");
goog.require("ol.geom.SimpleGeometry");
goog.require("ol.geom.flat.area");
goog.require("ol.geom.flat.center");
goog.require("ol.geom.flat.closest");
goog.require("ol.geom.flat.contains");
goog.require("ol.geom.flat.deflate");
goog.require("ol.geom.flat.inflate");
goog.require("ol.geom.flat.interiorpoint");
goog.require("ol.geom.flat.intersectsextent");
goog.require("ol.geom.flat.orient");
goog.require("ol.geom.flat.simplify");
ol.geom.MultiPolygon = function(coordinates, opt_layout) {
  ol.geom.SimpleGeometry.call(this);
  this.endss_ = [];
  this.flatInteriorPointsRevision_ = -1;
  this.flatInteriorPoints_ = null;
  this.maxDelta_ = -1;
  this.maxDeltaRevision_ = -1;
  this.orientedRevision_ = -1;
  this.orientedFlatCoordinates_ = null;
  this.setCoordinates(coordinates, opt_layout);
};
ol.inherits(ol.geom.MultiPolygon, ol.geom.SimpleGeometry);
ol.geom.MultiPolygon.prototype.appendPolygon = function(polygon) {
  var ends;
  if (!this.flatCoordinates) {
    this.flatCoordinates = polygon.getFlatCoordinates().slice();
    ends = polygon.getEnds().slice();
    this.endss_.push();
  } else {
    var offset = this.flatCoordinates.length;
    ol.array.extend(this.flatCoordinates, polygon.getFlatCoordinates());
    ends = polygon.getEnds().slice();
    var i, ii;
    for (i = 0, ii = ends.length; i < ii; ++i) {
      ends[i] += offset;
    }
  }
  this.endss_.push(ends);
  this.changed();
};
ol.geom.MultiPolygon.prototype.clone = function() {
  var multiPolygon = new ol.geom.MultiPolygon(null);
  var len = this.endss_.length;
  var newEndss = new Array(len);
  for (var i = 0; i < len; ++i) {
    newEndss[i] = this.endss_[i].slice();
  }
  multiPolygon.setFlatCoordinates(this.layout, this.flatCoordinates.slice(), newEndss);
  return multiPolygon;
};
ol.geom.MultiPolygon.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {
  if (minSquaredDistance < ol.extent.closestSquaredDistanceXY(this.getExtent(), x, y)) {
    return minSquaredDistance;
  }
  if (this.maxDeltaRevision_ != this.getRevision()) {
    this.maxDelta_ = Math.sqrt(ol.geom.flat.closest.getssMaxSquaredDelta(this.flatCoordinates, 0, this.endss_, this.stride, 0));
    this.maxDeltaRevision_ = this.getRevision();
  }
  return ol.geom.flat.closest.getssClosestPoint(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
};
ol.geom.MultiPolygon.prototype.containsXY = function(x, y) {
  return ol.geom.flat.contains.linearRingssContainsXY(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, x, y);
};
ol.geom.MultiPolygon.prototype.getArea = function() {
  return ol.geom.flat.area.linearRingss(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);
};
ol.geom.MultiPolygon.prototype.getCoordinates = function(opt_right) {
  var flatCoordinates;
  if (opt_right !== undefined) {
    flatCoordinates = this.getOrientedFlatCoordinates().slice();
    ol.geom.flat.orient.orientLinearRingss(flatCoordinates, 0, this.endss_, this.stride, opt_right);
  } else {
    flatCoordinates = this.flatCoordinates;
  }
  return ol.geom.flat.inflate.coordinatesss(flatCoordinates, 0, this.endss_, this.stride);
};
ol.geom.MultiPolygon.prototype.getEndss = function() {
  return this.endss_;
};
ol.geom.MultiPolygon.prototype.getFlatInteriorPoints = function() {
  if (this.flatInteriorPointsRevision_ != this.getRevision()) {
    var flatCenters = ol.geom.flat.center.linearRingss(this.flatCoordinates, 0, this.endss_, this.stride);
    this.flatInteriorPoints_ = ol.geom.flat.interiorpoint.linearRingss(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, flatCenters);
    this.flatInteriorPointsRevision_ = this.getRevision();
  }
  return this.flatInteriorPoints_;
};
ol.geom.MultiPolygon.prototype.getInteriorPoints = function() {
  var interiorPoints = new ol.geom.MultiPoint(null);
  interiorPoints.setFlatCoordinates(ol.geom.GeometryLayout.XYM, this.getFlatInteriorPoints().slice());
  return interiorPoints;
};
ol.geom.MultiPolygon.prototype.getOrientedFlatCoordinates = function() {
  if (this.orientedRevision_ != this.getRevision()) {
    var flatCoordinates = this.flatCoordinates;
    if (ol.geom.flat.orient.linearRingssAreOriented(flatCoordinates, 0, this.endss_, this.stride)) {
      this.orientedFlatCoordinates_ = flatCoordinates;
    } else {
      this.orientedFlatCoordinates_ = flatCoordinates.slice();
      this.orientedFlatCoordinates_.length = ol.geom.flat.orient.orientLinearRingss(this.orientedFlatCoordinates_, 0, this.endss_, this.stride);
    }
    this.orientedRevision_ = this.getRevision();
  }
  return this.orientedFlatCoordinates_;
};
ol.geom.MultiPolygon.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {
  var simplifiedFlatCoordinates = [];
  var simplifiedEndss = [];
  simplifiedFlatCoordinates.length = ol.geom.flat.simplify.quantizess(this.flatCoordinates, 0, this.endss_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEndss);
  var simplifiedMultiPolygon = new ol.geom.MultiPolygon(null);
  simplifiedMultiPolygon.setFlatCoordinates(ol.geom.GeometryLayout.XY, simplifiedFlatCoordinates, simplifiedEndss);
  return simplifiedMultiPolygon;
};
ol.geom.MultiPolygon.prototype.getPolygon = function(index) {
  if (index < 0 || this.endss_.length <= index) {
    return null;
  }
  var offset;
  if (index === 0) {
    offset = 0;
  } else {
    var prevEnds = this.endss_[index - 1];
    offset = prevEnds[prevEnds.length - 1];
  }
  var ends = this.endss_[index].slice();
  var end = ends[ends.length - 1];
  if (offset !== 0) {
    var i, ii;
    for (i = 0, ii = ends.length; i < ii; ++i) {
      ends[i] -= offset;
    }
  }
  var polygon = new ol.geom.Polygon(null);
  polygon.setFlatCoordinates(this.layout, this.flatCoordinates.slice(offset, end), ends);
  return polygon;
};
ol.geom.MultiPolygon.prototype.getPolygons = function() {
  var layout = this.layout;
  var flatCoordinates = this.flatCoordinates;
  var endss = this.endss_;
  var polygons = [];
  var offset = 0;
  var i, ii, j, jj;
  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i].slice();
    var end = ends[ends.length - 1];
    if (offset !== 0) {
      for (j = 0, jj = ends.length; j < jj; ++j) {
        ends[j] -= offset;
      }
    }
    var polygon = new ol.geom.Polygon(null);
    polygon.setFlatCoordinates(layout, flatCoordinates.slice(offset, end), ends);
    polygons.push(polygon);
    offset = end;
  }
  return polygons;
};
ol.geom.MultiPolygon.prototype.getType = function() {
  return ol.geom.GeometryType.MULTI_POLYGON;
};
ol.geom.MultiPolygon.prototype.intersectsExtent = function(extent) {
  return ol.geom.flat.intersectsextent.linearRingss(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, extent);
};
ol.geom.MultiPolygon.prototype.setCoordinates = function(coordinates, opt_layout) {
  if (!coordinates) {
    this.setFlatCoordinates(ol.geom.GeometryLayout.XY, null, this.endss_);
  } else {
    this.setLayout(opt_layout, coordinates, 3);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    var endss = ol.geom.flat.deflate.coordinatesss(this.flatCoordinates, 0, coordinates, this.stride, this.endss_);
    if (endss.length === 0) {
      this.flatCoordinates.length = 0;
    } else {
      var lastEnds = endss[endss.length - 1];
      this.flatCoordinates.length = lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];
    }
    this.changed();
  }
};
ol.geom.MultiPolygon.prototype.setFlatCoordinates = function(layout, flatCoordinates, endss) {
  this.setFlatCoordinatesInternal(layout, flatCoordinates);
  this.endss_ = endss;
  this.changed();
};
ol.geom.MultiPolygon.prototype.setPolygons = function(polygons) {
  var layout = this.getLayout();
  var flatCoordinates = [];
  var endss = [];
  var i, ii, ends;
  for (i = 0, ii = polygons.length; i < ii; ++i) {
    var polygon = polygons[i];
    if (i === 0) {
      layout = polygon.getLayout();
    }
    var offset = flatCoordinates.length;
    ends = polygon.getEnds();
    var j, jj;
    for (j = 0, jj = ends.length; j < jj; ++j) {
      ends[j] += offset;
    }
    ol.array.extend(flatCoordinates, polygon.getFlatCoordinates());
    endss.push(ends);
  }
  this.setFlatCoordinates(layout, flatCoordinates, endss);
};
goog.provide("ol.format.EsriJSON");
goog.require("ol");
goog.require("ol.Feature");
goog.require("ol.asserts");
goog.require("ol.extent");
goog.require("ol.format.Feature");
goog.require("ol.format.JSONFeature");
goog.require("ol.geom.GeometryLayout");
goog.require("ol.geom.GeometryType");
goog.require("ol.geom.LineString");
goog.require("ol.geom.LinearRing");
goog.require("ol.geom.MultiLineString");
goog.require("ol.geom.MultiPoint");
goog.require("ol.geom.MultiPolygon");
goog.require("ol.geom.Point");
goog.require("ol.geom.Polygon");
goog.require("ol.geom.flat.deflate");
goog.require("ol.geom.flat.orient");
goog.require("ol.obj");
goog.require("ol.proj");
ol.format.EsriJSON = function(opt_options) {
  var options = opt_options ? opt_options : {};
  ol.format.JSONFeature.call(this);
  this.geometryName_ = options.geometryName;
};
ol.inherits(ol.format.EsriJSON, ol.format.JSONFeature);
ol.format.EsriJSON.readGeometry_ = function(object, opt_options) {
  if (!object) {
    return null;
  }
  var type;
  if (typeof object.x === "number" && typeof object.y === "number") {
    type = ol.geom.GeometryType.POINT;
  } else {
    if (object.points) {
      type = ol.geom.GeometryType.MULTI_POINT;
    } else {
      if (object.paths) {
        if (object.paths.length === 1) {
          type = ol.geom.GeometryType.LINE_STRING;
        } else {
          type = ol.geom.GeometryType.MULTI_LINE_STRING;
        }
      } else {
        if (object.rings) {
          var layout = ol.format.EsriJSON.getGeometryLayout_(object);
          var rings = ol.format.EsriJSON.convertRings_(object.rings, layout);
          object = ol.obj.assign({}, object);
          if (rings.length === 1) {
            type = ol.geom.GeometryType.POLYGON;
            object.rings = rings[0];
          } else {
            type = ol.geom.GeometryType.MULTI_POLYGON;
            object.rings = rings;
          }
        }
      }
    }
  }
  var geometryReader = ol.format.EsriJSON.GEOMETRY_READERS_[type];
  return ol.format.Feature.transformWithOptions(geometryReader(object), false, opt_options);
};
ol.format.EsriJSON.convertRings_ = function(rings, layout) {
  var flatRing = [];
  var outerRings = [];
  var holes = [];
  var i, ii;
  for (i = 0, ii = rings.length; i < ii; ++i) {
    flatRing.length = 0;
    ol.geom.flat.deflate.coordinates(flatRing, 0, rings[i], layout.length);
    var clockwise = ol.geom.flat.orient.linearRingIsClockwise(flatRing, 0, flatRing.length, layout.length);
    if (clockwise) {
      outerRings.push([rings[i]]);
    } else {
      holes.push(rings[i]);
    }
  }
  while (holes.length) {
    var hole = holes.shift();
    var matched = false;
    for (i = outerRings.length - 1; i >= 0; i--) {
      var outerRing = outerRings[i][0];
      var containsHole = ol.extent.containsExtent((new ol.geom.LinearRing(outerRing)).getExtent(), (new ol.geom.LinearRing(hole)).getExtent());
      if (containsHole) {
        outerRings[i].push(hole);
        matched = true;
        break;
      }
    }
    if (!matched) {
      outerRings.push([hole.reverse()]);
    }
  }
  return outerRings;
};
ol.format.EsriJSON.readPointGeometry_ = function(object) {
  var point;
  if (object.m !== undefined && object.z !== undefined) {
    point = new ol.geom.Point([object.x, object.y, object.z, object.m], ol.geom.GeometryLayout.XYZM);
  } else {
    if (object.z !== undefined) {
      point = new ol.geom.Point([object.x, object.y, object.z], ol.geom.GeometryLayout.XYZ);
    } else {
      if (object.m !== undefined) {
        point = new ol.geom.Point([object.x, object.y, object.m], ol.geom.GeometryLayout.XYM);
      } else {
        point = new ol.geom.Point([object.x, object.y]);
      }
    }
  }
  return point;
};
ol.format.EsriJSON.readLineStringGeometry_ = function(object) {
  var layout = ol.format.EsriJSON.getGeometryLayout_(object);
  return new ol.geom.LineString(object.paths[0], layout);
};
ol.format.EsriJSON.readMultiLineStringGeometry_ = function(object) {
  var layout = ol.format.EsriJSON.getGeometryLayout_(object);
  return new ol.geom.MultiLineString(object.paths, layout);
};
ol.format.EsriJSON.getGeometryLayout_ = function(object) {
  var layout = ol.geom.GeometryLayout.XY;
  if (object.hasZ === true && object.hasM === true) {
    layout = ol.geom.GeometryLayout.XYZM;
  } else {
    if (object.hasZ === true) {
      layout = ol.geom.GeometryLayout.XYZ;
    } else {
      if (object.hasM === true) {
        layout = ol.geom.GeometryLayout.XYM;
      }
    }
  }
  return layout;
};
ol.format.EsriJSON.readMultiPointGeometry_ = function(object) {
  var layout = ol.format.EsriJSON.getGeometryLayout_(object);
  return new ol.geom.MultiPoint(object.points, layout);
};
ol.format.EsriJSON.readMultiPolygonGeometry_ = function(object) {
  var layout = ol.format.EsriJSON.getGeometryLayout_(object);
  return new ol.geom.MultiPolygon(object.rings, layout);
};
ol.format.EsriJSON.readPolygonGeometry_ = function(object) {
  var layout = ol.format.EsriJSON.getGeometryLayout_(object);
  return new ol.geom.Polygon(object.rings, layout);
};
ol.format.EsriJSON.writePointGeometry_ = function(geometry, opt_options) {
  var coordinates = geometry.getCoordinates();
  var esriJSON;
  var layout = geometry.getLayout();
  if (layout === ol.geom.GeometryLayout.XYZ) {
    esriJSON = {x:coordinates[0], y:coordinates[1], z:coordinates[2]};
  } else {
    if (layout === ol.geom.GeometryLayout.XYM) {
      esriJSON = {x:coordinates[0], y:coordinates[1], m:coordinates[2]};
    } else {
      if (layout === ol.geom.GeometryLayout.XYZM) {
        esriJSON = {x:coordinates[0], y:coordinates[1], z:coordinates[2], m:coordinates[3]};
      } else {
        if (layout === ol.geom.GeometryLayout.XY) {
          esriJSON = {x:coordinates[0], y:coordinates[1]};
        } else {
          ol.asserts.assert(false, 34);
        }
      }
    }
  }
  return esriJSON;
};
ol.format.EsriJSON.getHasZM_ = function(geometry) {
  var layout = geometry.getLayout();
  return {hasZ:layout === ol.geom.GeometryLayout.XYZ || layout === ol.geom.GeometryLayout.XYZM, hasM:layout === ol.geom.GeometryLayout.XYM || layout === ol.geom.GeometryLayout.XYZM};
};
ol.format.EsriJSON.writeLineStringGeometry_ = function(geometry, opt_options) {
  var hasZM = ol.format.EsriJSON.getHasZM_(geometry);
  return {hasZ:hasZM.hasZ, hasM:hasZM.hasM, paths:[geometry.getCoordinates()]};
};
ol.format.EsriJSON.writePolygonGeometry_ = function(geometry, opt_options) {
  var hasZM = ol.format.EsriJSON.getHasZM_(geometry);
  return {hasZ:hasZM.hasZ, hasM:hasZM.hasM, rings:geometry.getCoordinates(false)};
};
ol.format.EsriJSON.writeMultiLineStringGeometry_ = function(geometry, opt_options) {
  var hasZM = ol.format.EsriJSON.getHasZM_(geometry);
  return {hasZ:hasZM.hasZ, hasM:hasZM.hasM, paths:geometry.getCoordinates()};
};
ol.format.EsriJSON.writeMultiPointGeometry_ = function(geometry, opt_options) {
  var hasZM = ol.format.EsriJSON.getHasZM_(geometry);
  return {hasZ:hasZM.hasZ, hasM:hasZM.hasM, points:geometry.getCoordinates()};
};
ol.format.EsriJSON.writeMultiPolygonGeometry_ = function(geometry, opt_options) {
  var hasZM = ol.format.EsriJSON.getHasZM_(geometry);
  var coordinates = geometry.getCoordinates(false);
  var output = [];
  for (var i = 0; i < coordinates.length; i++) {
    for (var x = coordinates[i].length - 1; x >= 0; x--) {
      output.push(coordinates[i][x]);
    }
  }
  return {hasZ:hasZM.hasZ, hasM:hasZM.hasM, rings:output};
};
ol.format.EsriJSON.GEOMETRY_READERS_ = {};
ol.format.EsriJSON.GEOMETRY_READERS_[ol.geom.GeometryType.POINT] = ol.format.EsriJSON.readPointGeometry_;
ol.format.EsriJSON.GEOMETRY_READERS_[ol.geom.GeometryType.LINE_STRING] = ol.format.EsriJSON.readLineStringGeometry_;
ol.format.EsriJSON.GEOMETRY_READERS_[ol.geom.GeometryType.POLYGON] = ol.format.EsriJSON.readPolygonGeometry_;
ol.format.EsriJSON.GEOMETRY_READERS_[ol.geom.GeometryType.MULTI_POINT] = ol.format.EsriJSON.readMultiPointGeometry_;
ol.format.EsriJSON.GEOMETRY_READERS_[ol.geom.GeometryType.MULTI_LINE_STRING] = ol.format.EsriJSON.readMultiLineStringGeometry_;
ol.format.EsriJSON.GEOMETRY_READERS_[ol.geom.GeometryType.MULTI_POLYGON] = ol.format.EsriJSON.readMultiPolygonGeometry_;
ol.format.EsriJSON.GEOMETRY_WRITERS_ = {};
ol.format.EsriJSON.GEOMETRY_WRITERS_[ol.geom.GeometryType.POINT] = ol.format.EsriJSON.writePointGeometry_;
ol.format.EsriJSON.GEOMETRY_WRITERS_[ol.geom.GeometryType.LINE_STRING] = ol.format.EsriJSON.writeLineStringGeometry_;
ol.format.EsriJSON.GEOMETRY_WRITERS_[ol.geom.GeometryType.POLYGON] = ol.format.EsriJSON.writePolygonGeometry_;
ol.format.EsriJSON.GEOMETRY_WRITERS_[ol.geom.GeometryType.MULTI_POINT] = ol.format.EsriJSON.writeMultiPointGeometry_;
ol.format.EsriJSON.GEOMETRY_WRITERS_[ol.geom.GeometryType.MULTI_LINE_STRING] = ol.format.EsriJSON.writeMultiLineStringGeometry_;
ol.format.EsriJSON.GEOMETRY_WRITERS_[ol.geom.GeometryType.MULTI_POLYGON] = ol.format.EsriJSON.writeMultiPolygonGeometry_;
ol.format.EsriJSON.prototype.readFeature;
ol.format.EsriJSON.prototype.readFeatures;
ol.format.EsriJSON.prototype.readFeatureFromObject = function(object, opt_options) {
  var esriJSONFeature = object;
  var geometry = ol.format.EsriJSON.readGeometry_(esriJSONFeature.geometry, opt_options);
  var feature = new ol.Feature;
  if (this.geometryName_) {
    feature.setGeometryName(this.geometryName_);
  }
  feature.setGeometry(geometry);
  if (opt_options && opt_options.idField && esriJSONFeature.attributes[opt_options.idField]) {
    feature.setId(esriJSONFeature.attributes[opt_options.idField]);
  }
  if (esriJSONFeature.attributes) {
    feature.setProperties(esriJSONFeature.attributes);
  }
  return feature;
};
ol.format.EsriJSON.prototype.readFeaturesFromObject = function(object, opt_options) {
  var esriJSONObject = object;
  var options = opt_options ? opt_options : {};
  if (esriJSONObject.features) {
    var esriJSONFeatureCollection = object;
    var features = [];
    var esriJSONFeatures = esriJSONFeatureCollection.features;
    var i, ii;
    options.idField = object.objectIdFieldName;
    for (i = 0, ii = esriJSONFeatures.length; i < ii; ++i) {
      features.push(this.readFeatureFromObject(esriJSONFeatures[i], options));
    }
    return features;
  } else {
    return [this.readFeatureFromObject(object, options)];
  }
};
ol.format.EsriJSON.prototype.readGeometry;
ol.format.EsriJSON.prototype.readGeometryFromObject = function(object, opt_options) {
  return ol.format.EsriJSON.readGeometry_(object, opt_options);
};
ol.format.EsriJSON.prototype.readProjection;
ol.format.EsriJSON.prototype.readProjectionFromObject = function(object) {
  var esriJSONObject = object;
  if (esriJSONObject.spatialReference && esriJSONObject.spatialReference.wkid) {
    var crs = esriJSONObject.spatialReference.wkid;
    return ol.proj.get("EPSG:" + crs);
  } else {
    return null;
  }
};
ol.format.EsriJSON.writeGeometry_ = function(geometry, opt_options) {
  var geometryWriter = ol.format.EsriJSON.GEOMETRY_WRITERS_[geometry.getType()];
  return geometryWriter(ol.format.Feature.transformWithOptions(geometry, true, opt_options), opt_options);
};
ol.format.EsriJSON.prototype.writeGeometry;
ol.format.EsriJSON.prototype.writeGeometryObject = function(geometry, opt_options) {
  return ol.format.EsriJSON.writeGeometry_(geometry, this.adaptOptions(opt_options));
};
ol.format.EsriJSON.prototype.writeFeature;
ol.format.EsriJSON.prototype.writeFeatureObject = function(feature, opt_options) {
  opt_options = this.adaptOptions(opt_options);
  var object = {};
  var geometry = feature.getGeometry();
  if (geometry) {
    object["geometry"] = ol.format.EsriJSON.writeGeometry_(geometry, opt_options);
    if (opt_options && opt_options.featureProjection) {
      object["geometry"]["spatialReference"] = {wkid:ol.proj.get(opt_options.featureProjection).getCode().split(":").pop()};
    }
  }
  var properties = feature.getProperties();
  delete properties[feature.getGeometryName()];
  if (!ol.obj.isEmpty(properties)) {
    object["attributes"] = properties;
  } else {
    object["attributes"] = {};
  }
  return object;
};
ol.format.EsriJSON.prototype.writeFeatures;
ol.format.EsriJSON.prototype.writeFeaturesObject = function(features, opt_options) {
  opt_options = this.adaptOptions(opt_options);
  var objects = [];
  var i, ii;
  for (i = 0, ii = features.length; i < ii; ++i) {
    objects.push(this.writeFeatureObject(features[i], opt_options));
  }
  return {"features":objects};
};
goog.provide("ol.format.filter.Filter");
ol.format.filter.Filter = function(tagName) {
  this.tagName_ = tagName;
};
ol.format.filter.Filter.prototype.getTagName = function() {
  return this.tagName_;
};
goog.provide("ol.format.filter.LogicalNary");
goog.require("ol");
goog.require("ol.asserts");
goog.require("ol.format.filter.Filter");
ol.format.filter.LogicalNary = function(tagName, conditions) {
  ol.format.filter.Filter.call(this, tagName);
  this.conditions = Array.prototype.slice.call(arguments, 1);
  ol.asserts.assert(this.conditions.length >= 2, 57);
};
ol.inherits(ol.format.filter.LogicalNary, ol.format.filter.Filter);
goog.provide("ol.format.filter.And");
goog.require("ol");
goog.require("ol.format.filter.LogicalNary");
ol.format.filter.And = function(conditions) {
  var params = ["And"].concat(Array.prototype.slice.call(arguments));
  ol.format.filter.LogicalNary.apply(this, params);
};
ol.inherits(ol.format.filter.And, ol.format.filter.LogicalNary);
goog.provide("ol.format.filter.Bbox");
goog.require("ol");
goog.require("ol.format.filter.Filter");
ol.format.filter.Bbox = function(geometryName, extent, opt_srsName) {
  ol.format.filter.Filter.call(this, "BBOX");
  this.geometryName = geometryName;
  this.extent = extent;
  this.srsName = opt_srsName;
};
ol.inherits(ol.format.filter.Bbox, ol.format.filter.Filter);
goog.provide("ol.format.filter.Spatial");
goog.require("ol");
goog.require("ol.format.filter.Filter");
ol.format.filter.Spatial = function(tagName, geometryName, geometry, opt_srsName) {
  ol.format.filter.Filter.call(this, tagName);
  this.geometryName = geometryName || "the_geom";
  this.geometry = geometry;
  this.srsName = opt_srsName;
};
ol.inherits(ol.format.filter.Spatial, ol.format.filter.Filter);
goog.provide("ol.format.filter.Contains");
goog.require("ol");
goog.require("ol.format.filter.Spatial");
ol.format.filter.Contains = function(geometryName, geometry, opt_srsName) {
  ol.format.filter.Spatial.call(this, "Contains", geometryName, geometry, opt_srsName);
};
ol.inherits(ol.format.filter.Contains, ol.format.filter.Spatial);
goog.provide("ol.format.filter.Comparison");
goog.require("ol");
goog.require("ol.format.filter.Filter");
ol.format.filter.Comparison = function(tagName, propertyName) {
  ol.format.filter.Filter.call(this, tagName);
  this.propertyName = propertyName;
};
ol.inherits(ol.format.filter.Comparison, ol.format.filter.Filter);
goog.provide("ol.format.filter.During");
goog.require("ol");
goog.require("ol.format.filter.Comparison");
ol.format.filter.During = function(propertyName, begin, end) {
  ol.format.filter.Comparison.call(this, "During", propertyName);
  this.begin = begin;
  this.end = end;
};
ol.inherits(ol.format.filter.During, ol.format.filter.Comparison);
goog.provide("ol.format.filter.ComparisonBinary");
goog.require("ol");
goog.require("ol.format.filter.Comparison");
ol.format.filter.ComparisonBinary = function(tagName, propertyName, expression, opt_matchCase) {
  ol.format.filter.Comparison.call(this, tagName, propertyName);
  this.expression = expression;
  this.matchCase = opt_matchCase;
};
ol.inherits(ol.format.filter.ComparisonBinary, ol.format.filter.Comparison);
goog.provide("ol.format.filter.EqualTo");
goog.require("ol");
goog.require("ol.format.filter.ComparisonBinary");
ol.format.filter.EqualTo = function(propertyName, expression, opt_matchCase) {
  ol.format.filter.ComparisonBinary.call(this, "PropertyIsEqualTo", propertyName, expression, opt_matchCase);
};
ol.inherits(ol.format.filter.EqualTo, ol.format.filter.ComparisonBinary);
goog.provide("ol.format.filter.GreaterThan");
goog.require("ol");
goog.require("ol.format.filter.ComparisonBinary");
ol.format.filter.GreaterThan = function(propertyName, expression) {
  ol.format.filter.ComparisonBinary.call(this, "PropertyIsGreaterThan", propertyName, expression);
};
ol.inherits(ol.format.filter.GreaterThan, ol.format.filter.ComparisonBinary);
goog.provide("ol.format.filter.GreaterThanOrEqualTo");
goog.require("ol");
goog.require("ol.format.filter.ComparisonBinary");
ol.format.filter.GreaterThanOrEqualTo = function(propertyName, expression) {
  ol.format.filter.ComparisonBinary.call(this, "PropertyIsGreaterThanOrEqualTo", propertyName, expression);
};
ol.inherits(ol.format.filter.GreaterThanOrEqualTo, ol.format.filter.ComparisonBinary);
goog.provide("ol.format.filter.Intersects");
goog.require("ol");
goog.require("ol.format.filter.Spatial");
ol.format.filter.Intersects = function(geometryName, geometry, opt_srsName) {
  ol.format.filter.Spatial.call(this, "Intersects", geometryName, geometry, opt_srsName);
};
ol.inherits(ol.format.filter.Intersects, ol.format.filter.Spatial);
goog.provide("ol.format.filter.IsBetween");
goog.require("ol");
goog.require("ol.format.filter.Comparison");
ol.format.filter.IsBetween = function(propertyName, lowerBoundary, upperBoundary) {
  ol.format.filter.Comparison.call(this, "PropertyIsBetween", propertyName);
  this.lowerBoundary = lowerBoundary;
  this.upperBoundary = upperBoundary;
};
ol.inherits(ol.format.filter.IsBetween, ol.format.filter.Comparison);
goog.provide("ol.format.filter.IsLike");
goog.require("ol");
goog.require("ol.format.filter.Comparison");
ol.format.filter.IsLike = function(propertyName, pattern, opt_wildCard, opt_singleChar, opt_escapeChar, opt_matchCase) {
  ol.format.filter.Comparison.call(this, "PropertyIsLike", propertyName);
  this.pattern = pattern;
  this.wildCard = opt_wildCard !== undefined ? opt_wildCard : "*";
  this.singleChar = opt_singleChar !== undefined ? opt_singleChar : ".";
  this.escapeChar = opt_escapeChar !== undefined ? opt_escapeChar : "!";
  this.matchCase = opt_matchCase;
};
ol.inherits(ol.format.filter.IsLike, ol.format.filter.Comparison);
goog.provide("ol.format.filter.IsNull");
goog.require("ol");
goog.require("ol.format.filter.Comparison");
ol.format.filter.IsNull = function(propertyName) {
  ol.format.filter.Comparison.call(this, "PropertyIsNull", propertyName);
};
ol.inherits(ol.format.filter.IsNull, ol.format.filter.Comparison);
goog.provide("ol.format.filter.LessThan");
goog.require("ol");
goog.require("ol.format.filter.ComparisonBinary");
ol.format.filter.LessThan = function(propertyName, expression) {
  ol.format.filter.ComparisonBinary.call(this, "PropertyIsLessThan", propertyName, expression);
};
ol.inherits(ol.format.filter.LessThan, ol.format.filter.ComparisonBinary);
goog.provide("ol.format.filter.LessThanOrEqualTo");
goog.require("ol");
goog.require("ol.format.filter.ComparisonBinary");
ol.format.filter.LessThanOrEqualTo = function(propertyName, expression) {
  ol.format.filter.ComparisonBinary.call(this, "PropertyIsLessThanOrEqualTo", propertyName, expression);
};
ol.inherits(ol.format.filter.LessThanOrEqualTo, ol.format.filter.ComparisonBinary);
goog.provide("ol.format.filter.Not");
goog.require("ol");
goog.require("ol.format.filter.Filter");
ol.format.filter.Not = function(condition) {
  ol.format.filter.Filter.call(this, "Not");
  this.condition = condition;
};
ol.inherits(ol.format.filter.Not, ol.format.filter.Filter);
goog.provide("ol.format.filter.NotEqualTo");
goog.require("ol");
goog.require("ol.format.filter.ComparisonBinary");
ol.format.filter.NotEqualTo = function(propertyName, expression, opt_matchCase) {
  ol.format.filter.ComparisonBinary.call(this, "PropertyIsNotEqualTo", propertyName, expression, opt_matchCase);
};
ol.inherits(ol.format.filter.NotEqualTo, ol.format.filter.ComparisonBinary);
goog.provide("ol.format.filter.Or");
goog.require("ol");
goog.require("ol.format.filter.LogicalNary");
ol.format.filter.Or = function(conditions) {
  var params = ["Or"].concat(Array.prototype.slice.call(arguments));
  ol.format.filter.LogicalNary.apply(this, params);
};
ol.inherits(ol.format.filter.Or, ol.format.filter.LogicalNary);
goog.provide("ol.format.filter.Within");
goog.require("ol");
goog.require("ol.format.filter.Spatial");
ol.format.filter.Within = function(geometryName, geometry, opt_srsName) {
  ol.format.filter.Spatial.call(this, "Within", geometryName, geometry, opt_srsName);
};
ol.inherits(ol.format.filter.Within, ol.format.filter.Spatial);
goog.provide("ol.format.filter");
goog.require("ol.format.filter.And");
goog.require("ol.format.filter.Bbox");
goog.require("ol.format.filter.Contains");
goog.require("ol.format.filter.During");
goog.require("ol.format.filter.EqualTo");
goog.require("ol.format.filter.GreaterThan");
goog.require("ol.format.filter.GreaterThanOrEqualTo");
goog.require("ol.format.filter.Intersects");
goog.require("ol.format.filter.IsBetween");
goog.require("ol.format.filter.IsLike");
goog.require("ol.format.filter.IsNull");
goog.require("ol.format.filter.LessThan");
goog.require("ol.format.filter.LessThanOrEqualTo");
goog.require("ol.format.filter.Not");
goog.require("ol.format.filter.NotEqualTo");
goog.require("ol.format.filter.Or");
goog.require("ol.format.filter.Within");
ol.format.filter.and = function(conditions) {
  var params = [null].concat(Array.prototype.slice.call(arguments));
  return new (Function.prototype.bind.apply(ol.format.filter.And, params));
};
ol.format.filter.or = function(conditions) {
  var params = [null].concat(Array.prototype.slice.call(arguments));
  return new (Function.prototype.bind.apply(ol.format.filter.Or, params));
};
ol.format.filter.not = function(condition) {
  return new ol.format.filter.Not(condition);
};
ol.format.filter.bbox = function(geometryName, extent, opt_srsName) {
  return new ol.format.filter.Bbox(geometryName, extent, opt_srsName);
};
ol.format.filter.contains = function(geometryName, geometry, opt_srsName) {
  return new ol.format.filter.Contains(geometryName, geometry, opt_srsName);
};
ol.format.filter.intersects = function(geometryName, geometry, opt_srsName) {
  return new ol.format.filter.Intersects(geometryName, geometry, opt_srsName);
};
ol.format.filter.within = function(geometryName, geometry, opt_srsName) {
  return new ol.format.filter.Within(geometryName, geometry, opt_srsName);
};
ol.format.filter.equalTo = function(propertyName, expression, opt_matchCase) {
  return new ol.format.filter.EqualTo(propertyName, expression, opt_matchCase);
};
ol.format.filter.notEqualTo = function(propertyName, expression, opt_matchCase) {
  return new ol.format.filter.NotEqualTo(propertyName, expression, opt_matchCase);
};
ol.format.filter.lessThan = function(propertyName, expression) {
  return new ol.format.filter.LessThan(propertyName, expression);
};
ol.format.filter.lessThanOrEqualTo = function(propertyName, expression) {
  return new ol.format.filter.LessThanOrEqualTo(propertyName, expression);
};
ol.format.filter.greaterThan = function(propertyName, expression) {
  return new ol.format.filter.GreaterThan(propertyName, expression);
};
ol.format.filter.greaterThanOrEqualTo = function(propertyName, expression) {
  return new ol.format.filter.GreaterThanOrEqualTo(propertyName, expression);
};
ol.format.filter.isNull = function(propertyName) {
  return new ol.format.filter.IsNull(propertyName);
};
ol.format.filter.between = function(propertyName, lowerBoundary, upperBoundary) {
  return new ol.format.filter.IsBetween(propertyName, lowerBoundary, upperBoundary);
};
ol.format.filter.like = function(propertyName, pattern, opt_wildCard, opt_singleChar, opt_escapeChar, opt_matchCase) {
  return new ol.format.filter.IsLike(propertyName, pattern, opt_wildCard, opt_singleChar, opt_escapeChar, opt_matchCase);
};
ol.format.filter.during = function(propertyName, begin, end) {
  return new ol.format.filter.During(propertyName, begin, end);
};
goog.provide("ol.geom.GeometryCollection");
goog.require("ol");
goog.require("ol.events");
goog.require("ol.events.EventType");
goog.require("ol.extent");
goog.require("ol.geom.Geometry");
goog.require("ol.geom.GeometryType");
goog.require("ol.obj");
ol.geom.GeometryCollection = function(opt_geometries) {
  ol.geom.Geometry.call(this);
  this.geometries_ = opt_geometries ? opt_geometries : null;
  this.listenGeometriesChange_();
};
ol.inherits(ol.geom.GeometryCollection, ol.geom.Geometry);
ol.geom.GeometryCollection.cloneGeometries_ = function(geometries) {
  var clonedGeometries = [];
  var i, ii;
  for (i = 0, ii = geometries.length; i < ii; ++i) {
    clonedGeometries.push(geometries[i].clone());
  }
  return clonedGeometries;
};
ol.geom.GeometryCollection.prototype.unlistenGeometriesChange_ = function() {
  var i, ii;
  if (!this.geometries_) {
    return;
  }
  for (i = 0, ii = this.geometries_.length; i < ii; ++i) {
    ol.events.unlisten(this.geometries_[i], ol.events.EventType.CHANGE, this.changed, this);
  }
};
ol.geom.GeometryCollection.prototype.listenGeometriesChange_ = function() {
  var i, ii;
  if (!this.geometries_) {
    return;
  }
  for (i = 0, ii = this.geometries_.length; i < ii; ++i) {
    ol.events.listen(this.geometries_[i], ol.events.EventType.CHANGE, this.changed, this);
  }
};
ol.geom.GeometryCollection.prototype.clone = function() {
  var geometryCollection = new ol.geom.GeometryCollection(null);
  geometryCollection.setGeometries(this.geometries_);
  return geometryCollection;
};
ol.geom.GeometryCollection.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {
  if (minSquaredDistance < ol.extent.closestSquaredDistanceXY(this.getExtent(), x, y)) {
    return minSquaredDistance;
  }
  var geometries = this.geometries_;
  var i, ii;
  for (i = 0, ii = geometries.length; i < ii; ++i) {
    minSquaredDistance = geometries[i].closestPointXY(x, y, closestPoint, minSquaredDistance);
  }
  return minSquaredDistance;
};
ol.geom.GeometryCollection.prototype.containsXY = function(x, y) {
  var geometries = this.geometries_;
  var i, ii;
  for (i = 0, ii = geometries.length; i < ii; ++i) {
    if (geometries[i].containsXY(x, y)) {
      return true;
    }
  }
  return false;
};
ol.geom.GeometryCollection.prototype.computeExtent = function(extent) {
  ol.extent.createOrUpdateEmpty(extent);
  var geometries = this.geometries_;
  for (var i = 0, ii = geometries.length; i < ii; ++i) {
    ol.extent.extend(extent, geometries[i].getExtent());
  }
  return extent;
};
ol.geom.GeometryCollection.prototype.getGeometries = function() {
  return ol.geom.GeometryCollection.cloneGeometries_(this.geometries_);
};
ol.geom.GeometryCollection.prototype.getGeometriesArray = function() {
  return this.geometries_;
};
ol.geom.GeometryCollection.prototype.getSimplifiedGeometry = function(squaredTolerance) {
  if (this.simplifiedGeometryRevision != this.getRevision()) {
    ol.obj.clear(this.simplifiedGeometryCache);
    this.simplifiedGeometryMaxMinSquaredTolerance = 0;
    this.simplifiedGeometryRevision = this.getRevision();
  }
  if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance < this.simplifiedGeometryMaxMinSquaredTolerance) {
    return this;
  }
  var key = squaredTolerance.toString();
  if (this.simplifiedGeometryCache.hasOwnProperty(key)) {
    return this.simplifiedGeometryCache[key];
  } else {
    var simplifiedGeometries = [];
    var geometries = this.geometries_;
    var simplified = false;
    var i, ii;
    for (i = 0, ii = geometries.length; i < ii; ++i) {
      var geometry = geometries[i];
      var simplifiedGeometry = geometry.getSimplifiedGeometry(squaredTolerance);
      simplifiedGeometries.push(simplifiedGeometry);
      if (simplifiedGeometry !== geometry) {
        simplified = true;
      }
    }
    if (simplified) {
      var simplifiedGeometryCollection = new ol.geom.GeometryCollection(null);
      simplifiedGeometryCollection.setGeometriesArray(simplifiedGeometries);
      this.simplifiedGeometryCache[key] = simplifiedGeometryCollection;
      return simplifiedGeometryCollection;
    } else {
      this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
      return this;
    }
  }
};
ol.geom.GeometryCollection.prototype.getType = function() {
  return ol.geom.GeometryType.GEOMETRY_COLLECTION;
};
ol.geom.GeometryCollection.prototype.intersectsExtent = function(extent) {
  var geometries = this.geometries_;
  var i, ii;
  for (i = 0, ii = geometries.length; i < ii; ++i) {
    if (geometries[i].intersectsExtent(extent)) {
      return true;
    }
  }
  return false;
};
ol.geom.GeometryCollection.prototype.isEmpty = function() {
  return this.geometries_.length === 0;
};
ol.geom.GeometryCollection.prototype.rotate = function(angle, anchor) {
  var geometries = this.geometries_;
  for (var i = 0, ii = geometries.length; i < ii; ++i) {
    geometries[i].rotate(angle, anchor);
  }
  this.changed();
};
ol.geom.GeometryCollection.prototype.scale = function(sx, opt_sy, opt_anchor) {
  var anchor = opt_anchor;
  if (!anchor) {
    anchor = ol.extent.getCenter(this.getExtent());
  }
  var geometries = this.geometries_;
  for (var i = 0, ii = geometries.length; i < ii; ++i) {
    geometries[i].scale(sx, opt_sy, anchor);
  }
  this.changed();
};
ol.geom.GeometryCollection.prototype.setGeometries = function(geometries) {
  this.setGeometriesArray(ol.geom.GeometryCollection.cloneGeometries_(geometries));
};
ol.geom.GeometryCollection.prototype.setGeometriesArray = function(geometries) {
  this.unlistenGeometriesChange_();
  this.geometries_ = geometries;
  this.listenGeometriesChange_();
  this.changed();
};
ol.geom.GeometryCollection.prototype.applyTransform = function(transformFn) {
  var geometries = this.geometries_;
  var i, ii;
  for (i = 0, ii = geometries.length; i < ii; ++i) {
    geometries[i].applyTransform(transformFn);
  }
  this.changed();
};
ol.geom.GeometryCollection.prototype.translate = function(deltaX, deltaY) {
  var geometries = this.geometries_;
  var i, ii;
  for (i = 0, ii = geometries.length; i < ii; ++i) {
    geometries[i].translate(deltaX, deltaY);
  }
  this.changed();
};
ol.geom.GeometryCollection.prototype.disposeInternal = function() {
  this.unlistenGeometriesChange_();
  ol.geom.Geometry.prototype.disposeInternal.call(this);
};
goog.provide("ol.format.GeoJSON");
goog.require("ol");
goog.require("ol.asserts");
goog.require("ol.Feature");
goog.require("ol.format.Feature");
goog.require("ol.format.JSONFeature");
goog.require("ol.geom.GeometryCollection");
goog.require("ol.geom.LineString");
goog.require("ol.geom.MultiLineString");
goog.require("ol.geom.MultiPoint");
goog.require("ol.geom.MultiPolygon");
goog.require("ol.geom.Point");
goog.require("ol.geom.Polygon");
goog.require("ol.obj");
goog.require("ol.proj");
ol.format.GeoJSON = function(opt_options) {
  var options = opt_options ? opt_options : {};
  ol.format.JSONFeature.call(this);
  this.defaultDataProjection = ol.proj.get(options.defaultDataProjection ? options.defaultDataProjection : "EPSG:4326");
  if (options.featureProjection) {
    this.defaultFeatureProjection = ol.proj.get(options.featureProjection);
  }
  this.geometryName_ = options.geometryName;
  this.extractGeometryName_ = options.extractGeometryName;
};
ol.inherits(ol.format.GeoJSON, ol.format.JSONFeature);
ol.format.GeoJSON.readGeometry_ = function(object, opt_options) {
  if (!object) {
    return null;
  }
  var geometryReader = ol.format.GeoJSON.GEOMETRY_READERS_[object.type];
  return ol.format.Feature.transformWithOptions(geometryReader(object), false, opt_options);
};
ol.format.GeoJSON.readGeometryCollectionGeometry_ = function(object, opt_options) {
  var geometries = object.geometries.map(function(geometry) {
    return ol.format.GeoJSON.readGeometry_(geometry, opt_options);
  });
  return new ol.geom.GeometryCollection(geometries);
};
ol.format.GeoJSON.readPointGeometry_ = function(object) {
  return new ol.geom.Point(object.coordinates);
};
ol.format.GeoJSON.readLineStringGeometry_ = function(object) {
  return new ol.geom.LineString(object.coordinates);
};
ol.format.GeoJSON.readMultiLineStringGeometry_ = function(object) {
  return new ol.geom.MultiLineString(object.coordinates);
};
ol.format.GeoJSON.readMultiPointGeometry_ = function(object) {
  return new ol.geom.MultiPoint(object.coordinates);
};
ol.format.GeoJSON.readMultiPolygonGeometry_ = function(object) {
  return new ol.geom.MultiPolygon(object.coordinates);
};
ol.format.GeoJSON.readPolygonGeometry_ = function(object) {
  return new ol.geom.Polygon(object.coordinates);
};
ol.format.GeoJSON.writeGeometry_ = function(geometry, opt_options) {
  var geometryWriter = ol.format.GeoJSON.GEOMETRY_WRITERS_[geometry.getType()];
  return geometryWriter(ol.format.Feature.transformWithOptions(geometry, true, opt_options), opt_options);
};
ol.format.GeoJSON.writeEmptyGeometryCollectionGeometry_ = function(geometry) {
  return {type:"GeometryCollection", geometries:[]};
};
ol.format.GeoJSON.writeGeometryCollectionGeometry_ = function(geometry, opt_options) {
  var geometries = geometry.getGeometriesArray().map(function(geometry) {
    var options = ol.obj.assign({}, opt_options);
    delete options.featureProjection;
    return ol.format.GeoJSON.writeGeometry_(geometry, options);
  });
  return {type:"GeometryCollection", geometries:geometries};
};
ol.format.GeoJSON.writeLineStringGeometry_ = function(geometry, opt_options) {
  return {type:"LineString", coordinates:geometry.getCoordinates()};
};
ol.format.GeoJSON.writeMultiLineStringGeometry_ = function(geometry, opt_options) {
  return {type:"MultiLineString", coordinates:geometry.getCoordinates()};
};
ol.format.GeoJSON.writeMultiPointGeometry_ = function(geometry, opt_options) {
  return {type:"MultiPoint", coordinates:geometry.getCoordinates()};
};
ol.format.GeoJSON.writeMultiPolygonGeometry_ = function(geometry, opt_options) {
  var right;
  if (opt_options) {
    right = opt_options.rightHanded;
  }
  return {type:"MultiPolygon", coordinates:geometry.getCoordinates(right)};
};
ol.format.GeoJSON.writePointGeometry_ = function(geometry, opt_options) {
  return {type:"Point", coordinates:geometry.getCoordinates()};
};
ol.format.GeoJSON.writePolygonGeometry_ = function(geometry, opt_options) {
  var right;
  if (opt_options) {
    right = opt_options.rightHanded;
  }
  return {type:"Polygon", coordinates:geometry.getCoordinates(right)};
};
ol.format.GeoJSON.GEOMETRY_READERS_ = {"Point":ol.format.GeoJSON.readPointGeometry_, "LineString":ol.format.GeoJSON.readLineStringGeometry_, "Polygon":ol.format.GeoJSON.readPolygonGeometry_, "MultiPoint":ol.format.GeoJSON.readMultiPointGeometry_, "MultiLineString":ol.format.GeoJSON.readMultiLineStringGeometry_, "MultiPolygon":ol.format.GeoJSON.readMultiPolygonGeometry_, "GeometryCollection":ol.format.GeoJSON.readGeometryCollectionGeometry_};
ol.format.GeoJSON.GEOMETRY_WRITERS_ = {"Point":ol.format.GeoJSON.writePointGeometry_, "LineString":ol.format.GeoJSON.writeLineStringGeometry_, "Polygon":ol.format.GeoJSON.writePolygonGeometry_, "MultiPoint":ol.format.GeoJSON.writeMultiPointGeometry_, "MultiLineString":ol.format.GeoJSON.writeMultiLineStringGeometry_, "MultiPolygon":ol.format.GeoJSON.writeMultiPolygonGeometry_, "GeometryCollection":ol.format.GeoJSON.writeGeometryCollectionGeometry_, "Circle":ol.format.GeoJSON.writeEmptyGeometryCollectionGeometry_};
ol.format.GeoJSON.prototype.readFeature;
ol.format.GeoJSON.prototype.readFeatures;
ol.format.GeoJSON.prototype.readFeatureFromObject = function(object, opt_options) {
  var geoJSONFeature = null;
  if (object.type === "Feature") {
    geoJSONFeature = object;
  } else {
    geoJSONFeature = {type:"Feature", geometry:object};
  }
  var geometry = ol.format.GeoJSON.readGeometry_(geoJSONFeature.geometry, opt_options);
  var feature = new ol.Feature;
  if (this.geometryName_) {
    feature.setGeometryName(this.geometryName_);
  } else {
    if (this.extractGeometryName_ && geoJSONFeature.geometry_name !== undefined) {
      feature.setGeometryName(geoJSONFeature.geometry_name);
    }
  }
  feature.setGeometry(geometry);
  if (geoJSONFeature.id !== undefined) {
    feature.setId(geoJSONFeature.id);
  }
  if (geoJSONFeature.properties) {
    feature.setProperties(geoJSONFeature.properties);
  }
  return feature;
};
ol.format.GeoJSON.prototype.readFeaturesFromObject = function(object, opt_options) {
  var geoJSONObject = object;
  var features = null;
  if (geoJSONObject.type === "FeatureCollection") {
    var geoJSONFeatureCollection = object;
    features = [];
    var geoJSONFeatures = geoJSONFeatureCollection.features;
    var i, ii;
    for (i = 0, ii = geoJSONFeatures.length; i < ii; ++i) {
      features.push(this.readFeatureFromObject(geoJSONFeatures[i], opt_options));
    }
  } else {
    features = [this.readFeatureFromObject(object, opt_options)];
  }
  return features;
};
ol.format.GeoJSON.prototype.readGeometry;
ol.format.GeoJSON.prototype.readGeometryFromObject = function(object, opt_options) {
  return ol.format.GeoJSON.readGeometry_(object, opt_options);
};
ol.format.GeoJSON.prototype.readProjection;
ol.format.GeoJSON.prototype.readProjectionFromObject = function(object) {
  var geoJSONObject = object;
  var crs = geoJSONObject.crs;
  var projection;
  if (crs) {
    if (crs.type == "name") {
      projection = ol.proj.get(crs.properties.name);
    } else {
      ol.asserts.assert(false, 36);
    }
  } else {
    projection = this.defaultDataProjection;
  }
  return projection;
};
ol.format.GeoJSON.prototype.writeFeature;
ol.format.GeoJSON.prototype.writeFeatureObject = function(feature, opt_options) {
  opt_options = this.adaptOptions(opt_options);
  var object = {"type":"Feature"};
  var id = feature.getId();
  if (id !== undefined) {
    object.id = id;
  }
  var geometry = feature.getGeometry();
  if (geometry) {
    object.geometry = ol.format.GeoJSON.writeGeometry_(geometry, opt_options);
  } else {
    object.geometry = null;
  }
  var properties = feature.getProperties();
  delete properties[feature.getGeometryName()];
  if (!ol.obj.isEmpty(properties)) {
    object.properties = properties;
  } else {
    object.properties = null;
  }
  return object;
};
ol.format.GeoJSON.prototype.writeFeatures;
ol.format.GeoJSON.prototype.writeFeaturesObject = function(features, opt_options) {
  opt_options = this.adaptOptions(opt_options);
  var objects = [];
  var i, ii;
  for (i = 0, ii = features.length; i < ii; ++i) {
    objects.push(this.writeFeatureObject(features[i], opt_options));
  }
  return {type:"FeatureCollection", features:objects};
};
ol.format.GeoJSON.prototype.writeGeometry;
ol.format.GeoJSON.prototype.writeGeometryObject = function(geometry, opt_options) {
  return ol.format.GeoJSON.writeGeometry_(geometry, this.adaptOptions(opt_options));
};
goog.provide("ol.format.XMLFeature");
goog.require("ol");
goog.require("ol.array");
goog.require("ol.format.Feature");
goog.require("ol.format.FormatType");
goog.require("ol.xml");
ol.format.XMLFeature = function() {
  this.xmlSerializer_ = new XMLSerializer;
  ol.format.Feature.call(this);
};
ol.inherits(ol.format.XMLFeature, ol.format.Feature);
ol.format.XMLFeature.prototype.getType = function() {
  return ol.format.FormatType.XML;
};
ol.format.XMLFeature.prototype.readFeature = function(source, opt_options) {
  if (ol.xml.isDocument(source)) {
    return this.readFeatureFromDocument(source, opt_options);
  } else {
    if (ol.xml.isNode(source)) {
      return this.readFeatureFromNode(source, opt_options);
    } else {
      if (typeof source === "string") {
        var doc = ol.xml.parse(source);
        return this.readFeatureFromDocument(doc, opt_options);
      } else {
        return null;
      }
    }
  }
};
ol.format.XMLFeature.prototype.readFeatureFromDocument = function(doc, opt_options) {
  var features = this.readFeaturesFromDocument(doc, opt_options);
  if (features.length > 0) {
    return features[0];
  } else {
    return null;
  }
};
ol.format.XMLFeature.prototype.readFeatureFromNode = function(node, opt_options) {
  return null;
};
ol.format.XMLFeature.prototype.readFeatures = function(source, opt_options) {
  if (ol.xml.isDocument(source)) {
    return this.readFeaturesFromDocument(source, opt_options);
  } else {
    if (ol.xml.isNode(source)) {
      return this.readFeaturesFromNode(source, opt_options);
    } else {
      if (typeof source === "string") {
        var doc = ol.xml.parse(source);
        return this.readFeaturesFromDocument(doc, opt_options);
      } else {
        return [];
      }
    }
  }
};
ol.format.XMLFeature.prototype.readFeaturesFromDocument = function(doc, opt_options) {
  var features = [];
  var n;
  for (n = doc.firstChild; n; n = n.nextSibling) {
    if (n.nodeType == Node.ELEMENT_NODE) {
      ol.array.extend(features, this.readFeaturesFromNode(n, opt_options));
    }
  }
  return features;
};
ol.format.XMLFeature.prototype.readFeaturesFromNode = function(node, opt_options) {
};
ol.format.XMLFeature.prototype.readGeometry = function(source, opt_options) {
  if (ol.xml.isDocument(source)) {
    return this.readGeometryFromDocument(source, opt_options);
  } else {
    if (ol.xml.isNode(source)) {
      return this.readGeometryFromNode(source, opt_options);
    } else {
      if (typeof source === "string") {
        var doc = ol.xml.parse(source);
        return this.readGeometryFromDocument(doc, opt_options);
      } else {
        return null;
      }
    }
  }
};
ol.format.XMLFeature.prototype.readGeometryFromDocument = function(doc, opt_options) {
  return null;
};
ol.format.XMLFeature.prototype.readGeometryFromNode = function(node, opt_options) {
  return null;
};
ol.format.XMLFeature.prototype.readProjection = function(source) {
  if (ol.xml.isDocument(source)) {
    return this.readProjectionFromDocument(source);
  } else {
    if (ol.xml.isNode(source)) {
      return this.readProjectionFromNode(source);
    } else {
      if (typeof source === "string") {
        var doc = ol.xml.parse(source);
        return this.readProjectionFromDocument(doc);
      } else {
        return null;
      }
    }
  }
};
ol.format.XMLFeature.prototype.readProjectionFromDocument = function(doc) {
  return this.defaultDataProjection;
};
ol.format.XMLFeature.prototype.readProjectionFromNode = function(node) {
  return this.defaultDataProjection;
};
ol.format.XMLFeature.prototype.writeFeature = function(feature, opt_options) {
  var node = this.writeFeatureNode(feature, opt_options);
  return this.xmlSerializer_.serializeToString(node);
};
ol.format.XMLFeature.prototype.writeFeatureNode = function(feature, opt_options) {
  return null;
};
ol.format.XMLFeature.prototype.writeFeatures = function(features, opt_options) {
  var node = this.writeFeaturesNode(features, opt_options);
  return this.xmlSerializer_.serializeToString(node);
};
ol.format.XMLFeature.prototype.writeFeaturesNode = function(features, opt_options) {
  return null;
};
ol.format.XMLFeature.prototype.writeGeometry = function(geometry, opt_options) {
  var node = this.writeGeometryNode(geometry, opt_options);
  return this.xmlSerializer_.serializeToString(node);
};
ol.format.XMLFeature.prototype.writeGeometryNode = function(geometry, opt_options) {
  return null;
};
goog.provide("ol.format.GMLBase");
goog.require("ol");
goog.require("ol.array");
goog.require("ol.Feature");
goog.require("ol.format.Feature");
goog.require("ol.format.XMLFeature");
goog.require("ol.geom.GeometryLayout");
goog.require("ol.geom.LineString");
goog.require("ol.geom.LinearRing");
goog.require("ol.geom.MultiLineString");
goog.require("ol.geom.MultiPoint");
goog.require("ol.geom.MultiPolygon");
goog.require("ol.geom.Point");
goog.require("ol.geom.Polygon");
goog.require("ol.obj");
goog.require("ol.proj");
goog.require("ol.xml");
ol.format.GMLBase = function(opt_options) {
  var options = opt_options ? opt_options : {};
  this.featureType = options.featureType;
  this.featureNS = options.featureNS;
  this.srsName = options.srsName;
  this.schemaLocation = "";
  this.FEATURE_COLLECTION_PARSERS = {};
  this.FEATURE_COLLECTION_PARSERS[ol.format.GMLBase.GMLNS] = {"featureMember":ol.xml.makeReplacer(ol.format.GMLBase.prototype.readFeaturesInternal), "featureMembers":ol.xml.makeReplacer(ol.format.GMLBase.prototype.readFeaturesInternal)};
  ol.format.XMLFeature.call(this);
};
ol.inherits(ol.format.GMLBase, ol.format.XMLFeature);
ol.format.GMLBase.GMLNS = "http://www.opengis.net/gml";
ol.format.GMLBase.ONLY_WHITESPACE_RE_ = /^[\s\xa0]*$/;
ol.format.GMLBase.prototype.readFeaturesInternal = function(node, objectStack) {
  var localName = node.localName;
  var features = null;
  if (localName == "FeatureCollection") {
    if (node.namespaceURI === "http://www.opengis.net/wfs") {
      features = ol.xml.pushParseAndPop([], this.FEATURE_COLLECTION_PARSERS, node, objectStack, this);
    } else {
      features = ol.xml.pushParseAndPop(null, this.FEATURE_COLLECTION_PARSERS, node, objectStack, this);
    }
  } else {
    if (localName == "featureMembers" || localName == "featureMember") {
      var context = objectStack[0];
      var featureType = context["featureType"];
      var featureNS = context["featureNS"];
      var i, ii, prefix = "p", defaultPrefix = "p0";
      if (!featureType && node.childNodes) {
        featureType = [], featureNS = {};
        for (i = 0, ii = node.childNodes.length; i < ii; ++i) {
          var child = node.childNodes[i];
          if (child.nodeType === 1) {
            var ft = child.nodeName.split(":").pop();
            if (featureType.indexOf(ft) === -1) {
              var key = "";
              var count = 0;
              var uri = child.namespaceURI;
              for (var candidate in featureNS) {
                if (featureNS[candidate] === uri) {
                  key = candidate;
                  break;
                }
                ++count;
              }
              if (!key) {
                key = prefix + count;
                featureNS[key] = uri;
              }
              featureType.push(key + ":" + ft);
            }
          }
        }
        if (localName != "featureMember") {
          context["featureType"] = featureType;
          context["featureNS"] = featureNS;
        }
      }
      if (typeof featureNS === "string") {
        var ns = featureNS;
        featureNS = {};
        featureNS[defaultPrefix] = ns;
      }
      var parsersNS = {};
      var featureTypes = Array.isArray(featureType) ? featureType : [featureType];
      for (var p in featureNS) {
        var parsers = {};
        for (i = 0, ii = featureTypes.length; i < ii; ++i) {
          var featurePrefix = featureTypes[i].indexOf(":") === -1 ? defaultPrefix : featureTypes[i].split(":")[0];
          if (featurePrefix === p) {
            parsers[featureTypes[i].split(":").pop()] = localName == "featureMembers" ? ol.xml.makeArrayPusher(this.readFeatureElement, this) : ol.xml.makeReplacer(this.readFeatureElement, this);
          }
        }
        parsersNS[featureNS[p]] = parsers;
      }
      if (localName == "featureMember") {
        features = ol.xml.pushParseAndPop(undefined, parsersNS, node, objectStack);
      } else {
        features = ol.xml.pushParseAndPop([], parsersNS, node, objectStack);
      }
    }
  }
  if (features === null) {
    features = [];
  }
  return features;
};
ol.format.GMLBase.prototype.readGeometryElement = function(node, objectStack) {
  var context = objectStack[0];
  context["srsName"] = node.firstElementChild.getAttribute("srsName");
  context["srsDimension"] = node.firstElementChild.getAttribute("srsDimension");
  var geometry = ol.xml.pushParseAndPop(null, this.GEOMETRY_PARSERS_, node, objectStack, this);
  if (geometry) {
    return ol.format.Feature.transformWithOptions(geometry, false, context);
  } else {
    return undefined;
  }
};
ol.format.GMLBase.prototype.readFeatureElement = function(node, objectStack) {
  var n;
  var fid = node.getAttribute("fid") || ol.xml.getAttributeNS(node, ol.format.GMLBase.GMLNS, "id");
  var values = {}, geometryName;
  for (n = node.firstElementChild; n; n = n.nextElementSibling) {
    var localName = n.localName;
    if (n.childNodes.length === 0 || n.childNodes.length === 1 && (n.firstChild.nodeType === 3 || n.firstChild.nodeType === 4)) {
      var value = ol.xml.getAllTextContent(n, false);
      if (ol.format.GMLBase.ONLY_WHITESPACE_RE_.test(value)) {
        value = undefined;
      }
      values[localName] = value;
    } else {
      if (localName !== "boundedBy") {
        geometryName = localName;
      }
      values[localName] = this.readGeometryElement(n, objectStack);
    }
  }
  var feature = new ol.Feature(values);
  if (geometryName) {
    feature.setGeometryName(geometryName);
  }
  if (fid) {
    feature.setId(fid);
  }
  return feature;
};
ol.format.GMLBase.prototype.readPoint = function(node, objectStack) {
  var flatCoordinates = this.readFlatCoordinatesFromNode_(node, objectStack);
  if (flatCoordinates) {
    var point = new ol.geom.Point(null);
    point.setFlatCoordinates(ol.geom.GeometryLayout.XYZ, flatCoordinates);
    return point;
  }
};
ol.format.GMLBase.prototype.readMultiPoint = function(node, objectStack) {
  var coordinates = ol.xml.pushParseAndPop([], this.MULTIPOINT_PARSERS_, node, objectStack, this);
  if (coordinates) {
    return new ol.geom.MultiPoint(coordinates);
  } else {
    return undefined;
  }
};
ol.format.GMLBase.prototype.readMultiLineString = function(node, objectStack) {
  var lineStrings = ol.xml.pushParseAndPop([], this.MULTILINESTRING_PARSERS_, node, objectStack, this);
  if (lineStrings) {
    var multiLineString = new ol.geom.MultiLineString(null);
    multiLineString.setLineStrings(lineStrings);
    return multiLineString;
  } else {
    return undefined;
  }
};
ol.format.GMLBase.prototype.readMultiPolygon = function(node, objectStack) {
  var polygons = ol.xml.pushParseAndPop([], this.MULTIPOLYGON_PARSERS_, node, objectStack, this);
  if (polygons) {
    var multiPolygon = new ol.geom.MultiPolygon(null);
    multiPolygon.setPolygons(polygons);
    return multiPolygon;
  } else {
    return undefined;
  }
};
ol.format.GMLBase.prototype.pointMemberParser_ = function(node, objectStack) {
  ol.xml.parseNode(this.POINTMEMBER_PARSERS_, node, objectStack, this);
};
ol.format.GMLBase.prototype.lineStringMemberParser_ = function(node, objectStack) {
  ol.xml.parseNode(this.LINESTRINGMEMBER_PARSERS_, node, objectStack, this);
};
ol.format.GMLBase.prototype.polygonMemberParser_ = function(node, objectStack) {
  ol.xml.parseNode(this.POLYGONMEMBER_PARSERS_, node, objectStack, this);
};
ol.format.GMLBase.prototype.readLineString = function(node, objectStack) {
  var flatCoordinates = this.readFlatCoordinatesFromNode_(node, objectStack);
  if (flatCoordinates) {
    var lineString = new ol.geom.LineString(null);
    lineString.setFlatCoordinates(ol.geom.GeometryLayout.XYZ, flatCoordinates);
    return lineString;
  } else {
    return undefined;
  }
};
ol.format.GMLBase.prototype.readFlatLinearRing_ = function(node, objectStack) {
  var ring = ol.xml.pushParseAndPop(null, this.GEOMETRY_FLAT_COORDINATES_PARSERS_, node, objectStack, this);
  if (ring) {
    return ring;
  } else {
    return undefined;
  }
};
ol.format.GMLBase.prototype.readLinearRing = function(node, objectStack) {
  var flatCoordinates = this.readFlatCoordinatesFromNode_(node, objectStack);
  if (flatCoordinates) {
    var ring = new ol.geom.LinearRing(null);
    ring.setFlatCoordinates(ol.geom.GeometryLayout.XYZ, flatCoordinates);
    return ring;
  } else {
    return undefined;
  }
};
ol.format.GMLBase.prototype.readPolygon = function(node, objectStack) {
  var flatLinearRings = ol.xml.pushParseAndPop([null], this.FLAT_LINEAR_RINGS_PARSERS_, node, objectStack, this);
  if (flatLinearRings && flatLinearRings[0]) {
    var polygon = new ol.geom.Polygon(null);
    var flatCoordinates = flatLinearRings[0];
    var ends = [flatCoordinates.length];
    var i, ii;
    for (i = 1, ii = flatLinearRings.length; i < ii; ++i) {
      ol.array.extend(flatCoordinates, flatLinearRings[i]);
      ends.push(flatCoordinates.length);
    }
    polygon.setFlatCoordinates(ol.geom.GeometryLayout.XYZ, flatCoordinates, ends);
    return polygon;
  } else {
    return undefined;
  }
};
ol.format.GMLBase.prototype.readFlatCoordinatesFromNode_ = function(node, objectStack) {
  return ol.xml.pushParseAndPop(null, this.GEOMETRY_FLAT_COORDINATES_PARSERS_, node, objectStack, this);
};
ol.format.GMLBase.prototype.MULTIPOINT_PARSERS_ = {"http://www.opengis.net/gml":{"pointMember":ol.xml.makeArrayPusher(ol.format.GMLBase.prototype.pointMemberParser_), "pointMembers":ol.xml.makeArrayPusher(ol.format.GMLBase.prototype.pointMemberParser_)}};
ol.format.GMLBase.prototype.MULTILINESTRING_PARSERS_ = {"http://www.opengis.net/gml":{"lineStringMember":ol.xml.makeArrayPusher(ol.format.GMLBase.prototype.lineStringMemberParser_), "lineStringMembers":ol.xml.makeArrayPusher(ol.format.GMLBase.prototype.lineStringMemberParser_)}};
ol.format.GMLBase.prototype.MULTIPOLYGON_PARSERS_ = {"http://www.opengis.net/gml":{"polygonMember":ol.xml.makeArrayPusher(ol.format.GMLBase.prototype.polygonMemberParser_), "polygonMembers":ol.xml.makeArrayPusher(ol.format.GMLBase.prototype.polygonMemberParser_)}};
ol.format.GMLBase.prototype.POINTMEMBER_PARSERS_ = {"http://www.opengis.net/gml":{"Point":ol.xml.makeArrayPusher(ol.format.GMLBase.prototype.readFlatCoordinatesFromNode_)}};
ol.format.GMLBase.prototype.LINESTRINGMEMBER_PARSERS_ = {"http://www.opengis.net/gml":{"LineString":ol.xml.makeArrayPusher(ol.format.GMLBase.prototype.readLineString)}};
ol.format.GMLBase.prototype.POLYGONMEMBER_PARSERS_ = {"http://www.opengis.net/gml":{"Polygon":ol.xml.makeArrayPusher(ol.format.GMLBase.prototype.readPolygon)}};
ol.format.GMLBase.prototype.RING_PARSERS = {"http://www.opengis.net/gml":{"LinearRing":ol.xml.makeReplacer(ol.format.GMLBase.prototype.readFlatLinearRing_)}};
ol.format.GMLBase.prototype.readGeometryFromNode = function(node, opt_options) {
  var geometry = this.readGeometryElement(node, [this.getReadOptions(node, opt_options ? opt_options : {})]);
  return geometry ? geometry : null;
};
ol.format.GMLBase.prototype.readFeatures;
ol.format.GMLBase.prototype.readFeaturesFromNode = function(node, opt_options) {
  var options = {featureType:this.featureType, featureNS:this.featureNS};
  if (opt_options) {
    ol.obj.assign(options, this.getReadOptions(node, opt_options));
  }
  var features = this.readFeaturesInternal(node, [options]);
  return features || [];
};
ol.format.GMLBase.prototype.readProjectionFromNode = function(node) {
  return ol.proj.get(this.srsName ? this.srsName : node.firstElementChild.getAttribute("srsName"));
};
goog.provide("ol.format.XSD");
goog.require("ol.xml");
goog.require("ol.string");
ol.format.XSD.NAMESPACE_URI = "http://www.w3.org/2001/XMLSchema";
ol.format.XSD.readBoolean = function(node) {
  var s = ol.xml.getAllTextContent(node, false);
  return ol.format.XSD.readBooleanString(s);
};
ol.format.XSD.readBooleanString = function(string) {
  var m = /^\s*(true|1)|(false|0)\s*$/.exec(string);
  if (m) {
    return m[1] !== undefined || false;
  } else {
    return undefined;
  }
};
ol.format.XSD.readDateTime = function(node) {
  var s = ol.xml.getAllTextContent(node, false);
  var dateTime = Date.parse(s);
  return isNaN(dateTime) ? undefined : dateTime / 1000;
};
ol.format.XSD.readDecimal = function(node) {
  var s = ol.xml.getAllTextContent(node, false);
  return ol.format.XSD.readDecimalString(s);
};
ol.format.XSD.readDecimalString = function(string) {
  var m = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)\s*$/i.exec(string);
  if (m) {
    return parseFloat(m[1]);
  } else {
    return undefined;
  }
};
ol.format.XSD.readNonNegativeInteger = function(node) {
  var s = ol.xml.getAllTextContent(node, false);
  return ol.format.XSD.readNonNegativeIntegerString(s);
};
ol.format.XSD.readNonNegativeIntegerString = function(string) {
  var m = /^\s*(\d+)\s*$/.exec(string);
  if (m) {
    return parseInt(m[1], 10);
  } else {
    return undefined;
  }
};
ol.format.XSD.readString = function(node) {
  return ol.xml.getAllTextContent(node, false).trim();
};
ol.format.XSD.writeBooleanTextNode = function(node, bool) {
  ol.format.XSD.writeStringTextNode(node, bool ? "1" : "0");
};
ol.format.XSD.writeCDATASection = function(node, string) {
  node.appendChild(ol.xml.DOCUMENT.createCDATASection(string));
};
ol.format.XSD.writeDateTimeTextNode = function(node, dateTime) {
  var date = new Date(dateTime * 1000);
  var string = date.getUTCFullYear() + "-" + ol.string.padNumber(date.getUTCMonth() + 1, 2) + "-" + ol.string.padNumber(date.getUTCDate(), 2) + "T" + ol.string.padNumber(date.getUTCHours(), 2) + ":" + ol.string.padNumber(date.getUTCMinutes(), 2) + ":" + ol.string.padNumber(date.getUTCSeconds(), 2) + "Z";
  node.appendChild(ol.xml.DOCUMENT.createTextNode(string));
};
ol.format.XSD.writeDecimalTextNode = function(node, decimal) {
  var string = decimal.toPrecision();
  node.appendChild(ol.xml.DOCUMENT.createTextNode(string));
};
ol.format.XSD.writeNonNegativeIntegerTextNode = function(node, nonNegativeInteger) {
  var string = nonNegativeInteger.toString();
  node.appendChild(ol.xml.DOCUMENT.createTextNode(string));
};
ol.format.XSD.writeStringTextNode = function(node, string) {
  node.appendChild(ol.xml.DOCUMENT.createTextNode(string));
};
goog.provide("ol.format.GML3");
goog.require("ol");
goog.require("ol.array");
goog.require("ol.extent");
goog.require("ol.format.Feature");
goog.require("ol.format.GMLBase");
goog.require("ol.format.XSD");
goog.require("ol.geom.Geometry");
goog.require("ol.geom.GeometryLayout");
goog.require("ol.geom.LineString");
goog.require("ol.geom.MultiLineString");
goog.require("ol.geom.MultiPolygon");
goog.require("ol.geom.Polygon");
goog.require("ol.obj");
goog.require("ol.proj");
goog.require("ol.xml");
ol.format.GML3 = function(opt_options) {
  var options = opt_options ? opt_options : {};
  ol.format.GMLBase.call(this, options);
  this.surface_ = options.surface !== undefined ? options.surface : false;
  this.curve_ = options.curve !== undefined ? options.curve : false;
  this.multiCurve_ = options.multiCurve !== undefined ? options.multiCurve : true;
  this.multiSurface_ = options.multiSurface !== undefined ? options.multiSurface : true;
  this.schemaLocation = options.schemaLocation ? options.schemaLocation : ol.format.GML3.schemaLocation_;
  this.hasZ = options.hasZ !== undefined ? options.hasZ : false;
};
ol.inherits(ol.format.GML3, ol.format.GMLBase);
ol.format.GML3.schemaLocation_ = ol.format.GMLBase.GMLNS + " http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/" + "1.0.0/gmlsf.xsd";
ol.format.GML3.prototype.readMultiCurve_ = function(node, objectStack) {
  var lineStrings = ol.xml.pushParseAndPop([], this.MULTICURVE_PARSERS_, node, objectStack, this);
  if (lineStrings) {
    var multiLineString = new ol.geom.MultiLineString(null);
    multiLineString.setLineStrings(lineStrings);
    return multiLineString;
  } else {
    return undefined;
  }
};
ol.format.GML3.prototype.readMultiSurface_ = function(node, objectStack) {
  var polygons = ol.xml.pushParseAndPop([], this.MULTISURFACE_PARSERS_, node, objectStack, this);
  if (polygons) {
    var multiPolygon = new ol.geom.MultiPolygon(null);
    multiPolygon.setPolygons(polygons);
    return multiPolygon;
  } else {
    return undefined;
  }
};
ol.format.GML3.prototype.curveMemberParser_ = function(node, objectStack) {
  ol.xml.parseNode(this.CURVEMEMBER_PARSERS_, node, objectStack, this);
};
ol.format.GML3.prototype.surfaceMemberParser_ = function(node, objectStack) {
  ol.xml.parseNode(this.SURFACEMEMBER_PARSERS_, node, objectStack, this);
};
ol.format.GML3.prototype.readPatch_ = function(node, objectStack) {
  return ol.xml.pushParseAndPop([null], this.PATCHES_PARSERS_, node, objectStack, this);
};
ol.format.GML3.prototype.readSegment_ = function(node, objectStack) {
  return ol.xml.pushParseAndPop([null], this.SEGMENTS_PARSERS_, node, objectStack, this);
};
ol.format.GML3.prototype.readPolygonPatch_ = function(node, objectStack) {
  return ol.xml.pushParseAndPop([null], this.FLAT_LINEAR_RINGS_PARSERS_, node, objectStack, this);
};
ol.format.GML3.prototype.readLineStringSegment_ = function(node, objectStack) {
  return ol.xml.pushParseAndPop([null], this.GEOMETRY_FLAT_COORDINATES_PARSERS_, node, objectStack, this);
};
ol.format.GML3.prototype.interiorParser_ = function(node, objectStack) {
  var flatLinearRing = ol.xml.pushParseAndPop(undefined, this.RING_PARSERS, node, objectStack, this);
  if (flatLinearRing) {
    var flatLinearRings = objectStack[objectStack.length - 1];
    flatLinearRings.push(flatLinearRing);
  }
};
ol.format.GML3.prototype.exteriorParser_ = function(node, objectStack) {
  var flatLinearRing = ol.xml.pushParseAndPop(undefined, this.RING_PARSERS, node, objectStack, this);
  if (flatLinearRing) {
    var flatLinearRings = objectStack[objectStack.length - 1];
    flatLinearRings[0] = flatLinearRing;
  }
};
ol.format.GML3.prototype.readSurface_ = function(node, objectStack) {
  var flatLinearRings = ol.xml.pushParseAndPop([null], this.SURFACE_PARSERS_, node, objectStack, this);
  if (flatLinearRings && flatLinearRings[0]) {
    var polygon = new ol.geom.Polygon(null);
    var flatCoordinates = flatLinearRings[0];
    var ends = [flatCoordinates.length];
    var i, ii;
    for (i = 1, ii = flatLinearRings.length; i < ii; ++i) {
      ol.array.extend(flatCoordinates, flatLinearRings[i]);
      ends.push(flatCoordinates.length);
    }
    polygon.setFlatCoordinates(ol.geom.GeometryLayout.XYZ, flatCoordinates, ends);
    return polygon;
  } else {
    return undefined;
  }
};
ol.format.GML3.prototype.readCurve_ = function(node, objectStack) {
  var flatCoordinates = ol.xml.pushParseAndPop([null], this.CURVE_PARSERS_, node, objectStack, this);
  if (flatCoordinates) {
    var lineString = new ol.geom.LineString(null);
    lineString.setFlatCoordinates(ol.geom.GeometryLayout.XYZ, flatCoordinates);
    return lineString;
  } else {
    return undefined;
  }
};
ol.format.GML3.prototype.readEnvelope_ = function(node, objectStack) {
  var flatCoordinates = ol.xml.pushParseAndPop([null], this.ENVELOPE_PARSERS_, node, objectStack, this);
  return ol.extent.createOrUpdate(flatCoordinates[1][0], flatCoordinates[1][1], flatCoordinates[2][0], flatCoordinates[2][1]);
};
ol.format.GML3.prototype.readFlatPos_ = function(node, objectStack) {
  var s = ol.xml.getAllTextContent(node, false);
  var re = /^\s*([+\-]?\d*\.?\d+(?:[eE][+\-]?\d+)?)\s*/;
  var flatCoordinates = [];
  var m;
  while (m = re.exec(s)) {
    flatCoordinates.push(parseFloat(m[1]));
    s = s.substr(m[0].length);
  }
  if (s !== "") {
    return undefined;
  }
  var context = objectStack[0];
  var containerSrs = context["srsName"];
  var axisOrientation = "enu";
  if (containerSrs) {
    var proj = ol.proj.get(containerSrs);
    axisOrientation = proj.getAxisOrientation();
  }
  if (axisOrientation === "neu") {
    var i, ii;
    for (i = 0, ii = flatCoordinates.length; i < ii; i += 3) {
      var y = flatCoordinates[i];
      var x = flatCoordinates[i + 1];
      flatCoordinates[i] = x;
      flatCoordinates[i + 1] = y;
    }
  }
  var len = flatCoordinates.length;
  if (len == 2) {
    flatCoordinates.push(0);
  }
  if (len === 0) {
    return undefined;
  }
  return flatCoordinates;
};
ol.format.GML3.prototype.readFlatPosList_ = function(node, objectStack) {
  var s = ol.xml.getAllTextContent(node, false).replace(/^\s*|\s*$/g, "");
  var context = objectStack[0];
  var containerSrs = context["srsName"];
  var contextDimension = context["srsDimension"];
  var axisOrientation = "enu";
  if (containerSrs) {
    var proj = ol.proj.get(containerSrs);
    axisOrientation = proj.getAxisOrientation();
  }
  var coords = s.split(/\s+/);
  var dim = 2;
  if (node.getAttribute("srsDimension")) {
    dim = ol.format.XSD.readNonNegativeIntegerString(node.getAttribute("srsDimension"));
  } else {
    if (node.getAttribute("dimension")) {
      dim = ol.format.XSD.readNonNegativeIntegerString(node.getAttribute("dimension"));
    } else {
      if (node.parentNode.getAttribute("srsDimension")) {
        dim = ol.format.XSD.readNonNegativeIntegerString(node.parentNode.getAttribute("srsDimension"));
      } else {
        if (contextDimension) {
          dim = ol.format.XSD.readNonNegativeIntegerString(contextDimension);
        }
      }
    }
  }
  var x, y, z;
  var flatCoordinates = [];
  for (var i = 0, ii = coords.length; i < ii; i += dim) {
    x = parseFloat(coords[i]);
    y = parseFloat(coords[i + 1]);
    z = dim === 3 ? parseFloat(coords[i + 2]) : 0;
    if (axisOrientation.substr(0, 2) === "en") {
      flatCoordinates.push(x, y, z);
    } else {
      flatCoordinates.push(y, x, z);
    }
  }
  return flatCoordinates;
};
ol.format.GML3.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS_ = {"http://www.opengis.net/gml":{"pos":ol.xml.makeReplacer(ol.format.GML3.prototype.readFlatPos_), "posList":ol.xml.makeReplacer(ol.format.GML3.prototype.readFlatPosList_)}};
ol.format.GML3.prototype.FLAT_LINEAR_RINGS_PARSERS_ = {"http://www.opengis.net/gml":{"interior":ol.format.GML3.prototype.interiorParser_, "exterior":ol.format.GML3.prototype.exteriorParser_}};
ol.format.GML3.prototype.GEOMETRY_PARSERS_ = {"http://www.opengis.net/gml":{"Point":ol.xml.makeReplacer(ol.format.GMLBase.prototype.readPoint), "MultiPoint":ol.xml.makeReplacer(ol.format.GMLBase.prototype.readMultiPoint), "LineString":ol.xml.makeReplacer(ol.format.GMLBase.prototype.readLineString), "MultiLineString":ol.xml.makeReplacer(ol.format.GMLBase.prototype.readMultiLineString), "LinearRing":ol.xml.makeReplacer(ol.format.GMLBase.prototype.readLinearRing), "Polygon":ol.xml.makeReplacer(ol.format.GMLBase.prototype.readPolygon), 
"MultiPolygon":ol.xml.makeReplacer(ol.format.GMLBase.prototype.readMultiPolygon), "Surface":ol.xml.makeReplacer(ol.format.GML3.prototype.readSurface_), "MultiSurface":ol.xml.makeReplacer(ol.format.GML3.prototype.readMultiSurface_), "Curve":ol.xml.makeReplacer(ol.format.GML3.prototype.readCurve_), "MultiCurve":ol.xml.makeReplacer(ol.format.GML3.prototype.readMultiCurve_), "Envelope":ol.xml.makeReplacer(ol.format.GML3.prototype.readEnvelope_)}};
ol.format.GML3.prototype.MULTICURVE_PARSERS_ = {"http://www.opengis.net/gml":{"curveMember":ol.xml.makeArrayPusher(ol.format.GML3.prototype.curveMemberParser_), "curveMembers":ol.xml.makeArrayPusher(ol.format.GML3.prototype.curveMemberParser_)}};
ol.format.GML3.prototype.MULTISURFACE_PARSERS_ = {"http://www.opengis.net/gml":{"surfaceMember":ol.xml.makeArrayPusher(ol.format.GML3.prototype.surfaceMemberParser_), "surfaceMembers":ol.xml.makeArrayPusher(ol.format.GML3.prototype.surfaceMemberParser_)}};
ol.format.GML3.prototype.CURVEMEMBER_PARSERS_ = {"http://www.opengis.net/gml":{"LineString":ol.xml.makeArrayPusher(ol.format.GMLBase.prototype.readLineString), "Curve":ol.xml.makeArrayPusher(ol.format.GML3.prototype.readCurve_)}};
ol.format.GML3.prototype.SURFACEMEMBER_PARSERS_ = {"http://www.opengis.net/gml":{"Polygon":ol.xml.makeArrayPusher(ol.format.GMLBase.prototype.readPolygon), "Surface":ol.xml.makeArrayPusher(ol.format.GML3.prototype.readSurface_)}};
ol.format.GML3.prototype.SURFACE_PARSERS_ = {"http://www.opengis.net/gml":{"patches":ol.xml.makeReplacer(ol.format.GML3.prototype.readPatch_)}};
ol.format.GML3.prototype.CURVE_PARSERS_ = {"http://www.opengis.net/gml":{"segments":ol.xml.makeReplacer(ol.format.GML3.prototype.readSegment_)}};
ol.format.GML3.prototype.ENVELOPE_PARSERS_ = {"http://www.opengis.net/gml":{"lowerCorner":ol.xml.makeArrayPusher(ol.format.GML3.prototype.readFlatPosList_), "upperCorner":ol.xml.makeArrayPusher(ol.format.GML3.prototype.readFlatPosList_)}};
ol.format.GML3.prototype.PATCHES_PARSERS_ = {"http://www.opengis.net/gml":{"PolygonPatch":ol.xml.makeReplacer(ol.format.GML3.prototype.readPolygonPatch_)}};
ol.format.GML3.prototype.SEGMENTS_PARSERS_ = {"http://www.opengis.net/gml":{"LineStringSegment":ol.xml.makeReplacer(ol.format.GML3.prototype.readLineStringSegment_)}};
ol.format.GML3.prototype.writePos_ = function(node, value, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var hasZ = context["hasZ"];
  var srsDimension = hasZ ? 3 : 2;
  node.setAttribute("srsDimension", srsDimension);
  var srsName = context["srsName"];
  var axisOrientation = "enu";
  if (srsName) {
    axisOrientation = ol.proj.get(srsName).getAxisOrientation();
  }
  var point = value.getCoordinates();
  var coords;
  if (axisOrientation.substr(0, 2) === "en") {
    coords = point[0] + " " + point[1];
  } else {
    coords = point[1] + " " + point[0];
  }
  if (hasZ) {
    var z = point[2] || 0;
    coords += " " + z;
  }
  ol.format.XSD.writeStringTextNode(node, coords);
};
ol.format.GML3.prototype.getCoords_ = function(point, opt_srsName, opt_hasZ) {
  var axisOrientation = "enu";
  if (opt_srsName) {
    axisOrientation = ol.proj.get(opt_srsName).getAxisOrientation();
  }
  var coords = axisOrientation.substr(0, 2) === "en" ? point[0] + " " + point[1] : point[1] + " " + point[0];
  if (opt_hasZ) {
    var z = point[2] || 0;
    coords += " " + z;
  }
  return coords;
};
ol.format.GML3.prototype.writePosList_ = function(node, value, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var hasZ = context["hasZ"];
  var srsDimension = hasZ ? 3 : 2;
  node.setAttribute("srsDimension", srsDimension);
  var srsName = context["srsName"];
  var points = value.getCoordinates();
  var len = points.length;
  var parts = new Array(len);
  var point;
  for (var i = 0; i < len; ++i) {
    point = points[i];
    parts[i] = this.getCoords_(point, srsName, hasZ);
  }
  ol.format.XSD.writeStringTextNode(node, parts.join(" "));
};
ol.format.GML3.prototype.writePoint_ = function(node, geometry, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var srsName = context["srsName"];
  if (srsName) {
    node.setAttribute("srsName", srsName);
  }
  var pos = ol.xml.createElementNS(node.namespaceURI, "pos");
  node.appendChild(pos);
  this.writePos_(pos, geometry, objectStack);
};
ol.format.GML3.ENVELOPE_SERIALIZERS_ = {"http://www.opengis.net/gml":{"lowerCorner":ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode), "upperCorner":ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode)}};
ol.format.GML3.prototype.writeEnvelope = function(node, extent, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var srsName = context["srsName"];
  if (srsName) {
    node.setAttribute("srsName", srsName);
  }
  var keys = ["lowerCorner", "upperCorner"];
  var values = [extent[0] + " " + extent[1], extent[2] + " " + extent[3]];
  ol.xml.pushSerializeAndPop({node:node}, ol.format.GML3.ENVELOPE_SERIALIZERS_, ol.xml.OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, keys, this);
};
ol.format.GML3.prototype.writeLinearRing_ = function(node, geometry, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var srsName = context["srsName"];
  if (srsName) {
    node.setAttribute("srsName", srsName);
  }
  var posList = ol.xml.createElementNS(node.namespaceURI, "posList");
  node.appendChild(posList);
  this.writePosList_(posList, geometry, objectStack);
};
ol.format.GML3.prototype.RING_NODE_FACTORY_ = function(value, objectStack, opt_nodeName) {
  var context = objectStack[objectStack.length - 1];
  var parentNode = context.node;
  var exteriorWritten = context["exteriorWritten"];
  if (exteriorWritten === undefined) {
    context["exteriorWritten"] = true;
  }
  return ol.xml.createElementNS(parentNode.namespaceURI, exteriorWritten !== undefined ? "interior" : "exterior");
};
ol.format.GML3.prototype.writeSurfaceOrPolygon_ = function(node, geometry, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var hasZ = context["hasZ"];
  var srsName = context["srsName"];
  if (node.nodeName !== "PolygonPatch" && srsName) {
    node.setAttribute("srsName", srsName);
  }
  if (node.nodeName === "Polygon" || node.nodeName === "PolygonPatch") {
    var rings = geometry.getLinearRings();
    ol.xml.pushSerializeAndPop({node:node, hasZ:hasZ, srsName:srsName}, ol.format.GML3.RING_SERIALIZERS_, this.RING_NODE_FACTORY_, rings, objectStack, undefined, this);
  } else {
    if (node.nodeName === "Surface") {
      var patches = ol.xml.createElementNS(node.namespaceURI, "patches");
      node.appendChild(patches);
      this.writeSurfacePatches_(patches, geometry, objectStack);
    }
  }
};
ol.format.GML3.prototype.writeCurveOrLineString_ = function(node, geometry, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var srsName = context["srsName"];
  if (node.nodeName !== "LineStringSegment" && srsName) {
    node.setAttribute("srsName", srsName);
  }
  if (node.nodeName === "LineString" || node.nodeName === "LineStringSegment") {
    var posList = ol.xml.createElementNS(node.namespaceURI, "posList");
    node.appendChild(posList);
    this.writePosList_(posList, geometry, objectStack);
  } else {
    if (node.nodeName === "Curve") {
      var segments = ol.xml.createElementNS(node.namespaceURI, "segments");
      node.appendChild(segments);
      this.writeCurveSegments_(segments, geometry, objectStack);
    }
  }
};
ol.format.GML3.prototype.writeMultiSurfaceOrPolygon_ = function(node, geometry, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var hasZ = context["hasZ"];
  var srsName = context["srsName"];
  var surface = context["surface"];
  if (srsName) {
    node.setAttribute("srsName", srsName);
  }
  var polygons = geometry.getPolygons();
  ol.xml.pushSerializeAndPop({node:node, hasZ:hasZ, srsName:srsName, surface:surface}, ol.format.GML3.SURFACEORPOLYGONMEMBER_SERIALIZERS_, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, polygons, objectStack, undefined, this);
};
ol.format.GML3.prototype.writeMultiPoint_ = function(node, geometry, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var srsName = context["srsName"];
  var hasZ = context["hasZ"];
  if (srsName) {
    node.setAttribute("srsName", srsName);
  }
  var points = geometry.getPoints();
  ol.xml.pushSerializeAndPop({node:node, hasZ:hasZ, srsName:srsName}, ol.format.GML3.POINTMEMBER_SERIALIZERS_, ol.xml.makeSimpleNodeFactory("pointMember"), points, objectStack, undefined, this);
};
ol.format.GML3.prototype.writeMultiCurveOrLineString_ = function(node, geometry, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var hasZ = context["hasZ"];
  var srsName = context["srsName"];
  var curve = context["curve"];
  if (srsName) {
    node.setAttribute("srsName", srsName);
  }
  var lines = geometry.getLineStrings();
  ol.xml.pushSerializeAndPop({node:node, hasZ:hasZ, srsName:srsName, curve:curve}, ol.format.GML3.LINESTRINGORCURVEMEMBER_SERIALIZERS_, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, lines, objectStack, undefined, this);
};
ol.format.GML3.prototype.writeRing_ = function(node, ring, objectStack) {
  var linearRing = ol.xml.createElementNS(node.namespaceURI, "LinearRing");
  node.appendChild(linearRing);
  this.writeLinearRing_(linearRing, ring, objectStack);
};
ol.format.GML3.prototype.writeSurfaceOrPolygonMember_ = function(node, polygon, objectStack) {
  var child = this.GEOMETRY_NODE_FACTORY_(polygon, objectStack);
  if (child) {
    node.appendChild(child);
    this.writeSurfaceOrPolygon_(child, polygon, objectStack);
  }
};
ol.format.GML3.prototype.writePointMember_ = function(node, point, objectStack) {
  var child = ol.xml.createElementNS(node.namespaceURI, "Point");
  node.appendChild(child);
  this.writePoint_(child, point, objectStack);
};
ol.format.GML3.prototype.writeLineStringOrCurveMember_ = function(node, line, objectStack) {
  var child = this.GEOMETRY_NODE_FACTORY_(line, objectStack);
  if (child) {
    node.appendChild(child);
    this.writeCurveOrLineString_(child, line, objectStack);
  }
};
ol.format.GML3.prototype.writeSurfacePatches_ = function(node, polygon, objectStack) {
  var child = ol.xml.createElementNS(node.namespaceURI, "PolygonPatch");
  node.appendChild(child);
  this.writeSurfaceOrPolygon_(child, polygon, objectStack);
};
ol.format.GML3.prototype.writeCurveSegments_ = function(node, line, objectStack) {
  var child = ol.xml.createElementNS(node.namespaceURI, "LineStringSegment");
  node.appendChild(child);
  this.writeCurveOrLineString_(child, line, objectStack);
};
ol.format.GML3.prototype.writeGeometryElement = function(node, geometry, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var item = ol.obj.assign({}, context);
  item.node = node;
  var value;
  if (Array.isArray(geometry)) {
    if (context.dataProjection) {
      value = ol.proj.transformExtent(geometry, context.featureProjection, context.dataProjection);
    } else {
      value = geometry;
    }
  } else {
    value = ol.format.Feature.transformWithOptions(geometry, true, context);
  }
  ol.xml.pushSerializeAndPop(item, ol.format.GML3.GEOMETRY_SERIALIZERS_, this.GEOMETRY_NODE_FACTORY_, [value], objectStack, undefined, this);
};
ol.format.GML3.prototype.writeFeatureElement = function(node, feature, objectStack) {
  var fid = feature.getId();
  if (fid) {
    node.setAttribute("fid", fid);
  }
  var context = objectStack[objectStack.length - 1];
  var featureNS = context["featureNS"];
  var geometryName = feature.getGeometryName();
  if (!context.serializers) {
    context.serializers = {};
    context.serializers[featureNS] = {};
  }
  var properties = feature.getProperties();
  var keys = [], values = [];
  for (var key in properties) {
    var value = properties[key];
    if (value !== null) {
      keys.push(key);
      values.push(value);
      if (key == geometryName || value instanceof ol.geom.Geometry) {
        if (!(key in context.serializers[featureNS])) {
          context.serializers[featureNS][key] = ol.xml.makeChildAppender(this.writeGeometryElement, this);
        }
      } else {
        if (!(key in context.serializers[featureNS])) {
          context.serializers[featureNS][key] = ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode);
        }
      }
    }
  }
  var item = ol.obj.assign({}, context);
  item.node = node;
  ol.xml.pushSerializeAndPop(item, context.serializers, ol.xml.makeSimpleNodeFactory(undefined, featureNS), values, objectStack, keys);
};
ol.format.GML3.prototype.writeFeatureMembers_ = function(node, features, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var featureType = context["featureType"];
  var featureNS = context["featureNS"];
  var serializers = {};
  serializers[featureNS] = {};
  serializers[featureNS][featureType] = ol.xml.makeChildAppender(this.writeFeatureElement, this);
  var item = ol.obj.assign({}, context);
  item.node = node;
  ol.xml.pushSerializeAndPop(item, serializers, ol.xml.makeSimpleNodeFactory(featureType, featureNS), features, objectStack);
};
ol.format.GML3.SURFACEORPOLYGONMEMBER_SERIALIZERS_ = {"http://www.opengis.net/gml":{"surfaceMember":ol.xml.makeChildAppender(ol.format.GML3.prototype.writeSurfaceOrPolygonMember_), "polygonMember":ol.xml.makeChildAppender(ol.format.GML3.prototype.writeSurfaceOrPolygonMember_)}};
ol.format.GML3.POINTMEMBER_SERIALIZERS_ = {"http://www.opengis.net/gml":{"pointMember":ol.xml.makeChildAppender(ol.format.GML3.prototype.writePointMember_)}};
ol.format.GML3.LINESTRINGORCURVEMEMBER_SERIALIZERS_ = {"http://www.opengis.net/gml":{"lineStringMember":ol.xml.makeChildAppender(ol.format.GML3.prototype.writeLineStringOrCurveMember_), "curveMember":ol.xml.makeChildAppender(ol.format.GML3.prototype.writeLineStringOrCurveMember_)}};
ol.format.GML3.RING_SERIALIZERS_ = {"http://www.opengis.net/gml":{"exterior":ol.xml.makeChildAppender(ol.format.GML3.prototype.writeRing_), "interior":ol.xml.makeChildAppender(ol.format.GML3.prototype.writeRing_)}};
ol.format.GML3.GEOMETRY_SERIALIZERS_ = {"http://www.opengis.net/gml":{"Curve":ol.xml.makeChildAppender(ol.format.GML3.prototype.writeCurveOrLineString_), "MultiCurve":ol.xml.makeChildAppender(ol.format.GML3.prototype.writeMultiCurveOrLineString_), "Point":ol.xml.makeChildAppender(ol.format.GML3.prototype.writePoint_), "MultiPoint":ol.xml.makeChildAppender(ol.format.GML3.prototype.writeMultiPoint_), "LineString":ol.xml.makeChildAppender(ol.format.GML3.prototype.writeCurveOrLineString_), "MultiLineString":ol.xml.makeChildAppender(ol.format.GML3.prototype.writeMultiCurveOrLineString_), 
"LinearRing":ol.xml.makeChildAppender(ol.format.GML3.prototype.writeLinearRing_), "Polygon":ol.xml.makeChildAppender(ol.format.GML3.prototype.writeSurfaceOrPolygon_), "MultiPolygon":ol.xml.makeChildAppender(ol.format.GML3.prototype.writeMultiSurfaceOrPolygon_), "Surface":ol.xml.makeChildAppender(ol.format.GML3.prototype.writeSurfaceOrPolygon_), "MultiSurface":ol.xml.makeChildAppender(ol.format.GML3.prototype.writeMultiSurfaceOrPolygon_), "Envelope":ol.xml.makeChildAppender(ol.format.GML3.prototype.writeEnvelope)}};
ol.format.GML3.MULTIGEOMETRY_TO_MEMBER_NODENAME_ = {"MultiLineString":"lineStringMember", "MultiCurve":"curveMember", "MultiPolygon":"polygonMember", "MultiSurface":"surfaceMember"};
ol.format.GML3.prototype.MULTIGEOMETRY_MEMBER_NODE_FACTORY_ = function(value, objectStack, opt_nodeName) {
  var parentNode = objectStack[objectStack.length - 1].node;
  return ol.xml.createElementNS("http://www.opengis.net/gml", ol.format.GML3.MULTIGEOMETRY_TO_MEMBER_NODENAME_[parentNode.nodeName]);
};
ol.format.GML3.prototype.GEOMETRY_NODE_FACTORY_ = function(value, objectStack, opt_nodeName) {
  var context = objectStack[objectStack.length - 1];
  var multiSurface = context["multiSurface"];
  var surface = context["surface"];
  var curve = context["curve"];
  var multiCurve = context["multiCurve"];
  var nodeName;
  if (!Array.isArray(value)) {
    nodeName = value.getType();
    if (nodeName === "MultiPolygon" && multiSurface === true) {
      nodeName = "MultiSurface";
    } else {
      if (nodeName === "Polygon" && surface === true) {
        nodeName = "Surface";
      } else {
        if (nodeName === "LineString" && curve === true) {
          nodeName = "Curve";
        } else {
          if (nodeName === "MultiLineString" && multiCurve === true) {
            nodeName = "MultiCurve";
          }
        }
      }
    }
  } else {
    nodeName = "Envelope";
  }
  return ol.xml.createElementNS("http://www.opengis.net/gml", nodeName);
};
ol.format.GML3.prototype.writeGeometryNode = function(geometry, opt_options) {
  opt_options = this.adaptOptions(opt_options);
  var geom = ol.xml.createElementNS("http://www.opengis.net/gml", "geom");
  var context = {node:geom, hasZ:this.hasZ, srsName:this.srsName, curve:this.curve_, surface:this.surface_, multiSurface:this.multiSurface_, multiCurve:this.multiCurve_};
  if (opt_options) {
    ol.obj.assign(context, opt_options);
  }
  this.writeGeometryElement(geom, geometry, [context]);
  return geom;
};
ol.format.GML3.prototype.writeFeatures;
ol.format.GML3.prototype.writeFeaturesNode = function(features, opt_options) {
  opt_options = this.adaptOptions(opt_options);
  var node = ol.xml.createElementNS("http://www.opengis.net/gml", "featureMembers");
  ol.xml.setAttributeNS(node, "http://www.w3.org/2001/XMLSchema-instance", "xsi:schemaLocation", this.schemaLocation);
  var context = {srsName:this.srsName, hasZ:this.hasZ, curve:this.curve_, surface:this.surface_, multiSurface:this.multiSurface_, multiCurve:this.multiCurve_, featureNS:this.featureNS, featureType:this.featureType};
  if (opt_options) {
    ol.obj.assign(context, opt_options);
  }
  this.writeFeatureMembers_(node, features, [context]);
  return node;
};
goog.provide("ol.format.GML");
goog.require("ol.format.GML3");
ol.format.GML = ol.format.GML3;
ol.format.GML.prototype.writeFeatures;
ol.format.GML.prototype.writeFeaturesNode;
goog.provide("ol.format.GML2");
goog.require("ol");
goog.require("ol.extent");
goog.require("ol.format.Feature");
goog.require("ol.format.GMLBase");
goog.require("ol.format.XSD");
goog.require("ol.geom.Geometry");
goog.require("ol.obj");
goog.require("ol.proj");
goog.require("ol.xml");
ol.format.GML2 = function(opt_options) {
  var options = opt_options ? opt_options : {};
  ol.format.GMLBase.call(this, options);
  this.FEATURE_COLLECTION_PARSERS[ol.format.GMLBase.GMLNS]["featureMember"] = ol.xml.makeArrayPusher(ol.format.GMLBase.prototype.readFeaturesInternal);
  this.schemaLocation = options.schemaLocation ? options.schemaLocation : ol.format.GML2.schemaLocation_;
};
ol.inherits(ol.format.GML2, ol.format.GMLBase);
ol.format.GML2.schemaLocation_ = ol.format.GMLBase.GMLNS + " http://schemas.opengis.net/gml/2.1.2/feature.xsd";
ol.format.GML2.prototype.readFlatCoordinates_ = function(node, objectStack) {
  var s = ol.xml.getAllTextContent(node, false).replace(/^\s*|\s*$/g, "");
  var context = objectStack[0];
  var containerSrs = context["srsName"];
  var axisOrientation = "enu";
  if (containerSrs) {
    var proj = ol.proj.get(containerSrs);
    if (proj) {
      axisOrientation = proj.getAxisOrientation();
    }
  }
  var coordsGroups = s.trim().split(/\s+/);
  var x, y, z;
  var flatCoordinates = [];
  for (var i = 0, ii = coordsGroups.length; i < ii; i++) {
    var coords = coordsGroups[i].split(/,+/);
    x = parseFloat(coords[0]);
    y = parseFloat(coords[1]);
    z = coords.length === 3 ? parseFloat(coords[2]) : 0;
    if (axisOrientation.substr(0, 2) === "en") {
      flatCoordinates.push(x, y, z);
    } else {
      flatCoordinates.push(y, x, z);
    }
  }
  return flatCoordinates;
};
ol.format.GML2.prototype.readBox_ = function(node, objectStack) {
  var flatCoordinates = ol.xml.pushParseAndPop([null], this.BOX_PARSERS_, node, objectStack, this);
  return ol.extent.createOrUpdate(flatCoordinates[1][0], flatCoordinates[1][1], flatCoordinates[1][3], flatCoordinates[1][4]);
};
ol.format.GML2.prototype.innerBoundaryIsParser_ = function(node, objectStack) {
  var flatLinearRing = ol.xml.pushParseAndPop(undefined, this.RING_PARSERS, node, objectStack, this);
  if (flatLinearRing) {
    var flatLinearRings = objectStack[objectStack.length - 1];
    flatLinearRings.push(flatLinearRing);
  }
};
ol.format.GML2.prototype.outerBoundaryIsParser_ = function(node, objectStack) {
  var flatLinearRing = ol.xml.pushParseAndPop(undefined, this.RING_PARSERS, node, objectStack, this);
  if (flatLinearRing) {
    var flatLinearRings = objectStack[objectStack.length - 1];
    flatLinearRings[0] = flatLinearRing;
  }
};
ol.format.GML2.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS_ = {"http://www.opengis.net/gml":{"coordinates":ol.xml.makeReplacer(ol.format.GML2.prototype.readFlatCoordinates_)}};
ol.format.GML2.prototype.FLAT_LINEAR_RINGS_PARSERS_ = {"http://www.opengis.net/gml":{"innerBoundaryIs":ol.format.GML2.prototype.innerBoundaryIsParser_, "outerBoundaryIs":ol.format.GML2.prototype.outerBoundaryIsParser_}};
ol.format.GML2.prototype.BOX_PARSERS_ = {"http://www.opengis.net/gml":{"coordinates":ol.xml.makeArrayPusher(ol.format.GML2.prototype.readFlatCoordinates_)}};
ol.format.GML2.prototype.GEOMETRY_PARSERS_ = {"http://www.opengis.net/gml":{"Point":ol.xml.makeReplacer(ol.format.GMLBase.prototype.readPoint), "MultiPoint":ol.xml.makeReplacer(ol.format.GMLBase.prototype.readMultiPoint), "LineString":ol.xml.makeReplacer(ol.format.GMLBase.prototype.readLineString), "MultiLineString":ol.xml.makeReplacer(ol.format.GMLBase.prototype.readMultiLineString), "LinearRing":ol.xml.makeReplacer(ol.format.GMLBase.prototype.readLinearRing), "Polygon":ol.xml.makeReplacer(ol.format.GMLBase.prototype.readPolygon), 
"MultiPolygon":ol.xml.makeReplacer(ol.format.GMLBase.prototype.readMultiPolygon), "Box":ol.xml.makeReplacer(ol.format.GML2.prototype.readBox_)}};
ol.format.GML2.prototype.GEOMETRY_NODE_FACTORY_ = function(value, objectStack, opt_nodeName) {
  var context = objectStack[objectStack.length - 1];
  var multiSurface = context["multiSurface"];
  var surface = context["surface"];
  var multiCurve = context["multiCurve"];
  var nodeName;
  if (!Array.isArray(value)) {
    nodeName = value.getType();
    if (nodeName === "MultiPolygon" && multiSurface === true) {
      nodeName = "MultiSurface";
    } else {
      if (nodeName === "Polygon" && surface === true) {
        nodeName = "Surface";
      } else {
        if (nodeName === "MultiLineString" && multiCurve === true) {
          nodeName = "MultiCurve";
        }
      }
    }
  } else {
    nodeName = "Envelope";
  }
  return ol.xml.createElementNS("http://www.opengis.net/gml", nodeName);
};
ol.format.GML2.prototype.writeFeatureElement = function(node, feature, objectStack) {
  var fid = feature.getId();
  if (fid) {
    node.setAttribute("fid", fid);
  }
  var context = objectStack[objectStack.length - 1];
  var featureNS = context["featureNS"];
  var geometryName = feature.getGeometryName();
  if (!context.serializers) {
    context.serializers = {};
    context.serializers[featureNS] = {};
  }
  var properties = feature.getProperties();
  var keys = [], values = [];
  for (var key in properties) {
    var value = properties[key];
    if (value !== null) {
      keys.push(key);
      values.push(value);
      if (key == geometryName || value instanceof ol.geom.Geometry) {
        if (!(key in context.serializers[featureNS])) {
          context.serializers[featureNS][key] = ol.xml.makeChildAppender(this.writeGeometryElement, this);
        }
      } else {
        if (!(key in context.serializers[featureNS])) {
          context.serializers[featureNS][key] = ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode);
        }
      }
    }
  }
  var item = ol.obj.assign({}, context);
  item.node = node;
  ol.xml.pushSerializeAndPop(item, context.serializers, ol.xml.makeSimpleNodeFactory(undefined, featureNS), values, objectStack, keys);
};
ol.format.GML2.prototype.writeGeometryElement = function(node, geometry, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var item = ol.obj.assign({}, context);
  item.node = node;
  var value;
  if (Array.isArray(geometry)) {
    if (context.dataProjection) {
      value = ol.proj.transformExtent(geometry, context.featureProjection, context.dataProjection);
    } else {
      value = geometry;
    }
  } else {
    value = ol.format.Feature.transformWithOptions(geometry, true, context);
  }
  ol.xml.pushSerializeAndPop(item, ol.format.GML2.GEOMETRY_SERIALIZERS_, this.GEOMETRY_NODE_FACTORY_, [value], objectStack, undefined, this);
};
ol.format.GML2.prototype.writeCurveOrLineString_ = function(node, geometry, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var srsName = context["srsName"];
  if (node.nodeName !== "LineStringSegment" && srsName) {
    node.setAttribute("srsName", srsName);
  }
  if (node.nodeName === "LineString" || node.nodeName === "LineStringSegment") {
    var coordinates = this.createCoordinatesNode_(node.namespaceURI);
    node.appendChild(coordinates);
    this.writeCoordinates_(coordinates, geometry, objectStack);
  } else {
    if (node.nodeName === "Curve") {
      var segments = ol.xml.createElementNS(node.namespaceURI, "segments");
      node.appendChild(segments);
      this.writeCurveSegments_(segments, geometry, objectStack);
    }
  }
};
ol.format.GML2.prototype.createCoordinatesNode_ = function(namespaceURI) {
  var coordinates = ol.xml.createElementNS(namespaceURI, "coordinates");
  coordinates.setAttribute("decimal", ".");
  coordinates.setAttribute("cs", ",");
  coordinates.setAttribute("ts", " ");
  return coordinates;
};
ol.format.GML2.prototype.writeCoordinates_ = function(node, value, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var hasZ = context["hasZ"];
  var srsName = context["srsName"];
  var points = value.getCoordinates();
  var len = points.length;
  var parts = new Array(len);
  var point;
  for (var i = 0; i < len; ++i) {
    point = points[i];
    parts[i] = this.getCoords_(point, srsName, hasZ);
  }
  ol.format.XSD.writeStringTextNode(node, parts.join(" "));
};
ol.format.GML2.prototype.writeCurveSegments_ = function(node, line, objectStack) {
  var child = ol.xml.createElementNS(node.namespaceURI, "LineStringSegment");
  node.appendChild(child);
  this.writeCurveOrLineString_(child, line, objectStack);
};
ol.format.GML2.prototype.writeSurfaceOrPolygon_ = function(node, geometry, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var hasZ = context["hasZ"];
  var srsName = context["srsName"];
  if (node.nodeName !== "PolygonPatch" && srsName) {
    node.setAttribute("srsName", srsName);
  }
  if (node.nodeName === "Polygon" || node.nodeName === "PolygonPatch") {
    var rings = geometry.getLinearRings();
    ol.xml.pushSerializeAndPop({node:node, hasZ:hasZ, srsName:srsName}, ol.format.GML2.RING_SERIALIZERS_, this.RING_NODE_FACTORY_, rings, objectStack, undefined, this);
  } else {
    if (node.nodeName === "Surface") {
      var patches = ol.xml.createElementNS(node.namespaceURI, "patches");
      node.appendChild(patches);
      this.writeSurfacePatches_(patches, geometry, objectStack);
    }
  }
};
ol.format.GML2.prototype.RING_NODE_FACTORY_ = function(value, objectStack, opt_nodeName) {
  var context = objectStack[objectStack.length - 1];
  var parentNode = context.node;
  var exteriorWritten = context["exteriorWritten"];
  if (exteriorWritten === undefined) {
    context["exteriorWritten"] = true;
  }
  return ol.xml.createElementNS(parentNode.namespaceURI, exteriorWritten !== undefined ? "innerBoundaryIs" : "outerBoundaryIs");
};
ol.format.GML2.prototype.writeSurfacePatches_ = function(node, polygon, objectStack) {
  var child = ol.xml.createElementNS(node.namespaceURI, "PolygonPatch");
  node.appendChild(child);
  this.writeSurfaceOrPolygon_(child, polygon, objectStack);
};
ol.format.GML2.prototype.writeRing_ = function(node, ring, objectStack) {
  var linearRing = ol.xml.createElementNS(node.namespaceURI, "LinearRing");
  node.appendChild(linearRing);
  this.writeLinearRing_(linearRing, ring, objectStack);
};
ol.format.GML2.prototype.getCoords_ = function(point, opt_srsName, opt_hasZ) {
  var axisOrientation = "enu";
  if (opt_srsName) {
    axisOrientation = ol.proj.get(opt_srsName).getAxisOrientation();
  }
  var coords = axisOrientation.substr(0, 2) === "en" ? point[0] + "," + point[1] : point[1] + "," + point[0];
  if (opt_hasZ) {
    var z = point[2] || 0;
    coords += "," + z;
  }
  return coords;
};
ol.format.GML2.prototype.writeMultiCurveOrLineString_ = function(node, geometry, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var hasZ = context["hasZ"];
  var srsName = context["srsName"];
  var curve = context["curve"];
  if (srsName) {
    node.setAttribute("srsName", srsName);
  }
  var lines = geometry.getLineStrings();
  ol.xml.pushSerializeAndPop({node:node, hasZ:hasZ, srsName:srsName, curve:curve}, ol.format.GML2.LINESTRINGORCURVEMEMBER_SERIALIZERS_, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, lines, objectStack, undefined, this);
};
ol.format.GML2.prototype.writePoint_ = function(node, geometry, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var hasZ = context["hasZ"];
  var srsName = context["srsName"];
  if (srsName) {
    node.setAttribute("srsName", srsName);
  }
  var coordinates = this.createCoordinatesNode_(node.namespaceURI);
  node.appendChild(coordinates);
  var point = geometry.getCoordinates();
  var coord = this.getCoords_(point, srsName, hasZ);
  ol.format.XSD.writeStringTextNode(coordinates, coord);
};
ol.format.GML2.prototype.writeMultiPoint_ = function(node, geometry, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var hasZ = context["hasZ"];
  var srsName = context["srsName"];
  if (srsName) {
    node.setAttribute("srsName", srsName);
  }
  var points = geometry.getPoints();
  ol.xml.pushSerializeAndPop({node:node, hasZ:hasZ, srsName:srsName}, ol.format.GML2.POINTMEMBER_SERIALIZERS_, ol.xml.makeSimpleNodeFactory("pointMember"), points, objectStack, undefined, this);
};
ol.format.GML2.prototype.writePointMember_ = function(node, point, objectStack) {
  var child = ol.xml.createElementNS(node.namespaceURI, "Point");
  node.appendChild(child);
  this.writePoint_(child, point, objectStack);
};
ol.format.GML2.prototype.writeLineStringOrCurveMember_ = function(node, line, objectStack) {
  var child = this.GEOMETRY_NODE_FACTORY_(line, objectStack);
  if (child) {
    node.appendChild(child);
    this.writeCurveOrLineString_(child, line, objectStack);
  }
};
ol.format.GML2.prototype.writeLinearRing_ = function(node, geometry, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var srsName = context["srsName"];
  if (srsName) {
    node.setAttribute("srsName", srsName);
  }
  var coordinates = this.createCoordinatesNode_(node.namespaceURI);
  node.appendChild(coordinates);
  this.writeCoordinates_(coordinates, geometry, objectStack);
};
ol.format.GML2.prototype.writeMultiSurfaceOrPolygon_ = function(node, geometry, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var hasZ = context["hasZ"];
  var srsName = context["srsName"];
  var surface = context["surface"];
  if (srsName) {
    node.setAttribute("srsName", srsName);
  }
  var polygons = geometry.getPolygons();
  ol.xml.pushSerializeAndPop({node:node, hasZ:hasZ, srsName:srsName, surface:surface}, ol.format.GML2.SURFACEORPOLYGONMEMBER_SERIALIZERS_, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, polygons, objectStack, undefined, this);
};
ol.format.GML2.prototype.writeSurfaceOrPolygonMember_ = function(node, polygon, objectStack) {
  var child = this.GEOMETRY_NODE_FACTORY_(polygon, objectStack);
  if (child) {
    node.appendChild(child);
    this.writeSurfaceOrPolygon_(child, polygon, objectStack);
  }
};
ol.format.GML2.prototype.writeEnvelope = function(node, extent, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var srsName = context["srsName"];
  if (srsName) {
    node.setAttribute("srsName", srsName);
  }
  var keys = ["lowerCorner", "upperCorner"];
  var values = [extent[0] + " " + extent[1], extent[2] + " " + extent[3]];
  ol.xml.pushSerializeAndPop({node:node}, ol.format.GML2.ENVELOPE_SERIALIZERS_, ol.xml.OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, keys, this);
};
ol.format.GML2.GEOMETRY_SERIALIZERS_ = {"http://www.opengis.net/gml":{"Curve":ol.xml.makeChildAppender(ol.format.GML2.prototype.writeCurveOrLineString_), "MultiCurve":ol.xml.makeChildAppender(ol.format.GML2.prototype.writeMultiCurveOrLineString_), "Point":ol.xml.makeChildAppender(ol.format.GML2.prototype.writePoint_), "MultiPoint":ol.xml.makeChildAppender(ol.format.GML2.prototype.writeMultiPoint_), "LineString":ol.xml.makeChildAppender(ol.format.GML2.prototype.writeCurveOrLineString_), "MultiLineString":ol.xml.makeChildAppender(ol.format.GML2.prototype.writeMultiCurveOrLineString_), 
"LinearRing":ol.xml.makeChildAppender(ol.format.GML2.prototype.writeLinearRing_), "Polygon":ol.xml.makeChildAppender(ol.format.GML2.prototype.writeSurfaceOrPolygon_), "MultiPolygon":ol.xml.makeChildAppender(ol.format.GML2.prototype.writeMultiSurfaceOrPolygon_), "Surface":ol.xml.makeChildAppender(ol.format.GML2.prototype.writeSurfaceOrPolygon_), "MultiSurface":ol.xml.makeChildAppender(ol.format.GML2.prototype.writeMultiSurfaceOrPolygon_), "Envelope":ol.xml.makeChildAppender(ol.format.GML2.prototype.writeEnvelope)}};
ol.format.GML2.RING_SERIALIZERS_ = {"http://www.opengis.net/gml":{"outerBoundaryIs":ol.xml.makeChildAppender(ol.format.GML2.prototype.writeRing_), "innerBoundaryIs":ol.xml.makeChildAppender(ol.format.GML2.prototype.writeRing_)}};
ol.format.GML2.POINTMEMBER_SERIALIZERS_ = {"http://www.opengis.net/gml":{"pointMember":ol.xml.makeChildAppender(ol.format.GML2.prototype.writePointMember_)}};
ol.format.GML2.LINESTRINGORCURVEMEMBER_SERIALIZERS_ = {"http://www.opengis.net/gml":{"lineStringMember":ol.xml.makeChildAppender(ol.format.GML2.prototype.writeLineStringOrCurveMember_), "curveMember":ol.xml.makeChildAppender(ol.format.GML2.prototype.writeLineStringOrCurveMember_)}};
ol.format.GML2.prototype.MULTIGEOMETRY_MEMBER_NODE_FACTORY_ = function(value, objectStack, opt_nodeName) {
  var parentNode = objectStack[objectStack.length - 1].node;
  return ol.xml.createElementNS("http://www.opengis.net/gml", ol.format.GML2.MULTIGEOMETRY_TO_MEMBER_NODENAME_[parentNode.nodeName]);
};
ol.format.GML2.MULTIGEOMETRY_TO_MEMBER_NODENAME_ = {"MultiLineString":"lineStringMember", "MultiCurve":"curveMember", "MultiPolygon":"polygonMember", "MultiSurface":"surfaceMember"};
ol.format.GML2.SURFACEORPOLYGONMEMBER_SERIALIZERS_ = {"http://www.opengis.net/gml":{"surfaceMember":ol.xml.makeChildAppender(ol.format.GML2.prototype.writeSurfaceOrPolygonMember_), "polygonMember":ol.xml.makeChildAppender(ol.format.GML2.prototype.writeSurfaceOrPolygonMember_)}};
ol.format.GML2.ENVELOPE_SERIALIZERS_ = {"http://www.opengis.net/gml":{"lowerCorner":ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode), "upperCorner":ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode)}};
goog.provide("ol.format.GPX");
goog.require("ol");
goog.require("ol.Feature");
goog.require("ol.array");
goog.require("ol.format.Feature");
goog.require("ol.format.XMLFeature");
goog.require("ol.format.XSD");
goog.require("ol.geom.GeometryLayout");
goog.require("ol.geom.LineString");
goog.require("ol.geom.MultiLineString");
goog.require("ol.geom.Point");
goog.require("ol.proj");
goog.require("ol.xml");
ol.format.GPX = function(opt_options) {
  var options = opt_options ? opt_options : {};
  ol.format.XMLFeature.call(this);
  this.defaultDataProjection = ol.proj.get("EPSG:4326");
  this.readExtensions_ = options.readExtensions;
};
ol.inherits(ol.format.GPX, ol.format.XMLFeature);
ol.format.GPX.NAMESPACE_URIS_ = [null, "http://www.topografix.com/GPX/1/0", "http://www.topografix.com/GPX/1/1"];
ol.format.GPX.SCHEMA_LOCATION_ = "http://www.topografix.com/GPX/1/1 " + "http://www.topografix.com/GPX/1/1/gpx.xsd";
ol.format.GPX.appendCoordinate_ = function(flatCoordinates, layoutOptions, node, values) {
  flatCoordinates.push(parseFloat(node.getAttribute("lon")), parseFloat(node.getAttribute("lat")));
  if ("ele" in values) {
    flatCoordinates.push(values["ele"]);
    delete values["ele"];
    layoutOptions.hasZ = true;
  } else {
    flatCoordinates.push(0);
  }
  if ("time" in values) {
    flatCoordinates.push(values["time"]);
    delete values["time"];
    layoutOptions.hasM = true;
  } else {
    flatCoordinates.push(0);
  }
  return flatCoordinates;
};
ol.format.GPX.applyLayoutOptions_ = function(layoutOptions, flatCoordinates, ends) {
  var layout = ol.geom.GeometryLayout.XY;
  var stride = 2;
  if (layoutOptions.hasZ && layoutOptions.hasM) {
    layout = ol.geom.GeometryLayout.XYZM;
    stride = 4;
  } else {
    if (layoutOptions.hasZ) {
      layout = ol.geom.GeometryLayout.XYZ;
      stride = 3;
    } else {
      if (layoutOptions.hasM) {
        layout = ol.geom.GeometryLayout.XYM;
        stride = 3;
      }
    }
  }
  if (stride !== 4) {
    var i, ii;
    for (i = 0, ii = flatCoordinates.length / 4; i < ii; i++) {
      flatCoordinates[i * stride] = flatCoordinates[i * 4];
      flatCoordinates[i * stride + 1] = flatCoordinates[i * 4 + 1];
      if (layoutOptions.hasZ) {
        flatCoordinates[i * stride + 2] = flatCoordinates[i * 4 + 2];
      }
      if (layoutOptions.hasM) {
        flatCoordinates[i * stride + 2] = flatCoordinates[i * 4 + 3];
      }
    }
    flatCoordinates.length = flatCoordinates.length / 4 * stride;
    if (ends) {
      for (i = 0, ii = ends.length; i < ii; i++) {
        ends[i] = ends[i] / 4 * stride;
      }
    }
  }
  return layout;
};
ol.format.GPX.parseLink_ = function(node, objectStack) {
  var values = objectStack[objectStack.length - 1];
  var href = node.getAttribute("href");
  if (href !== null) {
    values["link"] = href;
  }
  ol.xml.parseNode(ol.format.GPX.LINK_PARSERS_, node, objectStack);
};
ol.format.GPX.parseExtensions_ = function(node, objectStack) {
  var values = objectStack[objectStack.length - 1];
  values["extensionsNode_"] = node;
};
ol.format.GPX.parseRtePt_ = function(node, objectStack) {
  var values = ol.xml.pushParseAndPop({}, ol.format.GPX.RTEPT_PARSERS_, node, objectStack);
  if (values) {
    var rteValues = objectStack[objectStack.length - 1];
    var flatCoordinates = rteValues["flatCoordinates"];
    var layoutOptions = rteValues["layoutOptions"];
    ol.format.GPX.appendCoordinate_(flatCoordinates, layoutOptions, node, values);
  }
};
ol.format.GPX.parseTrkPt_ = function(node, objectStack) {
  var values = ol.xml.pushParseAndPop({}, ol.format.GPX.TRKPT_PARSERS_, node, objectStack);
  if (values) {
    var trkValues = objectStack[objectStack.length - 1];
    var flatCoordinates = trkValues["flatCoordinates"];
    var layoutOptions = trkValues["layoutOptions"];
    ol.format.GPX.appendCoordinate_(flatCoordinates, layoutOptions, node, values);
  }
};
ol.format.GPX.parseTrkSeg_ = function(node, objectStack) {
  var values = objectStack[objectStack.length - 1];
  ol.xml.parseNode(ol.format.GPX.TRKSEG_PARSERS_, node, objectStack);
  var flatCoordinates = values["flatCoordinates"];
  var ends = values["ends"];
  ends.push(flatCoordinates.length);
};
ol.format.GPX.readRte_ = function(node, objectStack) {
  var options = objectStack[0];
  var values = ol.xml.pushParseAndPop({"flatCoordinates":[], "layoutOptions":{}}, ol.format.GPX.RTE_PARSERS_, node, objectStack);
  if (!values) {
    return undefined;
  }
  var flatCoordinates = values["flatCoordinates"];
  delete values["flatCoordinates"];
  var layoutOptions = values["layoutOptions"];
  delete values["layoutOptions"];
  var layout = ol.format.GPX.applyLayoutOptions_(layoutOptions, flatCoordinates);
  var geometry = new ol.geom.LineString(null);
  geometry.setFlatCoordinates(layout, flatCoordinates);
  ol.format.Feature.transformWithOptions(geometry, false, options);
  var feature = new ol.Feature(geometry);
  feature.setProperties(values);
  return feature;
};
ol.format.GPX.readTrk_ = function(node, objectStack) {
  var options = objectStack[0];
  var values = ol.xml.pushParseAndPop({"flatCoordinates":[], "ends":[], "layoutOptions":{}}, ol.format.GPX.TRK_PARSERS_, node, objectStack);
  if (!values) {
    return undefined;
  }
  var flatCoordinates = values["flatCoordinates"];
  delete values["flatCoordinates"];
  var ends = values["ends"];
  delete values["ends"];
  var layoutOptions = values["layoutOptions"];
  delete values["layoutOptions"];
  var layout = ol.format.GPX.applyLayoutOptions_(layoutOptions, flatCoordinates, ends);
  var geometry = new ol.geom.MultiLineString(null);
  geometry.setFlatCoordinates(layout, flatCoordinates, ends);
  ol.format.Feature.transformWithOptions(geometry, false, options);
  var feature = new ol.Feature(geometry);
  feature.setProperties(values);
  return feature;
};
ol.format.GPX.readWpt_ = function(node, objectStack) {
  var options = objectStack[0];
  var values = ol.xml.pushParseAndPop({}, ol.format.GPX.WPT_PARSERS_, node, objectStack);
  if (!values) {
    return undefined;
  }
  var layoutOptions = {};
  var coordinates = ol.format.GPX.appendCoordinate_([], layoutOptions, node, values);
  var layout = ol.format.GPX.applyLayoutOptions_(layoutOptions, coordinates);
  var geometry = new ol.geom.Point(coordinates, layout);
  ol.format.Feature.transformWithOptions(geometry, false, options);
  var feature = new ol.Feature(geometry);
  feature.setProperties(values);
  return feature;
};
ol.format.GPX.FEATURE_READER_ = {"rte":ol.format.GPX.readRte_, "trk":ol.format.GPX.readTrk_, "wpt":ol.format.GPX.readWpt_};
ol.format.GPX.GPX_PARSERS_ = ol.xml.makeStructureNS(ol.format.GPX.NAMESPACE_URIS_, {"rte":ol.xml.makeArrayPusher(ol.format.GPX.readRte_), "trk":ol.xml.makeArrayPusher(ol.format.GPX.readTrk_), "wpt":ol.xml.makeArrayPusher(ol.format.GPX.readWpt_)});
ol.format.GPX.LINK_PARSERS_ = ol.xml.makeStructureNS(ol.format.GPX.NAMESPACE_URIS_, {"text":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString, "linkText"), "type":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString, "linkType")});
ol.format.GPX.RTE_PARSERS_ = ol.xml.makeStructureNS(ol.format.GPX.NAMESPACE_URIS_, {"name":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "cmt":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "desc":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "src":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "link":ol.format.GPX.parseLink_, "number":ol.xml.makeObjectPropertySetter(ol.format.XSD.readNonNegativeInteger), "extensions":ol.format.GPX.parseExtensions_, 
"type":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "rtept":ol.format.GPX.parseRtePt_});
ol.format.GPX.RTEPT_PARSERS_ = ol.xml.makeStructureNS(ol.format.GPX.NAMESPACE_URIS_, {"ele":ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal), "time":ol.xml.makeObjectPropertySetter(ol.format.XSD.readDateTime)});
ol.format.GPX.TRK_PARSERS_ = ol.xml.makeStructureNS(ol.format.GPX.NAMESPACE_URIS_, {"name":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "cmt":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "desc":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "src":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "link":ol.format.GPX.parseLink_, "number":ol.xml.makeObjectPropertySetter(ol.format.XSD.readNonNegativeInteger), "type":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), 
"extensions":ol.format.GPX.parseExtensions_, "trkseg":ol.format.GPX.parseTrkSeg_});
ol.format.GPX.TRKSEG_PARSERS_ = ol.xml.makeStructureNS(ol.format.GPX.NAMESPACE_URIS_, {"trkpt":ol.format.GPX.parseTrkPt_});
ol.format.GPX.TRKPT_PARSERS_ = ol.xml.makeStructureNS(ol.format.GPX.NAMESPACE_URIS_, {"ele":ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal), "time":ol.xml.makeObjectPropertySetter(ol.format.XSD.readDateTime)});
ol.format.GPX.WPT_PARSERS_ = ol.xml.makeStructureNS(ol.format.GPX.NAMESPACE_URIS_, {"ele":ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal), "time":ol.xml.makeObjectPropertySetter(ol.format.XSD.readDateTime), "magvar":ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal), "geoidheight":ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal), "name":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "cmt":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "desc":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), 
"src":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "link":ol.format.GPX.parseLink_, "sym":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "type":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "fix":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "sat":ol.xml.makeObjectPropertySetter(ol.format.XSD.readNonNegativeInteger), "hdop":ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal), "vdop":ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal), 
"pdop":ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal), "ageofdgpsdata":ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal), "dgpsid":ol.xml.makeObjectPropertySetter(ol.format.XSD.readNonNegativeInteger), "extensions":ol.format.GPX.parseExtensions_});
ol.format.GPX.prototype.handleReadExtensions_ = function(features) {
  if (!features) {
    features = [];
  }
  for (var i = 0, ii = features.length; i < ii; ++i) {
    var feature = features[i];
    if (this.readExtensions_) {
      var extensionsNode = feature.get("extensionsNode_") || null;
      this.readExtensions_(feature, extensionsNode);
    }
    feature.set("extensionsNode_", undefined);
  }
};
ol.format.GPX.prototype.readFeature;
ol.format.GPX.prototype.readFeatureFromNode = function(node, opt_options) {
  if (!ol.array.includes(ol.format.GPX.NAMESPACE_URIS_, node.namespaceURI)) {
    return null;
  }
  var featureReader = ol.format.GPX.FEATURE_READER_[node.localName];
  if (!featureReader) {
    return null;
  }
  var feature = featureReader(node, [this.getReadOptions(node, opt_options)]);
  if (!feature) {
    return null;
  }
  this.handleReadExtensions_([feature]);
  return feature;
};
ol.format.GPX.prototype.readFeatures;
ol.format.GPX.prototype.readFeaturesFromNode = function(node, opt_options) {
  if (!ol.array.includes(ol.format.GPX.NAMESPACE_URIS_, node.namespaceURI)) {
    return [];
  }
  if (node.localName == "gpx") {
    var features = ol.xml.pushParseAndPop([], ol.format.GPX.GPX_PARSERS_, node, [this.getReadOptions(node, opt_options)]);
    if (features) {
      this.handleReadExtensions_(features);
      return features;
    } else {
      return [];
    }
  }
  return [];
};
ol.format.GPX.prototype.readProjection;
ol.format.GPX.writeLink_ = function(node, value, objectStack) {
  node.setAttribute("href", value);
  var context = objectStack[objectStack.length - 1];
  var properties = context["properties"];
  var link = [properties["linkText"], properties["linkType"]];
  ol.xml.pushSerializeAndPop({node:node}, ol.format.GPX.LINK_SERIALIZERS_, ol.xml.OBJECT_PROPERTY_NODE_FACTORY, link, objectStack, ol.format.GPX.LINK_SEQUENCE_);
};
ol.format.GPX.writeWptType_ = function(node, coordinate, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var parentNode = context.node;
  var namespaceURI = parentNode.namespaceURI;
  var properties = context["properties"];
  ol.xml.setAttributeNS(node, null, "lat", coordinate[1]);
  ol.xml.setAttributeNS(node, null, "lon", coordinate[0]);
  var geometryLayout = context["geometryLayout"];
  switch(geometryLayout) {
    case ol.geom.GeometryLayout.XYZM:
      if (coordinate[3] !== 0) {
        properties["time"] = coordinate[3];
      }
    case ol.geom.GeometryLayout.XYZ:
      if (coordinate[2] !== 0) {
        properties["ele"] = coordinate[2];
      }
      break;
    case ol.geom.GeometryLayout.XYM:
      if (coordinate[2] !== 0) {
        properties["time"] = coordinate[2];
      }
      break;
    default:
  }
  var orderedKeys = node.nodeName == "rtept" ? ol.format.GPX.RTEPT_TYPE_SEQUENCE_[namespaceURI] : ol.format.GPX.WPT_TYPE_SEQUENCE_[namespaceURI];
  var values = ol.xml.makeSequence(properties, orderedKeys);
  ol.xml.pushSerializeAndPop({node:node, "properties":properties}, ol.format.GPX.WPT_TYPE_SERIALIZERS_, ol.xml.OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
};
ol.format.GPX.writeRte_ = function(node, feature, objectStack) {
  var options = objectStack[0];
  var properties = feature.getProperties();
  var context = {node:node, "properties":properties};
  var geometry = feature.getGeometry();
  if (geometry) {
    geometry = ol.format.Feature.transformWithOptions(geometry, true, options);
    context["geometryLayout"] = geometry.getLayout();
    properties["rtept"] = geometry.getCoordinates();
  }
  var parentNode = objectStack[objectStack.length - 1].node;
  var orderedKeys = ol.format.GPX.RTE_SEQUENCE_[parentNode.namespaceURI];
  var values = ol.xml.makeSequence(properties, orderedKeys);
  ol.xml.pushSerializeAndPop(context, ol.format.GPX.RTE_SERIALIZERS_, ol.xml.OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
};
ol.format.GPX.writeTrk_ = function(node, feature, objectStack) {
  var options = objectStack[0];
  var properties = feature.getProperties();
  var context = {node:node, "properties":properties};
  var geometry = feature.getGeometry();
  if (geometry) {
    geometry = ol.format.Feature.transformWithOptions(geometry, true, options);
    properties["trkseg"] = geometry.getLineStrings();
  }
  var parentNode = objectStack[objectStack.length - 1].node;
  var orderedKeys = ol.format.GPX.TRK_SEQUENCE_[parentNode.namespaceURI];
  var values = ol.xml.makeSequence(properties, orderedKeys);
  ol.xml.pushSerializeAndPop(context, ol.format.GPX.TRK_SERIALIZERS_, ol.xml.OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
};
ol.format.GPX.writeTrkSeg_ = function(node, lineString, objectStack) {
  var context = {node:node, "geometryLayout":lineString.getLayout(), "properties":{}};
  ol.xml.pushSerializeAndPop(context, ol.format.GPX.TRKSEG_SERIALIZERS_, ol.format.GPX.TRKSEG_NODE_FACTORY_, lineString.getCoordinates(), objectStack);
};
ol.format.GPX.writeWpt_ = function(node, feature, objectStack) {
  var options = objectStack[0];
  var context = objectStack[objectStack.length - 1];
  context["properties"] = feature.getProperties();
  var geometry = feature.getGeometry();
  if (geometry) {
    geometry = ol.format.Feature.transformWithOptions(geometry, true, options);
    context["geometryLayout"] = geometry.getLayout();
    ol.format.GPX.writeWptType_(node, geometry.getCoordinates(), objectStack);
  }
};
ol.format.GPX.LINK_SEQUENCE_ = ["text", "type"];
ol.format.GPX.LINK_SERIALIZERS_ = ol.xml.makeStructureNS(ol.format.GPX.NAMESPACE_URIS_, {"text":ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode), "type":ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode)});
ol.format.GPX.RTE_SEQUENCE_ = ol.xml.makeStructureNS(ol.format.GPX.NAMESPACE_URIS_, ["name", "cmt", "desc", "src", "link", "number", "type", "rtept"]);
ol.format.GPX.RTE_SERIALIZERS_ = ol.xml.makeStructureNS(ol.format.GPX.NAMESPACE_URIS_, {"name":ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode), "cmt":ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode), "desc":ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode), "src":ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode), "link":ol.xml.makeChildAppender(ol.format.GPX.writeLink_), "number":ol.xml.makeChildAppender(ol.format.XSD.writeNonNegativeIntegerTextNode), "type":ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode), 
"rtept":ol.xml.makeArraySerializer(ol.xml.makeChildAppender(ol.format.GPX.writeWptType_))});
ol.format.GPX.RTEPT_TYPE_SEQUENCE_ = ol.xml.makeStructureNS(ol.format.GPX.NAMESPACE_URIS_, ["ele", "time"]);
ol.format.GPX.TRK_SEQUENCE_ = ol.xml.makeStructureNS(ol.format.GPX.NAMESPACE_URIS_, ["name", "cmt", "desc", "src", "link", "number", "type", "trkseg"]);
ol.format.GPX.TRK_SERIALIZERS_ = ol.xml.makeStructureNS(ol.format.GPX.NAMESPACE_URIS_, {"name":ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode), "cmt":ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode), "desc":ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode), "src":ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode), "link":ol.xml.makeChildAppender(ol.format.GPX.writeLink_), "number":ol.xml.makeChildAppender(ol.format.XSD.writeNonNegativeIntegerTextNode), "type":ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode), 
"trkseg":ol.xml.makeArraySerializer(ol.xml.makeChildAppender(ol.format.GPX.writeTrkSeg_))});
ol.format.GPX.TRKSEG_NODE_FACTORY_ = ol.xml.makeSimpleNodeFactory("trkpt");
ol.format.GPX.TRKSEG_SERIALIZERS_ = ol.xml.makeStructureNS(ol.format.GPX.NAMESPACE_URIS_, {"trkpt":ol.xml.makeChildAppender(ol.format.GPX.writeWptType_)});
ol.format.GPX.WPT_TYPE_SEQUENCE_ = ol.xml.makeStructureNS(ol.format.GPX.NAMESPACE_URIS_, ["ele", "time", "magvar", "geoidheight", "name", "cmt", "desc", "src", "link", "sym", "type", "fix", "sat", "hdop", "vdop", "pdop", "ageofdgpsdata", "dgpsid"]);
ol.format.GPX.WPT_TYPE_SERIALIZERS_ = ol.xml.makeStructureNS(ol.format.GPX.NAMESPACE_URIS_, {"ele":ol.xml.makeChildAppender(ol.format.XSD.writeDecimalTextNode), "time":ol.xml.makeChildAppender(ol.format.XSD.writeDateTimeTextNode), "magvar":ol.xml.makeChildAppender(ol.format.XSD.writeDecimalTextNode), "geoidheight":ol.xml.makeChildAppender(ol.format.XSD.writeDecimalTextNode), "name":ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode), "cmt":ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode), 
"desc":ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode), "src":ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode), "link":ol.xml.makeChildAppender(ol.format.GPX.writeLink_), "sym":ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode), "type":ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode), "fix":ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode), "sat":ol.xml.makeChildAppender(ol.format.XSD.writeNonNegativeIntegerTextNode), "hdop":ol.xml.makeChildAppender(ol.format.XSD.writeDecimalTextNode), 
"vdop":ol.xml.makeChildAppender(ol.format.XSD.writeDecimalTextNode), "pdop":ol.xml.makeChildAppender(ol.format.XSD.writeDecimalTextNode), "ageofdgpsdata":ol.xml.makeChildAppender(ol.format.XSD.writeDecimalTextNode), "dgpsid":ol.xml.makeChildAppender(ol.format.XSD.writeNonNegativeIntegerTextNode)});
ol.format.GPX.GEOMETRY_TYPE_TO_NODENAME_ = {"Point":"wpt", "LineString":"rte", "MultiLineString":"trk"};
ol.format.GPX.GPX_NODE_FACTORY_ = function(value, objectStack, opt_nodeName) {
  var geometry = value.getGeometry();
  if (geometry) {
    var nodeName = ol.format.GPX.GEOMETRY_TYPE_TO_NODENAME_[geometry.getType()];
    if (nodeName) {
      var parentNode = objectStack[objectStack.length - 1].node;
      return ol.xml.createElementNS(parentNode.namespaceURI, nodeName);
    }
  }
};
ol.format.GPX.GPX_SERIALIZERS_ = ol.xml.makeStructureNS(ol.format.GPX.NAMESPACE_URIS_, {"rte":ol.xml.makeChildAppender(ol.format.GPX.writeRte_), "trk":ol.xml.makeChildAppender(ol.format.GPX.writeTrk_), "wpt":ol.xml.makeChildAppender(ol.format.GPX.writeWpt_)});
ol.format.GPX.prototype.writeFeatures;
ol.format.GPX.prototype.writeFeaturesNode = function(features, opt_options) {
  opt_options = this.adaptOptions(opt_options);
  var gpx = ol.xml.createElementNS("http://www.topografix.com/GPX/1/1", "gpx");
  var xmlnsUri = "http://www.w3.org/2000/xmlns/";
  var xmlSchemaInstanceUri = "http://www.w3.org/2001/XMLSchema-instance";
  ol.xml.setAttributeNS(gpx, xmlnsUri, "xmlns:xsi", xmlSchemaInstanceUri);
  ol.xml.setAttributeNS(gpx, xmlSchemaInstanceUri, "xsi:schemaLocation", ol.format.GPX.SCHEMA_LOCATION_);
  gpx.setAttribute("version", "1.1");
  gpx.setAttribute("creator", "OpenLayers");
  ol.xml.pushSerializeAndPop({node:gpx}, ol.format.GPX.GPX_SERIALIZERS_, ol.format.GPX.GPX_NODE_FACTORY_, features, [opt_options]);
  return gpx;
};
goog.provide("ol.format.IGCZ");
ol.format.IGCZ = {BAROMETRIC:"barometric", GPS:"gps", NONE:"none"};
goog.provide("ol.format.TextFeature");
goog.require("ol");
goog.require("ol.format.Feature");
goog.require("ol.format.FormatType");
ol.format.TextFeature = function() {
  ol.format.Feature.call(this);
};
ol.inherits(ol.format.TextFeature, ol.format.Feature);
ol.format.TextFeature.prototype.getText_ = function(source) {
  if (typeof source === "string") {
    return source;
  } else {
    return "";
  }
};
ol.format.TextFeature.prototype.getType = function() {
  return ol.format.FormatType.TEXT;
};
ol.format.TextFeature.prototype.readFeature = function(source, opt_options) {
  return this.readFeatureFromText(this.getText_(source), this.adaptOptions(opt_options));
};
ol.format.TextFeature.prototype.readFeatureFromText = function(text, opt_options) {
};
ol.format.TextFeature.prototype.readFeatures = function(source, opt_options) {
  return this.readFeaturesFromText(this.getText_(source), this.adaptOptions(opt_options));
};
ol.format.TextFeature.prototype.readFeaturesFromText = function(text, opt_options) {
};
ol.format.TextFeature.prototype.readGeometry = function(source, opt_options) {
  return this.readGeometryFromText(this.getText_(source), this.adaptOptions(opt_options));
};
ol.format.TextFeature.prototype.readGeometryFromText = function(text, opt_options) {
};
ol.format.TextFeature.prototype.readProjection = function(source) {
  return this.readProjectionFromText(this.getText_(source));
};
ol.format.TextFeature.prototype.readProjectionFromText = function(text) {
  return this.defaultDataProjection;
};
ol.format.TextFeature.prototype.writeFeature = function(feature, opt_options) {
  return this.writeFeatureText(feature, this.adaptOptions(opt_options));
};
ol.format.TextFeature.prototype.writeFeatureText = function(feature, opt_options) {
};
ol.format.TextFeature.prototype.writeFeatures = function(features, opt_options) {
  return this.writeFeaturesText(features, this.adaptOptions(opt_options));
};
ol.format.TextFeature.prototype.writeFeaturesText = function(features, opt_options) {
};
ol.format.TextFeature.prototype.writeGeometry = function(geometry, opt_options) {
  return this.writeGeometryText(geometry, this.adaptOptions(opt_options));
};
ol.format.TextFeature.prototype.writeGeometryText = function(geometry, opt_options) {
};
goog.provide("ol.format.IGC");
goog.require("ol");
goog.require("ol.Feature");
goog.require("ol.format.Feature");
goog.require("ol.format.IGCZ");
goog.require("ol.format.TextFeature");
goog.require("ol.geom.GeometryLayout");
goog.require("ol.geom.LineString");
goog.require("ol.proj");
ol.format.IGC = function(opt_options) {
  var options = opt_options ? opt_options : {};
  ol.format.TextFeature.call(this);
  this.defaultDataProjection = ol.proj.get("EPSG:4326");
  this.altitudeMode_ = options.altitudeMode ? options.altitudeMode : ol.format.IGCZ.NONE;
};
ol.inherits(ol.format.IGC, ol.format.TextFeature);
ol.format.IGC.B_RECORD_RE_ = /^B(\d{2})(\d{2})(\d{2})(\d{2})(\d{5})([NS])(\d{3})(\d{5})([EW])([AV])(\d{5})(\d{5})/;
ol.format.IGC.H_RECORD_RE_ = /^H.([A-Z]{3}).*?:(.*)/;
ol.format.IGC.HFDTE_RECORD_RE_ = /^HFDTE(\d{2})(\d{2})(\d{2})/;
ol.format.IGC.NEWLINE_RE_ = /\r\n|\r|\n/;
ol.format.IGC.prototype.readFeature;
ol.format.IGC.prototype.readFeatureFromText = function(text, opt_options) {
  var altitudeMode = this.altitudeMode_;
  var lines = text.split(ol.format.IGC.NEWLINE_RE_);
  var properties = {};
  var flatCoordinates = [];
  var year = 2000;
  var month = 0;
  var day = 1;
  var lastDateTime = -1;
  var i, ii;
  for (i = 0, ii = lines.length; i < ii; ++i) {
    var line = lines[i];
    var m;
    if (line.charAt(0) == "B") {
      m = ol.format.IGC.B_RECORD_RE_.exec(line);
      if (m) {
        var hour = parseInt(m[1], 10);
        var minute = parseInt(m[2], 10);
        var second = parseInt(m[3], 10);
        var y = parseInt(m[4], 10) + parseInt(m[5], 10) / 60000;
        if (m[6] == "S") {
          y = -y;
        }
        var x = parseInt(m[7], 10) + parseInt(m[8], 10) / 60000;
        if (m[9] == "W") {
          x = -x;
        }
        flatCoordinates.push(x, y);
        if (altitudeMode != ol.format.IGCZ.NONE) {
          var z;
          if (altitudeMode == ol.format.IGCZ.GPS) {
            z = parseInt(m[11], 10);
          } else {
            if (altitudeMode == ol.format.IGCZ.BAROMETRIC) {
              z = parseInt(m[12], 10);
            } else {
              z = 0;
            }
          }
          flatCoordinates.push(z);
        }
        var dateTime = Date.UTC(year, month, day, hour, minute, second);
        if (dateTime < lastDateTime) {
          dateTime = Date.UTC(year, month, day + 1, hour, minute, second);
        }
        flatCoordinates.push(dateTime / 1000);
        lastDateTime = dateTime;
      }
    } else {
      if (line.charAt(0) == "H") {
        m = ol.format.IGC.HFDTE_RECORD_RE_.exec(line);
        if (m) {
          day = parseInt(m[1], 10);
          month = parseInt(m[2], 10) - 1;
          year = 2000 + parseInt(m[3], 10);
        } else {
          m = ol.format.IGC.H_RECORD_RE_.exec(line);
          if (m) {
            properties[m[1]] = m[2].trim();
          }
        }
      }
    }
  }
  if (flatCoordinates.length === 0) {
    return null;
  }
  var lineString = new ol.geom.LineString(null);
  var layout = altitudeMode == ol.format.IGCZ.NONE ? ol.geom.GeometryLayout.XYM : ol.geom.GeometryLayout.XYZM;
  lineString.setFlatCoordinates(layout, flatCoordinates);
  var feature = new ol.Feature(ol.format.Feature.transformWithOptions(lineString, false, opt_options));
  feature.setProperties(properties);
  return feature;
};
ol.format.IGC.prototype.readFeatures;
ol.format.IGC.prototype.readFeaturesFromText = function(text, opt_options) {
  var feature = this.readFeatureFromText(text, opt_options);
  if (feature) {
    return [feature];
  } else {
    return [];
  }
};
ol.format.IGC.prototype.readProjection;
ol.format.IGC.prototype.writeFeatureText = function(feature, opt_options) {
};
ol.format.IGC.prototype.writeFeaturesText = function(features, opt_options) {
};
ol.format.IGC.prototype.writeGeometryText = function(geometry, opt_options) {
};
ol.format.IGC.prototype.readGeometryFromText = function(text, opt_options) {
};
goog.provide("ol.style.Text");
goog.require("ol.style.Fill");
goog.require("ol.style.TextPlacement");
ol.style.Text = function(opt_options) {
  var options = opt_options || {};
  this.font_ = options.font;
  this.rotation_ = options.rotation;
  this.rotateWithView_ = options.rotateWithView;
  this.scale_ = options.scale;
  this.text_ = options.text;
  this.textAlign_ = options.textAlign;
  this.textBaseline_ = options.textBaseline;
  this.fill_ = options.fill !== undefined ? options.fill : new ol.style.Fill({color:ol.style.Text.DEFAULT_FILL_COLOR_});
  this.maxAngle_ = options.maxAngle !== undefined ? options.maxAngle : Math.PI / 4;
  this.placement_ = options.placement !== undefined ? options.placement : ol.style.TextPlacement.POINT;
  var overflow = options.overflow === undefined ? options.exceedLength : options.overflow;
  this.overflow_ = overflow !== undefined ? overflow : false;
  this.stroke_ = options.stroke !== undefined ? options.stroke : null;
  this.offsetX_ = options.offsetX !== undefined ? options.offsetX : 0;
  this.offsetY_ = options.offsetY !== undefined ? options.offsetY : 0;
  this.backgroundFill_ = options.backgroundFill ? options.backgroundFill : null;
  this.backgroundStroke_ = options.backgroundStroke ? options.backgroundStroke : null;
  this.padding_ = options.padding === undefined ? null : options.padding;
};
ol.style.Text.DEFAULT_FILL_COLOR_ = "#333";
ol.style.Text.prototype.clone = function() {
  return new ol.style.Text({font:this.getFont(), placement:this.getPlacement(), maxAngle:this.getMaxAngle(), overflow:this.getOverflow(), rotation:this.getRotation(), rotateWithView:this.getRotateWithView(), scale:this.getScale(), text:this.getText(), textAlign:this.getTextAlign(), textBaseline:this.getTextBaseline(), fill:this.getFill() ? this.getFill().clone() : undefined, stroke:this.getStroke() ? this.getStroke().clone() : undefined, offsetX:this.getOffsetX(), offsetY:this.getOffsetY()});
};
ol.style.Text.prototype.getOverflow = function() {
  return this.overflow_;
};
ol.style.Text.prototype.getFont = function() {
  return this.font_;
};
ol.style.Text.prototype.getMaxAngle = function() {
  return this.maxAngle_;
};
ol.style.Text.prototype.getPlacement = function() {
  return this.placement_;
};
ol.style.Text.prototype.getOffsetX = function() {
  return this.offsetX_;
};
ol.style.Text.prototype.getOffsetY = function() {
  return this.offsetY_;
};
ol.style.Text.prototype.getFill = function() {
  return this.fill_;
};
ol.style.Text.prototype.getRotateWithView = function() {
  return this.rotateWithView_;
};
ol.style.Text.prototype.getRotation = function() {
  return this.rotation_;
};
ol.style.Text.prototype.getScale = function() {
  return this.scale_;
};
ol.style.Text.prototype.getStroke = function() {
  return this.stroke_;
};
ol.style.Text.prototype.getText = function() {
  return this.text_;
};
ol.style.Text.prototype.getTextAlign = function() {
  return this.textAlign_;
};
ol.style.Text.prototype.getTextBaseline = function() {
  return this.textBaseline_;
};
ol.style.Text.prototype.getBackgroundFill = function() {
  return this.backgroundFill_;
};
ol.style.Text.prototype.getBackgroundStroke = function() {
  return this.backgroundStroke_;
};
ol.style.Text.prototype.getPadding = function() {
  return this.padding_;
};
ol.style.Text.prototype.setOverflow = function(overflow) {
  this.overflow_ = overflow;
};
ol.style.Text.prototype.setFont = function(font) {
  this.font_ = font;
};
ol.style.Text.prototype.setMaxAngle = function(maxAngle) {
  this.maxAngle_ = maxAngle;
};
ol.style.Text.prototype.setOffsetX = function(offsetX) {
  this.offsetX_ = offsetX;
};
ol.style.Text.prototype.setOffsetY = function(offsetY) {
  this.offsetY_ = offsetY;
};
ol.style.Text.prototype.setPlacement = function(placement) {
  this.placement_ = placement;
};
ol.style.Text.prototype.setFill = function(fill) {
  this.fill_ = fill;
};
ol.style.Text.prototype.setRotation = function(rotation) {
  this.rotation_ = rotation;
};
ol.style.Text.prototype.setScale = function(scale) {
  this.scale_ = scale;
};
ol.style.Text.prototype.setStroke = function(stroke) {
  this.stroke_ = stroke;
};
ol.style.Text.prototype.setText = function(text) {
  this.text_ = text;
};
ol.style.Text.prototype.setTextAlign = function(textAlign) {
  this.textAlign_ = textAlign;
};
ol.style.Text.prototype.setTextBaseline = function(textBaseline) {
  this.textBaseline_ = textBaseline;
};
ol.style.Text.prototype.setBackgroundFill = function(fill) {
  this.backgroundFill_ = fill;
};
ol.style.Text.prototype.setBackgroundStroke = function(stroke) {
  this.backgroundStroke_ = stroke;
};
ol.style.Text.prototype.setPadding = function(padding) {
  this.padding_ = padding;
};
goog.provide("ol.format.KML");
goog.require("ol");
goog.require("ol.Feature");
goog.require("ol.array");
goog.require("ol.asserts");
goog.require("ol.color");
goog.require("ol.format.Feature");
goog.require("ol.format.XMLFeature");
goog.require("ol.format.XSD");
goog.require("ol.geom.GeometryCollection");
goog.require("ol.geom.GeometryLayout");
goog.require("ol.geom.GeometryType");
goog.require("ol.geom.LineString");
goog.require("ol.geom.MultiLineString");
goog.require("ol.geom.MultiPoint");
goog.require("ol.geom.MultiPolygon");
goog.require("ol.geom.Point");
goog.require("ol.geom.Polygon");
goog.require("ol.math");
goog.require("ol.proj");
goog.require("ol.style.Fill");
goog.require("ol.style.Icon");
goog.require("ol.style.IconAnchorUnits");
goog.require("ol.style.IconOrigin");
goog.require("ol.style.Stroke");
goog.require("ol.style.Style");
goog.require("ol.style.Text");
goog.require("ol.xml");
ol.format.KML = function(opt_options) {
  var options = opt_options ? opt_options : {};
  ol.format.XMLFeature.call(this);
  if (!ol.format.KML.DEFAULT_STYLE_ARRAY_) {
    ol.format.KML.createStyleDefaults_();
  }
  this.defaultDataProjection = ol.proj.get("EPSG:4326");
  this.defaultStyle_ = options.defaultStyle ? options.defaultStyle : ol.format.KML.DEFAULT_STYLE_ARRAY_;
  this.extractStyles_ = options.extractStyles !== undefined ? options.extractStyles : true;
  this.writeStyles_ = options.writeStyles !== undefined ? options.writeStyles : true;
  this.sharedStyles_ = {};
  this.showPointNames_ = options.showPointNames !== undefined ? options.showPointNames : true;
};
ol.inherits(ol.format.KML, ol.format.XMLFeature);
ol.format.KML.GX_NAMESPACE_URIS_ = ["http://www.google.com/kml/ext/2.2"];
ol.format.KML.NAMESPACE_URIS_ = [null, "http://earth.google.com/kml/2.0", "http://earth.google.com/kml/2.1", "http://earth.google.com/kml/2.2", "http://www.opengis.net/kml/2.2"];
ol.format.KML.SCHEMA_LOCATION_ = "http://www.opengis.net/kml/2.2 " + "https://developers.google.com/kml/schema/kml22gx.xsd";
ol.format.KML.createStyleDefaults_ = function() {
  ol.format.KML.DEFAULT_COLOR_ = [255, 255, 255, 1];
  ol.format.KML.DEFAULT_FILL_STYLE_ = new ol.style.Fill({color:ol.format.KML.DEFAULT_COLOR_});
  ol.format.KML.DEFAULT_IMAGE_STYLE_ANCHOR_ = [20, 2];
  ol.format.KML.DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS_ = ol.style.IconAnchorUnits.PIXELS;
  ol.format.KML.DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS_ = ol.style.IconAnchorUnits.PIXELS;
  ol.format.KML.DEFAULT_IMAGE_STYLE_SIZE_ = [64, 64];
  ol.format.KML.DEFAULT_IMAGE_STYLE_SRC_ = "https://maps.google.com/mapfiles/kml/pushpin/ylw-pushpin.png";
  ol.format.KML.DEFAULT_IMAGE_SCALE_MULTIPLIER_ = 0.5;
  ol.format.KML.DEFAULT_IMAGE_STYLE_ = new ol.style.Icon({anchor:ol.format.KML.DEFAULT_IMAGE_STYLE_ANCHOR_, anchorOrigin:ol.style.IconOrigin.BOTTOM_LEFT, anchorXUnits:ol.format.KML.DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS_, anchorYUnits:ol.format.KML.DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS_, crossOrigin:"anonymous", rotation:0, scale:ol.format.KML.DEFAULT_IMAGE_SCALE_MULTIPLIER_, size:ol.format.KML.DEFAULT_IMAGE_STYLE_SIZE_, src:ol.format.KML.DEFAULT_IMAGE_STYLE_SRC_});
  ol.format.KML.DEFAULT_NO_IMAGE_STYLE_ = "NO_IMAGE";
  ol.format.KML.DEFAULT_STROKE_STYLE_ = new ol.style.Stroke({color:ol.format.KML.DEFAULT_COLOR_, width:1});
  ol.format.KML.DEFAULT_TEXT_STROKE_STYLE_ = new ol.style.Stroke({color:[51, 51, 51, 1], width:2});
  ol.format.KML.DEFAULT_TEXT_STYLE_ = new ol.style.Text({font:"bold 16px Helvetica", fill:ol.format.KML.DEFAULT_FILL_STYLE_, stroke:ol.format.KML.DEFAULT_TEXT_STROKE_STYLE_, scale:0.8});
  ol.format.KML.DEFAULT_STYLE_ = new ol.style.Style({fill:ol.format.KML.DEFAULT_FILL_STYLE_, image:ol.format.KML.DEFAULT_IMAGE_STYLE_, text:ol.format.KML.DEFAULT_TEXT_STYLE_, stroke:ol.format.KML.DEFAULT_STROKE_STYLE_, zIndex:0});
  ol.format.KML.DEFAULT_STYLE_ARRAY_ = [ol.format.KML.DEFAULT_STYLE_];
  return ol.format.KML.DEFAULT_STYLE_ARRAY_;
};
ol.format.KML.ICON_ANCHOR_UNITS_MAP_ = {"fraction":ol.style.IconAnchorUnits.FRACTION, "pixels":ol.style.IconAnchorUnits.PIXELS, "insetPixels":ol.style.IconAnchorUnits.PIXELS};
ol.format.KML.createNameStyleFunction_ = function(foundStyle, name) {
  var textStyle = null;
  var textOffset = [0, 0];
  var textAlign = "start";
  if (foundStyle.getImage()) {
    var imageSize = foundStyle.getImage().getImageSize();
    if (imageSize === null) {
      imageSize = ol.format.KML.DEFAULT_IMAGE_STYLE_SIZE_;
    }
    if (imageSize.length == 2) {
      var imageScale = foundStyle.getImage().getScale();
      textOffset[0] = imageScale * imageSize[0] / 2;
      textOffset[1] = -imageScale * imageSize[1] / 2;
      textAlign = "left";
    }
  }
  if (foundStyle.getText() !== null) {
    var foundText = foundStyle.getText();
    textStyle = foundText.clone();
    textStyle.setFont(foundText.getFont() || ol.format.KML.DEFAULT_TEXT_STYLE_.getFont());
    textStyle.setScale(foundText.getScale() || ol.format.KML.DEFAULT_TEXT_STYLE_.getScale());
    textStyle.setFill(foundText.getFill() || ol.format.KML.DEFAULT_TEXT_STYLE_.getFill());
    textStyle.setStroke(foundText.getStroke() || ol.format.KML.DEFAULT_TEXT_STROKE_STYLE_);
  } else {
    textStyle = ol.format.KML.DEFAULT_TEXT_STYLE_.clone();
  }
  textStyle.setText(name);
  textStyle.setOffsetX(textOffset[0]);
  textStyle.setOffsetY(textOffset[1]);
  textStyle.setTextAlign(textAlign);
  var nameStyle = new ol.style.Style({text:textStyle});
  return nameStyle;
};
ol.format.KML.createFeatureStyleFunction_ = function(style, styleUrl, defaultStyle, sharedStyles, showPointNames) {
  return function(resolution) {
    var drawName = showPointNames;
    var nameStyle;
    var name = "";
    if (drawName) {
      if (this.getGeometry()) {
        drawName = this.getGeometry().getType() === ol.geom.GeometryType.POINT;
      }
    }
    if (drawName) {
      name = this.get("name");
      drawName = drawName && name;
    }
    if (style) {
      if (drawName) {
        nameStyle = ol.format.KML.createNameStyleFunction_(style[0], name);
        return style.concat(nameStyle);
      }
      return style;
    }
    if (styleUrl) {
      var foundStyle = ol.format.KML.findStyle_(styleUrl, defaultStyle, sharedStyles);
      if (drawName) {
        nameStyle = ol.format.KML.createNameStyleFunction_(foundStyle[0], name);
        return foundStyle.concat(nameStyle);
      }
      return foundStyle;
    }
    if (drawName) {
      nameStyle = ol.format.KML.createNameStyleFunction_(defaultStyle[0], name);
      return defaultStyle.concat(nameStyle);
    }
    return defaultStyle;
  };
};
ol.format.KML.findStyle_ = function(styleValue, defaultStyle, sharedStyles) {
  if (Array.isArray(styleValue)) {
    return styleValue;
  } else {
    if (typeof styleValue === "string") {
      if (!(styleValue in sharedStyles) && "#" + styleValue in sharedStyles) {
        styleValue = "#" + styleValue;
      }
      return ol.format.KML.findStyle_(sharedStyles[styleValue], defaultStyle, sharedStyles);
    } else {
      return defaultStyle;
    }
  }
};
ol.format.KML.readColor_ = function(node) {
  var s = ol.xml.getAllTextContent(node, false);
  var m = /^\s*#?\s*([0-9A-Fa-f]{8})\s*$/.exec(s);
  if (m) {
    var hexColor = m[1];
    return [parseInt(hexColor.substr(6, 2), 16), parseInt(hexColor.substr(4, 2), 16), parseInt(hexColor.substr(2, 2), 16), parseInt(hexColor.substr(0, 2), 16) / 255];
  } else {
    return undefined;
  }
};
ol.format.KML.readFlatCoordinates_ = function(node) {
  var s = ol.xml.getAllTextContent(node, false);
  var flatCoordinates = [];
  var re = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)\s*,\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)(?:\s*,\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?))?\s*/i;
  var m;
  while (m = re.exec(s)) {
    var x = parseFloat(m[1]);
    var y = parseFloat(m[2]);
    var z = m[3] ? parseFloat(m[3]) : 0;
    flatCoordinates.push(x, y, z);
    s = s.substr(m[0].length);
  }
  if (s !== "") {
    return undefined;
  }
  return flatCoordinates;
};
ol.format.KML.readURI_ = function(node) {
  var s = ol.xml.getAllTextContent(node, false).trim();
  var baseURI = node.baseURI;
  if (!baseURI || baseURI == "about:blank") {
    baseURI = window.location.href;
  }
  if (baseURI) {
    var url = new URL(s, baseURI);
    return url.href;
  } else {
    return s;
  }
};
ol.format.KML.readVec2_ = function(node) {
  var xunits = node.getAttribute("xunits");
  var yunits = node.getAttribute("yunits");
  var origin;
  if (xunits !== "insetPixels") {
    if (yunits !== "insetPixels") {
      origin = ol.style.IconOrigin.BOTTOM_LEFT;
    } else {
      origin = ol.style.IconOrigin.TOP_LEFT;
    }
  } else {
    if (yunits !== "insetPixels") {
      origin = ol.style.IconOrigin.BOTTOM_RIGHT;
    } else {
      origin = ol.style.IconOrigin.TOP_RIGHT;
    }
  }
  return {x:parseFloat(node.getAttribute("x")), xunits:ol.format.KML.ICON_ANCHOR_UNITS_MAP_[xunits], y:parseFloat(node.getAttribute("y")), yunits:ol.format.KML.ICON_ANCHOR_UNITS_MAP_[yunits], origin:origin};
};
ol.format.KML.readScale_ = function(node) {
  return ol.format.XSD.readDecimal(node);
};
ol.format.KML.readStyleMapValue_ = function(node, objectStack) {
  return ol.xml.pushParseAndPop(undefined, ol.format.KML.STYLE_MAP_PARSERS_, node, objectStack);
};
ol.format.KML.IconStyleParser_ = function(node, objectStack) {
  var object = ol.xml.pushParseAndPop({}, ol.format.KML.ICON_STYLE_PARSERS_, node, objectStack);
  if (!object) {
    return;
  }
  var styleObject = objectStack[objectStack.length - 1];
  var IconObject = "Icon" in object ? object["Icon"] : {};
  var drawIcon = !("Icon" in object) || Object.keys(IconObject).length > 0;
  var src;
  var href = IconObject["href"];
  if (href) {
    src = href;
  } else {
    if (drawIcon) {
      src = ol.format.KML.DEFAULT_IMAGE_STYLE_SRC_;
    }
  }
  var anchor, anchorXUnits, anchorYUnits;
  var anchorOrigin = ol.style.IconOrigin.BOTTOM_LEFT;
  var hotSpot = object["hotSpot"];
  if (hotSpot) {
    anchor = [hotSpot.x, hotSpot.y];
    anchorXUnits = hotSpot.xunits;
    anchorYUnits = hotSpot.yunits;
    anchorOrigin = hotSpot.origin;
  } else {
    if (src === ol.format.KML.DEFAULT_IMAGE_STYLE_SRC_) {
      anchor = ol.format.KML.DEFAULT_IMAGE_STYLE_ANCHOR_;
      anchorXUnits = ol.format.KML.DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS_;
      anchorYUnits = ol.format.KML.DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS_;
    } else {
      if (/^http:\/\/maps\.(?:google|gstatic)\.com\//.test(src)) {
        anchor = [0.5, 0];
        anchorXUnits = ol.style.IconAnchorUnits.FRACTION;
        anchorYUnits = ol.style.IconAnchorUnits.FRACTION;
      }
    }
  }
  var offset;
  var x = IconObject["x"];
  var y = IconObject["y"];
  if (x !== undefined && y !== undefined) {
    offset = [x, y];
  }
  var size;
  var w = IconObject["w"];
  var h = IconObject["h"];
  if (w !== undefined && h !== undefined) {
    size = [w, h];
  }
  var rotation;
  var heading = object["heading"];
  if (heading !== undefined) {
    rotation = ol.math.toRadians(heading);
  }
  var scale = object["scale"];
  if (drawIcon) {
    if (src == ol.format.KML.DEFAULT_IMAGE_STYLE_SRC_) {
      size = ol.format.KML.DEFAULT_IMAGE_STYLE_SIZE_;
      if (scale === undefined) {
        scale = ol.format.KML.DEFAULT_IMAGE_SCALE_MULTIPLIER_;
      }
    }
    var imageStyle = new ol.style.Icon({anchor:anchor, anchorOrigin:anchorOrigin, anchorXUnits:anchorXUnits, anchorYUnits:anchorYUnits, crossOrigin:"anonymous", offset:offset, offsetOrigin:ol.style.IconOrigin.BOTTOM_LEFT, rotation:rotation, scale:scale, size:size, src:src});
    styleObject["imageStyle"] = imageStyle;
  } else {
    styleObject["imageStyle"] = ol.format.KML.DEFAULT_NO_IMAGE_STYLE_;
  }
};
ol.format.KML.LabelStyleParser_ = function(node, objectStack) {
  var object = ol.xml.pushParseAndPop({}, ol.format.KML.LABEL_STYLE_PARSERS_, node, objectStack);
  if (!object) {
    return;
  }
  var styleObject = objectStack[objectStack.length - 1];
  var textStyle = new ol.style.Text({fill:new ol.style.Fill({color:"color" in object ? object["color"] : ol.format.KML.DEFAULT_COLOR_}), scale:object["scale"]});
  styleObject["textStyle"] = textStyle;
};
ol.format.KML.LineStyleParser_ = function(node, objectStack) {
  var object = ol.xml.pushParseAndPop({}, ol.format.KML.LINE_STYLE_PARSERS_, node, objectStack);
  if (!object) {
    return;
  }
  var styleObject = objectStack[objectStack.length - 1];
  var strokeStyle = new ol.style.Stroke({color:"color" in object ? object["color"] : ol.format.KML.DEFAULT_COLOR_, width:"width" in object ? object["width"] : 1});
  styleObject["strokeStyle"] = strokeStyle;
};
ol.format.KML.PolyStyleParser_ = function(node, objectStack) {
  var object = ol.xml.pushParseAndPop({}, ol.format.KML.POLY_STYLE_PARSERS_, node, objectStack);
  if (!object) {
    return;
  }
  var styleObject = objectStack[objectStack.length - 1];
  var fillStyle = new ol.style.Fill({color:"color" in object ? object["color"] : ol.format.KML.DEFAULT_COLOR_});
  styleObject["fillStyle"] = fillStyle;
  var fill = object["fill"];
  if (fill !== undefined) {
    styleObject["fill"] = fill;
  }
  var outline = object["outline"];
  if (outline !== undefined) {
    styleObject["outline"] = outline;
  }
};
ol.format.KML.readFlatLinearRing_ = function(node, objectStack) {
  return ol.xml.pushParseAndPop(null, ol.format.KML.FLAT_LINEAR_RING_PARSERS_, node, objectStack);
};
ol.format.KML.gxCoordParser_ = function(node, objectStack) {
  var gxTrackObject = objectStack[objectStack.length - 1];
  var flatCoordinates = gxTrackObject.flatCoordinates;
  var s = ol.xml.getAllTextContent(node, false);
  var re = /^\s*([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s*$/i;
  var m = re.exec(s);
  if (m) {
    var x = parseFloat(m[1]);
    var y = parseFloat(m[2]);
    var z = parseFloat(m[3]);
    flatCoordinates.push(x, y, z, 0);
  } else {
    flatCoordinates.push(0, 0, 0, 0);
  }
};
ol.format.KML.readGxMultiTrack_ = function(node, objectStack) {
  var lineStrings = ol.xml.pushParseAndPop([], ol.format.KML.GX_MULTITRACK_GEOMETRY_PARSERS_, node, objectStack);
  if (!lineStrings) {
    return undefined;
  }
  var multiLineString = new ol.geom.MultiLineString(null);
  multiLineString.setLineStrings(lineStrings);
  return multiLineString;
};
ol.format.KML.readGxTrack_ = function(node, objectStack) {
  var gxTrackObject = ol.xml.pushParseAndPop({flatCoordinates:[], whens:[]}, ol.format.KML.GX_TRACK_PARSERS_, node, objectStack);
  if (!gxTrackObject) {
    return undefined;
  }
  var flatCoordinates = gxTrackObject.flatCoordinates;
  var whens = gxTrackObject.whens;
  var i, ii;
  for (i = 0, ii = Math.min(flatCoordinates.length, whens.length); i < ii; ++i) {
    flatCoordinates[4 * i + 3] = whens[i];
  }
  var lineString = new ol.geom.LineString(null);
  lineString.setFlatCoordinates(ol.geom.GeometryLayout.XYZM, flatCoordinates);
  return lineString;
};
ol.format.KML.readIcon_ = function(node, objectStack) {
  var iconObject = ol.xml.pushParseAndPop({}, ol.format.KML.ICON_PARSERS_, node, objectStack);
  if (iconObject) {
    return iconObject;
  } else {
    return null;
  }
};
ol.format.KML.readFlatCoordinatesFromNode_ = function(node, objectStack) {
  return ol.xml.pushParseAndPop(null, ol.format.KML.GEOMETRY_FLAT_COORDINATES_PARSERS_, node, objectStack);
};
ol.format.KML.readLineString_ = function(node, objectStack) {
  var properties = ol.xml.pushParseAndPop({}, ol.format.KML.EXTRUDE_AND_ALTITUDE_MODE_PARSERS_, node, objectStack);
  var flatCoordinates = ol.format.KML.readFlatCoordinatesFromNode_(node, objectStack);
  if (flatCoordinates) {
    var lineString = new ol.geom.LineString(null);
    lineString.setFlatCoordinates(ol.geom.GeometryLayout.XYZ, flatCoordinates);
    lineString.setProperties(properties);
    return lineString;
  } else {
    return undefined;
  }
};
ol.format.KML.readLinearRing_ = function(node, objectStack) {
  var properties = ol.xml.pushParseAndPop({}, ol.format.KML.EXTRUDE_AND_ALTITUDE_MODE_PARSERS_, node, objectStack);
  var flatCoordinates = ol.format.KML.readFlatCoordinatesFromNode_(node, objectStack);
  if (flatCoordinates) {
    var polygon = new ol.geom.Polygon(null);
    polygon.setFlatCoordinates(ol.geom.GeometryLayout.XYZ, flatCoordinates, [flatCoordinates.length]);
    polygon.setProperties(properties);
    return polygon;
  } else {
    return undefined;
  }
};
ol.format.KML.readMultiGeometry_ = function(node, objectStack) {
  var geometries = ol.xml.pushParseAndPop([], ol.format.KML.MULTI_GEOMETRY_PARSERS_, node, objectStack);
  if (!geometries) {
    return null;
  }
  if (geometries.length === 0) {
    return new ol.geom.GeometryCollection(geometries);
  }
  var multiGeometry;
  var homogeneous = true;
  var type = geometries[0].getType();
  var geometry, i, ii;
  for (i = 1, ii = geometries.length; i < ii; ++i) {
    geometry = geometries[i];
    if (geometry.getType() != type) {
      homogeneous = false;
      break;
    }
  }
  if (homogeneous) {
    var layout;
    var flatCoordinates;
    if (type == ol.geom.GeometryType.POINT) {
      var point = geometries[0];
      layout = point.getLayout();
      flatCoordinates = point.getFlatCoordinates();
      for (i = 1, ii = geometries.length; i < ii; ++i) {
        geometry = geometries[i];
        ol.array.extend(flatCoordinates, geometry.getFlatCoordinates());
      }
      multiGeometry = new ol.geom.MultiPoint(null);
      multiGeometry.setFlatCoordinates(layout, flatCoordinates);
      ol.format.KML.setCommonGeometryProperties_(multiGeometry, geometries);
    } else {
      if (type == ol.geom.GeometryType.LINE_STRING) {
        multiGeometry = new ol.geom.MultiLineString(null);
        multiGeometry.setLineStrings(geometries);
        ol.format.KML.setCommonGeometryProperties_(multiGeometry, geometries);
      } else {
        if (type == ol.geom.GeometryType.POLYGON) {
          multiGeometry = new ol.geom.MultiPolygon(null);
          multiGeometry.setPolygons(geometries);
          ol.format.KML.setCommonGeometryProperties_(multiGeometry, geometries);
        } else {
          if (type == ol.geom.GeometryType.GEOMETRY_COLLECTION) {
            multiGeometry = new ol.geom.GeometryCollection(geometries);
          } else {
            ol.asserts.assert(false, 37);
          }
        }
      }
    }
  } else {
    multiGeometry = new ol.geom.GeometryCollection(geometries);
  }
  return multiGeometry;
};
ol.format.KML.readPoint_ = function(node, objectStack) {
  var properties = ol.xml.pushParseAndPop({}, ol.format.KML.EXTRUDE_AND_ALTITUDE_MODE_PARSERS_, node, objectStack);
  var flatCoordinates = ol.format.KML.readFlatCoordinatesFromNode_(node, objectStack);
  if (flatCoordinates) {
    var point = new ol.geom.Point(null);
    point.setFlatCoordinates(ol.geom.GeometryLayout.XYZ, flatCoordinates);
    point.setProperties(properties);
    return point;
  } else {
    return undefined;
  }
};
ol.format.KML.readPolygon_ = function(node, objectStack) {
  var properties = ol.xml.pushParseAndPop({}, ol.format.KML.EXTRUDE_AND_ALTITUDE_MODE_PARSERS_, node, objectStack);
  var flatLinearRings = ol.xml.pushParseAndPop([null], ol.format.KML.FLAT_LINEAR_RINGS_PARSERS_, node, objectStack);
  if (flatLinearRings && flatLinearRings[0]) {
    var polygon = new ol.geom.Polygon(null);
    var flatCoordinates = flatLinearRings[0];
    var ends = [flatCoordinates.length];
    var i, ii;
    for (i = 1, ii = flatLinearRings.length; i < ii; ++i) {
      ol.array.extend(flatCoordinates, flatLinearRings[i]);
      ends.push(flatCoordinates.length);
    }
    polygon.setFlatCoordinates(ol.geom.GeometryLayout.XYZ, flatCoordinates, ends);
    polygon.setProperties(properties);
    return polygon;
  } else {
    return undefined;
  }
};
ol.format.KML.readStyle_ = function(node, objectStack) {
  var styleObject = ol.xml.pushParseAndPop({}, ol.format.KML.STYLE_PARSERS_, node, objectStack);
  if (!styleObject) {
    return null;
  }
  var fillStyle = "fillStyle" in styleObject ? styleObject["fillStyle"] : ol.format.KML.DEFAULT_FILL_STYLE_;
  var fill = styleObject["fill"];
  if (fill !== undefined && !fill) {
    fillStyle = null;
  }
  var imageStyle = "imageStyle" in styleObject ? styleObject["imageStyle"] : ol.format.KML.DEFAULT_IMAGE_STYLE_;
  if (imageStyle == ol.format.KML.DEFAULT_NO_IMAGE_STYLE_) {
    imageStyle = undefined;
  }
  var textStyle = "textStyle" in styleObject ? styleObject["textStyle"] : ol.format.KML.DEFAULT_TEXT_STYLE_;
  var strokeStyle = "strokeStyle" in styleObject ? styleObject["strokeStyle"] : ol.format.KML.DEFAULT_STROKE_STYLE_;
  var outline = styleObject["outline"];
  if (outline !== undefined && !outline) {
    strokeStyle = null;
  }
  return [new ol.style.Style({fill:fillStyle, image:imageStyle, stroke:strokeStyle, text:textStyle, zIndex:undefined})];
};
ol.format.KML.setCommonGeometryProperties_ = function(multiGeometry, geometries) {
  var ii = geometries.length;
  var extrudes = new Array(geometries.length);
  var tessellates = new Array(geometries.length);
  var altitudeModes = new Array(geometries.length);
  var geometry, i, hasExtrude, hasTessellate, hasAltitudeMode;
  hasExtrude = hasTessellate = hasAltitudeMode = false;
  for (i = 0; i < ii; ++i) {
    geometry = geometries[i];
    extrudes[i] = geometry.get("extrude");
    tessellates[i] = geometry.get("tessellate");
    altitudeModes[i] = geometry.get("altitudeMode");
    hasExtrude = hasExtrude || extrudes[i] !== undefined;
    hasTessellate = hasTessellate || tessellates[i] !== undefined;
    hasAltitudeMode = hasAltitudeMode || altitudeModes[i];
  }
  if (hasExtrude) {
    multiGeometry.set("extrude", extrudes);
  }
  if (hasTessellate) {
    multiGeometry.set("tessellate", tessellates);
  }
  if (hasAltitudeMode) {
    multiGeometry.set("altitudeMode", altitudeModes);
  }
};
ol.format.KML.DataParser_ = function(node, objectStack) {
  var name = node.getAttribute("name");
  ol.xml.parseNode(ol.format.KML.DATA_PARSERS_, node, objectStack);
  var featureObject = objectStack[objectStack.length - 1];
  if (name !== null) {
    featureObject[name] = featureObject.value;
  } else {
    if (featureObject.displayName !== null) {
      featureObject[featureObject.displayName] = featureObject.value;
    }
  }
  delete featureObject["value"];
};
ol.format.KML.ExtendedDataParser_ = function(node, objectStack) {
  ol.xml.parseNode(ol.format.KML.EXTENDED_DATA_PARSERS_, node, objectStack);
};
ol.format.KML.RegionParser_ = function(node, objectStack) {
  ol.xml.parseNode(ol.format.KML.REGION_PARSERS_, node, objectStack);
};
ol.format.KML.PairDataParser_ = function(node, objectStack) {
  var pairObject = ol.xml.pushParseAndPop({}, ol.format.KML.PAIR_PARSERS_, node, objectStack);
  if (!pairObject) {
    return;
  }
  var key = pairObject["key"];
  if (key && key == "normal") {
    var styleUrl = pairObject["styleUrl"];
    if (styleUrl) {
      objectStack[objectStack.length - 1] = styleUrl;
    }
    var Style = pairObject["Style"];
    if (Style) {
      objectStack[objectStack.length - 1] = Style;
    }
  }
};
ol.format.KML.PlacemarkStyleMapParser_ = function(node, objectStack) {
  var styleMapValue = ol.format.KML.readStyleMapValue_(node, objectStack);
  if (!styleMapValue) {
    return;
  }
  var placemarkObject = objectStack[objectStack.length - 1];
  if (Array.isArray(styleMapValue)) {
    placemarkObject["Style"] = styleMapValue;
  } else {
    if (typeof styleMapValue === "string") {
      placemarkObject["styleUrl"] = styleMapValue;
    } else {
      ol.asserts.assert(false, 38);
    }
  }
};
ol.format.KML.SchemaDataParser_ = function(node, objectStack) {
  ol.xml.parseNode(ol.format.KML.SCHEMA_DATA_PARSERS_, node, objectStack);
};
ol.format.KML.SimpleDataParser_ = function(node, objectStack) {
  var name = node.getAttribute("name");
  if (name !== null) {
    var data = ol.format.XSD.readString(node);
    var featureObject = objectStack[objectStack.length - 1];
    featureObject[name] = data;
  }
};
ol.format.KML.LatLonAltBoxParser_ = function(node, objectStack) {
  var object = ol.xml.pushParseAndPop({}, ol.format.KML.LAT_LON_ALT_BOX_PARSERS_, node, objectStack);
  if (!object) {
    return;
  }
  var regionObject = objectStack[objectStack.length - 1];
  var extent = [parseFloat(object["west"]), parseFloat(object["south"]), parseFloat(object["east"]), parseFloat(object["north"])];
  regionObject["extent"] = extent;
  regionObject["altitudeMode"] = object["altitudeMode"];
  regionObject["minAltitude"] = parseFloat(object["minAltitude"]);
  regionObject["maxAltitude"] = parseFloat(object["maxAltitude"]);
};
ol.format.KML.LodParser_ = function(node, objectStack) {
  var object = ol.xml.pushParseAndPop({}, ol.format.KML.LOD_PARSERS_, node, objectStack);
  if (!object) {
    return;
  }
  var lodObject = objectStack[objectStack.length - 1];
  lodObject["minLodPixels"] = parseFloat(object["minLodPixels"]);
  lodObject["maxLodPixels"] = parseFloat(object["maxLodPixels"]);
  lodObject["minFadeExtent"] = parseFloat(object["minFadeExtent"]);
  lodObject["maxFadeExtent"] = parseFloat(object["maxFadeExtent"]);
};
ol.format.KML.innerBoundaryIsParser_ = function(node, objectStack) {
  var flatLinearRing = ol.xml.pushParseAndPop(undefined, ol.format.KML.INNER_BOUNDARY_IS_PARSERS_, node, objectStack);
  if (flatLinearRing) {
    var flatLinearRings = objectStack[objectStack.length - 1];
    flatLinearRings.push(flatLinearRing);
  }
};
ol.format.KML.outerBoundaryIsParser_ = function(node, objectStack) {
  var flatLinearRing = ol.xml.pushParseAndPop(undefined, ol.format.KML.OUTER_BOUNDARY_IS_PARSERS_, node, objectStack);
  if (flatLinearRing) {
    var flatLinearRings = objectStack[objectStack.length - 1];
    flatLinearRings[0] = flatLinearRing;
  }
};
ol.format.KML.LinkParser_ = function(node, objectStack) {
  ol.xml.parseNode(ol.format.KML.LINK_PARSERS_, node, objectStack);
};
ol.format.KML.whenParser_ = function(node, objectStack) {
  var gxTrackObject = objectStack[objectStack.length - 1];
  var whens = gxTrackObject.whens;
  var s = ol.xml.getAllTextContent(node, false);
  var when = Date.parse(s);
  whens.push(isNaN(when) ? 0 : when);
};
ol.format.KML.DATA_PARSERS_ = ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_, {"displayName":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "value":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString)});
ol.format.KML.EXTENDED_DATA_PARSERS_ = ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_, {"Data":ol.format.KML.DataParser_, "SchemaData":ol.format.KML.SchemaDataParser_});
ol.format.KML.REGION_PARSERS_ = ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_, {"LatLonAltBox":ol.format.KML.LatLonAltBoxParser_, "Lod":ol.format.KML.LodParser_});
ol.format.KML.LAT_LON_ALT_BOX_PARSERS_ = ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_, {"altitudeMode":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "minAltitude":ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal), "maxAltitude":ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal), "north":ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal), "south":ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal), "east":ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal), 
"west":ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal)});
ol.format.KML.LOD_PARSERS_ = ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_, {"minLodPixels":ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal), "maxLodPixels":ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal), "minFadeExtent":ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal), "maxFadeExtent":ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal)});
ol.format.KML.EXTRUDE_AND_ALTITUDE_MODE_PARSERS_ = ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_, {"extrude":ol.xml.makeObjectPropertySetter(ol.format.XSD.readBoolean), "tessellate":ol.xml.makeObjectPropertySetter(ol.format.XSD.readBoolean), "altitudeMode":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString)});
ol.format.KML.FLAT_LINEAR_RING_PARSERS_ = ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_, {"coordinates":ol.xml.makeReplacer(ol.format.KML.readFlatCoordinates_)});
ol.format.KML.FLAT_LINEAR_RINGS_PARSERS_ = ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_, {"innerBoundaryIs":ol.format.KML.innerBoundaryIsParser_, "outerBoundaryIs":ol.format.KML.outerBoundaryIsParser_});
ol.format.KML.GX_TRACK_PARSERS_ = ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_, {"when":ol.format.KML.whenParser_}, ol.xml.makeStructureNS(ol.format.KML.GX_NAMESPACE_URIS_, {"coord":ol.format.KML.gxCoordParser_}));
ol.format.KML.GEOMETRY_FLAT_COORDINATES_PARSERS_ = ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_, {"coordinates":ol.xml.makeReplacer(ol.format.KML.readFlatCoordinates_)});
ol.format.KML.ICON_PARSERS_ = ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_, {"href":ol.xml.makeObjectPropertySetter(ol.format.KML.readURI_)}, ol.xml.makeStructureNS(ol.format.KML.GX_NAMESPACE_URIS_, {"x":ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal), "y":ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal), "w":ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal), "h":ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal)}));
ol.format.KML.ICON_STYLE_PARSERS_ = ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_, {"Icon":ol.xml.makeObjectPropertySetter(ol.format.KML.readIcon_), "heading":ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal), "hotSpot":ol.xml.makeObjectPropertySetter(ol.format.KML.readVec2_), "scale":ol.xml.makeObjectPropertySetter(ol.format.KML.readScale_)});
ol.format.KML.INNER_BOUNDARY_IS_PARSERS_ = ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_, {"LinearRing":ol.xml.makeReplacer(ol.format.KML.readFlatLinearRing_)});
ol.format.KML.LABEL_STYLE_PARSERS_ = ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_, {"color":ol.xml.makeObjectPropertySetter(ol.format.KML.readColor_), "scale":ol.xml.makeObjectPropertySetter(ol.format.KML.readScale_)});
ol.format.KML.LINE_STYLE_PARSERS_ = ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_, {"color":ol.xml.makeObjectPropertySetter(ol.format.KML.readColor_), "width":ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal)});
ol.format.KML.MULTI_GEOMETRY_PARSERS_ = ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_, {"LineString":ol.xml.makeArrayPusher(ol.format.KML.readLineString_), "LinearRing":ol.xml.makeArrayPusher(ol.format.KML.readLinearRing_), "MultiGeometry":ol.xml.makeArrayPusher(ol.format.KML.readMultiGeometry_), "Point":ol.xml.makeArrayPusher(ol.format.KML.readPoint_), "Polygon":ol.xml.makeArrayPusher(ol.format.KML.readPolygon_)});
ol.format.KML.GX_MULTITRACK_GEOMETRY_PARSERS_ = ol.xml.makeStructureNS(ol.format.KML.GX_NAMESPACE_URIS_, {"Track":ol.xml.makeArrayPusher(ol.format.KML.readGxTrack_)});
ol.format.KML.NETWORK_LINK_PARSERS_ = ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_, {"ExtendedData":ol.format.KML.ExtendedDataParser_, "Region":ol.format.KML.RegionParser_, "Link":ol.format.KML.LinkParser_, "address":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "description":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "name":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "open":ol.xml.makeObjectPropertySetter(ol.format.XSD.readBoolean), "phoneNumber":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), 
"visibility":ol.xml.makeObjectPropertySetter(ol.format.XSD.readBoolean)});
ol.format.KML.LINK_PARSERS_ = ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_, {"href":ol.xml.makeObjectPropertySetter(ol.format.KML.readURI_)});
ol.format.KML.OUTER_BOUNDARY_IS_PARSERS_ = ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_, {"LinearRing":ol.xml.makeReplacer(ol.format.KML.readFlatLinearRing_)});
ol.format.KML.PAIR_PARSERS_ = ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_, {"Style":ol.xml.makeObjectPropertySetter(ol.format.KML.readStyle_), "key":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "styleUrl":ol.xml.makeObjectPropertySetter(ol.format.KML.readURI_)});
ol.format.KML.PLACEMARK_PARSERS_ = ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_, {"ExtendedData":ol.format.KML.ExtendedDataParser_, "Region":ol.format.KML.RegionParser_, "MultiGeometry":ol.xml.makeObjectPropertySetter(ol.format.KML.readMultiGeometry_, "geometry"), "LineString":ol.xml.makeObjectPropertySetter(ol.format.KML.readLineString_, "geometry"), "LinearRing":ol.xml.makeObjectPropertySetter(ol.format.KML.readLinearRing_, "geometry"), "Point":ol.xml.makeObjectPropertySetter(ol.format.KML.readPoint_, 
"geometry"), "Polygon":ol.xml.makeObjectPropertySetter(ol.format.KML.readPolygon_, "geometry"), "Style":ol.xml.makeObjectPropertySetter(ol.format.KML.readStyle_), "StyleMap":ol.format.KML.PlacemarkStyleMapParser_, "address":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "description":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "name":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "open":ol.xml.makeObjectPropertySetter(ol.format.XSD.readBoolean), "phoneNumber":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), 
"styleUrl":ol.xml.makeObjectPropertySetter(ol.format.KML.readURI_), "visibility":ol.xml.makeObjectPropertySetter(ol.format.XSD.readBoolean)}, ol.xml.makeStructureNS(ol.format.KML.GX_NAMESPACE_URIS_, {"MultiTrack":ol.xml.makeObjectPropertySetter(ol.format.KML.readGxMultiTrack_, "geometry"), "Track":ol.xml.makeObjectPropertySetter(ol.format.KML.readGxTrack_, "geometry")}));
ol.format.KML.POLY_STYLE_PARSERS_ = ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_, {"color":ol.xml.makeObjectPropertySetter(ol.format.KML.readColor_), "fill":ol.xml.makeObjectPropertySetter(ol.format.XSD.readBoolean), "outline":ol.xml.makeObjectPropertySetter(ol.format.XSD.readBoolean)});
ol.format.KML.SCHEMA_DATA_PARSERS_ = ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_, {"SimpleData":ol.format.KML.SimpleDataParser_});
ol.format.KML.STYLE_PARSERS_ = ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_, {"IconStyle":ol.format.KML.IconStyleParser_, "LabelStyle":ol.format.KML.LabelStyleParser_, "LineStyle":ol.format.KML.LineStyleParser_, "PolyStyle":ol.format.KML.PolyStyleParser_});
ol.format.KML.STYLE_MAP_PARSERS_ = ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_, {"Pair":ol.format.KML.PairDataParser_});
ol.format.KML.prototype.readDocumentOrFolder_ = function(node, objectStack) {
  var parsersNS = ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_, {"Document":ol.xml.makeArrayExtender(this.readDocumentOrFolder_, this), "Folder":ol.xml.makeArrayExtender(this.readDocumentOrFolder_, this), "Placemark":ol.xml.makeArrayPusher(this.readPlacemark_, this), "Style":this.readSharedStyle_.bind(this), "StyleMap":this.readSharedStyleMap_.bind(this)});
  var features = ol.xml.pushParseAndPop([], parsersNS, node, objectStack, this);
  if (features) {
    return features;
  } else {
    return undefined;
  }
};
ol.format.KML.prototype.readPlacemark_ = function(node, objectStack) {
  var object = ol.xml.pushParseAndPop({"geometry":null}, ol.format.KML.PLACEMARK_PARSERS_, node, objectStack);
  if (!object) {
    return undefined;
  }
  var feature = new ol.Feature;
  var id = node.getAttribute("id");
  if (id !== null) {
    feature.setId(id);
  }
  var options = objectStack[0];
  var geometry = object["geometry"];
  if (geometry) {
    ol.format.Feature.transformWithOptions(geometry, false, options);
  }
  feature.setGeometry(geometry);
  delete object["geometry"];
  if (this.extractStyles_) {
    var style = object["Style"];
    var styleUrl = object["styleUrl"];
    var styleFunction = ol.format.KML.createFeatureStyleFunction_(style, styleUrl, this.defaultStyle_, this.sharedStyles_, this.showPointNames_);
    feature.setStyle(styleFunction);
  }
  delete object["Style"];
  feature.setProperties(object);
  return feature;
};
ol.format.KML.prototype.readSharedStyle_ = function(node, objectStack) {
  var id = node.getAttribute("id");
  if (id !== null) {
    var style = ol.format.KML.readStyle_(node, objectStack);
    if (style) {
      var styleUri;
      var baseURI = node.baseURI;
      if (!baseURI || baseURI == "about:blank") {
        baseURI = window.location.href;
      }
      if (baseURI) {
        var url = new URL("#" + id, baseURI);
        styleUri = url.href;
      } else {
        styleUri = "#" + id;
      }
      this.sharedStyles_[styleUri] = style;
    }
  }
};
ol.format.KML.prototype.readSharedStyleMap_ = function(node, objectStack) {
  var id = node.getAttribute("id");
  if (id === null) {
    return;
  }
  var styleMapValue = ol.format.KML.readStyleMapValue_(node, objectStack);
  if (!styleMapValue) {
    return;
  }
  var styleUri;
  var baseURI = node.baseURI;
  if (!baseURI || baseURI == "about:blank") {
    baseURI = window.location.href;
  }
  if (baseURI) {
    var url = new URL("#" + id, baseURI);
    styleUri = url.href;
  } else {
    styleUri = "#" + id;
  }
  this.sharedStyles_[styleUri] = styleMapValue;
};
ol.format.KML.prototype.readFeature;
ol.format.KML.prototype.readFeatureFromNode = function(node, opt_options) {
  if (!ol.array.includes(ol.format.KML.NAMESPACE_URIS_, node.namespaceURI)) {
    return null;
  }
  var feature = this.readPlacemark_(node, [this.getReadOptions(node, opt_options)]);
  if (feature) {
    return feature;
  } else {
    return null;
  }
};
ol.format.KML.prototype.readFeatures;
ol.format.KML.prototype.readFeaturesFromNode = function(node, opt_options) {
  if (!ol.array.includes(ol.format.KML.NAMESPACE_URIS_, node.namespaceURI)) {
    return [];
  }
  var features;
  var localName = node.localName;
  if (localName == "Document" || localName == "Folder") {
    features = this.readDocumentOrFolder_(node, [this.getReadOptions(node, opt_options)]);
    if (features) {
      return features;
    } else {
      return [];
    }
  } else {
    if (localName == "Placemark") {
      var feature = this.readPlacemark_(node, [this.getReadOptions(node, opt_options)]);
      if (feature) {
        return [feature];
      } else {
        return [];
      }
    } else {
      if (localName == "kml") {
        features = [];
        var n;
        for (n = node.firstElementChild; n; n = n.nextElementSibling) {
          var fs = this.readFeaturesFromNode(n, opt_options);
          if (fs) {
            ol.array.extend(features, fs);
          }
        }
        return features;
      } else {
        return [];
      }
    }
  }
};
ol.format.KML.prototype.readName = function(source) {
  if (ol.xml.isDocument(source)) {
    return this.readNameFromDocument(source);
  } else {
    if (ol.xml.isNode(source)) {
      return this.readNameFromNode(source);
    } else {
      if (typeof source === "string") {
        var doc = ol.xml.parse(source);
        return this.readNameFromDocument(doc);
      } else {
        return undefined;
      }
    }
  }
};
ol.format.KML.prototype.readNameFromDocument = function(doc) {
  var n;
  for (n = doc.firstChild; n; n = n.nextSibling) {
    if (n.nodeType == Node.ELEMENT_NODE) {
      var name = this.readNameFromNode(n);
      if (name) {
        return name;
      }
    }
  }
  return undefined;
};
ol.format.KML.prototype.readNameFromNode = function(node) {
  var n;
  for (n = node.firstElementChild; n; n = n.nextElementSibling) {
    if (ol.array.includes(ol.format.KML.NAMESPACE_URIS_, n.namespaceURI) && n.localName == "name") {
      return ol.format.XSD.readString(n);
    }
  }
  for (n = node.firstElementChild; n; n = n.nextElementSibling) {
    var localName = n.localName;
    if (ol.array.includes(ol.format.KML.NAMESPACE_URIS_, n.namespaceURI) && (localName == "Document" || localName == "Folder" || localName == "Placemark" || localName == "kml")) {
      var name = this.readNameFromNode(n);
      if (name) {
        return name;
      }
    }
  }
  return undefined;
};
ol.format.KML.prototype.readNetworkLinks = function(source) {
  var networkLinks = [];
  if (ol.xml.isDocument(source)) {
    ol.array.extend(networkLinks, this.readNetworkLinksFromDocument(source));
  } else {
    if (ol.xml.isNode(source)) {
      ol.array.extend(networkLinks, this.readNetworkLinksFromNode(source));
    } else {
      if (typeof source === "string") {
        var doc = ol.xml.parse(source);
        ol.array.extend(networkLinks, this.readNetworkLinksFromDocument(doc));
      }
    }
  }
  return networkLinks;
};
ol.format.KML.prototype.readNetworkLinksFromDocument = function(doc) {
  var n, networkLinks = [];
  for (n = doc.firstChild; n; n = n.nextSibling) {
    if (n.nodeType == Node.ELEMENT_NODE) {
      ol.array.extend(networkLinks, this.readNetworkLinksFromNode(n));
    }
  }
  return networkLinks;
};
ol.format.KML.prototype.readNetworkLinksFromNode = function(node) {
  var n, networkLinks = [];
  for (n = node.firstElementChild; n; n = n.nextElementSibling) {
    if (ol.array.includes(ol.format.KML.NAMESPACE_URIS_, n.namespaceURI) && n.localName == "NetworkLink") {
      var obj = ol.xml.pushParseAndPop({}, ol.format.KML.NETWORK_LINK_PARSERS_, n, []);
      networkLinks.push(obj);
    }
  }
  for (n = node.firstElementChild; n; n = n.nextElementSibling) {
    var localName = n.localName;
    if (ol.array.includes(ol.format.KML.NAMESPACE_URIS_, n.namespaceURI) && (localName == "Document" || localName == "Folder" || localName == "kml")) {
      ol.array.extend(networkLinks, this.readNetworkLinksFromNode(n));
    }
  }
  return networkLinks;
};
ol.format.KML.prototype.readRegion = function(source) {
  var regions = [];
  if (ol.xml.isDocument(source)) {
    ol.array.extend(regions, this.readRegionFromDocument(source));
  } else {
    if (ol.xml.isNode(source)) {
      ol.array.extend(regions, this.readRegionFromNode(source));
    } else {
      if (typeof source === "string") {
        var doc = ol.xml.parse(source);
        ol.array.extend(regions, this.readRegionFromDocument(doc));
      }
    }
  }
  return regions;
};
ol.format.KML.prototype.readRegionFromDocument = function(doc) {
  var n, regions = [];
  for (n = doc.firstChild; n; n = n.nextSibling) {
    if (n.nodeType == Node.ELEMENT_NODE) {
      ol.array.extend(regions, this.readRegionFromNode(n));
    }
  }
  return regions;
};
ol.format.KML.prototype.readRegionFromNode = function(node) {
  var n, regions = [];
  for (n = node.firstElementChild; n; n = n.nextElementSibling) {
    if (ol.array.includes(ol.format.KML.NAMESPACE_URIS_, n.namespaceURI) && n.localName == "Region") {
      var obj = ol.xml.pushParseAndPop({}, ol.format.KML.REGION_PARSERS_, n, []);
      regions.push(obj);
    }
  }
  for (n = node.firstElementChild; n; n = n.nextElementSibling) {
    var localName = n.localName;
    if (ol.array.includes(ol.format.KML.NAMESPACE_URIS_, n.namespaceURI) && (localName == "Document" || localName == "Folder" || localName == "kml")) {
      ol.array.extend(regions, this.readRegionFromNode(n));
    }
  }
  return regions;
};
ol.format.KML.prototype.readProjection;
ol.format.KML.writeColorTextNode_ = function(node, color) {
  var rgba = ol.color.asArray(color);
  var opacity = rgba.length == 4 ? rgba[3] : 1;
  var abgr = [opacity * 255, rgba[2], rgba[1], rgba[0]];
  var i;
  for (i = 0; i < 4; ++i) {
    var hex = parseInt(abgr[i], 10).toString(16);
    abgr[i] = hex.length == 1 ? "0" + hex : hex;
  }
  ol.format.XSD.writeStringTextNode(node, abgr.join(""));
};
ol.format.KML.writeCoordinatesTextNode_ = function(node, coordinates, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var layout = context["layout"];
  var stride = context["stride"];
  var dimension;
  if (layout == ol.geom.GeometryLayout.XY || layout == ol.geom.GeometryLayout.XYM) {
    dimension = 2;
  } else {
    if (layout == ol.geom.GeometryLayout.XYZ || layout == ol.geom.GeometryLayout.XYZM) {
      dimension = 3;
    } else {
      ol.asserts.assert(false, 34);
    }
  }
  var d, i;
  var ii = coordinates.length;
  var text = "";
  if (ii > 0) {
    text += coordinates[0];
    for (d = 1; d < dimension; ++d) {
      text += "," + coordinates[d];
    }
    for (i = stride; i < ii; i += stride) {
      text += " " + coordinates[i];
      for (d = 1; d < dimension; ++d) {
        text += "," + coordinates[i + d];
      }
    }
  }
  ol.format.XSD.writeStringTextNode(node, text);
};
ol.format.KML.writeDataNode_ = function(node, pair, objectStack) {
  node.setAttribute("name", pair.name);
  var context = {node:node};
  var value = pair.value;
  if (typeof value == "object") {
    if (value !== null && value.displayName) {
      ol.xml.pushSerializeAndPop(context, ol.format.KML.EXTENDEDDATA_NODE_SERIALIZERS_, ol.xml.OBJECT_PROPERTY_NODE_FACTORY, [value.displayName], objectStack, ["displayName"]);
    }
    if (value !== null && value.value) {
      ol.xml.pushSerializeAndPop(context, ol.format.KML.EXTENDEDDATA_NODE_SERIALIZERS_, ol.xml.OBJECT_PROPERTY_NODE_FACTORY, [value.value], objectStack, ["value"]);
    }
  } else {
    ol.xml.pushSerializeAndPop(context, ol.format.KML.EXTENDEDDATA_NODE_SERIALIZERS_, ol.xml.OBJECT_PROPERTY_NODE_FACTORY, [value], objectStack, ["value"]);
  }
};
ol.format.KML.writeDataNodeName_ = function(node, name) {
  ol.format.XSD.writeCDATASection(node, name);
};
ol.format.KML.writeDataNodeValue_ = function(node, value) {
  ol.format.XSD.writeStringTextNode(node, value);
};
ol.format.KML.writeDocument_ = function(node, features, objectStack) {
  var context = {node:node};
  ol.xml.pushSerializeAndPop(context, ol.format.KML.DOCUMENT_SERIALIZERS_, ol.format.KML.DOCUMENT_NODE_FACTORY_, features, objectStack, undefined, this);
};
ol.format.KML.writeExtendedData_ = function(node, namesAndValues, objectStack) {
  var context = {node:node};
  var names = namesAndValues.names, values = namesAndValues.values;
  var length = names.length;
  for (var i = 0; i < length; i++) {
    ol.xml.pushSerializeAndPop(context, ol.format.KML.EXTENDEDDATA_NODE_SERIALIZERS_, ol.format.KML.DATA_NODE_FACTORY_, [{name:names[i], value:values[i]}], objectStack);
  }
};
ol.format.KML.writeIcon_ = function(node, icon, objectStack) {
  var context = {node:node};
  var parentNode = objectStack[objectStack.length - 1].node;
  var orderedKeys = ol.format.KML.ICON_SEQUENCE_[parentNode.namespaceURI];
  var values = ol.xml.makeSequence(icon, orderedKeys);
  ol.xml.pushSerializeAndPop(context, ol.format.KML.ICON_SERIALIZERS_, ol.xml.OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
  orderedKeys = ol.format.KML.ICON_SEQUENCE_[ol.format.KML.GX_NAMESPACE_URIS_[0]];
  values = ol.xml.makeSequence(icon, orderedKeys);
  ol.xml.pushSerializeAndPop(context, ol.format.KML.ICON_SERIALIZERS_, ol.format.KML.GX_NODE_FACTORY_, values, objectStack, orderedKeys);
};
ol.format.KML.writeIconStyle_ = function(node, style, objectStack) {
  var context = {node:node};
  var properties = {};
  var src = style.getSrc();
  var size = style.getSize();
  var iconImageSize = style.getImageSize();
  var iconProperties = {"href":src};
  if (size) {
    iconProperties["w"] = size[0];
    iconProperties["h"] = size[1];
    var anchor = style.getAnchor();
    var origin = style.getOrigin();
    if (origin && iconImageSize && origin[0] !== 0 && origin[1] !== size[1]) {
      iconProperties["x"] = origin[0];
      iconProperties["y"] = iconImageSize[1] - (origin[1] + size[1]);
    }
    if (anchor && (anchor[0] !== size[0] / 2 || anchor[1] !== size[1] / 2)) {
      var hotSpot = {x:anchor[0], xunits:ol.style.IconAnchorUnits.PIXELS, y:size[1] - anchor[1], yunits:ol.style.IconAnchorUnits.PIXELS};
      properties["hotSpot"] = hotSpot;
    }
  }
  properties["Icon"] = iconProperties;
  var scale = style.getScale();
  if (scale !== 1) {
    properties["scale"] = scale;
  }
  var rotation = style.getRotation();
  if (rotation !== 0) {
    properties["heading"] = rotation;
  }
  var parentNode = objectStack[objectStack.length - 1].node;
  var orderedKeys = ol.format.KML.ICON_STYLE_SEQUENCE_[parentNode.namespaceURI];
  var values = ol.xml.makeSequence(properties, orderedKeys);
  ol.xml.pushSerializeAndPop(context, ol.format.KML.ICON_STYLE_SERIALIZERS_, ol.xml.OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
};
ol.format.KML.writeLabelStyle_ = function(node, style, objectStack) {
  var context = {node:node};
  var properties = {};
  var fill = style.getFill();
  if (fill) {
    properties["color"] = fill.getColor();
  }
  var scale = style.getScale();
  if (scale && scale !== 1) {
    properties["scale"] = scale;
  }
  var parentNode = objectStack[objectStack.length - 1].node;
  var orderedKeys = ol.format.KML.LABEL_STYLE_SEQUENCE_[parentNode.namespaceURI];
  var values = ol.xml.makeSequence(properties, orderedKeys);
  ol.xml.pushSerializeAndPop(context, ol.format.KML.LABEL_STYLE_SERIALIZERS_, ol.xml.OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
};
ol.format.KML.writeLineStyle_ = function(node, style, objectStack) {
  var context = {node:node};
  var properties = {"color":style.getColor(), "width":style.getWidth()};
  var parentNode = objectStack[objectStack.length - 1].node;
  var orderedKeys = ol.format.KML.LINE_STYLE_SEQUENCE_[parentNode.namespaceURI];
  var values = ol.xml.makeSequence(properties, orderedKeys);
  ol.xml.pushSerializeAndPop(context, ol.format.KML.LINE_STYLE_SERIALIZERS_, ol.xml.OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
};
ol.format.KML.writeMultiGeometry_ = function(node, geometry, objectStack) {
  var context = {node:node};
  var type = geometry.getType();
  var geometries;
  var factory;
  if (type == ol.geom.GeometryType.GEOMETRY_COLLECTION) {
    geometries = geometry.getGeometries();
    factory = ol.format.KML.GEOMETRY_NODE_FACTORY_;
  } else {
    if (type == ol.geom.GeometryType.MULTI_POINT) {
      geometries = geometry.getPoints();
      factory = ol.format.KML.POINT_NODE_FACTORY_;
    } else {
      if (type == ol.geom.GeometryType.MULTI_LINE_STRING) {
        geometries = geometry.getLineStrings();
        factory = ol.format.KML.LINE_STRING_NODE_FACTORY_;
      } else {
        if (type == ol.geom.GeometryType.MULTI_POLYGON) {
          geometries = geometry.getPolygons();
          factory = ol.format.KML.POLYGON_NODE_FACTORY_;
        } else {
          ol.asserts.assert(false, 39);
        }
      }
    }
  }
  ol.xml.pushSerializeAndPop(context, ol.format.KML.MULTI_GEOMETRY_SERIALIZERS_, factory, geometries, objectStack);
};
ol.format.KML.writeBoundaryIs_ = function(node, linearRing, objectStack) {
  var context = {node:node};
  ol.xml.pushSerializeAndPop(context, ol.format.KML.BOUNDARY_IS_SERIALIZERS_, ol.format.KML.LINEAR_RING_NODE_FACTORY_, [linearRing], objectStack);
};
ol.format.KML.writePlacemark_ = function(node, feature, objectStack) {
  var context = {node:node};
  if (feature.getId()) {
    node.setAttribute("id", feature.getId());
  }
  var properties = feature.getProperties();
  var filter = {"address":1, "description":1, "name":1, "open":1, "phoneNumber":1, "styleUrl":1, "visibility":1};
  filter[feature.getGeometryName()] = 1;
  var keys = Object.keys(properties || {}).sort().filter(function(v) {
    return !filter[v];
  });
  if (keys.length > 0) {
    var sequence = ol.xml.makeSequence(properties, keys);
    var namesAndValues = {names:keys, values:sequence};
    ol.xml.pushSerializeAndPop(context, ol.format.KML.PLACEMARK_SERIALIZERS_, ol.format.KML.EXTENDEDDATA_NODE_FACTORY_, [namesAndValues], objectStack);
  }
  var styleFunction = feature.getStyleFunction();
  if (styleFunction) {
    var styles = styleFunction.call(feature, 0);
    if (styles) {
      var style = Array.isArray(styles) ? styles[0] : styles;
      if (this.writeStyles_) {
        properties["Style"] = style;
      }
      var textStyle = style.getText();
      if (textStyle) {
        properties["name"] = textStyle.getText();
      }
    }
  }
  var parentNode = objectStack[objectStack.length - 1].node;
  var orderedKeys = ol.format.KML.PLACEMARK_SEQUENCE_[parentNode.namespaceURI];
  var values = ol.xml.makeSequence(properties, orderedKeys);
  ol.xml.pushSerializeAndPop(context, ol.format.KML.PLACEMARK_SERIALIZERS_, ol.xml.OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
  var options = objectStack[0];
  var geometry = feature.getGeometry();
  if (geometry) {
    geometry = ol.format.Feature.transformWithOptions(geometry, true, options);
  }
  ol.xml.pushSerializeAndPop(context, ol.format.KML.PLACEMARK_SERIALIZERS_, ol.format.KML.GEOMETRY_NODE_FACTORY_, [geometry], objectStack);
};
ol.format.KML.writePrimitiveGeometry_ = function(node, geometry, objectStack) {
  var flatCoordinates = geometry.getFlatCoordinates();
  var context = {node:node};
  context["layout"] = geometry.getLayout();
  context["stride"] = geometry.getStride();
  var properties = geometry.getProperties();
  properties.coordinates = flatCoordinates;
  var parentNode = objectStack[objectStack.length - 1].node;
  var orderedKeys = ol.format.KML.PRIMITIVE_GEOMETRY_SEQUENCE_[parentNode.namespaceURI];
  var values = ol.xml.makeSequence(properties, orderedKeys);
  ol.xml.pushSerializeAndPop(context, ol.format.KML.PRIMITIVE_GEOMETRY_SERIALIZERS_, ol.xml.OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
};
ol.format.KML.writePolygon_ = function(node, polygon, objectStack) {
  var linearRings = polygon.getLinearRings();
  var outerRing = linearRings.shift();
  var context = {node:node};
  ol.xml.pushSerializeAndPop(context, ol.format.KML.POLYGON_SERIALIZERS_, ol.format.KML.INNER_BOUNDARY_NODE_FACTORY_, linearRings, objectStack);
  ol.xml.pushSerializeAndPop(context, ol.format.KML.POLYGON_SERIALIZERS_, ol.format.KML.OUTER_BOUNDARY_NODE_FACTORY_, [outerRing], objectStack);
};
ol.format.KML.writePolyStyle_ = function(node, style, objectStack) {
  var context = {node:node};
  ol.xml.pushSerializeAndPop(context, ol.format.KML.POLY_STYLE_SERIALIZERS_, ol.format.KML.COLOR_NODE_FACTORY_, [style.getColor()], objectStack);
};
ol.format.KML.writeScaleTextNode_ = function(node, scale) {
  ol.format.XSD.writeDecimalTextNode(node, Math.round(scale * 1e6) / 1e6);
};
ol.format.KML.writeStyle_ = function(node, style, objectStack) {
  var context = {node:node};
  var properties = {};
  var fillStyle = style.getFill();
  var strokeStyle = style.getStroke();
  var imageStyle = style.getImage();
  var textStyle = style.getText();
  if (imageStyle instanceof ol.style.Icon) {
    properties["IconStyle"] = imageStyle;
  }
  if (textStyle) {
    properties["LabelStyle"] = textStyle;
  }
  if (strokeStyle) {
    properties["LineStyle"] = strokeStyle;
  }
  if (fillStyle) {
    properties["PolyStyle"] = fillStyle;
  }
  var parentNode = objectStack[objectStack.length - 1].node;
  var orderedKeys = ol.format.KML.STYLE_SEQUENCE_[parentNode.namespaceURI];
  var values = ol.xml.makeSequence(properties, orderedKeys);
  ol.xml.pushSerializeAndPop(context, ol.format.KML.STYLE_SERIALIZERS_, ol.xml.OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);
};
ol.format.KML.writeVec2_ = function(node, vec2) {
  node.setAttribute("x", vec2.x);
  node.setAttribute("y", vec2.y);
  node.setAttribute("xunits", vec2.xunits);
  node.setAttribute("yunits", vec2.yunits);
};
ol.format.KML.KML_SEQUENCE_ = ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_, ["Document", "Placemark"]);
ol.format.KML.KML_SERIALIZERS_ = ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_, {"Document":ol.xml.makeChildAppender(ol.format.KML.writeDocument_), "Placemark":ol.xml.makeChildAppender(ol.format.KML.writePlacemark_)});
ol.format.KML.DOCUMENT_SERIALIZERS_ = ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_, {"Placemark":ol.xml.makeChildAppender(ol.format.KML.writePlacemark_)});
ol.format.KML.EXTENDEDDATA_NODE_SERIALIZERS_ = ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_, {"Data":ol.xml.makeChildAppender(ol.format.KML.writeDataNode_), "value":ol.xml.makeChildAppender(ol.format.KML.writeDataNodeValue_), "displayName":ol.xml.makeChildAppender(ol.format.KML.writeDataNodeName_)});
ol.format.KML.GEOMETRY_TYPE_TO_NODENAME_ = {"Point":"Point", "LineString":"LineString", "LinearRing":"LinearRing", "Polygon":"Polygon", "MultiPoint":"MultiGeometry", "MultiLineString":"MultiGeometry", "MultiPolygon":"MultiGeometry", "GeometryCollection":"MultiGeometry"};
ol.format.KML.ICON_SEQUENCE_ = ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_, ["href"], ol.xml.makeStructureNS(ol.format.KML.GX_NAMESPACE_URIS_, ["x", "y", "w", "h"]));
ol.format.KML.ICON_SERIALIZERS_ = ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_, {"href":ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode)}, ol.xml.makeStructureNS(ol.format.KML.GX_NAMESPACE_URIS_, {"x":ol.xml.makeChildAppender(ol.format.XSD.writeDecimalTextNode), "y":ol.xml.makeChildAppender(ol.format.XSD.writeDecimalTextNode), "w":ol.xml.makeChildAppender(ol.format.XSD.writeDecimalTextNode), "h":ol.xml.makeChildAppender(ol.format.XSD.writeDecimalTextNode)}));
ol.format.KML.ICON_STYLE_SEQUENCE_ = ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_, ["scale", "heading", "Icon", "hotSpot"]);
ol.format.KML.ICON_STYLE_SERIALIZERS_ = ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_, {"Icon":ol.xml.makeChildAppender(ol.format.KML.writeIcon_), "heading":ol.xml.makeChildAppender(ol.format.XSD.writeDecimalTextNode), "hotSpot":ol.xml.makeChildAppender(ol.format.KML.writeVec2_), "scale":ol.xml.makeChildAppender(ol.format.KML.writeScaleTextNode_)});
ol.format.KML.LABEL_STYLE_SEQUENCE_ = ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_, ["color", "scale"]);
ol.format.KML.LABEL_STYLE_SERIALIZERS_ = ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_, {"color":ol.xml.makeChildAppender(ol.format.KML.writeColorTextNode_), "scale":ol.xml.makeChildAppender(ol.format.KML.writeScaleTextNode_)});
ol.format.KML.LINE_STYLE_SEQUENCE_ = ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_, ["color", "width"]);
ol.format.KML.LINE_STYLE_SERIALIZERS_ = ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_, {"color":ol.xml.makeChildAppender(ol.format.KML.writeColorTextNode_), "width":ol.xml.makeChildAppender(ol.format.XSD.writeDecimalTextNode)});
ol.format.KML.BOUNDARY_IS_SERIALIZERS_ = ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_, {"LinearRing":ol.xml.makeChildAppender(ol.format.KML.writePrimitiveGeometry_)});
ol.format.KML.MULTI_GEOMETRY_SERIALIZERS_ = ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_, {"LineString":ol.xml.makeChildAppender(ol.format.KML.writePrimitiveGeometry_), "Point":ol.xml.makeChildAppender(ol.format.KML.writePrimitiveGeometry_), "Polygon":ol.xml.makeChildAppender(ol.format.KML.writePolygon_), "GeometryCollection":ol.xml.makeChildAppender(ol.format.KML.writeMultiGeometry_)});
ol.format.KML.PLACEMARK_SEQUENCE_ = ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_, ["name", "open", "visibility", "address", "phoneNumber", "description", "styleUrl", "Style"]);
ol.format.KML.PLACEMARK_SERIALIZERS_ = ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_, {"ExtendedData":ol.xml.makeChildAppender(ol.format.KML.writeExtendedData_), "MultiGeometry":ol.xml.makeChildAppender(ol.format.KML.writeMultiGeometry_), "LineString":ol.xml.makeChildAppender(ol.format.KML.writePrimitiveGeometry_), "LinearRing":ol.xml.makeChildAppender(ol.format.KML.writePrimitiveGeometry_), "Point":ol.xml.makeChildAppender(ol.format.KML.writePrimitiveGeometry_), "Polygon":ol.xml.makeChildAppender(ol.format.KML.writePolygon_), 
"Style":ol.xml.makeChildAppender(ol.format.KML.writeStyle_), "address":ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode), "description":ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode), "name":ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode), "open":ol.xml.makeChildAppender(ol.format.XSD.writeBooleanTextNode), "phoneNumber":ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode), "styleUrl":ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode), "visibility":ol.xml.makeChildAppender(ol.format.XSD.writeBooleanTextNode)});
ol.format.KML.PRIMITIVE_GEOMETRY_SEQUENCE_ = ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_, ["extrude", "tessellate", "altitudeMode", "coordinates"]);
ol.format.KML.PRIMITIVE_GEOMETRY_SERIALIZERS_ = ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_, {"extrude":ol.xml.makeChildAppender(ol.format.XSD.writeBooleanTextNode), "tessellate":ol.xml.makeChildAppender(ol.format.XSD.writeBooleanTextNode), "altitudeMode":ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode), "coordinates":ol.xml.makeChildAppender(ol.format.KML.writeCoordinatesTextNode_)});
ol.format.KML.POLYGON_SERIALIZERS_ = ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_, {"outerBoundaryIs":ol.xml.makeChildAppender(ol.format.KML.writeBoundaryIs_), "innerBoundaryIs":ol.xml.makeChildAppender(ol.format.KML.writeBoundaryIs_)});
ol.format.KML.POLY_STYLE_SERIALIZERS_ = ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_, {"color":ol.xml.makeChildAppender(ol.format.KML.writeColorTextNode_)});
ol.format.KML.STYLE_SEQUENCE_ = ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_, ["IconStyle", "LabelStyle", "LineStyle", "PolyStyle"]);
ol.format.KML.STYLE_SERIALIZERS_ = ol.xml.makeStructureNS(ol.format.KML.NAMESPACE_URIS_, {"IconStyle":ol.xml.makeChildAppender(ol.format.KML.writeIconStyle_), "LabelStyle":ol.xml.makeChildAppender(ol.format.KML.writeLabelStyle_), "LineStyle":ol.xml.makeChildAppender(ol.format.KML.writeLineStyle_), "PolyStyle":ol.xml.makeChildAppender(ol.format.KML.writePolyStyle_)});
ol.format.KML.GX_NODE_FACTORY_ = function(value, objectStack, opt_nodeName) {
  return ol.xml.createElementNS(ol.format.KML.GX_NAMESPACE_URIS_[0], "gx:" + opt_nodeName);
};
ol.format.KML.DOCUMENT_NODE_FACTORY_ = function(value, objectStack, opt_nodeName) {
  var parentNode = objectStack[objectStack.length - 1].node;
  return ol.xml.createElementNS(parentNode.namespaceURI, "Placemark");
};
ol.format.KML.GEOMETRY_NODE_FACTORY_ = function(value, objectStack, opt_nodeName) {
  if (value) {
    var parentNode = objectStack[objectStack.length - 1].node;
    return ol.xml.createElementNS(parentNode.namespaceURI, ol.format.KML.GEOMETRY_TYPE_TO_NODENAME_[value.getType()]);
  }
};
ol.format.KML.COLOR_NODE_FACTORY_ = ol.xml.makeSimpleNodeFactory("color");
ol.format.KML.DATA_NODE_FACTORY_ = ol.xml.makeSimpleNodeFactory("Data");
ol.format.KML.EXTENDEDDATA_NODE_FACTORY_ = ol.xml.makeSimpleNodeFactory("ExtendedData");
ol.format.KML.INNER_BOUNDARY_NODE_FACTORY_ = ol.xml.makeSimpleNodeFactory("innerBoundaryIs");
ol.format.KML.POINT_NODE_FACTORY_ = ol.xml.makeSimpleNodeFactory("Point");
ol.format.KML.LINE_STRING_NODE_FACTORY_ = ol.xml.makeSimpleNodeFactory("LineString");
ol.format.KML.LINEAR_RING_NODE_FACTORY_ = ol.xml.makeSimpleNodeFactory("LinearRing");
ol.format.KML.POLYGON_NODE_FACTORY_ = ol.xml.makeSimpleNodeFactory("Polygon");
ol.format.KML.OUTER_BOUNDARY_NODE_FACTORY_ = ol.xml.makeSimpleNodeFactory("outerBoundaryIs");
ol.format.KML.prototype.writeFeatures;
ol.format.KML.prototype.writeFeaturesNode = function(features, opt_options) {
  opt_options = this.adaptOptions(opt_options);
  var kml = ol.xml.createElementNS(ol.format.KML.NAMESPACE_URIS_[4], "kml");
  var xmlnsUri = "http://www.w3.org/2000/xmlns/";
  var xmlSchemaInstanceUri = "http://www.w3.org/2001/XMLSchema-instance";
  ol.xml.setAttributeNS(kml, xmlnsUri, "xmlns:gx", ol.format.KML.GX_NAMESPACE_URIS_[0]);
  ol.xml.setAttributeNS(kml, xmlnsUri, "xmlns:xsi", xmlSchemaInstanceUri);
  ol.xml.setAttributeNS(kml, xmlSchemaInstanceUri, "xsi:schemaLocation", ol.format.KML.SCHEMA_LOCATION_);
  var context = {node:kml};
  var properties = {};
  if (features.length > 1) {
    properties["Document"] = features;
  } else {
    if (features.length == 1) {
      properties["Placemark"] = features[0];
    }
  }
  var orderedKeys = ol.format.KML.KML_SEQUENCE_[kml.namespaceURI];
  var values = ol.xml.makeSequence(properties, orderedKeys);
  ol.xml.pushSerializeAndPop(context, ol.format.KML.KML_SERIALIZERS_, ol.xml.OBJECT_PROPERTY_NODE_FACTORY, values, [opt_options], orderedKeys, this);
  return kml;
};
goog.provide("ol.ext.PBF");
ol.ext.PBF = function() {
};
(function() {
  (function(exports) {
    var read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else {
        if (e === eMax) {
          return m ? NaN : (s ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    var write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else {
          if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer[offset + i - d] |= s * 128;
    };
    var ieee754 = {read:read, write:write};
    var pbf = Pbf;
    function Pbf(buf) {
      this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);
      this.pos = 0;
      this.type = 0;
      this.length = this.buf.length;
    }
    Pbf.Varint = 0;
    Pbf.Fixed64 = 1;
    Pbf.Bytes = 2;
    Pbf.Fixed32 = 5;
    var SHIFT_LEFT_32 = (1 << 16) * (1 << 16);
    var SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;
    Pbf.prototype = {destroy:function() {
      this.buf = null;
    }, readFields:function(readField, result, end) {
      end = end || this.length;
      while (this.pos < end) {
        var val = this.readVarint(), tag = val >> 3, startPos = this.pos;
        this.type = val & 7;
        readField(tag, result, this);
        if (this.pos === startPos) {
          this.skip(val);
        }
      }
      return result;
    }, readMessage:function(readField, result) {
      return this.readFields(readField, result, this.readVarint() + this.pos);
    }, readFixed32:function() {
      var val = readUInt32(this.buf, this.pos);
      this.pos += 4;
      return val;
    }, readSFixed32:function() {
      var val = readInt32(this.buf, this.pos);
      this.pos += 4;
      return val;
    }, readFixed64:function() {
      var val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
      this.pos += 8;
      return val;
    }, readSFixed64:function() {
      var val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
      this.pos += 8;
      return val;
    }, readFloat:function() {
      var val = ieee754.read(this.buf, this.pos, true, 23, 4);
      this.pos += 4;
      return val;
    }, readDouble:function() {
      var val = ieee754.read(this.buf, this.pos, true, 52, 8);
      this.pos += 8;
      return val;
    }, readVarint:function(isSigned) {
      var buf = this.buf, val, b;
      b = buf[this.pos++];
      val = b & 127;
      if (b < 128) {
        return val;
      }
      b = buf[this.pos++];
      val |= (b & 127) << 7;
      if (b < 128) {
        return val;
      }
      b = buf[this.pos++];
      val |= (b & 127) << 14;
      if (b < 128) {
        return val;
      }
      b = buf[this.pos++];
      val |= (b & 127) << 21;
      if (b < 128) {
        return val;
      }
      b = buf[this.pos];
      val |= (b & 15) << 28;
      return readVarintRemainder(val, isSigned, this);
    }, readVarint64:function() {
      return this.readVarint(true);
    }, readSVarint:function() {
      var num = this.readVarint();
      return num % 2 === 1 ? (num + 1) / -2 : num / 2;
    }, readBoolean:function() {
      return Boolean(this.readVarint());
    }, readString:function() {
      var end = this.readVarint() + this.pos, str = readUtf8(this.buf, this.pos, end);
      this.pos = end;
      return str;
    }, readBytes:function() {
      var end = this.readVarint() + this.pos, buffer = this.buf.subarray(this.pos, end);
      this.pos = end;
      return buffer;
    }, readPackedVarint:function(arr, isSigned) {
      var end = readPackedEnd(this);
      arr = arr || [];
      while (this.pos < end) {
        arr.push(this.readVarint(isSigned));
      }
      return arr;
    }, readPackedSVarint:function(arr) {
      var end = readPackedEnd(this);
      arr = arr || [];
      while (this.pos < end) {
        arr.push(this.readSVarint());
      }
      return arr;
    }, readPackedBoolean:function(arr) {
      var end = readPackedEnd(this);
      arr = arr || [];
      while (this.pos < end) {
        arr.push(this.readBoolean());
      }
      return arr;
    }, readPackedFloat:function(arr) {
      var end = readPackedEnd(this);
      arr = arr || [];
      while (this.pos < end) {
        arr.push(this.readFloat());
      }
      return arr;
    }, readPackedDouble:function(arr) {
      var end = readPackedEnd(this);
      arr = arr || [];
      while (this.pos < end) {
        arr.push(this.readDouble());
      }
      return arr;
    }, readPackedFixed32:function(arr) {
      var end = readPackedEnd(this);
      arr = arr || [];
      while (this.pos < end) {
        arr.push(this.readFixed32());
      }
      return arr;
    }, readPackedSFixed32:function(arr) {
      var end = readPackedEnd(this);
      arr = arr || [];
      while (this.pos < end) {
        arr.push(this.readSFixed32());
      }
      return arr;
    }, readPackedFixed64:function(arr) {
      var end = readPackedEnd(this);
      arr = arr || [];
      while (this.pos < end) {
        arr.push(this.readFixed64());
      }
      return arr;
    }, readPackedSFixed64:function(arr) {
      var end = readPackedEnd(this);
      arr = arr || [];
      while (this.pos < end) {
        arr.push(this.readSFixed64());
      }
      return arr;
    }, skip:function(val) {
      var type = val & 7;
      if (type === Pbf.Varint) {
        while (this.buf[this.pos++] > 127) {
        }
      } else {
        if (type === Pbf.Bytes) {
          this.pos = this.readVarint() + this.pos;
        } else {
          if (type === Pbf.Fixed32) {
            this.pos += 4;
          } else {
            if (type === Pbf.Fixed64) {
              this.pos += 8;
            } else {
              throw new Error("Unimplemented type: " + type);
            }
          }
        }
      }
    }, writeTag:function(tag, type) {
      this.writeVarint(tag << 3 | type);
    }, realloc:function(min) {
      var length = this.length || 16;
      while (length < this.pos + min) {
        length *= 2;
      }
      if (length !== this.length) {
        var buf = new Uint8Array(length);
        buf.set(this.buf);
        this.buf = buf;
        this.length = length;
      }
    }, finish:function() {
      this.length = this.pos;
      this.pos = 0;
      return this.buf.subarray(0, this.length);
    }, writeFixed32:function(val) {
      this.realloc(4);
      writeInt32(this.buf, val, this.pos);
      this.pos += 4;
    }, writeSFixed32:function(val) {
      this.realloc(4);
      writeInt32(this.buf, val, this.pos);
      this.pos += 4;
    }, writeFixed64:function(val) {
      this.realloc(8);
      writeInt32(this.buf, val & -1, this.pos);
      writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
      this.pos += 8;
    }, writeSFixed64:function(val) {
      this.realloc(8);
      writeInt32(this.buf, val & -1, this.pos);
      writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
      this.pos += 8;
    }, writeVarint:function(val) {
      val = +val || 0;
      if (val > 268435455 || val < 0) {
        writeBigVarint(val, this);
        return;
      }
      this.realloc(4);
      this.buf[this.pos++] = val & 127 | (val > 127 ? 128 : 0);
      if (val <= 127) {
        return;
      }
      this.buf[this.pos++] = (val >>>= 7) & 127 | (val > 127 ? 128 : 0);
      if (val <= 127) {
        return;
      }
      this.buf[this.pos++] = (val >>>= 7) & 127 | (val > 127 ? 128 : 0);
      if (val <= 127) {
        return;
      }
      this.buf[this.pos++] = val >>> 7 & 127;
    }, writeSVarint:function(val) {
      this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
    }, writeBoolean:function(val) {
      this.writeVarint(Boolean(val));
    }, writeString:function(str) {
      str = String(str);
      this.realloc(str.length * 4);
      this.pos++;
      var startPos = this.pos;
      this.pos = writeUtf8(this.buf, str, this.pos);
      var len = this.pos - startPos;
      if (len >= 128) {
        makeRoomForExtraLength(startPos, len, this);
      }
      this.pos = startPos - 1;
      this.writeVarint(len);
      this.pos += len;
    }, writeFloat:function(val) {
      this.realloc(4);
      ieee754.write(this.buf, val, this.pos, true, 23, 4);
      this.pos += 4;
    }, writeDouble:function(val) {
      this.realloc(8);
      ieee754.write(this.buf, val, this.pos, true, 52, 8);
      this.pos += 8;
    }, writeBytes:function(buffer) {
      var len = buffer.length;
      this.writeVarint(len);
      this.realloc(len);
      for (var i = 0; i < len; i++) {
        this.buf[this.pos++] = buffer[i];
      }
    }, writeRawMessage:function(fn, obj) {
      this.pos++;
      var startPos = this.pos;
      fn(obj, this);
      var len = this.pos - startPos;
      if (len >= 128) {
        makeRoomForExtraLength(startPos, len, this);
      }
      this.pos = startPos - 1;
      this.writeVarint(len);
      this.pos += len;
    }, writeMessage:function(tag, fn, obj) {
      this.writeTag(tag, Pbf.Bytes);
      this.writeRawMessage(fn, obj);
    }, writePackedVarint:function(tag, arr) {
      this.writeMessage(tag, writePackedVarint, arr);
    }, writePackedSVarint:function(tag, arr) {
      this.writeMessage(tag, writePackedSVarint, arr);
    }, writePackedBoolean:function(tag, arr) {
      this.writeMessage(tag, writePackedBoolean, arr);
    }, writePackedFloat:function(tag, arr) {
      this.writeMessage(tag, writePackedFloat, arr);
    }, writePackedDouble:function(tag, arr) {
      this.writeMessage(tag, writePackedDouble, arr);
    }, writePackedFixed32:function(tag, arr) {
      this.writeMessage(tag, writePackedFixed32, arr);
    }, writePackedSFixed32:function(tag, arr) {
      this.writeMessage(tag, writePackedSFixed32, arr);
    }, writePackedFixed64:function(tag, arr) {
      this.writeMessage(tag, writePackedFixed64, arr);
    }, writePackedSFixed64:function(tag, arr) {
      this.writeMessage(tag, writePackedSFixed64, arr);
    }, writeBytesField:function(tag, buffer) {
      this.writeTag(tag, Pbf.Bytes);
      this.writeBytes(buffer);
    }, writeFixed32Field:function(tag, val) {
      this.writeTag(tag, Pbf.Fixed32);
      this.writeFixed32(val);
    }, writeSFixed32Field:function(tag, val) {
      this.writeTag(tag, Pbf.Fixed32);
      this.writeSFixed32(val);
    }, writeFixed64Field:function(tag, val) {
      this.writeTag(tag, Pbf.Fixed64);
      this.writeFixed64(val);
    }, writeSFixed64Field:function(tag, val) {
      this.writeTag(tag, Pbf.Fixed64);
      this.writeSFixed64(val);
    }, writeVarintField:function(tag, val) {
      this.writeTag(tag, Pbf.Varint);
      this.writeVarint(val);
    }, writeSVarintField:function(tag, val) {
      this.writeTag(tag, Pbf.Varint);
      this.writeSVarint(val);
    }, writeStringField:function(tag, str) {
      this.writeTag(tag, Pbf.Bytes);
      this.writeString(str);
    }, writeFloatField:function(tag, val) {
      this.writeTag(tag, Pbf.Fixed32);
      this.writeFloat(val);
    }, writeDoubleField:function(tag, val) {
      this.writeTag(tag, Pbf.Fixed64);
      this.writeDouble(val);
    }, writeBooleanField:function(tag, val) {
      this.writeVarintField(tag, Boolean(val));
    }};
    function readVarintRemainder(l, s, p) {
      var buf = p.buf, h, b;
      b = buf[p.pos++];
      h = (b & 112) >> 4;
      if (b < 128) {
        return toNum(l, h, s);
      }
      b = buf[p.pos++];
      h |= (b & 127) << 3;
      if (b < 128) {
        return toNum(l, h, s);
      }
      b = buf[p.pos++];
      h |= (b & 127) << 10;
      if (b < 128) {
        return toNum(l, h, s);
      }
      b = buf[p.pos++];
      h |= (b & 127) << 17;
      if (b < 128) {
        return toNum(l, h, s);
      }
      b = buf[p.pos++];
      h |= (b & 127) << 24;
      if (b < 128) {
        return toNum(l, h, s);
      }
      b = buf[p.pos++];
      h |= (b & 1) << 31;
      if (b < 128) {
        return toNum(l, h, s);
      }
      throw new Error("Expected varint not more than 10 bytes");
    }
    function readPackedEnd(pbf) {
      return pbf.type === Pbf.Bytes ? pbf.readVarint() + pbf.pos : pbf.pos + 1;
    }
    function toNum(low, high, isSigned) {
      if (isSigned) {
        return high * 4294967296 + (low >>> 0);
      }
      return (high >>> 0) * 4294967296 + (low >>> 0);
    }
    function writeBigVarint(val, pbf) {
      var low, high;
      if (val >= 0) {
        low = val % 4294967296 | 0;
        high = val / 4294967296 | 0;
      } else {
        low = ~(-val % 4294967296);
        high = ~(-val / 4294967296);
        if (low ^ 4294967295) {
          low = low + 1 | 0;
        } else {
          low = 0;
          high = high + 1 | 0;
        }
      }
      if (val >= 1.8446744073709552E19 || val < -1.8446744073709552E19) {
        throw new Error("Given varint doesn't fit into 10 bytes");
      }
      pbf.realloc(10);
      writeBigVarintLow(low, high, pbf);
      writeBigVarintHigh(high, pbf);
    }
    function writeBigVarintLow(low, high, pbf) {
      pbf.buf[pbf.pos++] = low & 127 | 128;
      low >>>= 7;
      pbf.buf[pbf.pos++] = low & 127 | 128;
      low >>>= 7;
      pbf.buf[pbf.pos++] = low & 127 | 128;
      low >>>= 7;
      pbf.buf[pbf.pos++] = low & 127 | 128;
      low >>>= 7;
      pbf.buf[pbf.pos] = low & 127;
    }
    function writeBigVarintHigh(high, pbf) {
      var lsb = (high & 7) << 4;
      pbf.buf[pbf.pos++] |= lsb | ((high >>>= 3) ? 128 : 0);
      if (!high) {
        return;
      }
      pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
      if (!high) {
        return;
      }
      pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
      if (!high) {
        return;
      }
      pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
      if (!high) {
        return;
      }
      pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
      if (!high) {
        return;
      }
      pbf.buf[pbf.pos++] = high & 127;
    }
    function makeRoomForExtraLength(startPos, len, pbf) {
      var extraLen = len <= 16383 ? 1 : len <= 2097151 ? 2 : len <= 268435455 ? 3 : Math.ceil(Math.log(len) / (Math.LN2 * 7));
      pbf.realloc(extraLen);
      for (var i = pbf.pos - 1; i >= startPos; i--) {
        pbf.buf[i + extraLen] = pbf.buf[i];
      }
    }
    function writePackedVarint(arr, pbf) {
      for (var i = 0; i < arr.length; i++) {
        pbf.writeVarint(arr[i]);
      }
    }
    function writePackedSVarint(arr, pbf) {
      for (var i = 0; i < arr.length; i++) {
        pbf.writeSVarint(arr[i]);
      }
    }
    function writePackedFloat(arr, pbf) {
      for (var i = 0; i < arr.length; i++) {
        pbf.writeFloat(arr[i]);
      }
    }
    function writePackedDouble(arr, pbf) {
      for (var i = 0; i < arr.length; i++) {
        pbf.writeDouble(arr[i]);
      }
    }
    function writePackedBoolean(arr, pbf) {
      for (var i = 0; i < arr.length; i++) {
        pbf.writeBoolean(arr[i]);
      }
    }
    function writePackedFixed32(arr, pbf) {
      for (var i = 0; i < arr.length; i++) {
        pbf.writeFixed32(arr[i]);
      }
    }
    function writePackedSFixed32(arr, pbf) {
      for (var i = 0; i < arr.length; i++) {
        pbf.writeSFixed32(arr[i]);
      }
    }
    function writePackedFixed64(arr, pbf) {
      for (var i = 0; i < arr.length; i++) {
        pbf.writeFixed64(arr[i]);
      }
    }
    function writePackedSFixed64(arr, pbf) {
      for (var i = 0; i < arr.length; i++) {
        pbf.writeSFixed64(arr[i]);
      }
    }
    function readUInt32(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + buf[pos + 3] * 16777216;
    }
    function writeInt32(buf, val, pos) {
      buf[pos] = val;
      buf[pos + 1] = val >>> 8;
      buf[pos + 2] = val >>> 16;
      buf[pos + 3] = val >>> 24;
    }
    function readInt32(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + (buf[pos + 3] << 24);
    }
    function readUtf8(buf, pos, end) {
      var str = "";
      var i = pos;
      while (i < end) {
        var b0 = buf[i];
        var c = null;
        var bytesPerSequence = b0 > 239 ? 4 : b0 > 223 ? 3 : b0 > 191 ? 2 : 1;
        if (i + bytesPerSequence > end) {
          break;
        }
        var b1, b2, b3;
        if (bytesPerSequence === 1) {
          if (b0 < 128) {
            c = b0;
          }
        } else {
          if (bytesPerSequence === 2) {
            b1 = buf[i + 1];
            if ((b1 & 192) === 128) {
              c = (b0 & 31) << 6 | b1 & 63;
              if (c <= 127) {
                c = null;
              }
            }
          } else {
            if (bytesPerSequence === 3) {
              b1 = buf[i + 1];
              b2 = buf[i + 2];
              if ((b1 & 192) === 128 && (b2 & 192) === 128) {
                c = (b0 & 15) << 12 | (b1 & 63) << 6 | b2 & 63;
                if (c <= 2047 || c >= 55296 && c <= 57343) {
                  c = null;
                }
              }
            } else {
              if (bytesPerSequence === 4) {
                b1 = buf[i + 1];
                b2 = buf[i + 2];
                b3 = buf[i + 3];
                if ((b1 & 192) === 128 && (b2 & 192) === 128 && (b3 & 192) === 128) {
                  c = (b0 & 15) << 18 | (b1 & 63) << 12 | (b2 & 63) << 6 | b3 & 63;
                  if (c <= 65535 || c >= 1114112) {
                    c = null;
                  }
                }
              }
            }
          }
        }
        if (c === null) {
          c = 65533;
          bytesPerSequence = 1;
        } else {
          if (c > 65535) {
            c -= 65536;
            str += String.fromCharCode(c >>> 10 & 1023 | 55296);
            c = 56320 | c & 1023;
          }
        }
        str += String.fromCharCode(c);
        i += bytesPerSequence;
      }
      return str;
    }
    function writeUtf8(buf, str, pos) {
      for (var i = 0, c, lead; i < str.length; i++) {
        c = str.charCodeAt(i);
        if (c > 55295 && c < 57344) {
          if (lead) {
            if (c < 56320) {
              buf[pos++] = 239;
              buf[pos++] = 191;
              buf[pos++] = 189;
              lead = c;
              continue;
            } else {
              c = lead - 55296 << 10 | c - 56320 | 65536;
              lead = null;
            }
          } else {
            if (c > 56319 || i + 1 === str.length) {
              buf[pos++] = 239;
              buf[pos++] = 191;
              buf[pos++] = 189;
            } else {
              lead = c;
            }
            continue;
          }
        } else {
          if (lead) {
            buf[pos++] = 239;
            buf[pos++] = 191;
            buf[pos++] = 189;
            lead = null;
          }
        }
        if (c < 128) {
          buf[pos++] = c;
        } else {
          if (c < 2048) {
            buf[pos++] = c >> 6 | 192;
          } else {
            if (c < 65536) {
              buf[pos++] = c >> 12 | 224;
            } else {
              buf[pos++] = c >> 18 | 240;
              buf[pos++] = c >> 12 & 63 | 128;
            }
            buf[pos++] = c >> 6 & 63 | 128;
          }
          buf[pos++] = c & 63 | 128;
        }
      }
      return pos;
    }
    exports["default"] = pbf;
  })(this.PBF = this.PBF || {});
}).call(ol.ext);
ol.ext.PBF = ol.ext.PBF.default;
goog.provide("ol.render.Feature");
goog.require("ol");
goog.require("ol.array");
goog.require("ol.extent");
goog.require("ol.geom.GeometryType");
goog.require("ol.geom.flat.center");
goog.require("ol.geom.flat.interiorpoint");
goog.require("ol.geom.flat.interpolate");
goog.require("ol.geom.flat.transform");
goog.require("ol.transform");
ol.render.Feature = function(type, flatCoordinates, ends, properties, id) {
  this.extent_;
  this.id_ = id;
  this.type_ = type;
  this.flatCoordinates_ = flatCoordinates;
  this.flatInteriorPoints_ = null;
  this.flatMidpoints_ = null;
  this.ends_ = ends;
  this.properties_ = properties;
  this.tmpTransform_ = ol.transform.create();
};
ol.render.Feature.prototype.get = function(key) {
  return this.properties_[key];
};
ol.render.Feature.prototype.getEnds = ol.render.Feature.prototype.getEndss = function() {
  return this.ends_;
};
ol.render.Feature.prototype.getExtent = function() {
  if (!this.extent_) {
    this.extent_ = this.type_ === ol.geom.GeometryType.POINT ? ol.extent.createOrUpdateFromCoordinate(this.flatCoordinates_) : ol.extent.createOrUpdateFromFlatCoordinates(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2);
  }
  return this.extent_;
};
ol.render.Feature.prototype.getFlatInteriorPoint = function() {
  if (!this.flatInteriorPoints_) {
    var flatCenter = ol.extent.getCenter(this.getExtent());
    this.flatInteriorPoints_ = ol.geom.flat.interiorpoint.linearRings(this.flatCoordinates_, 0, this.ends_, 2, flatCenter, 0);
  }
  return this.flatInteriorPoints_;
};
ol.render.Feature.prototype.getFlatInteriorPoints = function() {
  if (!this.flatInteriorPoints_) {
    var flatCenters = ol.geom.flat.center.linearRingss(this.flatCoordinates_, 0, this.ends_, 2);
    this.flatInteriorPoints_ = ol.geom.flat.interiorpoint.linearRingss(this.flatCoordinates_, 0, this.ends_, 2, flatCenters);
  }
  return this.flatInteriorPoints_;
};
ol.render.Feature.prototype.getFlatMidpoint = function() {
  if (!this.flatMidpoints_) {
    this.flatMidpoints_ = ol.geom.flat.interpolate.lineString(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, 0.5);
  }
  return this.flatMidpoints_;
};
ol.render.Feature.prototype.getFlatMidpoints = function() {
  if (!this.flatMidpoints_) {
    this.flatMidpoints_ = [];
    var flatCoordinates = this.flatCoordinates_;
    var offset = 0;
    var ends = this.ends_;
    for (var i = 0, ii = ends.length; i < ii; ++i) {
      var end = ends[i];
      var midpoint = ol.geom.flat.interpolate.lineString(flatCoordinates, offset, end, 2, 0.5);
      ol.array.extend(this.flatMidpoints_, midpoint);
      offset = end;
    }
  }
  return this.flatMidpoints_;
};
ol.render.Feature.prototype.getId = function() {
  return this.id_;
};
ol.render.Feature.prototype.getOrientedFlatCoordinates = function() {
  return this.flatCoordinates_;
};
ol.render.Feature.prototype.getFlatCoordinates = ol.render.Feature.prototype.getOrientedFlatCoordinates;
ol.render.Feature.prototype.getGeometry = function() {
  return this;
};
ol.render.Feature.prototype.getProperties = function() {
  return this.properties_;
};
ol.render.Feature.prototype.getSimplifiedGeometry = ol.render.Feature.prototype.getGeometry;
ol.render.Feature.prototype.getStride = function() {
  return 2;
};
ol.render.Feature.prototype.getStyleFunction = ol.nullFunction;
ol.render.Feature.prototype.getType = function() {
  return this.type_;
};
ol.render.Feature.prototype.transform = function(source, destination) {
  var pixelExtent = source.getExtent();
  var projectedExtent = source.getWorldExtent();
  var scale = ol.extent.getHeight(projectedExtent) / ol.extent.getHeight(pixelExtent);
  var transform = this.tmpTransform_;
  ol.transform.compose(transform, projectedExtent[0], projectedExtent[3], scale, -scale, 0, 0, 0);
  ol.geom.flat.transform.transform2D(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, transform, this.flatCoordinates_);
};
goog.provide("ol.format.MVT");
goog.require("ol");
goog.require("ol.asserts");
goog.require("ol.ext.PBF");
goog.require("ol.format.Feature");
goog.require("ol.format.FormatType");
goog.require("ol.geom.GeometryLayout");
goog.require("ol.geom.GeometryType");
goog.require("ol.geom.LineString");
goog.require("ol.geom.MultiLineString");
goog.require("ol.geom.MultiPoint");
goog.require("ol.geom.MultiPolygon");
goog.require("ol.geom.Point");
goog.require("ol.geom.Polygon");
goog.require("ol.geom.flat.orient");
goog.require("ol.proj.Projection");
goog.require("ol.proj.Units");
goog.require("ol.render.Feature");
ol.format.MVT = function(opt_options) {
  ol.format.Feature.call(this);
  var options = opt_options ? opt_options : {};
  this.defaultDataProjection = new ol.proj.Projection({code:"EPSG:3857", units:ol.proj.Units.TILE_PIXELS});
  this.featureClass_ = options.featureClass ? options.featureClass : ol.render.Feature;
  this.geometryName_ = options.geometryName;
  this.layerName_ = options.layerName ? options.layerName : "layer";
  this.layers_ = options.layers ? options.layers : null;
  this.extent_ = null;
};
ol.inherits(ol.format.MVT, ol.format.Feature);
ol.format.MVT.pbfReaders_ = {layers:function(tag, layers, pbf) {
  if (tag === 3) {
    var layer = {keys:[], values:[], features:[]};
    var end = pbf.readVarint() + pbf.pos;
    pbf.readFields(ol.format.MVT.pbfReaders_.layer, layer, end);
    layer.length = layer.features.length;
    if (layer.length) {
      layers[layer.name] = layer;
    }
  }
}, layer:function(tag, layer, pbf) {
  if (tag === 15) {
    layer.version = pbf.readVarint();
  } else {
    if (tag === 1) {
      layer.name = pbf.readString();
    } else {
      if (tag === 5) {
        layer.extent = pbf.readVarint();
      } else {
        if (tag === 2) {
          layer.features.push(pbf.pos);
        } else {
          if (tag === 3) {
            layer.keys.push(pbf.readString());
          } else {
            if (tag === 4) {
              var value = null;
              var end = pbf.readVarint() + pbf.pos;
              while (pbf.pos < end) {
                tag = pbf.readVarint() >> 3;
                value = tag === 1 ? pbf.readString() : tag === 2 ? pbf.readFloat() : tag === 3 ? pbf.readDouble() : tag === 4 ? pbf.readVarint64() : tag === 5 ? pbf.readVarint() : tag === 6 ? pbf.readSVarint() : tag === 7 ? pbf.readBoolean() : null;
              }
              layer.values.push(value);
            }
          }
        }
      }
    }
  }
}, feature:function(tag, feature, pbf) {
  if (tag == 1) {
    feature.id = pbf.readVarint();
  } else {
    if (tag == 2) {
      var end = pbf.readVarint() + pbf.pos;
      while (pbf.pos < end) {
        var key = feature.layer.keys[pbf.readVarint()];
        var value = feature.layer.values[pbf.readVarint()];
        feature.properties[key] = value;
      }
    } else {
      if (tag == 3) {
        feature.type = pbf.readVarint();
      } else {
        if (tag == 4) {
          feature.geometry = pbf.pos;
        }
      }
    }
  }
}};
ol.format.MVT.readRawFeature_ = function(pbf, layer, i) {
  pbf.pos = layer.features[i];
  var end = pbf.readVarint() + pbf.pos;
  var feature = {layer:layer, type:0, properties:{}};
  pbf.readFields(ol.format.MVT.pbfReaders_.feature, feature, end);
  return feature;
};
ol.format.MVT.readRawGeometry_ = function(pbf, feature, flatCoordinates, ends) {
  pbf.pos = feature.geometry;
  var end = pbf.readVarint() + pbf.pos;
  var cmd = 1;
  var length = 0;
  var x = 0;
  var y = 0;
  var coordsLen = 0;
  var currentEnd = 0;
  while (pbf.pos < end) {
    if (!length) {
      var cmdLen = pbf.readVarint();
      cmd = cmdLen & 7;
      length = cmdLen >> 3;
    }
    length--;
    if (cmd === 1 || cmd === 2) {
      x += pbf.readSVarint();
      y += pbf.readSVarint();
      if (cmd === 1) {
        if (coordsLen > currentEnd) {
          ends.push(coordsLen);
          currentEnd = coordsLen;
        }
      }
      flatCoordinates.push(x, y);
      coordsLen += 2;
    } else {
      if (cmd === 7) {
        if (coordsLen > currentEnd) {
          flatCoordinates.push(flatCoordinates[currentEnd], flatCoordinates[currentEnd + 1]);
          coordsLen += 2;
        }
      } else {
        ol.asserts.assert(false, 59);
      }
    }
  }
  if (coordsLen > currentEnd) {
    ends.push(coordsLen);
    currentEnd = coordsLen;
  }
};
ol.format.MVT.getGeometryType_ = function(type, numEnds) {
  var geometryType;
  if (type === 1) {
    geometryType = numEnds === 1 ? ol.geom.GeometryType.POINT : ol.geom.GeometryType.MULTI_POINT;
  } else {
    if (type === 2) {
      geometryType = numEnds === 1 ? ol.geom.GeometryType.LINE_STRING : ol.geom.GeometryType.MULTI_LINE_STRING;
    } else {
      if (type === 3) {
        geometryType = ol.geom.GeometryType.POLYGON;
      }
    }
  }
  return geometryType;
};
ol.format.MVT.prototype.createFeature_ = function(pbf, rawFeature, opt_options) {
  var type = rawFeature.type;
  if (type === 0) {
    return null;
  }
  var feature;
  var id = rawFeature.id;
  var values = rawFeature.properties;
  values[this.layerName_] = rawFeature.layer.name;
  var flatCoordinates = [];
  var ends = [];
  ol.format.MVT.readRawGeometry_(pbf, rawFeature, flatCoordinates, ends);
  var geometryType = ol.format.MVT.getGeometryType_(type, ends.length);
  if (this.featureClass_ === ol.render.Feature) {
    feature = new this.featureClass_(geometryType, flatCoordinates, ends, values, id);
  } else {
    var geom;
    if (geometryType == ol.geom.GeometryType.POLYGON) {
      var endss = [];
      var offset = 0;
      var prevEndIndex = 0;
      for (var i = 0, ii = ends.length; i < ii; ++i) {
        var end = ends[i];
        if (!ol.geom.flat.orient.linearRingIsClockwise(flatCoordinates, offset, end, 2)) {
          endss.push(ends.slice(prevEndIndex, i));
          prevEndIndex = i;
        }
        offset = end;
      }
      if (endss.length > 1) {
        ends = endss;
        geom = new ol.geom.MultiPolygon(null);
      } else {
        geom = new ol.geom.Polygon(null);
      }
    } else {
      geom = geometryType === ol.geom.GeometryType.POINT ? new ol.geom.Point(null) : geometryType === ol.geom.GeometryType.LINE_STRING ? new ol.geom.LineString(null) : geometryType === ol.geom.GeometryType.POLYGON ? new ol.geom.Polygon(null) : geometryType === ol.geom.GeometryType.MULTI_POINT ? new ol.geom.MultiPoint(null) : geometryType === ol.geom.GeometryType.MULTI_LINE_STRING ? new ol.geom.MultiLineString(null) : null;
    }
    geom.setFlatCoordinates(ol.geom.GeometryLayout.XY, flatCoordinates, ends);
    feature = new this.featureClass_;
    if (this.geometryName_) {
      feature.setGeometryName(this.geometryName_);
    }
    var geometry = ol.format.Feature.transformWithOptions(geom, false, this.adaptOptions(opt_options));
    feature.setGeometry(geometry);
    feature.setId(id);
    feature.setProperties(values);
  }
  return feature;
};
ol.format.MVT.prototype.getLastExtent = function() {
  return this.extent_;
};
ol.format.MVT.prototype.getType = function() {
  return ol.format.FormatType.ARRAY_BUFFER;
};
ol.format.MVT.prototype.readFeatures = function(source, opt_options) {
  var layers = this.layers_;
  var pbf = new ol.ext.PBF(source);
  var pbfLayers = pbf.readFields(ol.format.MVT.pbfReaders_.layers, {});
  var features = [];
  var pbfLayer;
  for (var name in pbfLayers) {
    if (layers && layers.indexOf(name) == -1) {
      continue;
    }
    pbfLayer = pbfLayers[name];
    var rawFeature;
    for (var i = 0, ii = pbfLayer.length; i < ii; ++i) {
      rawFeature = ol.format.MVT.readRawFeature_(pbf, pbfLayer, i);
      features.push(this.createFeature_(pbf, rawFeature));
    }
    this.extent_ = pbfLayer ? [0, 0, pbfLayer.extent, pbfLayer.extent] : null;
  }
  return features;
};
ol.format.MVT.prototype.readProjection = function(source) {
  return this.defaultDataProjection;
};
ol.format.MVT.prototype.setLayers = function(layers) {
  this.layers_ = layers;
};
ol.format.MVT.prototype.readFeature = function() {
};
ol.format.MVT.prototype.readGeometry = function() {
};
ol.format.MVT.prototype.writeFeature = function() {
};
ol.format.MVT.prototype.writeGeometry = function() {
};
ol.format.MVT.prototype.writeFeatures = function() {
};
goog.provide("ol.format.OSMXML");
goog.require("ol");
goog.require("ol.array");
goog.require("ol.Feature");
goog.require("ol.format.Feature");
goog.require("ol.format.XMLFeature");
goog.require("ol.geom.GeometryLayout");
goog.require("ol.geom.LineString");
goog.require("ol.geom.Point");
goog.require("ol.geom.Polygon");
goog.require("ol.obj");
goog.require("ol.proj");
goog.require("ol.xml");
ol.format.OSMXML = function() {
  ol.format.XMLFeature.call(this);
  this.defaultDataProjection = ol.proj.get("EPSG:4326");
};
ol.inherits(ol.format.OSMXML, ol.format.XMLFeature);
ol.format.OSMXML.readNode_ = function(node, objectStack) {
  var options = objectStack[0];
  var state = objectStack[objectStack.length - 1];
  var id = node.getAttribute("id");
  var coordinates = [parseFloat(node.getAttribute("lon")), parseFloat(node.getAttribute("lat"))];
  state.nodes[id] = coordinates;
  var values = ol.xml.pushParseAndPop({tags:{}}, ol.format.OSMXML.NODE_PARSERS_, node, objectStack);
  if (!ol.obj.isEmpty(values.tags)) {
    var geometry = new ol.geom.Point(coordinates);
    ol.format.Feature.transformWithOptions(geometry, false, options);
    var feature = new ol.Feature(geometry);
    feature.setId(id);
    feature.setProperties(values.tags);
    state.features.push(feature);
  }
};
ol.format.OSMXML.readWay_ = function(node, objectStack) {
  var id = node.getAttribute("id");
  var values = ol.xml.pushParseAndPop({id:id, ndrefs:[], tags:{}}, ol.format.OSMXML.WAY_PARSERS_, node, objectStack);
  var state = objectStack[objectStack.length - 1];
  state.ways.push(values);
};
ol.format.OSMXML.readNd_ = function(node, objectStack) {
  var values = objectStack[objectStack.length - 1];
  values.ndrefs.push(node.getAttribute("ref"));
};
ol.format.OSMXML.readTag_ = function(node, objectStack) {
  var values = objectStack[objectStack.length - 1];
  values.tags[node.getAttribute("k")] = node.getAttribute("v");
};
ol.format.OSMXML.NAMESPACE_URIS_ = [null];
ol.format.OSMXML.WAY_PARSERS_ = ol.xml.makeStructureNS(ol.format.OSMXML.NAMESPACE_URIS_, {"nd":ol.format.OSMXML.readNd_, "tag":ol.format.OSMXML.readTag_});
ol.format.OSMXML.PARSERS_ = ol.xml.makeStructureNS(ol.format.OSMXML.NAMESPACE_URIS_, {"node":ol.format.OSMXML.readNode_, "way":ol.format.OSMXML.readWay_});
ol.format.OSMXML.NODE_PARSERS_ = ol.xml.makeStructureNS(ol.format.OSMXML.NAMESPACE_URIS_, {"tag":ol.format.OSMXML.readTag_});
ol.format.OSMXML.prototype.readFeatures;
ol.format.OSMXML.prototype.readFeaturesFromNode = function(node, opt_options) {
  var options = this.getReadOptions(node, opt_options);
  if (node.localName == "osm") {
    var state = ol.xml.pushParseAndPop({nodes:{}, ways:[], features:[]}, ol.format.OSMXML.PARSERS_, node, [options]);
    for (var j = 0; j < state.ways.length; j++) {
      var values = state.ways[j];
      var flatCoordinates = [];
      for (var i = 0, ii = values.ndrefs.length; i < ii; i++) {
        var point = state.nodes[values.ndrefs[i]];
        ol.array.extend(flatCoordinates, point);
      }
      var geometry;
      if (values.ndrefs[0] == values.ndrefs[values.ndrefs.length - 1]) {
        geometry = new ol.geom.Polygon(null);
        geometry.setFlatCoordinates(ol.geom.GeometryLayout.XY, flatCoordinates, [flatCoordinates.length]);
      } else {
        geometry = new ol.geom.LineString(null);
        geometry.setFlatCoordinates(ol.geom.GeometryLayout.XY, flatCoordinates);
      }
      ol.format.Feature.transformWithOptions(geometry, false, options);
      var feature = new ol.Feature(geometry);
      feature.setId(values.id);
      feature.setProperties(values.tags);
      state.features.push(feature);
    }
    if (state.features) {
      return state.features;
    }
  }
  return [];
};
ol.format.OSMXML.prototype.readProjection;
ol.format.OSMXML.prototype.writeFeatureNode = function(feature, opt_options) {
};
ol.format.OSMXML.prototype.writeFeaturesNode = function(features, opt_options) {
};
ol.format.OSMXML.prototype.writeGeometryNode = function(geometry, opt_options) {
};
goog.provide("ol.format.XLink");
ol.format.XLink.NAMESPACE_URI = "http://www.w3.org/1999/xlink";
ol.format.XLink.readHref = function(node) {
  return node.getAttributeNS(ol.format.XLink.NAMESPACE_URI, "href");
};
goog.provide("ol.format.XML");
goog.require("ol.xml");
ol.format.XML = function() {
};
ol.format.XML.prototype.read = function(source) {
  if (ol.xml.isDocument(source)) {
    return this.readFromDocument(source);
  } else {
    if (ol.xml.isNode(source)) {
      return this.readFromNode(source);
    } else {
      if (typeof source === "string") {
        var doc = ol.xml.parse(source);
        return this.readFromDocument(doc);
      } else {
        return null;
      }
    }
  }
};
ol.format.XML.prototype.readFromDocument = function(doc) {
};
ol.format.XML.prototype.readFromNode = function(node) {
};
goog.provide("ol.format.OWS");
goog.require("ol");
goog.require("ol.format.XLink");
goog.require("ol.format.XML");
goog.require("ol.format.XSD");
goog.require("ol.xml");
ol.format.OWS = function() {
  ol.format.XML.call(this);
};
ol.inherits(ol.format.OWS, ol.format.XML);
ol.format.OWS.prototype.readFromDocument = function(doc) {
  for (var n = doc.firstChild; n; n = n.nextSibling) {
    if (n.nodeType == Node.ELEMENT_NODE) {
      return this.readFromNode(n);
    }
  }
  return null;
};
ol.format.OWS.prototype.readFromNode = function(node) {
  var owsObject = ol.xml.pushParseAndPop({}, ol.format.OWS.PARSERS_, node, []);
  return owsObject ? owsObject : null;
};
ol.format.OWS.readAddress_ = function(node, objectStack) {
  return ol.xml.pushParseAndPop({}, ol.format.OWS.ADDRESS_PARSERS_, node, objectStack);
};
ol.format.OWS.readAllowedValues_ = function(node, objectStack) {
  return ol.xml.pushParseAndPop({}, ol.format.OWS.ALLOWED_VALUES_PARSERS_, node, objectStack);
};
ol.format.OWS.readConstraint_ = function(node, objectStack) {
  var name = node.getAttribute("name");
  if (!name) {
    return undefined;
  }
  return ol.xml.pushParseAndPop({"name":name}, ol.format.OWS.CONSTRAINT_PARSERS_, node, objectStack);
};
ol.format.OWS.readContactInfo_ = function(node, objectStack) {
  return ol.xml.pushParseAndPop({}, ol.format.OWS.CONTACT_INFO_PARSERS_, node, objectStack);
};
ol.format.OWS.readDcp_ = function(node, objectStack) {
  return ol.xml.pushParseAndPop({}, ol.format.OWS.DCP_PARSERS_, node, objectStack);
};
ol.format.OWS.readGet_ = function(node, objectStack) {
  var href = ol.format.XLink.readHref(node);
  if (!href) {
    return undefined;
  }
  return ol.xml.pushParseAndPop({"href":href}, ol.format.OWS.REQUEST_METHOD_PARSERS_, node, objectStack);
};
ol.format.OWS.readHttp_ = function(node, objectStack) {
  return ol.xml.pushParseAndPop({}, ol.format.OWS.HTTP_PARSERS_, node, objectStack);
};
ol.format.OWS.readOperation_ = function(node, objectStack) {
  var name = node.getAttribute("name");
  var value = ol.xml.pushParseAndPop({}, ol.format.OWS.OPERATION_PARSERS_, node, objectStack);
  if (!value) {
    return undefined;
  }
  var object = objectStack[objectStack.length - 1];
  object[name] = value;
};
ol.format.OWS.readOperationsMetadata_ = function(node, objectStack) {
  return ol.xml.pushParseAndPop({}, ol.format.OWS.OPERATIONS_METADATA_PARSERS_, node, objectStack);
};
ol.format.OWS.readPhone_ = function(node, objectStack) {
  return ol.xml.pushParseAndPop({}, ol.format.OWS.PHONE_PARSERS_, node, objectStack);
};
ol.format.OWS.readServiceIdentification_ = function(node, objectStack) {
  return ol.xml.pushParseAndPop({}, ol.format.OWS.SERVICE_IDENTIFICATION_PARSERS_, node, objectStack);
};
ol.format.OWS.readServiceContact_ = function(node, objectStack) {
  return ol.xml.pushParseAndPop({}, ol.format.OWS.SERVICE_CONTACT_PARSERS_, node, objectStack);
};
ol.format.OWS.readServiceProvider_ = function(node, objectStack) {
  return ol.xml.pushParseAndPop({}, ol.format.OWS.SERVICE_PROVIDER_PARSERS_, node, objectStack);
};
ol.format.OWS.readValue_ = function(node, objectStack) {
  return ol.format.XSD.readString(node);
};
ol.format.OWS.NAMESPACE_URIS_ = [null, "http://www.opengis.net/ows/1.1"];
ol.format.OWS.PARSERS_ = ol.xml.makeStructureNS(ol.format.OWS.NAMESPACE_URIS_, {"ServiceIdentification":ol.xml.makeObjectPropertySetter(ol.format.OWS.readServiceIdentification_), "ServiceProvider":ol.xml.makeObjectPropertySetter(ol.format.OWS.readServiceProvider_), "OperationsMetadata":ol.xml.makeObjectPropertySetter(ol.format.OWS.readOperationsMetadata_)});
ol.format.OWS.ADDRESS_PARSERS_ = ol.xml.makeStructureNS(ol.format.OWS.NAMESPACE_URIS_, {"DeliveryPoint":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "City":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "AdministrativeArea":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "PostalCode":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "Country":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "ElectronicMailAddress":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString)});
ol.format.OWS.ALLOWED_VALUES_PARSERS_ = ol.xml.makeStructureNS(ol.format.OWS.NAMESPACE_URIS_, {"Value":ol.xml.makeObjectPropertyPusher(ol.format.OWS.readValue_)});
ol.format.OWS.CONSTRAINT_PARSERS_ = ol.xml.makeStructureNS(ol.format.OWS.NAMESPACE_URIS_, {"AllowedValues":ol.xml.makeObjectPropertySetter(ol.format.OWS.readAllowedValues_)});
ol.format.OWS.CONTACT_INFO_PARSERS_ = ol.xml.makeStructureNS(ol.format.OWS.NAMESPACE_URIS_, {"Phone":ol.xml.makeObjectPropertySetter(ol.format.OWS.readPhone_), "Address":ol.xml.makeObjectPropertySetter(ol.format.OWS.readAddress_)});
ol.format.OWS.DCP_PARSERS_ = ol.xml.makeStructureNS(ol.format.OWS.NAMESPACE_URIS_, {"HTTP":ol.xml.makeObjectPropertySetter(ol.format.OWS.readHttp_)});
ol.format.OWS.HTTP_PARSERS_ = ol.xml.makeStructureNS(ol.format.OWS.NAMESPACE_URIS_, {"Get":ol.xml.makeObjectPropertyPusher(ol.format.OWS.readGet_), "Post":undefined});
ol.format.OWS.OPERATION_PARSERS_ = ol.xml.makeStructureNS(ol.format.OWS.NAMESPACE_URIS_, {"DCP":ol.xml.makeObjectPropertySetter(ol.format.OWS.readDcp_)});
ol.format.OWS.OPERATIONS_METADATA_PARSERS_ = ol.xml.makeStructureNS(ol.format.OWS.NAMESPACE_URIS_, {"Operation":ol.format.OWS.readOperation_});
ol.format.OWS.PHONE_PARSERS_ = ol.xml.makeStructureNS(ol.format.OWS.NAMESPACE_URIS_, {"Voice":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "Facsimile":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString)});
ol.format.OWS.REQUEST_METHOD_PARSERS_ = ol.xml.makeStructureNS(ol.format.OWS.NAMESPACE_URIS_, {"Constraint":ol.xml.makeObjectPropertyPusher(ol.format.OWS.readConstraint_)});
ol.format.OWS.SERVICE_CONTACT_PARSERS_ = ol.xml.makeStructureNS(ol.format.OWS.NAMESPACE_URIS_, {"IndividualName":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "PositionName":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "ContactInfo":ol.xml.makeObjectPropertySetter(ol.format.OWS.readContactInfo_)});
ol.format.OWS.SERVICE_IDENTIFICATION_PARSERS_ = ol.xml.makeStructureNS(ol.format.OWS.NAMESPACE_URIS_, {"Abstract":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "AccessConstraints":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "Fees":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "Title":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "ServiceTypeVersion":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "ServiceType":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString)});
ol.format.OWS.SERVICE_PROVIDER_PARSERS_ = ol.xml.makeStructureNS(ol.format.OWS.NAMESPACE_URIS_, {"ProviderName":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "ProviderSite":ol.xml.makeObjectPropertySetter(ol.format.XLink.readHref), "ServiceContact":ol.xml.makeObjectPropertySetter(ol.format.OWS.readServiceContact_)});
goog.provide("ol.geom.flat.flip");
ol.geom.flat.flip.flipXY = function(flatCoordinates, offset, end, stride, opt_dest, opt_destOffset) {
  var dest, destOffset;
  if (opt_dest !== undefined) {
    dest = opt_dest;
    destOffset = opt_destOffset !== undefined ? opt_destOffset : 0;
  } else {
    dest = [];
    destOffset = 0;
  }
  var j = offset;
  while (j < end) {
    var x = flatCoordinates[j++];
    dest[destOffset++] = flatCoordinates[j++];
    dest[destOffset++] = x;
    for (var k = 2; k < stride; ++k) {
      dest[destOffset++] = flatCoordinates[j++];
    }
  }
  dest.length = destOffset;
  return dest;
};
goog.provide("ol.format.Polyline");
goog.require("ol");
goog.require("ol.asserts");
goog.require("ol.Feature");
goog.require("ol.format.Feature");
goog.require("ol.format.TextFeature");
goog.require("ol.geom.GeometryLayout");
goog.require("ol.geom.LineString");
goog.require("ol.geom.SimpleGeometry");
goog.require("ol.geom.flat.flip");
goog.require("ol.geom.flat.inflate");
goog.require("ol.proj");
ol.format.Polyline = function(opt_options) {
  var options = opt_options ? opt_options : {};
  ol.format.TextFeature.call(this);
  this.defaultDataProjection = ol.proj.get("EPSG:4326");
  this.factor_ = options.factor ? options.factor : 1e5;
  this.geometryLayout_ = options.geometryLayout ? options.geometryLayout : ol.geom.GeometryLayout.XY;
};
ol.inherits(ol.format.Polyline, ol.format.TextFeature);
ol.format.Polyline.encodeDeltas = function(numbers, stride, opt_factor) {
  var factor = opt_factor ? opt_factor : 1e5;
  var d;
  var lastNumbers = new Array(stride);
  for (d = 0; d < stride; ++d) {
    lastNumbers[d] = 0;
  }
  var i, ii;
  for (i = 0, ii = numbers.length; i < ii;) {
    for (d = 0; d < stride; ++d, ++i) {
      var num = numbers[i];
      var delta = num - lastNumbers[d];
      lastNumbers[d] = num;
      numbers[i] = delta;
    }
  }
  return ol.format.Polyline.encodeFloats(numbers, factor);
};
ol.format.Polyline.decodeDeltas = function(encoded, stride, opt_factor) {
  var factor = opt_factor ? opt_factor : 1e5;
  var d;
  var lastNumbers = new Array(stride);
  for (d = 0; d < stride; ++d) {
    lastNumbers[d] = 0;
  }
  var numbers = ol.format.Polyline.decodeFloats(encoded, factor);
  var i, ii;
  for (i = 0, ii = numbers.length; i < ii;) {
    for (d = 0; d < stride; ++d, ++i) {
      lastNumbers[d] += numbers[i];
      numbers[i] = lastNumbers[d];
    }
  }
  return numbers;
};
ol.format.Polyline.encodeFloats = function(numbers, opt_factor) {
  var factor = opt_factor ? opt_factor : 1e5;
  var i, ii;
  for (i = 0, ii = numbers.length; i < ii; ++i) {
    numbers[i] = Math.round(numbers[i] * factor);
  }
  return ol.format.Polyline.encodeSignedIntegers(numbers);
};
ol.format.Polyline.decodeFloats = function(encoded, opt_factor) {
  var factor = opt_factor ? opt_factor : 1e5;
  var numbers = ol.format.Polyline.decodeSignedIntegers(encoded);
  var i, ii;
  for (i = 0, ii = numbers.length; i < ii; ++i) {
    numbers[i] /= factor;
  }
  return numbers;
};
ol.format.Polyline.encodeSignedIntegers = function(numbers) {
  var i, ii;
  for (i = 0, ii = numbers.length; i < ii; ++i) {
    var num = numbers[i];
    numbers[i] = num < 0 ? ~(num << 1) : num << 1;
  }
  return ol.format.Polyline.encodeUnsignedIntegers(numbers);
};
ol.format.Polyline.decodeSignedIntegers = function(encoded) {
  var numbers = ol.format.Polyline.decodeUnsignedIntegers(encoded);
  var i, ii;
  for (i = 0, ii = numbers.length; i < ii; ++i) {
    var num = numbers[i];
    numbers[i] = num & 1 ? ~(num >> 1) : num >> 1;
  }
  return numbers;
};
ol.format.Polyline.encodeUnsignedIntegers = function(numbers) {
  var encoded = "";
  var i, ii;
  for (i = 0, ii = numbers.length; i < ii; ++i) {
    encoded += ol.format.Polyline.encodeUnsignedInteger(numbers[i]);
  }
  return encoded;
};
ol.format.Polyline.decodeUnsignedIntegers = function(encoded) {
  var numbers = [];
  var current = 0;
  var shift = 0;
  var i, ii;
  for (i = 0, ii = encoded.length; i < ii; ++i) {
    var b = encoded.charCodeAt(i) - 63;
    current |= (b & 31) << shift;
    if (b < 32) {
      numbers.push(current);
      current = 0;
      shift = 0;
    } else {
      shift += 5;
    }
  }
  return numbers;
};
ol.format.Polyline.encodeUnsignedInteger = function(num) {
  var value, encoded = "";
  while (num >= 32) {
    value = (32 | num & 31) + 63;
    encoded += String.fromCharCode(value);
    num >>= 5;
  }
  value = num + 63;
  encoded += String.fromCharCode(value);
  return encoded;
};
ol.format.Polyline.prototype.readFeature;
ol.format.Polyline.prototype.readFeatureFromText = function(text, opt_options) {
  var geometry = this.readGeometryFromText(text, opt_options);
  return new ol.Feature(geometry);
};
ol.format.Polyline.prototype.readFeatures;
ol.format.Polyline.prototype.readFeaturesFromText = function(text, opt_options) {
  var feature = this.readFeatureFromText(text, opt_options);
  return [feature];
};
ol.format.Polyline.prototype.readGeometry;
ol.format.Polyline.prototype.readGeometryFromText = function(text, opt_options) {
  var stride = ol.geom.SimpleGeometry.getStrideForLayout(this.geometryLayout_);
  var flatCoordinates = ol.format.Polyline.decodeDeltas(text, stride, this.factor_);
  ol.geom.flat.flip.flipXY(flatCoordinates, 0, flatCoordinates.length, stride, flatCoordinates);
  var coordinates = ol.geom.flat.inflate.coordinates(flatCoordinates, 0, flatCoordinates.length, stride);
  return ol.format.Feature.transformWithOptions(new ol.geom.LineString(coordinates, this.geometryLayout_), false, this.adaptOptions(opt_options));
};
ol.format.Polyline.prototype.readProjection;
ol.format.Polyline.prototype.writeFeatureText = function(feature, opt_options) {
  var geometry = feature.getGeometry();
  if (geometry) {
    return this.writeGeometryText(geometry, opt_options);
  } else {
    ol.asserts.assert(false, 40);
    return "";
  }
};
ol.format.Polyline.prototype.writeFeaturesText = function(features, opt_options) {
  return this.writeFeatureText(features[0], opt_options);
};
ol.format.Polyline.prototype.writeGeometry;
ol.format.Polyline.prototype.writeGeometryText = function(geometry, opt_options) {
  geometry = ol.format.Feature.transformWithOptions(geometry, true, this.adaptOptions(opt_options));
  var flatCoordinates = geometry.getFlatCoordinates();
  var stride = geometry.getStride();
  ol.geom.flat.flip.flipXY(flatCoordinates, 0, flatCoordinates.length, stride, flatCoordinates);
  return ol.format.Polyline.encodeDeltas(flatCoordinates, stride, this.factor_);
};
goog.provide("ol.format.TopoJSON");
goog.require("ol");
goog.require("ol.Feature");
goog.require("ol.format.Feature");
goog.require("ol.format.JSONFeature");
goog.require("ol.geom.LineString");
goog.require("ol.geom.MultiLineString");
goog.require("ol.geom.MultiPoint");
goog.require("ol.geom.MultiPolygon");
goog.require("ol.geom.Point");
goog.require("ol.geom.Polygon");
goog.require("ol.proj");
ol.format.TopoJSON = function(opt_options) {
  var options = opt_options ? opt_options : {};
  ol.format.JSONFeature.call(this);
  this.layerName_ = options.layerName;
  this.layers_ = options.layers ? options.layers : null;
  this.defaultDataProjection = ol.proj.get(options.defaultDataProjection ? options.defaultDataProjection : "EPSG:4326");
};
ol.inherits(ol.format.TopoJSON, ol.format.JSONFeature);
ol.format.TopoJSON.concatenateArcs_ = function(indices, arcs) {
  var coordinates = [];
  var index, arc;
  var i, ii;
  var j, jj;
  for (i = 0, ii = indices.length; i < ii; ++i) {
    index = indices[i];
    if (i > 0) {
      coordinates.pop();
    }
    if (index >= 0) {
      arc = arcs[index];
    } else {
      arc = arcs[~index].slice().reverse();
    }
    coordinates.push.apply(coordinates, arc);
  }
  for (j = 0, jj = coordinates.length; j < jj; ++j) {
    coordinates[j] = coordinates[j].slice();
  }
  return coordinates;
};
ol.format.TopoJSON.readPointGeometry_ = function(object, scale, translate) {
  var coordinates = object.coordinates;
  if (scale && translate) {
    ol.format.TopoJSON.transformVertex_(coordinates, scale, translate);
  }
  return new ol.geom.Point(coordinates);
};
ol.format.TopoJSON.readMultiPointGeometry_ = function(object, scale, translate) {
  var coordinates = object.coordinates;
  var i, ii;
  if (scale && translate) {
    for (i = 0, ii = coordinates.length; i < ii; ++i) {
      ol.format.TopoJSON.transformVertex_(coordinates[i], scale, translate);
    }
  }
  return new ol.geom.MultiPoint(coordinates);
};
ol.format.TopoJSON.readLineStringGeometry_ = function(object, arcs) {
  var coordinates = ol.format.TopoJSON.concatenateArcs_(object.arcs, arcs);
  return new ol.geom.LineString(coordinates);
};
ol.format.TopoJSON.readMultiLineStringGeometry_ = function(object, arcs) {
  var coordinates = [];
  var i, ii;
  for (i = 0, ii = object.arcs.length; i < ii; ++i) {
    coordinates[i] = ol.format.TopoJSON.concatenateArcs_(object.arcs[i], arcs);
  }
  return new ol.geom.MultiLineString(coordinates);
};
ol.format.TopoJSON.readPolygonGeometry_ = function(object, arcs) {
  var coordinates = [];
  var i, ii;
  for (i = 0, ii = object.arcs.length; i < ii; ++i) {
    coordinates[i] = ol.format.TopoJSON.concatenateArcs_(object.arcs[i], arcs);
  }
  return new ol.geom.Polygon(coordinates);
};
ol.format.TopoJSON.readMultiPolygonGeometry_ = function(object, arcs) {
  var coordinates = [];
  var polyArray, ringCoords, j, jj;
  var i, ii;
  for (i = 0, ii = object.arcs.length; i < ii; ++i) {
    polyArray = object.arcs[i];
    ringCoords = [];
    for (j = 0, jj = polyArray.length; j < jj; ++j) {
      ringCoords[j] = ol.format.TopoJSON.concatenateArcs_(polyArray[j], arcs);
    }
    coordinates[i] = ringCoords;
  }
  return new ol.geom.MultiPolygon(coordinates);
};
ol.format.TopoJSON.readFeaturesFromGeometryCollection_ = function(collection, arcs, scale, translate, property, name, opt_options) {
  var geometries = collection.geometries;
  var features = [];
  var i, ii;
  for (i = 0, ii = geometries.length; i < ii; ++i) {
    features[i] = ol.format.TopoJSON.readFeatureFromGeometry_(geometries[i], arcs, scale, translate, property, name, opt_options);
  }
  return features;
};
ol.format.TopoJSON.readFeatureFromGeometry_ = function(object, arcs, scale, translate, property, name, opt_options) {
  var geometry;
  var type = object.type;
  var geometryReader = ol.format.TopoJSON.GEOMETRY_READERS_[type];
  if (type === "Point" || type === "MultiPoint") {
    geometry = geometryReader(object, scale, translate);
  } else {
    geometry = geometryReader(object, arcs);
  }
  var feature = new ol.Feature;
  feature.setGeometry(ol.format.Feature.transformWithOptions(geometry, false, opt_options));
  if (object.id !== undefined) {
    feature.setId(object.id);
  }
  var properties = object.properties;
  if (property) {
    if (!properties) {
      properties = {};
    }
    properties[property] = name;
  }
  if (properties) {
    feature.setProperties(properties);
  }
  return feature;
};
ol.format.TopoJSON.prototype.readFeatures;
ol.format.TopoJSON.prototype.readFeaturesFromObject = function(object, opt_options) {
  if (object.type == "Topology") {
    var topoJSONTopology = object;
    var transform, scale = null, translate = null;
    if (topoJSONTopology.transform) {
      transform = topoJSONTopology.transform;
      scale = transform.scale;
      translate = transform.translate;
    }
    var arcs = topoJSONTopology.arcs;
    if (transform) {
      ol.format.TopoJSON.transformArcs_(arcs, scale, translate);
    }
    var features = [];
    var topoJSONFeatures = topoJSONTopology.objects;
    var property = this.layerName_;
    var objectName, feature;
    for (objectName in topoJSONFeatures) {
      if (this.layers_ && this.layers_.indexOf(objectName) == -1) {
        continue;
      }
      if (topoJSONFeatures[objectName].type === "GeometryCollection") {
        feature = topoJSONFeatures[objectName];
        features.push.apply(features, ol.format.TopoJSON.readFeaturesFromGeometryCollection_(feature, arcs, scale, translate, property, objectName, opt_options));
      } else {
        feature = topoJSONFeatures[objectName];
        features.push(ol.format.TopoJSON.readFeatureFromGeometry_(feature, arcs, scale, translate, property, objectName, opt_options));
      }
    }
    return features;
  } else {
    return [];
  }
};
ol.format.TopoJSON.transformArcs_ = function(arcs, scale, translate) {
  var i, ii;
  for (i = 0, ii = arcs.length; i < ii; ++i) {
    ol.format.TopoJSON.transformArc_(arcs[i], scale, translate);
  }
};
ol.format.TopoJSON.transformArc_ = function(arc, scale, translate) {
  var x = 0;
  var y = 0;
  var vertex;
  var i, ii;
  for (i = 0, ii = arc.length; i < ii; ++i) {
    vertex = arc[i];
    x += vertex[0];
    y += vertex[1];
    vertex[0] = x;
    vertex[1] = y;
    ol.format.TopoJSON.transformVertex_(vertex, scale, translate);
  }
};
ol.format.TopoJSON.transformVertex_ = function(vertex, scale, translate) {
  vertex[0] = vertex[0] * scale[0] + translate[0];
  vertex[1] = vertex[1] * scale[1] + translate[1];
};
ol.format.TopoJSON.prototype.readProjection;
ol.format.TopoJSON.prototype.readProjectionFromObject = function(object) {
  return this.defaultDataProjection;
};
ol.format.TopoJSON.GEOMETRY_READERS_ = {"Point":ol.format.TopoJSON.readPointGeometry_, "LineString":ol.format.TopoJSON.readLineStringGeometry_, "Polygon":ol.format.TopoJSON.readPolygonGeometry_, "MultiPoint":ol.format.TopoJSON.readMultiPointGeometry_, "MultiLineString":ol.format.TopoJSON.readMultiLineStringGeometry_, "MultiPolygon":ol.format.TopoJSON.readMultiPolygonGeometry_};
ol.format.TopoJSON.prototype.writeFeatureObject = function(feature, opt_options) {
};
ol.format.TopoJSON.prototype.writeFeaturesObject = function(features, opt_options) {
};
ol.format.TopoJSON.prototype.writeGeometryObject = function(geometry, opt_options) {
};
ol.format.TopoJSON.prototype.readGeometryFromObject = function() {
};
ol.format.TopoJSON.prototype.readFeatureFromObject = function() {
};
goog.provide("ol.format.WFS");
goog.require("ol");
goog.require("ol.asserts");
goog.require("ol.format.GML2");
goog.require("ol.format.GML3");
goog.require("ol.format.GMLBase");
goog.require("ol.format.filter");
goog.require("ol.format.XMLFeature");
goog.require("ol.format.XSD");
goog.require("ol.geom.Geometry");
goog.require("ol.obj");
goog.require("ol.proj");
goog.require("ol.xml");
ol.format.WFS = function(opt_options) {
  var options = opt_options ? opt_options : {};
  this.featureType_ = options.featureType;
  this.featureNS_ = options.featureNS;
  this.gmlFormat_ = options.gmlFormat ? options.gmlFormat : new ol.format.GML3;
  this.schemaLocation_ = options.schemaLocation ? options.schemaLocation : ol.format.WFS.SCHEMA_LOCATIONS[ol.format.WFS.DEFAULT_VERSION];
  ol.format.XMLFeature.call(this);
};
ol.inherits(ol.format.WFS, ol.format.XMLFeature);
ol.format.WFS.FEATURE_PREFIX = "feature";
ol.format.WFS.XMLNS = "http://www.w3.org/2000/xmlns/";
ol.format.WFS.OGCNS = "http://www.opengis.net/ogc";
ol.format.WFS.WFSNS = "http://www.opengis.net/wfs";
ol.format.WFS.FESNS = "http://www.opengis.net/fes";
ol.format.WFS.SCHEMA_LOCATIONS = {"1.1.0":"http://www.opengis.net/wfs " + "http://schemas.opengis.net/wfs/1.1.0/wfs.xsd", "1.0.0":"http://www.opengis.net/wfs " + "http://schemas.opengis.net/wfs/1.0.0/wfs.xsd"};
ol.format.WFS.DEFAULT_VERSION = "1.1.0";
ol.format.WFS.prototype.getFeatureType = function() {
  return this.featureType_;
};
ol.format.WFS.prototype.setFeatureType = function(featureType) {
  this.featureType_ = featureType;
};
ol.format.WFS.prototype.readFeatures;
ol.format.WFS.prototype.readFeaturesFromNode = function(node, opt_options) {
  var context = {"featureType":this.featureType_, "featureNS":this.featureNS_};
  ol.obj.assign(context, this.getReadOptions(node, opt_options ? opt_options : {}));
  var objectStack = [context];
  this.gmlFormat_.FEATURE_COLLECTION_PARSERS[ol.format.GMLBase.GMLNS]["featureMember"] = ol.xml.makeArrayPusher(ol.format.GMLBase.prototype.readFeaturesInternal);
  var features = ol.xml.pushParseAndPop([], this.gmlFormat_.FEATURE_COLLECTION_PARSERS, node, objectStack, this.gmlFormat_);
  if (!features) {
    features = [];
  }
  return features;
};
ol.format.WFS.prototype.readTransactionResponse = function(source) {
  if (ol.xml.isDocument(source)) {
    return this.readTransactionResponseFromDocument(source);
  } else {
    if (ol.xml.isNode(source)) {
      return this.readTransactionResponseFromNode(source);
    } else {
      if (typeof source === "string") {
        var doc = ol.xml.parse(source);
        return this.readTransactionResponseFromDocument(doc);
      } else {
        return undefined;
      }
    }
  }
};
ol.format.WFS.prototype.readFeatureCollectionMetadata = function(source) {
  if (ol.xml.isDocument(source)) {
    return this.readFeatureCollectionMetadataFromDocument(source);
  } else {
    if (ol.xml.isNode(source)) {
      return this.readFeatureCollectionMetadataFromNode(source);
    } else {
      if (typeof source === "string") {
        var doc = ol.xml.parse(source);
        return this.readFeatureCollectionMetadataFromDocument(doc);
      } else {
        return undefined;
      }
    }
  }
};
ol.format.WFS.prototype.readFeatureCollectionMetadataFromDocument = function(doc) {
  for (var n = doc.firstChild; n; n = n.nextSibling) {
    if (n.nodeType == Node.ELEMENT_NODE) {
      return this.readFeatureCollectionMetadataFromNode(n);
    }
  }
  return undefined;
};
ol.format.WFS.FEATURE_COLLECTION_PARSERS_ = {"http://www.opengis.net/gml":{"boundedBy":ol.xml.makeObjectPropertySetter(ol.format.GMLBase.prototype.readGeometryElement, "bounds")}};
ol.format.WFS.prototype.readFeatureCollectionMetadataFromNode = function(node) {
  var result = {};
  var value = ol.format.XSD.readNonNegativeIntegerString(node.getAttribute("numberOfFeatures"));
  result["numberOfFeatures"] = value;
  return ol.xml.pushParseAndPop(result, ol.format.WFS.FEATURE_COLLECTION_PARSERS_, node, [], this.gmlFormat_);
};
ol.format.WFS.TRANSACTION_SUMMARY_PARSERS_ = {"http://www.opengis.net/wfs":{"totalInserted":ol.xml.makeObjectPropertySetter(ol.format.XSD.readNonNegativeInteger), "totalUpdated":ol.xml.makeObjectPropertySetter(ol.format.XSD.readNonNegativeInteger), "totalDeleted":ol.xml.makeObjectPropertySetter(ol.format.XSD.readNonNegativeInteger)}};
ol.format.WFS.readTransactionSummary_ = function(node, objectStack) {
  return ol.xml.pushParseAndPop({}, ol.format.WFS.TRANSACTION_SUMMARY_PARSERS_, node, objectStack);
};
ol.format.WFS.OGC_FID_PARSERS_ = {"http://www.opengis.net/ogc":{"FeatureId":ol.xml.makeArrayPusher(function(node, objectStack) {
  return node.getAttribute("fid");
})}};
ol.format.WFS.fidParser_ = function(node, objectStack) {
  ol.xml.parseNode(ol.format.WFS.OGC_FID_PARSERS_, node, objectStack);
};
ol.format.WFS.INSERT_RESULTS_PARSERS_ = {"http://www.opengis.net/wfs":{"Feature":ol.format.WFS.fidParser_}};
ol.format.WFS.readInsertResults_ = function(node, objectStack) {
  return ol.xml.pushParseAndPop([], ol.format.WFS.INSERT_RESULTS_PARSERS_, node, objectStack);
};
ol.format.WFS.TRANSACTION_RESPONSE_PARSERS_ = {"http://www.opengis.net/wfs":{"TransactionSummary":ol.xml.makeObjectPropertySetter(ol.format.WFS.readTransactionSummary_, "transactionSummary"), "InsertResults":ol.xml.makeObjectPropertySetter(ol.format.WFS.readInsertResults_, "insertIds")}};
ol.format.WFS.prototype.readTransactionResponseFromDocument = function(doc) {
  for (var n = doc.firstChild; n; n = n.nextSibling) {
    if (n.nodeType == Node.ELEMENT_NODE) {
      return this.readTransactionResponseFromNode(n);
    }
  }
  return undefined;
};
ol.format.WFS.prototype.readTransactionResponseFromNode = function(node) {
  return ol.xml.pushParseAndPop({}, ol.format.WFS.TRANSACTION_RESPONSE_PARSERS_, node, []);
};
ol.format.WFS.QUERY_SERIALIZERS_ = {"http://www.opengis.net/wfs":{"PropertyName":ol.xml.makeChildAppender(ol.format.XSD.writeStringTextNode)}};
ol.format.WFS.writeFeature_ = function(node, feature, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var featureType = context["featureType"];
  var featureNS = context["featureNS"];
  var gmlVersion = context["gmlVersion"];
  var child = ol.xml.createElementNS(featureNS, featureType);
  node.appendChild(child);
  if (gmlVersion === 2) {
    ol.format.GML2.prototype.writeFeatureElement(child, feature, objectStack);
  } else {
    ol.format.GML3.prototype.writeFeatureElement(child, feature, objectStack);
  }
};
ol.format.WFS.writeOgcFidFilter_ = function(node, fid, objectStack) {
  var filter = ol.xml.createElementNS(ol.format.WFS.OGCNS, "Filter");
  var child = ol.xml.createElementNS(ol.format.WFS.OGCNS, "FeatureId");
  filter.appendChild(child);
  child.setAttribute("fid", fid);
  node.appendChild(filter);
};
ol.format.WFS.getTypeName_ = function(featurePrefix, featureType) {
  featurePrefix = featurePrefix ? featurePrefix : ol.format.WFS.FEATURE_PREFIX;
  var prefix = featurePrefix + ":";
  if (featureType.indexOf(prefix) === 0) {
    return featureType;
  } else {
    return prefix + featureType;
  }
};
ol.format.WFS.writeDelete_ = function(node, feature, objectStack) {
  var context = objectStack[objectStack.length - 1];
  ol.asserts.assert(feature.getId() !== undefined, 26);
  var featureType = context["featureType"];
  var featurePrefix = context["featurePrefix"];
  var featureNS = context["featureNS"];
  var typeName = ol.format.WFS.getTypeName_(featurePrefix, featureType);
  node.setAttribute("typeName", typeName);
  ol.xml.setAttributeNS(node, ol.format.WFS.XMLNS, "xmlns:" + featurePrefix, featureNS);
  var fid = feature.getId();
  if (fid !== undefined) {
    ol.format.WFS.writeOgcFidFilter_(node, fid, objectStack);
  }
};
ol.format.WFS.writeUpdate_ = function(node, feature, objectStack) {
  var context = objectStack[objectStack.length - 1];
  ol.asserts.assert(feature.getId() !== undefined, 27);
  var featureType = context["featureType"];
  var featurePrefix = context["featurePrefix"];
  var featureNS = context["featureNS"];
  var typeName = ol.format.WFS.getTypeName_(featurePrefix, featureType);
  var geometryName = feature.getGeometryName();
  node.setAttribute("typeName", typeName);
  ol.xml.setAttributeNS(node, ol.format.WFS.XMLNS, "xmlns:" + featurePrefix, featureNS);
  var fid = feature.getId();
  if (fid !== undefined) {
    var keys = feature.getKeys();
    var values = [];
    for (var i = 0, ii = keys.length; i < ii; i++) {
      var value = feature.get(keys[i]);
      if (value !== undefined) {
        var name = keys[i];
        if (value instanceof ol.geom.Geometry) {
          name = geometryName;
        }
        values.push({name:name, value:value});
      }
    }
    ol.xml.pushSerializeAndPop({"gmlVersion":context["gmlVersion"], node:node, "hasZ":context["hasZ"], "srsName":context["srsName"]}, ol.format.WFS.TRANSACTION_SERIALIZERS_, ol.xml.makeSimpleNodeFactory("Property"), values, objectStack);
    ol.format.WFS.writeOgcFidFilter_(node, fid, objectStack);
  }
};
ol.format.WFS.writeProperty_ = function(node, pair, objectStack) {
  var name = ol.xml.createElementNS(ol.format.WFS.WFSNS, "Name");
  var context = objectStack[objectStack.length - 1];
  var gmlVersion = context["gmlVersion"];
  node.appendChild(name);
  ol.format.XSD.writeStringTextNode(name, pair.name);
  if (pair.value !== undefined && pair.value !== null) {
    var value = ol.xml.createElementNS(ol.format.WFS.WFSNS, "Value");
    node.appendChild(value);
    if (pair.value instanceof ol.geom.Geometry) {
      if (gmlVersion === 2) {
        ol.format.GML2.prototype.writeGeometryElement(value, pair.value, objectStack);
      } else {
        ol.format.GML3.prototype.writeGeometryElement(value, pair.value, objectStack);
      }
    } else {
      ol.format.XSD.writeStringTextNode(value, pair.value);
    }
  }
};
ol.format.WFS.writeNative_ = function(node, nativeElement, objectStack) {
  if (nativeElement.vendorId) {
    node.setAttribute("vendorId", nativeElement.vendorId);
  }
  if (nativeElement.safeToIgnore !== undefined) {
    node.setAttribute("safeToIgnore", nativeElement.safeToIgnore);
  }
  if (nativeElement.value !== undefined) {
    ol.format.XSD.writeStringTextNode(node, nativeElement.value);
  }
};
ol.format.WFS.TRANSACTION_SERIALIZERS_ = {"http://www.opengis.net/wfs":{"Insert":ol.xml.makeChildAppender(ol.format.WFS.writeFeature_), "Update":ol.xml.makeChildAppender(ol.format.WFS.writeUpdate_), "Delete":ol.xml.makeChildAppender(ol.format.WFS.writeDelete_), "Property":ol.xml.makeChildAppender(ol.format.WFS.writeProperty_), "Native":ol.xml.makeChildAppender(ol.format.WFS.writeNative_)}};
ol.format.WFS.writeQuery_ = function(node, featureType, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var featurePrefix = context["featurePrefix"];
  var featureNS = context["featureNS"];
  var propertyNames = context["propertyNames"];
  var srsName = context["srsName"];
  var typeName;
  if (featurePrefix) {
    typeName = ol.format.WFS.getTypeName_(featurePrefix, featureType);
  } else {
    typeName = featureType;
  }
  node.setAttribute("typeName", typeName);
  if (srsName) {
    node.setAttribute("srsName", srsName);
  }
  if (featureNS) {
    ol.xml.setAttributeNS(node, ol.format.WFS.XMLNS, "xmlns:" + featurePrefix, featureNS);
  }
  var item = ol.obj.assign({}, context);
  item.node = node;
  ol.xml.pushSerializeAndPop(item, ol.format.WFS.QUERY_SERIALIZERS_, ol.xml.makeSimpleNodeFactory("PropertyName"), propertyNames, objectStack);
  var filter = context["filter"];
  if (filter) {
    var child = ol.xml.createElementNS(ol.format.WFS.OGCNS, "Filter");
    node.appendChild(child);
    ol.format.WFS.writeFilterCondition_(child, filter, objectStack);
  }
};
ol.format.WFS.writeFilterCondition_ = function(node, filter, objectStack) {
  var item = {node:node};
  ol.xml.pushSerializeAndPop(item, ol.format.WFS.GETFEATURE_SERIALIZERS_, ol.xml.makeSimpleNodeFactory(filter.getTagName()), [filter], objectStack);
};
ol.format.WFS.writeBboxFilter_ = function(node, filter, objectStack) {
  var context = objectStack[objectStack.length - 1];
  context["srsName"] = filter.srsName;
  ol.format.WFS.writeOgcPropertyName_(node, filter.geometryName);
  ol.format.GML3.prototype.writeGeometryElement(node, filter.extent, objectStack);
};
ol.format.WFS.writeContainsFilter_ = function(node, filter, objectStack) {
  var context = objectStack[objectStack.length - 1];
  context["srsName"] = filter.srsName;
  ol.format.WFS.writeOgcPropertyName_(node, filter.geometryName);
  ol.format.GML3.prototype.writeGeometryElement(node, filter.geometry, objectStack);
};
ol.format.WFS.writeIntersectsFilter_ = function(node, filter, objectStack) {
  var context = objectStack[objectStack.length - 1];
  context["srsName"] = filter.srsName;
  ol.format.WFS.writeOgcPropertyName_(node, filter.geometryName);
  ol.format.GML3.prototype.writeGeometryElement(node, filter.geometry, objectStack);
};
ol.format.WFS.writeWithinFilter_ = function(node, filter, objectStack) {
  var context = objectStack[objectStack.length - 1];
  context["srsName"] = filter.srsName;
  ol.format.WFS.writeOgcPropertyName_(node, filter.geometryName);
  ol.format.GML3.prototype.writeGeometryElement(node, filter.geometry, objectStack);
};
ol.format.WFS.writeDuringFilter_ = function(node, filter, objectStack) {
  var valueReference = ol.xml.createElementNS(ol.format.WFS.FESNS, "ValueReference");
  ol.format.XSD.writeStringTextNode(valueReference, filter.propertyName);
  node.appendChild(valueReference);
  var timePeriod = ol.xml.createElementNS(ol.format.GMLBase.GMLNS, "TimePeriod");
  node.appendChild(timePeriod);
  var begin = ol.xml.createElementNS(ol.format.GMLBase.GMLNS, "begin");
  timePeriod.appendChild(begin);
  ol.format.WFS.writeTimeInstant_(begin, filter.begin);
  var end = ol.xml.createElementNS(ol.format.GMLBase.GMLNS, "end");
  timePeriod.appendChild(end);
  ol.format.WFS.writeTimeInstant_(end, filter.end);
};
ol.format.WFS.writeLogicalFilter_ = function(node, filter, objectStack) {
  var item = {node:node};
  var conditions = filter.conditions;
  for (var i = 0, ii = conditions.length; i < ii; ++i) {
    var condition = conditions[i];
    ol.xml.pushSerializeAndPop(item, ol.format.WFS.GETFEATURE_SERIALIZERS_, ol.xml.makeSimpleNodeFactory(condition.getTagName()), [condition], objectStack);
  }
};
ol.format.WFS.writeNotFilter_ = function(node, filter, objectStack) {
  var item = {node:node};
  var condition = filter.condition;
  ol.xml.pushSerializeAndPop(item, ol.format.WFS.GETFEATURE_SERIALIZERS_, ol.xml.makeSimpleNodeFactory(condition.getTagName()), [condition], objectStack);
};
ol.format.WFS.writeComparisonFilter_ = function(node, filter, objectStack) {
  if (filter.matchCase !== undefined) {
    node.setAttribute("matchCase", filter.matchCase.toString());
  }
  ol.format.WFS.writeOgcPropertyName_(node, filter.propertyName);
  ol.format.WFS.writeOgcLiteral_(node, "" + filter.expression);
};
ol.format.WFS.writeIsNullFilter_ = function(node, filter, objectStack) {
  ol.format.WFS.writeOgcPropertyName_(node, filter.propertyName);
};
ol.format.WFS.writeIsBetweenFilter_ = function(node, filter, objectStack) {
  ol.format.WFS.writeOgcPropertyName_(node, filter.propertyName);
  var lowerBoundary = ol.xml.createElementNS(ol.format.WFS.OGCNS, "LowerBoundary");
  node.appendChild(lowerBoundary);
  ol.format.WFS.writeOgcLiteral_(lowerBoundary, "" + filter.lowerBoundary);
  var upperBoundary = ol.xml.createElementNS(ol.format.WFS.OGCNS, "UpperBoundary");
  node.appendChild(upperBoundary);
  ol.format.WFS.writeOgcLiteral_(upperBoundary, "" + filter.upperBoundary);
};
ol.format.WFS.writeIsLikeFilter_ = function(node, filter, objectStack) {
  node.setAttribute("wildCard", filter.wildCard);
  node.setAttribute("singleChar", filter.singleChar);
  node.setAttribute("escapeChar", filter.escapeChar);
  if (filter.matchCase !== undefined) {
    node.setAttribute("matchCase", filter.matchCase.toString());
  }
  ol.format.WFS.writeOgcPropertyName_(node, filter.propertyName);
  ol.format.WFS.writeOgcLiteral_(node, "" + filter.pattern);
};
ol.format.WFS.writeOgcExpression_ = function(tagName, node, value) {
  var property = ol.xml.createElementNS(ol.format.WFS.OGCNS, tagName);
  ol.format.XSD.writeStringTextNode(property, value);
  node.appendChild(property);
};
ol.format.WFS.writeOgcPropertyName_ = function(node, value) {
  ol.format.WFS.writeOgcExpression_("PropertyName", node, value);
};
ol.format.WFS.writeOgcLiteral_ = function(node, value) {
  ol.format.WFS.writeOgcExpression_("Literal", node, value);
};
ol.format.WFS.writeTimeInstant_ = function(node, time) {
  var timeInstant = ol.xml.createElementNS(ol.format.GMLBase.GMLNS, "TimeInstant");
  node.appendChild(timeInstant);
  var timePosition = ol.xml.createElementNS(ol.format.GMLBase.GMLNS, "timePosition");
  timeInstant.appendChild(timePosition);
  ol.format.XSD.writeStringTextNode(timePosition, time);
};
ol.format.WFS.GETFEATURE_SERIALIZERS_ = {"http://www.opengis.net/wfs":{"Query":ol.xml.makeChildAppender(ol.format.WFS.writeQuery_)}, "http://www.opengis.net/ogc":{"During":ol.xml.makeChildAppender(ol.format.WFS.writeDuringFilter_), "And":ol.xml.makeChildAppender(ol.format.WFS.writeLogicalFilter_), "Or":ol.xml.makeChildAppender(ol.format.WFS.writeLogicalFilter_), "Not":ol.xml.makeChildAppender(ol.format.WFS.writeNotFilter_), "BBOX":ol.xml.makeChildAppender(ol.format.WFS.writeBboxFilter_), "Contains":ol.xml.makeChildAppender(ol.format.WFS.writeContainsFilter_), 
"Intersects":ol.xml.makeChildAppender(ol.format.WFS.writeIntersectsFilter_), "Within":ol.xml.makeChildAppender(ol.format.WFS.writeWithinFilter_), "PropertyIsEqualTo":ol.xml.makeChildAppender(ol.format.WFS.writeComparisonFilter_), "PropertyIsNotEqualTo":ol.xml.makeChildAppender(ol.format.WFS.writeComparisonFilter_), "PropertyIsLessThan":ol.xml.makeChildAppender(ol.format.WFS.writeComparisonFilter_), "PropertyIsLessThanOrEqualTo":ol.xml.makeChildAppender(ol.format.WFS.writeComparisonFilter_), "PropertyIsGreaterThan":ol.xml.makeChildAppender(ol.format.WFS.writeComparisonFilter_), 
"PropertyIsGreaterThanOrEqualTo":ol.xml.makeChildAppender(ol.format.WFS.writeComparisonFilter_), "PropertyIsNull":ol.xml.makeChildAppender(ol.format.WFS.writeIsNullFilter_), "PropertyIsBetween":ol.xml.makeChildAppender(ol.format.WFS.writeIsBetweenFilter_), "PropertyIsLike":ol.xml.makeChildAppender(ol.format.WFS.writeIsLikeFilter_)}};
ol.format.WFS.writeFilter = function(filter) {
  var child = ol.xml.createElementNS(ol.format.WFS.OGCNS, "Filter");
  ol.format.WFS.writeFilterCondition_(child, filter, []);
  return child;
};
ol.format.WFS.writeGetFeature_ = function(node, featureTypes, objectStack) {
  var context = objectStack[objectStack.length - 1];
  var item = ol.obj.assign({}, context);
  item.node = node;
  ol.xml.pushSerializeAndPop(item, ol.format.WFS.GETFEATURE_SERIALIZERS_, ol.xml.makeSimpleNodeFactory("Query"), featureTypes, objectStack);
};
ol.format.WFS.prototype.writeGetFeature = function(options) {
  var node = ol.xml.createElementNS(ol.format.WFS.WFSNS, "GetFeature");
  node.setAttribute("service", "WFS");
  node.setAttribute("version", "1.1.0");
  var filter;
  if (options) {
    if (options.handle) {
      node.setAttribute("handle", options.handle);
    }
    if (options.outputFormat) {
      node.setAttribute("outputFormat", options.outputFormat);
    }
    if (options.maxFeatures !== undefined) {
      node.setAttribute("maxFeatures", options.maxFeatures);
    }
    if (options.resultType) {
      node.setAttribute("resultType", options.resultType);
    }
    if (options.startIndex !== undefined) {
      node.setAttribute("startIndex", options.startIndex);
    }
    if (options.count !== undefined) {
      node.setAttribute("count", options.count);
    }
    filter = options.filter;
    if (options.bbox) {
      ol.asserts.assert(options.geometryName, 12);
      var bbox = ol.format.filter.bbox(options.geometryName, options.bbox, options.srsName);
      if (filter) {
        filter = ol.format.filter.and(filter, bbox);
      } else {
        filter = bbox;
      }
    }
  }
  ol.xml.setAttributeNS(node, "http://www.w3.org/2001/XMLSchema-instance", "xsi:schemaLocation", this.schemaLocation_);
  var context = {node:node, "srsName":options.srsName, "featureNS":options.featureNS ? options.featureNS : this.featureNS_, "featurePrefix":options.featurePrefix, "geometryName":options.geometryName, "filter":filter, "propertyNames":options.propertyNames ? options.propertyNames : []};
  ol.asserts.assert(Array.isArray(options.featureTypes), 11);
  ol.format.WFS.writeGetFeature_(node, options.featureTypes, [context]);
  return node;
};
ol.format.WFS.prototype.writeTransaction = function(inserts, updates, deletes, options) {
  var objectStack = [];
  var node = ol.xml.createElementNS(ol.format.WFS.WFSNS, "Transaction");
  var version = options.version ? options.version : ol.format.WFS.DEFAULT_VERSION;
  var gmlVersion = version === "1.0.0" ? 2 : 3;
  node.setAttribute("service", "WFS");
  node.setAttribute("version", version);
  var baseObj;
  var obj;
  if (options) {
    baseObj = options.gmlOptions ? options.gmlOptions : {};
    if (options.handle) {
      node.setAttribute("handle", options.handle);
    }
  }
  var schemaLocation = ol.format.WFS.SCHEMA_LOCATIONS[version];
  ol.xml.setAttributeNS(node, "http://www.w3.org/2001/XMLSchema-instance", "xsi:schemaLocation", schemaLocation);
  var featurePrefix = options.featurePrefix ? options.featurePrefix : ol.format.WFS.FEATURE_PREFIX;
  if (inserts) {
    obj = {node:node, "featureNS":options.featureNS, "featureType":options.featureType, "featurePrefix":featurePrefix, "gmlVersion":gmlVersion, "hasZ":options.hasZ, "srsName":options.srsName};
    ol.obj.assign(obj, baseObj);
    ol.xml.pushSerializeAndPop(obj, ol.format.WFS.TRANSACTION_SERIALIZERS_, ol.xml.makeSimpleNodeFactory("Insert"), inserts, objectStack);
  }
  if (updates) {
    obj = {node:node, "featureNS":options.featureNS, "featureType":options.featureType, "featurePrefix":featurePrefix, "gmlVersion":gmlVersion, "hasZ":options.hasZ, "srsName":options.srsName};
    ol.obj.assign(obj, baseObj);
    ol.xml.pushSerializeAndPop(obj, ol.format.WFS.TRANSACTION_SERIALIZERS_, ol.xml.makeSimpleNodeFactory("Update"), updates, objectStack);
  }
  if (deletes) {
    ol.xml.pushSerializeAndPop({node:node, "featureNS":options.featureNS, "featureType":options.featureType, "featurePrefix":featurePrefix, "gmlVersion":gmlVersion, "srsName":options.srsName}, ol.format.WFS.TRANSACTION_SERIALIZERS_, ol.xml.makeSimpleNodeFactory("Delete"), deletes, objectStack);
  }
  if (options.nativeElements) {
    ol.xml.pushSerializeAndPop({node:node, "featureNS":options.featureNS, "featureType":options.featureType, "featurePrefix":featurePrefix, "gmlVersion":gmlVersion, "srsName":options.srsName}, ol.format.WFS.TRANSACTION_SERIALIZERS_, ol.xml.makeSimpleNodeFactory("Native"), options.nativeElements, objectStack);
  }
  return node;
};
ol.format.WFS.prototype.readProjection;
ol.format.WFS.prototype.readProjectionFromDocument = function(doc) {
  for (var n = doc.firstChild; n; n = n.nextSibling) {
    if (n.nodeType == Node.ELEMENT_NODE) {
      return this.readProjectionFromNode(n);
    }
  }
  return null;
};
ol.format.WFS.prototype.readProjectionFromNode = function(node) {
  if (node.firstElementChild && node.firstElementChild.firstElementChild) {
    node = node.firstElementChild.firstElementChild;
    for (var n = node.firstElementChild; n; n = n.nextElementSibling) {
      if (!(n.childNodes.length === 0 || n.childNodes.length === 1 && n.firstChild.nodeType === 3)) {
        var objectStack = [{}];
        this.gmlFormat_.readGeometryElement(n, objectStack);
        return ol.proj.get(objectStack.pop().srsName);
      }
    }
  }
  return null;
};
goog.provide("ol.format.WKT");
goog.require("ol");
goog.require("ol.Feature");
goog.require("ol.format.Feature");
goog.require("ol.format.TextFeature");
goog.require("ol.geom.GeometryCollection");
goog.require("ol.geom.GeometryType");
goog.require("ol.geom.GeometryLayout");
goog.require("ol.geom.LineString");
goog.require("ol.geom.MultiLineString");
goog.require("ol.geom.MultiPoint");
goog.require("ol.geom.MultiPolygon");
goog.require("ol.geom.Point");
goog.require("ol.geom.Polygon");
goog.require("ol.geom.SimpleGeometry");
ol.format.WKT = function(opt_options) {
  var options = opt_options ? opt_options : {};
  ol.format.TextFeature.call(this);
  this.splitCollection_ = options.splitCollection !== undefined ? options.splitCollection : false;
};
ol.inherits(ol.format.WKT, ol.format.TextFeature);
ol.format.WKT.EMPTY = "EMPTY";
ol.format.WKT.Z = "Z";
ol.format.WKT.M = "M";
ol.format.WKT.ZM = "ZM";
ol.format.WKT.encodePointGeometry_ = function(geom) {
  var coordinates = geom.getCoordinates();
  if (coordinates.length === 0) {
    return "";
  }
  return coordinates.join(" ");
};
ol.format.WKT.encodeMultiPointGeometry_ = function(geom) {
  var array = [];
  var components = geom.getPoints();
  for (var i = 0, ii = components.length; i < ii; ++i) {
    array.push("(" + ol.format.WKT.encodePointGeometry_(components[i]) + ")");
  }
  return array.join(",");
};
ol.format.WKT.encodeGeometryCollectionGeometry_ = function(geom) {
  var array = [];
  var geoms = geom.getGeometries();
  for (var i = 0, ii = geoms.length; i < ii; ++i) {
    array.push(ol.format.WKT.encode_(geoms[i]));
  }
  return array.join(",");
};
ol.format.WKT.encodeLineStringGeometry_ = function(geom) {
  var coordinates = geom.getCoordinates();
  var array = [];
  for (var i = 0, ii = coordinates.length; i < ii; ++i) {
    array.push(coordinates[i].join(" "));
  }
  return array.join(",");
};
ol.format.WKT.encodeMultiLineStringGeometry_ = function(geom) {
  var array = [];
  var components = geom.getLineStrings();
  for (var i = 0, ii = components.length; i < ii; ++i) {
    array.push("(" + ol.format.WKT.encodeLineStringGeometry_(components[i]) + ")");
  }
  return array.join(",");
};
ol.format.WKT.encodePolygonGeometry_ = function(geom) {
  var array = [];
  var rings = geom.getLinearRings();
  for (var i = 0, ii = rings.length; i < ii; ++i) {
    array.push("(" + ol.format.WKT.encodeLineStringGeometry_(rings[i]) + ")");
  }
  return array.join(",");
};
ol.format.WKT.encodeMultiPolygonGeometry_ = function(geom) {
  var array = [];
  var components = geom.getPolygons();
  for (var i = 0, ii = components.length; i < ii; ++i) {
    array.push("(" + ol.format.WKT.encodePolygonGeometry_(components[i]) + ")");
  }
  return array.join(",");
};
ol.format.WKT.encodeGeometryLayout_ = function(geom) {
  var layout = geom.getLayout();
  var dimInfo = "";
  if (layout === ol.geom.GeometryLayout.XYZ || layout === ol.geom.GeometryLayout.XYZM) {
    dimInfo += ol.format.WKT.Z;
  }
  if (layout === ol.geom.GeometryLayout.XYM || layout === ol.geom.GeometryLayout.XYZM) {
    dimInfo += ol.format.WKT.M;
  }
  return dimInfo;
};
ol.format.WKT.encode_ = function(geom) {
  var type = geom.getType();
  var geometryEncoder = ol.format.WKT.GeometryEncoder_[type];
  var enc = geometryEncoder(geom);
  type = type.toUpperCase();
  if (geom instanceof ol.geom.SimpleGeometry) {
    var dimInfo = ol.format.WKT.encodeGeometryLayout_(geom);
    if (dimInfo.length > 0) {
      type += " " + dimInfo;
    }
  }
  if (enc.length === 0) {
    return type + " " + ol.format.WKT.EMPTY;
  }
  return type + "(" + enc + ")";
};
ol.format.WKT.GeometryEncoder_ = {"Point":ol.format.WKT.encodePointGeometry_, "LineString":ol.format.WKT.encodeLineStringGeometry_, "Polygon":ol.format.WKT.encodePolygonGeometry_, "MultiPoint":ol.format.WKT.encodeMultiPointGeometry_, "MultiLineString":ol.format.WKT.encodeMultiLineStringGeometry_, "MultiPolygon":ol.format.WKT.encodeMultiPolygonGeometry_, "GeometryCollection":ol.format.WKT.encodeGeometryCollectionGeometry_};
ol.format.WKT.prototype.parse_ = function(wkt) {
  var lexer = new ol.format.WKT.Lexer(wkt);
  var parser = new ol.format.WKT.Parser(lexer);
  return parser.parse();
};
ol.format.WKT.prototype.readFeature;
ol.format.WKT.prototype.readFeatureFromText = function(text, opt_options) {
  var geom = this.readGeometryFromText(text, opt_options);
  if (geom) {
    var feature = new ol.Feature;
    feature.setGeometry(geom);
    return feature;
  }
  return null;
};
ol.format.WKT.prototype.readFeatures;
ol.format.WKT.prototype.readFeaturesFromText = function(text, opt_options) {
  var geometries = [];
  var geometry = this.readGeometryFromText(text, opt_options);
  if (this.splitCollection_ && geometry.getType() == ol.geom.GeometryType.GEOMETRY_COLLECTION) {
    geometries = geometry.getGeometriesArray();
  } else {
    geometries = [geometry];
  }
  var feature, features = [];
  for (var i = 0, ii = geometries.length; i < ii; ++i) {
    feature = new ol.Feature;
    feature.setGeometry(geometries[i]);
    features.push(feature);
  }
  return features;
};
ol.format.WKT.prototype.readGeometry;
ol.format.WKT.prototype.readGeometryFromText = function(text, opt_options) {
  var geometry = this.parse_(text);
  if (geometry) {
    return ol.format.Feature.transformWithOptions(geometry, false, opt_options);
  } else {
    return null;
  }
};
ol.format.WKT.prototype.writeFeature;
ol.format.WKT.prototype.writeFeatureText = function(feature, opt_options) {
  var geometry = feature.getGeometry();
  if (geometry) {
    return this.writeGeometryText(geometry, opt_options);
  }
  return "";
};
ol.format.WKT.prototype.writeFeatures;
ol.format.WKT.prototype.writeFeaturesText = function(features, opt_options) {
  if (features.length == 1) {
    return this.writeFeatureText(features[0], opt_options);
  }
  var geometries = [];
  for (var i = 0, ii = features.length; i < ii; ++i) {
    geometries.push(features[i].getGeometry());
  }
  var collection = new ol.geom.GeometryCollection(geometries);
  return this.writeGeometryText(collection, opt_options);
};
ol.format.WKT.prototype.writeGeometry;
ol.format.WKT.prototype.writeGeometryText = function(geometry, opt_options) {
  return ol.format.WKT.encode_(ol.format.Feature.transformWithOptions(geometry, true, opt_options));
};
ol.format.WKT.TokenType_ = {TEXT:1, LEFT_PAREN:2, RIGHT_PAREN:3, NUMBER:4, COMMA:5, EOF:6};
ol.format.WKT.Lexer = function(wkt) {
  this.wkt = wkt;
  this.index_ = -1;
};
ol.format.WKT.Lexer.prototype.isAlpha_ = function(c) {
  return c >= "a" && c <= "z" || c >= "A" && c <= "Z";
};
ol.format.WKT.Lexer.prototype.isNumeric_ = function(c, opt_decimal) {
  var decimal = opt_decimal !== undefined ? opt_decimal : false;
  return c >= "0" && c <= "9" || c == "." && !decimal;
};
ol.format.WKT.Lexer.prototype.isWhiteSpace_ = function(c) {
  return c == " " || c == "\t" || c == "\r" || c == "\n";
};
ol.format.WKT.Lexer.prototype.nextChar_ = function() {
  return this.wkt.charAt(++this.index_);
};
ol.format.WKT.Lexer.prototype.nextToken = function() {
  var c = this.nextChar_();
  var token = {position:this.index_, value:c};
  if (c == "(") {
    token.type = ol.format.WKT.TokenType_.LEFT_PAREN;
  } else {
    if (c == ",") {
      token.type = ol.format.WKT.TokenType_.COMMA;
    } else {
      if (c == ")") {
        token.type = ol.format.WKT.TokenType_.RIGHT_PAREN;
      } else {
        if (this.isNumeric_(c) || c == "-") {
          token.type = ol.format.WKT.TokenType_.NUMBER;
          token.value = this.readNumber_();
        } else {
          if (this.isAlpha_(c)) {
            token.type = ol.format.WKT.TokenType_.TEXT;
            token.value = this.readText_();
          } else {
            if (this.isWhiteSpace_(c)) {
              return this.nextToken();
            } else {
              if (c === "") {
                token.type = ol.format.WKT.TokenType_.EOF;
              } else {
                throw new Error("Unexpected character: " + c);
              }
            }
          }
        }
      }
    }
  }
  return token;
};
ol.format.WKT.Lexer.prototype.readNumber_ = function() {
  var c, index = this.index_;
  var decimal = false;
  var scientificNotation = false;
  do {
    if (c == ".") {
      decimal = true;
    } else {
      if (c == "e" || c == "E") {
        scientificNotation = true;
      }
    }
    c = this.nextChar_();
  } while (this.isNumeric_(c, decimal) || !scientificNotation && (c == "e" || c == "E") || scientificNotation && (c == "-" || c == "+"));
  return parseFloat(this.wkt.substring(index, this.index_--));
};
ol.format.WKT.Lexer.prototype.readText_ = function() {
  var c, index = this.index_;
  do {
    c = this.nextChar_();
  } while (this.isAlpha_(c));
  return this.wkt.substring(index, this.index_--).toUpperCase();
};
ol.format.WKT.Parser = function(lexer) {
  this.lexer_ = lexer;
  this.token_;
  this.layout_ = ol.geom.GeometryLayout.XY;
};
ol.format.WKT.Parser.prototype.consume_ = function() {
  this.token_ = this.lexer_.nextToken();
};
ol.format.WKT.Parser.prototype.isTokenType = function(type) {
  var isMatch = this.token_.type == type;
  return isMatch;
};
ol.format.WKT.Parser.prototype.match = function(type) {
  var isMatch = this.isTokenType(type);
  if (isMatch) {
    this.consume_();
  }
  return isMatch;
};
ol.format.WKT.Parser.prototype.parse = function() {
  this.consume_();
  var geometry = this.parseGeometry_();
  return geometry;
};
ol.format.WKT.Parser.prototype.parseGeometryLayout_ = function() {
  var layout = ol.geom.GeometryLayout.XY;
  var dimToken = this.token_;
  if (this.isTokenType(ol.format.WKT.TokenType_.TEXT)) {
    var dimInfo = dimToken.value;
    if (dimInfo === ol.format.WKT.Z) {
      layout = ol.geom.GeometryLayout.XYZ;
    } else {
      if (dimInfo === ol.format.WKT.M) {
        layout = ol.geom.GeometryLayout.XYM;
      } else {
        if (dimInfo === ol.format.WKT.ZM) {
          layout = ol.geom.GeometryLayout.XYZM;
        }
      }
    }
    if (layout !== ol.geom.GeometryLayout.XY) {
      this.consume_();
    }
  }
  return layout;
};
ol.format.WKT.Parser.prototype.parseGeometry_ = function() {
  var token = this.token_;
  if (this.match(ol.format.WKT.TokenType_.TEXT)) {
    var geomType = token.value;
    this.layout_ = this.parseGeometryLayout_();
    if (geomType == ol.geom.GeometryType.GEOMETRY_COLLECTION.toUpperCase()) {
      var geometries = this.parseGeometryCollectionText_();
      return new ol.geom.GeometryCollection(geometries);
    } else {
      var parser = ol.format.WKT.Parser.GeometryParser_[geomType];
      var ctor = ol.format.WKT.Parser.GeometryConstructor_[geomType];
      if (!parser || !ctor) {
        throw new Error("Invalid geometry type: " + geomType);
      }
      var coordinates = parser.call(this);
      return new ctor(coordinates, this.layout_);
    }
  }
  throw new Error(this.formatErrorMessage_());
};
ol.format.WKT.Parser.prototype.parseGeometryCollectionText_ = function() {
  if (this.match(ol.format.WKT.TokenType_.LEFT_PAREN)) {
    var geometries = [];
    do {
      geometries.push(this.parseGeometry_());
    } while (this.match(ol.format.WKT.TokenType_.COMMA));
    if (this.match(ol.format.WKT.TokenType_.RIGHT_PAREN)) {
      return geometries;
    }
  } else {
    if (this.isEmptyGeometry_()) {
      return [];
    }
  }
  throw new Error(this.formatErrorMessage_());
};
ol.format.WKT.Parser.prototype.parsePointText_ = function() {
  if (this.match(ol.format.WKT.TokenType_.LEFT_PAREN)) {
    var coordinates = this.parsePoint_();
    if (this.match(ol.format.WKT.TokenType_.RIGHT_PAREN)) {
      return coordinates;
    }
  } else {
    if (this.isEmptyGeometry_()) {
      return null;
    }
  }
  throw new Error(this.formatErrorMessage_());
};
ol.format.WKT.Parser.prototype.parseLineStringText_ = function() {
  if (this.match(ol.format.WKT.TokenType_.LEFT_PAREN)) {
    var coordinates = this.parsePointList_();
    if (this.match(ol.format.WKT.TokenType_.RIGHT_PAREN)) {
      return coordinates;
    }
  } else {
    if (this.isEmptyGeometry_()) {
      return [];
    }
  }
  throw new Error(this.formatErrorMessage_());
};
ol.format.WKT.Parser.prototype.parsePolygonText_ = function() {
  if (this.match(ol.format.WKT.TokenType_.LEFT_PAREN)) {
    var coordinates = this.parseLineStringTextList_();
    if (this.match(ol.format.WKT.TokenType_.RIGHT_PAREN)) {
      return coordinates;
    }
  } else {
    if (this.isEmptyGeometry_()) {
      return [];
    }
  }
  throw new Error(this.formatErrorMessage_());
};
ol.format.WKT.Parser.prototype.parseMultiPointText_ = function() {
  if (this.match(ol.format.WKT.TokenType_.LEFT_PAREN)) {
    var coordinates;
    if (this.token_.type == ol.format.WKT.TokenType_.LEFT_PAREN) {
      coordinates = this.parsePointTextList_();
    } else {
      coordinates = this.parsePointList_();
    }
    if (this.match(ol.format.WKT.TokenType_.RIGHT_PAREN)) {
      return coordinates;
    }
  } else {
    if (this.isEmptyGeometry_()) {
      return [];
    }
  }
  throw new Error(this.formatErrorMessage_());
};
ol.format.WKT.Parser.prototype.parseMultiLineStringText_ = function() {
  if (this.match(ol.format.WKT.TokenType_.LEFT_PAREN)) {
    var coordinates = this.parseLineStringTextList_();
    if (this.match(ol.format.WKT.TokenType_.RIGHT_PAREN)) {
      return coordinates;
    }
  } else {
    if (this.isEmptyGeometry_()) {
      return [];
    }
  }
  throw new Error(this.formatErrorMessage_());
};
ol.format.WKT.Parser.prototype.parseMultiPolygonText_ = function() {
  if (this.match(ol.format.WKT.TokenType_.LEFT_PAREN)) {
    var coordinates = this.parsePolygonTextList_();
    if (this.match(ol.format.WKT.TokenType_.RIGHT_PAREN)) {
      return coordinates;
    }
  } else {
    if (this.isEmptyGeometry_()) {
      return [];
    }
  }
  throw new Error(this.formatErrorMessage_());
};
ol.format.WKT.Parser.prototype.parsePoint_ = function() {
  var coordinates = [];
  var dimensions = this.layout_.length;
  for (var i = 0; i < dimensions; ++i) {
    var token = this.token_;
    if (this.match(ol.format.WKT.TokenType_.NUMBER)) {
      coordinates.push(token.value);
    } else {
      break;
    }
  }
  if (coordinates.length == dimensions) {
    return coordinates;
  }
  throw new Error(this.formatErrorMessage_());
};
ol.format.WKT.Parser.prototype.parsePointList_ = function() {
  var coordinates = [this.parsePoint_()];
  while (this.match(ol.format.WKT.TokenType_.COMMA)) {
    coordinates.push(this.parsePoint_());
  }
  return coordinates;
};
ol.format.WKT.Parser.prototype.parsePointTextList_ = function() {
  var coordinates = [this.parsePointText_()];
  while (this.match(ol.format.WKT.TokenType_.COMMA)) {
    coordinates.push(this.parsePointText_());
  }
  return coordinates;
};
ol.format.WKT.Parser.prototype.parseLineStringTextList_ = function() {
  var coordinates = [this.parseLineStringText_()];
  while (this.match(ol.format.WKT.TokenType_.COMMA)) {
    coordinates.push(this.parseLineStringText_());
  }
  return coordinates;
};
ol.format.WKT.Parser.prototype.parsePolygonTextList_ = function() {
  var coordinates = [this.parsePolygonText_()];
  while (this.match(ol.format.WKT.TokenType_.COMMA)) {
    coordinates.push(this.parsePolygonText_());
  }
  return coordinates;
};
ol.format.WKT.Parser.prototype.isEmptyGeometry_ = function() {
  var isEmpty = this.isTokenType(ol.format.WKT.TokenType_.TEXT) && this.token_.value == ol.format.WKT.EMPTY;
  if (isEmpty) {
    this.consume_();
  }
  return isEmpty;
};
ol.format.WKT.Parser.prototype.formatErrorMessage_ = function() {
  return "Unexpected `" + this.token_.value + "` at position " + this.token_.position + " in `" + this.lexer_.wkt + "`";
};
ol.format.WKT.Parser.GeometryConstructor_ = {"POINT":ol.geom.Point, "LINESTRING":ol.geom.LineString, "POLYGON":ol.geom.Polygon, "MULTIPOINT":ol.geom.MultiPoint, "MULTILINESTRING":ol.geom.MultiLineString, "MULTIPOLYGON":ol.geom.MultiPolygon};
ol.format.WKT.Parser.GeometryParser_ = {"POINT":ol.format.WKT.Parser.prototype.parsePointText_, "LINESTRING":ol.format.WKT.Parser.prototype.parseLineStringText_, "POLYGON":ol.format.WKT.Parser.prototype.parsePolygonText_, "MULTIPOINT":ol.format.WKT.Parser.prototype.parseMultiPointText_, "MULTILINESTRING":ol.format.WKT.Parser.prototype.parseMultiLineStringText_, "MULTIPOLYGON":ol.format.WKT.Parser.prototype.parseMultiPolygonText_};
goog.provide("ol.format.WMSCapabilities");
goog.require("ol");
goog.require("ol.format.XLink");
goog.require("ol.format.XML");
goog.require("ol.format.XSD");
goog.require("ol.xml");
ol.format.WMSCapabilities = function() {
  ol.format.XML.call(this);
  this.version = undefined;
};
ol.inherits(ol.format.WMSCapabilities, ol.format.XML);
ol.format.WMSCapabilities.prototype.read;
ol.format.WMSCapabilities.prototype.readFromDocument = function(doc) {
  for (var n = doc.firstChild; n; n = n.nextSibling) {
    if (n.nodeType == Node.ELEMENT_NODE) {
      return this.readFromNode(n);
    }
  }
  return null;
};
ol.format.WMSCapabilities.prototype.readFromNode = function(node) {
  this.version = node.getAttribute("version").trim();
  var wmsCapabilityObject = ol.xml.pushParseAndPop({"version":this.version}, ol.format.WMSCapabilities.PARSERS_, node, []);
  return wmsCapabilityObject ? wmsCapabilityObject : null;
};
ol.format.WMSCapabilities.readAttribution_ = function(node, objectStack) {
  return ol.xml.pushParseAndPop({}, ol.format.WMSCapabilities.ATTRIBUTION_PARSERS_, node, objectStack);
};
ol.format.WMSCapabilities.readBoundingBox_ = function(node, objectStack) {
  var extent = [ol.format.XSD.readDecimalString(node.getAttribute("minx")), ol.format.XSD.readDecimalString(node.getAttribute("miny")), ol.format.XSD.readDecimalString(node.getAttribute("maxx")), ol.format.XSD.readDecimalString(node.getAttribute("maxy"))];
  var resolutions = [ol.format.XSD.readDecimalString(node.getAttribute("resx")), ol.format.XSD.readDecimalString(node.getAttribute("resy"))];
  return {"crs":node.getAttribute("CRS"), "extent":extent, "res":resolutions};
};
ol.format.WMSCapabilities.readEXGeographicBoundingBox_ = function(node, objectStack) {
  var geographicBoundingBox = ol.xml.pushParseAndPop({}, ol.format.WMSCapabilities.EX_GEOGRAPHIC_BOUNDING_BOX_PARSERS_, node, objectStack);
  if (!geographicBoundingBox) {
    return undefined;
  }
  var westBoundLongitude = geographicBoundingBox["westBoundLongitude"];
  var southBoundLatitude = geographicBoundingBox["southBoundLatitude"];
  var eastBoundLongitude = geographicBoundingBox["eastBoundLongitude"];
  var northBoundLatitude = geographicBoundingBox["northBoundLatitude"];
  if (westBoundLongitude === undefined || southBoundLatitude === undefined || eastBoundLongitude === undefined || northBoundLatitude === undefined) {
    return undefined;
  }
  return [westBoundLongitude, southBoundLatitude, eastBoundLongitude, northBoundLatitude];
};
ol.format.WMSCapabilities.readCapability_ = function(node, objectStack) {
  return ol.xml.pushParseAndPop({}, ol.format.WMSCapabilities.CAPABILITY_PARSERS_, node, objectStack);
};
ol.format.WMSCapabilities.readService_ = function(node, objectStack) {
  return ol.xml.pushParseAndPop({}, ol.format.WMSCapabilities.SERVICE_PARSERS_, node, objectStack);
};
ol.format.WMSCapabilities.readContactInformation_ = function(node, objectStack) {
  return ol.xml.pushParseAndPop({}, ol.format.WMSCapabilities.CONTACT_INFORMATION_PARSERS_, node, objectStack);
};
ol.format.WMSCapabilities.readContactPersonPrimary_ = function(node, objectStack) {
  return ol.xml.pushParseAndPop({}, ol.format.WMSCapabilities.CONTACT_PERSON_PARSERS_, node, objectStack);
};
ol.format.WMSCapabilities.readContactAddress_ = function(node, objectStack) {
  return ol.xml.pushParseAndPop({}, ol.format.WMSCapabilities.CONTACT_ADDRESS_PARSERS_, node, objectStack);
};
ol.format.WMSCapabilities.readException_ = function(node, objectStack) {
  return ol.xml.pushParseAndPop([], ol.format.WMSCapabilities.EXCEPTION_PARSERS_, node, objectStack);
};
ol.format.WMSCapabilities.readCapabilityLayer_ = function(node, objectStack) {
  return ol.xml.pushParseAndPop({}, ol.format.WMSCapabilities.LAYER_PARSERS_, node, objectStack);
};
ol.format.WMSCapabilities.readLayer_ = function(node, objectStack) {
  var parentLayerObject = objectStack[objectStack.length - 1];
  var layerObject = ol.xml.pushParseAndPop({}, ol.format.WMSCapabilities.LAYER_PARSERS_, node, objectStack);
  if (!layerObject) {
    return undefined;
  }
  var queryable = ol.format.XSD.readBooleanString(node.getAttribute("queryable"));
  if (queryable === undefined) {
    queryable = parentLayerObject["queryable"];
  }
  layerObject["queryable"] = queryable !== undefined ? queryable : false;
  var cascaded = ol.format.XSD.readNonNegativeIntegerString(node.getAttribute("cascaded"));
  if (cascaded === undefined) {
    cascaded = parentLayerObject["cascaded"];
  }
  layerObject["cascaded"] = cascaded;
  var opaque = ol.format.XSD.readBooleanString(node.getAttribute("opaque"));
  if (opaque === undefined) {
    opaque = parentLayerObject["opaque"];
  }
  layerObject["opaque"] = opaque !== undefined ? opaque : false;
  var noSubsets = ol.format.XSD.readBooleanString(node.getAttribute("noSubsets"));
  if (noSubsets === undefined) {
    noSubsets = parentLayerObject["noSubsets"];
  }
  layerObject["noSubsets"] = noSubsets !== undefined ? noSubsets : false;
  var fixedWidth = ol.format.XSD.readDecimalString(node.getAttribute("fixedWidth"));
  if (!fixedWidth) {
    fixedWidth = parentLayerObject["fixedWidth"];
  }
  layerObject["fixedWidth"] = fixedWidth;
  var fixedHeight = ol.format.XSD.readDecimalString(node.getAttribute("fixedHeight"));
  if (!fixedHeight) {
    fixedHeight = parentLayerObject["fixedHeight"];
  }
  layerObject["fixedHeight"] = fixedHeight;
  var addKeys = ["Style", "CRS", "AuthorityURL"];
  addKeys.forEach(function(key) {
    if (key in parentLayerObject) {
      var childValue = layerObject[key] || [];
      layerObject[key] = childValue.concat(parentLayerObject[key]);
    }
  });
  var replaceKeys = ["EX_GeographicBoundingBox", "BoundingBox", "Dimension", "Attribution", "MinScaleDenominator", "MaxScaleDenominator"];
  replaceKeys.forEach(function(key) {
    if (!(key in layerObject)) {
      var parentValue = parentLayerObject[key];
      layerObject[key] = parentValue;
    }
  });
  return layerObject;
};
ol.format.WMSCapabilities.readDimension_ = function(node, objectStack) {
  var dimensionObject = {"name":node.getAttribute("name"), "units":node.getAttribute("units"), "unitSymbol":node.getAttribute("unitSymbol"), "default":node.getAttribute("default"), "multipleValues":ol.format.XSD.readBooleanString(node.getAttribute("multipleValues")), "nearestValue":ol.format.XSD.readBooleanString(node.getAttribute("nearestValue")), "current":ol.format.XSD.readBooleanString(node.getAttribute("current")), "values":ol.format.XSD.readString(node)};
  return dimensionObject;
};
ol.format.WMSCapabilities.readFormatOnlineresource_ = function(node, objectStack) {
  return ol.xml.pushParseAndPop({}, ol.format.WMSCapabilities.FORMAT_ONLINERESOURCE_PARSERS_, node, objectStack);
};
ol.format.WMSCapabilities.readRequest_ = function(node, objectStack) {
  return ol.xml.pushParseAndPop({}, ol.format.WMSCapabilities.REQUEST_PARSERS_, node, objectStack);
};
ol.format.WMSCapabilities.readDCPType_ = function(node, objectStack) {
  return ol.xml.pushParseAndPop({}, ol.format.WMSCapabilities.DCPTYPE_PARSERS_, node, objectStack);
};
ol.format.WMSCapabilities.readHTTP_ = function(node, objectStack) {
  return ol.xml.pushParseAndPop({}, ol.format.WMSCapabilities.HTTP_PARSERS_, node, objectStack);
};
ol.format.WMSCapabilities.readOperationType_ = function(node, objectStack) {
  return ol.xml.pushParseAndPop({}, ol.format.WMSCapabilities.OPERATIONTYPE_PARSERS_, node, objectStack);
};
ol.format.WMSCapabilities.readSizedFormatOnlineresource_ = function(node, objectStack) {
  var formatOnlineresource = ol.format.WMSCapabilities.readFormatOnlineresource_(node, objectStack);
  if (formatOnlineresource) {
    var size = [ol.format.XSD.readNonNegativeIntegerString(node.getAttribute("width")), ol.format.XSD.readNonNegativeIntegerString(node.getAttribute("height"))];
    formatOnlineresource["size"] = size;
    return formatOnlineresource;
  }
  return undefined;
};
ol.format.WMSCapabilities.readAuthorityURL_ = function(node, objectStack) {
  var authorityObject = ol.format.WMSCapabilities.readFormatOnlineresource_(node, objectStack);
  if (authorityObject) {
    authorityObject["name"] = node.getAttribute("name");
    return authorityObject;
  }
  return undefined;
};
ol.format.WMSCapabilities.readMetadataURL_ = function(node, objectStack) {
  var metadataObject = ol.format.WMSCapabilities.readFormatOnlineresource_(node, objectStack);
  if (metadataObject) {
    metadataObject["type"] = node.getAttribute("type");
    return metadataObject;
  }
  return undefined;
};
ol.format.WMSCapabilities.readStyle_ = function(node, objectStack) {
  return ol.xml.pushParseAndPop({}, ol.format.WMSCapabilities.STYLE_PARSERS_, node, objectStack);
};
ol.format.WMSCapabilities.readKeywordList_ = function(node, objectStack) {
  return ol.xml.pushParseAndPop([], ol.format.WMSCapabilities.KEYWORDLIST_PARSERS_, node, objectStack);
};
ol.format.WMSCapabilities.NAMESPACE_URIS_ = [null, "http://www.opengis.net/wms"];
ol.format.WMSCapabilities.PARSERS_ = ol.xml.makeStructureNS(ol.format.WMSCapabilities.NAMESPACE_URIS_, {"Service":ol.xml.makeObjectPropertySetter(ol.format.WMSCapabilities.readService_), "Capability":ol.xml.makeObjectPropertySetter(ol.format.WMSCapabilities.readCapability_)});
ol.format.WMSCapabilities.CAPABILITY_PARSERS_ = ol.xml.makeStructureNS(ol.format.WMSCapabilities.NAMESPACE_URIS_, {"Request":ol.xml.makeObjectPropertySetter(ol.format.WMSCapabilities.readRequest_), "Exception":ol.xml.makeObjectPropertySetter(ol.format.WMSCapabilities.readException_), "Layer":ol.xml.makeObjectPropertySetter(ol.format.WMSCapabilities.readCapabilityLayer_)});
ol.format.WMSCapabilities.SERVICE_PARSERS_ = ol.xml.makeStructureNS(ol.format.WMSCapabilities.NAMESPACE_URIS_, {"Name":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "Title":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "Abstract":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "KeywordList":ol.xml.makeObjectPropertySetter(ol.format.WMSCapabilities.readKeywordList_), "OnlineResource":ol.xml.makeObjectPropertySetter(ol.format.XLink.readHref), "ContactInformation":ol.xml.makeObjectPropertySetter(ol.format.WMSCapabilities.readContactInformation_), 
"Fees":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "AccessConstraints":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "LayerLimit":ol.xml.makeObjectPropertySetter(ol.format.XSD.readNonNegativeInteger), "MaxWidth":ol.xml.makeObjectPropertySetter(ol.format.XSD.readNonNegativeInteger), "MaxHeight":ol.xml.makeObjectPropertySetter(ol.format.XSD.readNonNegativeInteger)});
ol.format.WMSCapabilities.CONTACT_INFORMATION_PARSERS_ = ol.xml.makeStructureNS(ol.format.WMSCapabilities.NAMESPACE_URIS_, {"ContactPersonPrimary":ol.xml.makeObjectPropertySetter(ol.format.WMSCapabilities.readContactPersonPrimary_), "ContactPosition":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "ContactAddress":ol.xml.makeObjectPropertySetter(ol.format.WMSCapabilities.readContactAddress_), "ContactVoiceTelephone":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "ContactFacsimileTelephone":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), 
"ContactElectronicMailAddress":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString)});
ol.format.WMSCapabilities.CONTACT_PERSON_PARSERS_ = ol.xml.makeStructureNS(ol.format.WMSCapabilities.NAMESPACE_URIS_, {"ContactPerson":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "ContactOrganization":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString)});
ol.format.WMSCapabilities.CONTACT_ADDRESS_PARSERS_ = ol.xml.makeStructureNS(ol.format.WMSCapabilities.NAMESPACE_URIS_, {"AddressType":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "Address":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "City":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "StateOrProvince":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "PostCode":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "Country":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString)});
ol.format.WMSCapabilities.EXCEPTION_PARSERS_ = ol.xml.makeStructureNS(ol.format.WMSCapabilities.NAMESPACE_URIS_, {"Format":ol.xml.makeArrayPusher(ol.format.XSD.readString)});
ol.format.WMSCapabilities.LAYER_PARSERS_ = ol.xml.makeStructureNS(ol.format.WMSCapabilities.NAMESPACE_URIS_, {"Name":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "Title":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "Abstract":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "KeywordList":ol.xml.makeObjectPropertySetter(ol.format.WMSCapabilities.readKeywordList_), "CRS":ol.xml.makeObjectPropertyPusher(ol.format.XSD.readString), "EX_GeographicBoundingBox":ol.xml.makeObjectPropertySetter(ol.format.WMSCapabilities.readEXGeographicBoundingBox_), 
"BoundingBox":ol.xml.makeObjectPropertyPusher(ol.format.WMSCapabilities.readBoundingBox_), "Dimension":ol.xml.makeObjectPropertyPusher(ol.format.WMSCapabilities.readDimension_), "Attribution":ol.xml.makeObjectPropertySetter(ol.format.WMSCapabilities.readAttribution_), "AuthorityURL":ol.xml.makeObjectPropertyPusher(ol.format.WMSCapabilities.readAuthorityURL_), "Identifier":ol.xml.makeObjectPropertyPusher(ol.format.XSD.readString), "MetadataURL":ol.xml.makeObjectPropertyPusher(ol.format.WMSCapabilities.readMetadataURL_), 
"DataURL":ol.xml.makeObjectPropertyPusher(ol.format.WMSCapabilities.readFormatOnlineresource_), "FeatureListURL":ol.xml.makeObjectPropertyPusher(ol.format.WMSCapabilities.readFormatOnlineresource_), "Style":ol.xml.makeObjectPropertyPusher(ol.format.WMSCapabilities.readStyle_), "MinScaleDenominator":ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal), "MaxScaleDenominator":ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal), "Layer":ol.xml.makeObjectPropertyPusher(ol.format.WMSCapabilities.readLayer_)});
ol.format.WMSCapabilities.ATTRIBUTION_PARSERS_ = ol.xml.makeStructureNS(ol.format.WMSCapabilities.NAMESPACE_URIS_, {"Title":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "OnlineResource":ol.xml.makeObjectPropertySetter(ol.format.XLink.readHref), "LogoURL":ol.xml.makeObjectPropertySetter(ol.format.WMSCapabilities.readSizedFormatOnlineresource_)});
ol.format.WMSCapabilities.EX_GEOGRAPHIC_BOUNDING_BOX_PARSERS_ = ol.xml.makeStructureNS(ol.format.WMSCapabilities.NAMESPACE_URIS_, {"westBoundLongitude":ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal), "eastBoundLongitude":ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal), "southBoundLatitude":ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal), "northBoundLatitude":ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal)});
ol.format.WMSCapabilities.REQUEST_PARSERS_ = ol.xml.makeStructureNS(ol.format.WMSCapabilities.NAMESPACE_URIS_, {"GetCapabilities":ol.xml.makeObjectPropertySetter(ol.format.WMSCapabilities.readOperationType_), "GetMap":ol.xml.makeObjectPropertySetter(ol.format.WMSCapabilities.readOperationType_), "GetFeatureInfo":ol.xml.makeObjectPropertySetter(ol.format.WMSCapabilities.readOperationType_)});
ol.format.WMSCapabilities.OPERATIONTYPE_PARSERS_ = ol.xml.makeStructureNS(ol.format.WMSCapabilities.NAMESPACE_URIS_, {"Format":ol.xml.makeObjectPropertyPusher(ol.format.XSD.readString), "DCPType":ol.xml.makeObjectPropertyPusher(ol.format.WMSCapabilities.readDCPType_)});
ol.format.WMSCapabilities.DCPTYPE_PARSERS_ = ol.xml.makeStructureNS(ol.format.WMSCapabilities.NAMESPACE_URIS_, {"HTTP":ol.xml.makeObjectPropertySetter(ol.format.WMSCapabilities.readHTTP_)});
ol.format.WMSCapabilities.HTTP_PARSERS_ = ol.xml.makeStructureNS(ol.format.WMSCapabilities.NAMESPACE_URIS_, {"Get":ol.xml.makeObjectPropertySetter(ol.format.WMSCapabilities.readFormatOnlineresource_), "Post":ol.xml.makeObjectPropertySetter(ol.format.WMSCapabilities.readFormatOnlineresource_)});
ol.format.WMSCapabilities.STYLE_PARSERS_ = ol.xml.makeStructureNS(ol.format.WMSCapabilities.NAMESPACE_URIS_, {"Name":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "Title":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "Abstract":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "LegendURL":ol.xml.makeObjectPropertyPusher(ol.format.WMSCapabilities.readSizedFormatOnlineresource_), "StyleSheetURL":ol.xml.makeObjectPropertySetter(ol.format.WMSCapabilities.readFormatOnlineresource_), 
"StyleURL":ol.xml.makeObjectPropertySetter(ol.format.WMSCapabilities.readFormatOnlineresource_)});
ol.format.WMSCapabilities.FORMAT_ONLINERESOURCE_PARSERS_ = ol.xml.makeStructureNS(ol.format.WMSCapabilities.NAMESPACE_URIS_, {"Format":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "OnlineResource":ol.xml.makeObjectPropertySetter(ol.format.XLink.readHref)});
ol.format.WMSCapabilities.KEYWORDLIST_PARSERS_ = ol.xml.makeStructureNS(ol.format.WMSCapabilities.NAMESPACE_URIS_, {"Keyword":ol.xml.makeArrayPusher(ol.format.XSD.readString)});
goog.provide("ol.format.WMSGetFeatureInfo");
goog.require("ol");
goog.require("ol.array");
goog.require("ol.format.GML2");
goog.require("ol.format.XMLFeature");
goog.require("ol.obj");
goog.require("ol.xml");
ol.format.WMSGetFeatureInfo = function(opt_options) {
  var options = opt_options ? opt_options : {};
  this.featureNS_ = "http://mapserver.gis.umn.edu/mapserver";
  this.gmlFormat_ = new ol.format.GML2;
  this.layers_ = options.layers ? options.layers : null;
  ol.format.XMLFeature.call(this);
};
ol.inherits(ol.format.WMSGetFeatureInfo, ol.format.XMLFeature);
ol.format.WMSGetFeatureInfo.featureIdentifier_ = "_feature";
ol.format.WMSGetFeatureInfo.layerIdentifier_ = "_layer";
ol.format.WMSGetFeatureInfo.prototype.getLayers = function() {
  return this.layers_;
};
ol.format.WMSGetFeatureInfo.prototype.setLayers = function(layers) {
  this.layers_ = layers;
};
ol.format.WMSGetFeatureInfo.prototype.readFeatures_ = function(node, objectStack) {
  node.setAttribute("namespaceURI", this.featureNS_);
  var localName = node.localName;
  var features = [];
  if (node.childNodes.length === 0) {
    return features;
  }
  if (localName == "msGMLOutput") {
    for (var i = 0, ii = node.childNodes.length; i < ii; i++) {
      var layer = node.childNodes[i];
      if (layer.nodeType !== Node.ELEMENT_NODE) {
        continue;
      }
      var context = objectStack[0];
      var toRemove = ol.format.WMSGetFeatureInfo.layerIdentifier_;
      var layerName = layer.localName.replace(toRemove, "");
      if (this.layers_ && !ol.array.includes(this.layers_, layerName)) {
        continue;
      }
      var featureType = layerName + ol.format.WMSGetFeatureInfo.featureIdentifier_;
      context["featureType"] = featureType;
      context["featureNS"] = this.featureNS_;
      var parsers = {};
      parsers[featureType] = ol.xml.makeArrayPusher(this.gmlFormat_.readFeatureElement, this.gmlFormat_);
      var parsersNS = ol.xml.makeStructureNS([context["featureNS"], null], parsers);
      layer.setAttribute("namespaceURI", this.featureNS_);
      var layerFeatures = ol.xml.pushParseAndPop([], parsersNS, layer, objectStack, this.gmlFormat_);
      if (layerFeatures) {
        ol.array.extend(features, layerFeatures);
      }
    }
  }
  if (localName == "FeatureCollection") {
    var gmlFeatures = ol.xml.pushParseAndPop([], this.gmlFormat_.FEATURE_COLLECTION_PARSERS, node, [{}], this.gmlFormat_);
    if (gmlFeatures) {
      features = gmlFeatures;
    }
  }
  return features;
};
ol.format.WMSGetFeatureInfo.prototype.readFeatures;
ol.format.WMSGetFeatureInfo.prototype.readFeaturesFromNode = function(node, opt_options) {
  var options = {};
  if (opt_options) {
    ol.obj.assign(options, this.getReadOptions(node, opt_options));
  }
  return this.readFeatures_(node, [options]);
};
ol.format.WMSGetFeatureInfo.prototype.writeFeatureNode = function(feature, opt_options) {
};
ol.format.WMSGetFeatureInfo.prototype.writeFeaturesNode = function(features, opt_options) {
};
ol.format.WMSGetFeatureInfo.prototype.writeGeometryNode = function(geometry, opt_options) {
};
goog.provide("ol.format.WMTSCapabilities");
goog.require("ol");
goog.require("ol.extent");
goog.require("ol.format.OWS");
goog.require("ol.format.XLink");
goog.require("ol.format.XML");
goog.require("ol.format.XSD");
goog.require("ol.xml");
ol.format.WMTSCapabilities = function() {
  ol.format.XML.call(this);
  this.owsParser_ = new ol.format.OWS;
};
ol.inherits(ol.format.WMTSCapabilities, ol.format.XML);
ol.format.WMTSCapabilities.prototype.read;
ol.format.WMTSCapabilities.prototype.readFromDocument = function(doc) {
  for (var n = doc.firstChild; n; n = n.nextSibling) {
    if (n.nodeType == Node.ELEMENT_NODE) {
      return this.readFromNode(n);
    }
  }
  return null;
};
ol.format.WMTSCapabilities.prototype.readFromNode = function(node) {
  var version = node.getAttribute("version").trim();
  var WMTSCapabilityObject = this.owsParser_.readFromNode(node);
  if (!WMTSCapabilityObject) {
    return null;
  }
  WMTSCapabilityObject["version"] = version;
  WMTSCapabilityObject = ol.xml.pushParseAndPop(WMTSCapabilityObject, ol.format.WMTSCapabilities.PARSERS_, node, []);
  return WMTSCapabilityObject ? WMTSCapabilityObject : null;
};
ol.format.WMTSCapabilities.readContents_ = function(node, objectStack) {
  return ol.xml.pushParseAndPop({}, ol.format.WMTSCapabilities.CONTENTS_PARSERS_, node, objectStack);
};
ol.format.WMTSCapabilities.readLayer_ = function(node, objectStack) {
  return ol.xml.pushParseAndPop({}, ol.format.WMTSCapabilities.LAYER_PARSERS_, node, objectStack);
};
ol.format.WMTSCapabilities.readTileMatrixSet_ = function(node, objectStack) {
  return ol.xml.pushParseAndPop({}, ol.format.WMTSCapabilities.TMS_PARSERS_, node, objectStack);
};
ol.format.WMTSCapabilities.readStyle_ = function(node, objectStack) {
  var style = ol.xml.pushParseAndPop({}, ol.format.WMTSCapabilities.STYLE_PARSERS_, node, objectStack);
  if (!style) {
    return undefined;
  }
  var isDefault = node.getAttribute("isDefault") === "true";
  style["isDefault"] = isDefault;
  return style;
};
ol.format.WMTSCapabilities.readTileMatrixSetLink_ = function(node, objectStack) {
  return ol.xml.pushParseAndPop({}, ol.format.WMTSCapabilities.TMS_LINKS_PARSERS_, node, objectStack);
};
ol.format.WMTSCapabilities.readDimensions_ = function(node, objectStack) {
  return ol.xml.pushParseAndPop({}, ol.format.WMTSCapabilities.DIMENSION_PARSERS_, node, objectStack);
};
ol.format.WMTSCapabilities.readResourceUrl_ = function(node, objectStack) {
  var format = node.getAttribute("format");
  var template = node.getAttribute("template");
  var resourceType = node.getAttribute("resourceType");
  var resource = {};
  if (format) {
    resource["format"] = format;
  }
  if (template) {
    resource["template"] = template;
  }
  if (resourceType) {
    resource["resourceType"] = resourceType;
  }
  return resource;
};
ol.format.WMTSCapabilities.readWgs84BoundingBox_ = function(node, objectStack) {
  var coordinates = ol.xml.pushParseAndPop([], ol.format.WMTSCapabilities.WGS84_BBOX_READERS_, node, objectStack);
  if (coordinates.length != 2) {
    return undefined;
  }
  return ol.extent.boundingExtent(coordinates);
};
ol.format.WMTSCapabilities.readLegendUrl_ = function(node, objectStack) {
  var legend = {};
  legend["format"] = node.getAttribute("format");
  legend["href"] = ol.format.XLink.readHref(node);
  return legend;
};
ol.format.WMTSCapabilities.readCoordinates_ = function(node, objectStack) {
  var coordinates = ol.format.XSD.readString(node).split(" ");
  if (!coordinates || coordinates.length != 2) {
    return undefined;
  }
  var x = +coordinates[0];
  var y = +coordinates[1];
  if (isNaN(x) || isNaN(y)) {
    return undefined;
  }
  return [x, y];
};
ol.format.WMTSCapabilities.readTileMatrix_ = function(node, objectStack) {
  return ol.xml.pushParseAndPop({}, ol.format.WMTSCapabilities.TM_PARSERS_, node, objectStack);
};
ol.format.WMTSCapabilities.readTileMatrixLimitsList_ = function(node, objectStack) {
  return ol.xml.pushParseAndPop([], ol.format.WMTSCapabilities.TMS_LIMITS_LIST_PARSERS_, node, objectStack);
};
ol.format.WMTSCapabilities.readTileMatrixLimits_ = function(node, objectStack) {
  return ol.xml.pushParseAndPop({}, ol.format.WMTSCapabilities.TMS_LIMITS_PARSERS_, node, objectStack);
};
ol.format.WMTSCapabilities.NAMESPACE_URIS_ = [null, "http://www.opengis.net/wmts/1.0"];
ol.format.WMTSCapabilities.OWS_NAMESPACE_URIS_ = [null, "http://www.opengis.net/ows/1.1"];
ol.format.WMTSCapabilities.PARSERS_ = ol.xml.makeStructureNS(ol.format.WMTSCapabilities.NAMESPACE_URIS_, {"Contents":ol.xml.makeObjectPropertySetter(ol.format.WMTSCapabilities.readContents_)});
ol.format.WMTSCapabilities.CONTENTS_PARSERS_ = ol.xml.makeStructureNS(ol.format.WMTSCapabilities.NAMESPACE_URIS_, {"Layer":ol.xml.makeObjectPropertyPusher(ol.format.WMTSCapabilities.readLayer_), "TileMatrixSet":ol.xml.makeObjectPropertyPusher(ol.format.WMTSCapabilities.readTileMatrixSet_)});
ol.format.WMTSCapabilities.LAYER_PARSERS_ = ol.xml.makeStructureNS(ol.format.WMTSCapabilities.NAMESPACE_URIS_, {"Style":ol.xml.makeObjectPropertyPusher(ol.format.WMTSCapabilities.readStyle_), "Format":ol.xml.makeObjectPropertyPusher(ol.format.XSD.readString), "TileMatrixSetLink":ol.xml.makeObjectPropertyPusher(ol.format.WMTSCapabilities.readTileMatrixSetLink_), "Dimension":ol.xml.makeObjectPropertyPusher(ol.format.WMTSCapabilities.readDimensions_), "ResourceURL":ol.xml.makeObjectPropertyPusher(ol.format.WMTSCapabilities.readResourceUrl_)}, 
ol.xml.makeStructureNS(ol.format.WMTSCapabilities.OWS_NAMESPACE_URIS_, {"Title":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "Abstract":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "WGS84BoundingBox":ol.xml.makeObjectPropertySetter(ol.format.WMTSCapabilities.readWgs84BoundingBox_), "Identifier":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString)}));
ol.format.WMTSCapabilities.STYLE_PARSERS_ = ol.xml.makeStructureNS(ol.format.WMTSCapabilities.NAMESPACE_URIS_, {"LegendURL":ol.xml.makeObjectPropertyPusher(ol.format.WMTSCapabilities.readLegendUrl_)}, ol.xml.makeStructureNS(ol.format.WMTSCapabilities.OWS_NAMESPACE_URIS_, {"Title":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "Identifier":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString)}));
ol.format.WMTSCapabilities.TMS_LINKS_PARSERS_ = ol.xml.makeStructureNS(ol.format.WMTSCapabilities.NAMESPACE_URIS_, {"TileMatrixSet":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "TileMatrixSetLimits":ol.xml.makeObjectPropertySetter(ol.format.WMTSCapabilities.readTileMatrixLimitsList_)});
ol.format.WMTSCapabilities.TMS_LIMITS_LIST_PARSERS_ = ol.xml.makeStructureNS(ol.format.WMTSCapabilities.NAMESPACE_URIS_, {"TileMatrixLimits":ol.xml.makeArrayPusher(ol.format.WMTSCapabilities.readTileMatrixLimits_)});
ol.format.WMTSCapabilities.TMS_LIMITS_PARSERS_ = ol.xml.makeStructureNS(ol.format.WMTSCapabilities.NAMESPACE_URIS_, {"TileMatrix":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "MinTileRow":ol.xml.makeObjectPropertySetter(ol.format.XSD.readNonNegativeInteger), "MaxTileRow":ol.xml.makeObjectPropertySetter(ol.format.XSD.readNonNegativeInteger), "MinTileCol":ol.xml.makeObjectPropertySetter(ol.format.XSD.readNonNegativeInteger), "MaxTileCol":ol.xml.makeObjectPropertySetter(ol.format.XSD.readNonNegativeInteger)});
ol.format.WMTSCapabilities.DIMENSION_PARSERS_ = ol.xml.makeStructureNS(ol.format.WMTSCapabilities.NAMESPACE_URIS_, {"Default":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "Value":ol.xml.makeObjectPropertyPusher(ol.format.XSD.readString)}, ol.xml.makeStructureNS(ol.format.WMTSCapabilities.OWS_NAMESPACE_URIS_, {"Identifier":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString)}));
ol.format.WMTSCapabilities.WGS84_BBOX_READERS_ = ol.xml.makeStructureNS(ol.format.WMTSCapabilities.OWS_NAMESPACE_URIS_, {"LowerCorner":ol.xml.makeArrayPusher(ol.format.WMTSCapabilities.readCoordinates_), "UpperCorner":ol.xml.makeArrayPusher(ol.format.WMTSCapabilities.readCoordinates_)});
ol.format.WMTSCapabilities.TMS_PARSERS_ = ol.xml.makeStructureNS(ol.format.WMTSCapabilities.NAMESPACE_URIS_, {"WellKnownScaleSet":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "TileMatrix":ol.xml.makeObjectPropertyPusher(ol.format.WMTSCapabilities.readTileMatrix_)}, ol.xml.makeStructureNS(ol.format.WMTSCapabilities.OWS_NAMESPACE_URIS_, {"SupportedCRS":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString), "Identifier":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString)}));
ol.format.WMTSCapabilities.TM_PARSERS_ = ol.xml.makeStructureNS(ol.format.WMTSCapabilities.NAMESPACE_URIS_, {"TopLeftCorner":ol.xml.makeObjectPropertySetter(ol.format.WMTSCapabilities.readCoordinates_), "ScaleDenominator":ol.xml.makeObjectPropertySetter(ol.format.XSD.readDecimal), "TileWidth":ol.xml.makeObjectPropertySetter(ol.format.XSD.readNonNegativeInteger), "TileHeight":ol.xml.makeObjectPropertySetter(ol.format.XSD.readNonNegativeInteger), "MatrixWidth":ol.xml.makeObjectPropertySetter(ol.format.XSD.readNonNegativeInteger), 
"MatrixHeight":ol.xml.makeObjectPropertySetter(ol.format.XSD.readNonNegativeInteger)}, ol.xml.makeStructureNS(ol.format.WMTSCapabilities.OWS_NAMESPACE_URIS_, {"Identifier":ol.xml.makeObjectPropertySetter(ol.format.XSD.readString)}));
goog.provide("ol.GeolocationProperty");
ol.GeolocationProperty = {ACCURACY:"accuracy", ACCURACY_GEOMETRY:"accuracyGeometry", ALTITUDE:"altitude", ALTITUDE_ACCURACY:"altitudeAccuracy", HEADING:"heading", POSITION:"position", PROJECTION:"projection", SPEED:"speed", TRACKING:"tracking", TRACKING_OPTIONS:"trackingOptions"};
goog.provide("ol.Geolocation");
goog.require("ol");
goog.require("ol.GeolocationProperty");
goog.require("ol.Object");
goog.require("ol.Sphere");
goog.require("ol.events");
goog.require("ol.events.EventType");
goog.require("ol.geom.Polygon");
goog.require("ol.has");
goog.require("ol.math");
goog.require("ol.proj");
goog.require("ol.proj.EPSG4326");
ol.Geolocation = function(opt_options) {
  ol.Object.call(this);
  var options = opt_options || {};
  this.position_ = null;
  this.transform_ = ol.proj.identityTransform;
  this.sphere_ = new ol.Sphere(ol.proj.EPSG4326.RADIUS);
  this.watchId_ = undefined;
  ol.events.listen(this, ol.Object.getChangeEventType(ol.GeolocationProperty.PROJECTION), this.handleProjectionChanged_, this);
  ol.events.listen(this, ol.Object.getChangeEventType(ol.GeolocationProperty.TRACKING), this.handleTrackingChanged_, this);
  if (options.projection !== undefined) {
    this.setProjection(options.projection);
  }
  if (options.trackingOptions !== undefined) {
    this.setTrackingOptions(options.trackingOptions);
  }
  this.setTracking(options.tracking !== undefined ? options.tracking : false);
};
ol.inherits(ol.Geolocation, ol.Object);
ol.Geolocation.prototype.disposeInternal = function() {
  this.setTracking(false);
  ol.Object.prototype.disposeInternal.call(this);
};
ol.Geolocation.prototype.handleProjectionChanged_ = function() {
  var projection = this.getProjection();
  if (projection) {
    this.transform_ = ol.proj.getTransformFromProjections(ol.proj.get("EPSG:4326"), projection);
    if (this.position_) {
      this.set(ol.GeolocationProperty.POSITION, this.transform_(this.position_));
    }
  }
};
ol.Geolocation.prototype.handleTrackingChanged_ = function() {
  if (ol.has.GEOLOCATION) {
    var tracking = this.getTracking();
    if (tracking && this.watchId_ === undefined) {
      this.watchId_ = navigator.geolocation.watchPosition(this.positionChange_.bind(this), this.positionError_.bind(this), this.getTrackingOptions());
    } else {
      if (!tracking && this.watchId_ !== undefined) {
        navigator.geolocation.clearWatch(this.watchId_);
        this.watchId_ = undefined;
      }
    }
  }
};
ol.Geolocation.prototype.positionChange_ = function(position) {
  var coords = position.coords;
  this.set(ol.GeolocationProperty.ACCURACY, coords.accuracy);
  this.set(ol.GeolocationProperty.ALTITUDE, coords.altitude === null ? undefined : coords.altitude);
  this.set(ol.GeolocationProperty.ALTITUDE_ACCURACY, coords.altitudeAccuracy === null ? undefined : coords.altitudeAccuracy);
  this.set(ol.GeolocationProperty.HEADING, coords.heading === null ? undefined : ol.math.toRadians(coords.heading));
  if (!this.position_) {
    this.position_ = [coords.longitude, coords.latitude];
  } else {
    this.position_[0] = coords.longitude;
    this.position_[1] = coords.latitude;
  }
  var projectedPosition = this.transform_(this.position_);
  this.set(ol.GeolocationProperty.POSITION, projectedPosition);
  this.set(ol.GeolocationProperty.SPEED, coords.speed === null ? undefined : coords.speed);
  var geometry = ol.geom.Polygon.circular(this.sphere_, this.position_, coords.accuracy);
  geometry.applyTransform(this.transform_);
  this.set(ol.GeolocationProperty.ACCURACY_GEOMETRY, geometry);
  this.changed();
};
ol.Geolocation.prototype.positionError_ = function(error) {
  error.type = ol.events.EventType.ERROR;
  this.setTracking(false);
  this.dispatchEvent(error);
};
ol.Geolocation.prototype.getAccuracy = function() {
  return this.get(ol.GeolocationProperty.ACCURACY);
};
ol.Geolocation.prototype.getAccuracyGeometry = function() {
  return this.get(ol.GeolocationProperty.ACCURACY_GEOMETRY) || null;
};
ol.Geolocation.prototype.getAltitude = function() {
  return this.get(ol.GeolocationProperty.ALTITUDE);
};
ol.Geolocation.prototype.getAltitudeAccuracy = function() {
  return this.get(ol.GeolocationProperty.ALTITUDE_ACCURACY);
};
ol.Geolocation.prototype.getHeading = function() {
  return this.get(ol.GeolocationProperty.HEADING);
};
ol.Geolocation.prototype.getPosition = function() {
  return this.get(ol.GeolocationProperty.POSITION);
};
ol.Geolocation.prototype.getProjection = function() {
  return this.get(ol.GeolocationProperty.PROJECTION);
};
ol.Geolocation.prototype.getSpeed = function() {
  return this.get(ol.GeolocationProperty.SPEED);
};
ol.Geolocation.prototype.getTracking = function() {
  return this.get(ol.GeolocationProperty.TRACKING);
};
ol.Geolocation.prototype.getTrackingOptions = function() {
  return this.get(ol.GeolocationProperty.TRACKING_OPTIONS);
};
ol.Geolocation.prototype.setProjection = function(projection) {
  this.set(ol.GeolocationProperty.PROJECTION, ol.proj.get(projection));
};
ol.Geolocation.prototype.setTracking = function(tracking) {
  this.set(ol.GeolocationProperty.TRACKING, tracking);
};
ol.Geolocation.prototype.setTrackingOptions = function(options) {
  this.set(ol.GeolocationProperty.TRACKING_OPTIONS, options);
};
goog.provide("ol.geom.Circle");
goog.require("ol");
goog.require("ol.extent");
goog.require("ol.geom.GeometryLayout");
goog.require("ol.geom.GeometryType");
goog.require("ol.geom.SimpleGeometry");
goog.require("ol.geom.flat.deflate");
ol.geom.Circle = function(center, opt_radius, opt_layout) {
  ol.geom.SimpleGeometry.call(this);
  var radius = opt_radius ? opt_radius : 0;
  this.setCenterAndRadius(center, radius, opt_layout);
};
ol.inherits(ol.geom.Circle, ol.geom.SimpleGeometry);
ol.geom.Circle.prototype.clone = function() {
  var circle = new ol.geom.Circle(null);
  circle.setFlatCoordinates(this.layout, this.flatCoordinates.slice());
  return circle;
};
ol.geom.Circle.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {
  var flatCoordinates = this.flatCoordinates;
  var dx = x - flatCoordinates[0];
  var dy = y - flatCoordinates[1];
  var squaredDistance = dx * dx + dy * dy;
  if (squaredDistance < minSquaredDistance) {
    var i;
    if (squaredDistance === 0) {
      for (i = 0; i < this.stride; ++i) {
        closestPoint[i] = flatCoordinates[i];
      }
    } else {
      var delta = this.getRadius() / Math.sqrt(squaredDistance);
      closestPoint[0] = flatCoordinates[0] + delta * dx;
      closestPoint[1] = flatCoordinates[1] + delta * dy;
      for (i = 2; i < this.stride; ++i) {
        closestPoint[i] = flatCoordinates[i];
      }
    }
    closestPoint.length = this.stride;
    return squaredDistance;
  } else {
    return minSquaredDistance;
  }
};
ol.geom.Circle.prototype.containsXY = function(x, y) {
  var flatCoordinates = this.flatCoordinates;
  var dx = x - flatCoordinates[0];
  var dy = y - flatCoordinates[1];
  return dx * dx + dy * dy <= this.getRadiusSquared_();
};
ol.geom.Circle.prototype.getCenter = function() {
  return this.flatCoordinates.slice(0, this.stride);
};
ol.geom.Circle.prototype.computeExtent = function(extent) {
  var flatCoordinates = this.flatCoordinates;
  var radius = flatCoordinates[this.stride] - flatCoordinates[0];
  return ol.extent.createOrUpdate(flatCoordinates[0] - radius, flatCoordinates[1] - radius, flatCoordinates[0] + radius, flatCoordinates[1] + radius, extent);
};
ol.geom.Circle.prototype.getRadius = function() {
  return Math.sqrt(this.getRadiusSquared_());
};
ol.geom.Circle.prototype.getRadiusSquared_ = function() {
  var dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];
  var dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];
  return dx * dx + dy * dy;
};
ol.geom.Circle.prototype.getType = function() {
  return ol.geom.GeometryType.CIRCLE;
};
ol.geom.Circle.prototype.intersectsExtent = function(extent) {
  var circleExtent = this.getExtent();
  if (ol.extent.intersects(extent, circleExtent)) {
    var center = this.getCenter();
    if (extent[0] <= center[0] && extent[2] >= center[0]) {
      return true;
    }
    if (extent[1] <= center[1] && extent[3] >= center[1]) {
      return true;
    }
    return ol.extent.forEachCorner(extent, this.intersectsCoordinate, this);
  }
  return false;
};
ol.geom.Circle.prototype.setCenter = function(center) {
  var stride = this.stride;
  var radius = this.flatCoordinates[stride] - this.flatCoordinates[0];
  var flatCoordinates = center.slice();
  flatCoordinates[stride] = flatCoordinates[0] + radius;
  var i;
  for (i = 1; i < stride; ++i) {
    flatCoordinates[stride + i] = center[i];
  }
  this.setFlatCoordinates(this.layout, flatCoordinates);
};
ol.geom.Circle.prototype.setCenterAndRadius = function(center, radius, opt_layout) {
  if (!center) {
    this.setFlatCoordinates(ol.geom.GeometryLayout.XY, null);
  } else {
    this.setLayout(opt_layout, center, 0);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    var flatCoordinates = this.flatCoordinates;
    var offset = ol.geom.flat.deflate.coordinate(flatCoordinates, 0, center, this.stride);
    flatCoordinates[offset++] = flatCoordinates[0] + radius;
    var i, ii;
    for (i = 1, ii = this.stride; i < ii; ++i) {
      flatCoordinates[offset++] = flatCoordinates[i];
    }
    flatCoordinates.length = offset;
    this.changed();
  }
};
ol.geom.Circle.prototype.getCoordinates = function() {
};
ol.geom.Circle.prototype.setCoordinates = function(coordinates, opt_layout) {
};
ol.geom.Circle.prototype.setFlatCoordinates = function(layout, flatCoordinates) {
  this.setFlatCoordinatesInternal(layout, flatCoordinates);
  this.changed();
};
ol.geom.Circle.prototype.setRadius = function(radius) {
  this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;
  this.changed();
};
ol.geom.Circle.prototype.transform;
goog.provide("ol.geom.flat.geodesic");
goog.require("ol.math");
goog.require("ol.proj");
ol.geom.flat.geodesic.line_ = function(interpolate, transform, squaredTolerance) {
  var flatCoordinates = [];
  var geoA = interpolate(0);
  var geoB = interpolate(1);
  var a = transform(geoA);
  var b = transform(geoB);
  var geoStack = [geoB, geoA];
  var stack = [b, a];
  var fractionStack = [1, 0];
  var fractions = {};
  var maxIterations = 1e5;
  var geoM, m, fracA, fracB, fracM, key;
  while (--maxIterations > 0 && fractionStack.length > 0) {
    fracA = fractionStack.pop();
    geoA = geoStack.pop();
    a = stack.pop();
    key = fracA.toString();
    if (!(key in fractions)) {
      flatCoordinates.push(a[0], a[1]);
      fractions[key] = true;
    }
    fracB = fractionStack.pop();
    geoB = geoStack.pop();
    b = stack.pop();
    fracM = (fracA + fracB) / 2;
    geoM = interpolate(fracM);
    m = transform(geoM);
    if (ol.math.squaredSegmentDistance(m[0], m[1], a[0], a[1], b[0], b[1]) < squaredTolerance) {
      flatCoordinates.push(b[0], b[1]);
      key = fracB.toString();
      fractions[key] = true;
    } else {
      fractionStack.push(fracB, fracM, fracM, fracA);
      stack.push(b, m, m, a);
      geoStack.push(geoB, geoM, geoM, geoA);
    }
  }
  return flatCoordinates;
};
ol.geom.flat.geodesic.greatCircleArc = function(lon1, lat1, lon2, lat2, projection, squaredTolerance) {
  var geoProjection = ol.proj.get("EPSG:4326");
  var cosLat1 = Math.cos(ol.math.toRadians(lat1));
  var sinLat1 = Math.sin(ol.math.toRadians(lat1));
  var cosLat2 = Math.cos(ol.math.toRadians(lat2));
  var sinLat2 = Math.sin(ol.math.toRadians(lat2));
  var cosDeltaLon = Math.cos(ol.math.toRadians(lon2 - lon1));
  var sinDeltaLon = Math.sin(ol.math.toRadians(lon2 - lon1));
  var d = sinLat1 * sinLat2 + cosLat1 * cosLat2 * cosDeltaLon;
  return ol.geom.flat.geodesic.line_(function(frac) {
    if (1 <= d) {
      return [lon2, lat2];
    }
    var D = frac * Math.acos(d);
    var cosD = Math.cos(D);
    var sinD = Math.sin(D);
    var y = sinDeltaLon * cosLat2;
    var x = cosLat1 * sinLat2 - sinLat1 * cosLat2 * cosDeltaLon;
    var theta = Math.atan2(y, x);
    var lat = Math.asin(sinLat1 * cosD + cosLat1 * sinD * Math.cos(theta));
    var lon = ol.math.toRadians(lon1) + Math.atan2(Math.sin(theta) * sinD * cosLat1, cosD - sinLat1 * Math.sin(lat));
    return [ol.math.toDegrees(lon), ol.math.toDegrees(lat)];
  }, ol.proj.getTransform(geoProjection, projection), squaredTolerance);
};
ol.geom.flat.geodesic.meridian = function(lon, lat1, lat2, projection, squaredTolerance) {
  var epsg4326Projection = ol.proj.get("EPSG:4326");
  return ol.geom.flat.geodesic.line_(function(frac) {
    return [lon, lat1 + (lat2 - lat1) * frac];
  }, ol.proj.getTransform(epsg4326Projection, projection), squaredTolerance);
};
ol.geom.flat.geodesic.parallel = function(lat, lon1, lon2, projection, squaredTolerance) {
  var epsg4326Projection = ol.proj.get("EPSG:4326");
  return ol.geom.flat.geodesic.line_(function(frac) {
    return [lon1 + (lon2 - lon1) * frac, lat];
  }, ol.proj.getTransform(epsg4326Projection, projection), squaredTolerance);
};
goog.provide("ol.geom.flat.topology");
goog.require("ol.geom.flat.area");
ol.geom.flat.topology.lineStringIsClosed = function(flatCoordinates, offset, end, stride) {
  var lastCoord = end - stride;
  if (flatCoordinates[offset] === flatCoordinates[lastCoord] && flatCoordinates[offset + 1] === flatCoordinates[lastCoord + 1] && (end - offset) / stride > 3) {
    return !!ol.geom.flat.area.linearRing(flatCoordinates, offset, end, stride);
  }
  return false;
};
goog.provide("ol.Graticule");
goog.require("ol.coordinate");
goog.require("ol.extent");
goog.require("ol.geom.GeometryLayout");
goog.require("ol.geom.LineString");
goog.require("ol.geom.Point");
goog.require("ol.geom.flat.geodesic");
goog.require("ol.math");
goog.require("ol.proj");
goog.require("ol.render.EventType");
goog.require("ol.style.Fill");
goog.require("ol.style.Stroke");
goog.require("ol.style.Text");
ol.Graticule = function(opt_options) {
  var options = opt_options || {};
  this.map_ = null;
  this.projection_ = null;
  this.maxLat_ = Infinity;
  this.maxLon_ = Infinity;
  this.minLat_ = -Infinity;
  this.minLon_ = -Infinity;
  this.maxLatP_ = Infinity;
  this.maxLonP_ = Infinity;
  this.minLatP_ = -Infinity;
  this.minLonP_ = -Infinity;
  this.targetSize_ = options.targetSize !== undefined ? options.targetSize : 100;
  this.maxLines_ = options.maxLines !== undefined ? options.maxLines : 100;
  this.meridians_ = [];
  this.parallels_ = [];
  this.strokeStyle_ = options.strokeStyle !== undefined ? options.strokeStyle : ol.Graticule.DEFAULT_STROKE_STYLE_;
  this.fromLonLatTransform_ = undefined;
  this.toLonLatTransform_ = undefined;
  this.projectionCenterLonLat_ = null;
  this.meridiansLabels_ = null;
  this.parallelsLabels_ = null;
  if (options.showLabels == true) {
    var degreesToString = ol.coordinate.degreesToStringHDMS;
    this.lonLabelFormatter_ = options.lonLabelFormatter == undefined ? degreesToString.bind(this, "EW") : options.lonLabelFormatter;
    this.latLabelFormatter_ = options.latLabelFormatter == undefined ? degreesToString.bind(this, "NS") : options.latLabelFormatter;
    this.lonLabelPosition_ = options.lonLabelPosition == undefined ? 0 : options.lonLabelPosition;
    this.latLabelPosition_ = options.latLabelPosition == undefined ? 1 : options.latLabelPosition;
    this.lonLabelStyle_ = options.lonLabelStyle !== undefined ? options.lonLabelStyle : new ol.style.Text({font:"12px Calibri,sans-serif", textBaseline:"bottom", fill:new ol.style.Fill({color:"rgba(0,0,0,1)"}), stroke:new ol.style.Stroke({color:"rgba(255,255,255,1)", width:3})});
    this.latLabelStyle_ = options.latLabelStyle !== undefined ? options.latLabelStyle : new ol.style.Text({font:"12px Calibri,sans-serif", textAlign:"end", fill:new ol.style.Fill({color:"rgba(0,0,0,1)"}), stroke:new ol.style.Stroke({color:"rgba(255,255,255,1)", width:3})});
    this.meridiansLabels_ = [];
    this.parallelsLabels_ = [];
  }
  this.setMap(options.map !== undefined ? options.map : null);
};
ol.Graticule.DEFAULT_STROKE_STYLE_ = new ol.style.Stroke({color:"rgba(0,0,0,0.2)"});
ol.Graticule.intervals_ = [90, 45, 30, 20, 10, 5, 2, 1, 0.5, 0.2, 0.1, 0.05, 0.01, 0.005, 0.002, 0.001];
ol.Graticule.prototype.addMeridian_ = function(lon, minLat, maxLat, squaredTolerance, extent, index) {
  var lineString = this.getMeridian_(lon, minLat, maxLat, squaredTolerance, index);
  if (ol.extent.intersects(lineString.getExtent(), extent)) {
    if (this.meridiansLabels_) {
      var textPoint = this.getMeridianPoint_(lineString, extent, index);
      this.meridiansLabels_[index] = {geom:textPoint, text:this.lonLabelFormatter_(lon)};
    }
    this.meridians_[index++] = lineString;
  }
  return index;
};
ol.Graticule.prototype.getMeridianPoint_ = function(lineString, extent, index) {
  var flatCoordinates = lineString.getFlatCoordinates();
  var clampedBottom = Math.max(extent[1], flatCoordinates[1]);
  var clampedTop = Math.min(extent[3], flatCoordinates[flatCoordinates.length - 1]);
  var lat = ol.math.clamp(extent[1] + Math.abs(extent[1] - extent[3]) * this.lonLabelPosition_, clampedBottom, clampedTop);
  var coordinate = [flatCoordinates[0], lat];
  var point = this.meridiansLabels_[index] !== undefined ? this.meridiansLabels_[index].geom : new ol.geom.Point(null);
  point.setCoordinates(coordinate);
  return point;
};
ol.Graticule.prototype.addParallel_ = function(lat, minLon, maxLon, squaredTolerance, extent, index) {
  var lineString = this.getParallel_(lat, minLon, maxLon, squaredTolerance, index);
  if (ol.extent.intersects(lineString.getExtent(), extent)) {
    if (this.parallelsLabels_) {
      var textPoint = this.getParallelPoint_(lineString, extent, index);
      this.parallelsLabels_[index] = {geom:textPoint, text:this.latLabelFormatter_(lat)};
    }
    this.parallels_[index++] = lineString;
  }
  return index;
};
ol.Graticule.prototype.getParallelPoint_ = function(lineString, extent, index) {
  var flatCoordinates = lineString.getFlatCoordinates();
  var clampedLeft = Math.max(extent[0], flatCoordinates[0]);
  var clampedRight = Math.min(extent[2], flatCoordinates[flatCoordinates.length - 2]);
  var lon = ol.math.clamp(extent[0] + Math.abs(extent[0] - extent[2]) * this.latLabelPosition_, clampedLeft, clampedRight);
  var coordinate = [lon, flatCoordinates[1]];
  var point = this.parallelsLabels_[index] !== undefined ? this.parallelsLabels_[index].geom : new ol.geom.Point(null);
  point.setCoordinates(coordinate);
  return point;
};
ol.Graticule.prototype.createGraticule_ = function(extent, center, resolution, squaredTolerance) {
  var interval = this.getInterval_(resolution);
  if (interval == -1) {
    this.meridians_.length = this.parallels_.length = 0;
    if (this.meridiansLabels_) {
      this.meridiansLabels_.length = 0;
    }
    if (this.parallelsLabels_) {
      this.parallelsLabels_.length = 0;
    }
    return;
  }
  var centerLonLat = this.toLonLatTransform_(center);
  var centerLon = centerLonLat[0];
  var centerLat = centerLonLat[1];
  var maxLines = this.maxLines_;
  var cnt, idx, lat, lon;
  var validExtent = [Math.max(extent[0], this.minLonP_), Math.max(extent[1], this.minLatP_), Math.min(extent[2], this.maxLonP_), Math.min(extent[3], this.maxLatP_)];
  validExtent = ol.proj.transformExtent(validExtent, this.projection_, "EPSG:4326");
  var maxLat = validExtent[3];
  var maxLon = validExtent[2];
  var minLat = validExtent[1];
  var minLon = validExtent[0];
  centerLon = Math.floor(centerLon / interval) * interval;
  lon = ol.math.clamp(centerLon, this.minLon_, this.maxLon_);
  idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, 0);
  cnt = 0;
  while (lon != this.minLon_ && cnt++ < maxLines) {
    lon = Math.max(lon - interval, this.minLon_);
    idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);
  }
  lon = ol.math.clamp(centerLon, this.minLon_, this.maxLon_);
  cnt = 0;
  while (lon != this.maxLon_ && cnt++ < maxLines) {
    lon = Math.min(lon + interval, this.maxLon_);
    idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);
  }
  this.meridians_.length = idx;
  if (this.meridiansLabels_) {
    this.meridiansLabels_.length = idx;
  }
  centerLat = Math.floor(centerLat / interval) * interval;
  lat = ol.math.clamp(centerLat, this.minLat_, this.maxLat_);
  idx = this.addParallel_(lat, minLon, maxLon, squaredTolerance, extent, 0);
  cnt = 0;
  while (lat != this.minLat_ && cnt++ < maxLines) {
    lat = Math.max(lat - interval, this.minLat_);
    idx = this.addParallel_(lat, minLon, maxLon, squaredTolerance, extent, idx);
  }
  lat = ol.math.clamp(centerLat, this.minLat_, this.maxLat_);
  cnt = 0;
  while (lat != this.maxLat_ && cnt++ < maxLines) {
    lat = Math.min(lat + interval, this.maxLat_);
    idx = this.addParallel_(lat, minLon, maxLon, squaredTolerance, extent, idx);
  }
  this.parallels_.length = idx;
  if (this.parallelsLabels_) {
    this.parallelsLabels_.length = idx;
  }
};
ol.Graticule.prototype.getInterval_ = function(resolution) {
  var centerLon = this.projectionCenterLonLat_[0];
  var centerLat = this.projectionCenterLonLat_[1];
  var interval = -1;
  var i, ii, delta, dist;
  var target = Math.pow(this.targetSize_ * resolution, 2);
  var p1 = [];
  var p2 = [];
  for (i = 0, ii = ol.Graticule.intervals_.length; i < ii; ++i) {
    delta = ol.Graticule.intervals_[i] / 2;
    p1[0] = centerLon - delta;
    p1[1] = centerLat - delta;
    p2[0] = centerLon + delta;
    p2[1] = centerLat + delta;
    this.fromLonLatTransform_(p1, p1);
    this.fromLonLatTransform_(p2, p2);
    dist = Math.pow(p2[0] - p1[0], 2) + Math.pow(p2[1] - p1[1], 2);
    if (dist <= target) {
      break;
    }
    interval = ol.Graticule.intervals_[i];
  }
  return interval;
};
ol.Graticule.prototype.getMap = function() {
  return this.map_;
};
ol.Graticule.prototype.getMeridian_ = function(lon, minLat, maxLat, squaredTolerance, index) {
  var flatCoordinates = ol.geom.flat.geodesic.meridian(lon, minLat, maxLat, this.projection_, squaredTolerance);
  var lineString = this.meridians_[index] !== undefined ? this.meridians_[index] : new ol.geom.LineString(null);
  lineString.setFlatCoordinates(ol.geom.GeometryLayout.XY, flatCoordinates);
  return lineString;
};
ol.Graticule.prototype.getMeridians = function() {
  return this.meridians_;
};
ol.Graticule.prototype.getParallel_ = function(lat, minLon, maxLon, squaredTolerance, index) {
  var flatCoordinates = ol.geom.flat.geodesic.parallel(lat, minLon, maxLon, this.projection_, squaredTolerance);
  var lineString = this.parallels_[index] !== undefined ? this.parallels_[index] : new ol.geom.LineString(null);
  lineString.setFlatCoordinates(ol.geom.GeometryLayout.XY, flatCoordinates);
  return lineString;
};
ol.Graticule.prototype.getParallels = function() {
  return this.parallels_;
};
ol.Graticule.prototype.handlePostCompose_ = function(e) {
  var vectorContext = e.vectorContext;
  var frameState = e.frameState;
  var extent = frameState.extent;
  var viewState = frameState.viewState;
  var center = viewState.center;
  var projection = viewState.projection;
  var resolution = viewState.resolution;
  var pixelRatio = frameState.pixelRatio;
  var squaredTolerance = resolution * resolution / (4 * pixelRatio * pixelRatio);
  var updateProjectionInfo = !this.projection_ || !ol.proj.equivalent(this.projection_, projection);
  if (updateProjectionInfo) {
    this.updateProjectionInfo_(projection);
  }
  this.createGraticule_(extent, center, resolution, squaredTolerance);
  vectorContext.setFillStrokeStyle(null, this.strokeStyle_);
  var i, l, line;
  for (i = 0, l = this.meridians_.length; i < l; ++i) {
    line = this.meridians_[i];
    vectorContext.drawGeometry(line);
  }
  for (i = 0, l = this.parallels_.length; i < l; ++i) {
    line = this.parallels_[i];
    vectorContext.drawGeometry(line);
  }
  var labelData;
  if (this.meridiansLabels_) {
    for (i = 0, l = this.meridiansLabels_.length; i < l; ++i) {
      labelData = this.meridiansLabels_[i];
      this.lonLabelStyle_.setText(labelData.text);
      vectorContext.setTextStyle(this.lonLabelStyle_);
      vectorContext.drawGeometry(labelData.geom);
    }
  }
  if (this.parallelsLabels_) {
    for (i = 0, l = this.parallelsLabels_.length; i < l; ++i) {
      labelData = this.parallelsLabels_[i];
      this.latLabelStyle_.setText(labelData.text);
      vectorContext.setTextStyle(this.latLabelStyle_);
      vectorContext.drawGeometry(labelData.geom);
    }
  }
};
ol.Graticule.prototype.updateProjectionInfo_ = function(projection) {
  var epsg4326Projection = ol.proj.get("EPSG:4326");
  var extent = projection.getExtent();
  var worldExtent = projection.getWorldExtent();
  var worldExtentP = ol.proj.transformExtent(worldExtent, epsg4326Projection, projection);
  var maxLat = worldExtent[3];
  var maxLon = worldExtent[2];
  var minLat = worldExtent[1];
  var minLon = worldExtent[0];
  var maxLatP = worldExtentP[3];
  var maxLonP = worldExtentP[2];
  var minLatP = worldExtentP[1];
  var minLonP = worldExtentP[0];
  this.maxLat_ = maxLat;
  this.maxLon_ = maxLon;
  this.minLat_ = minLat;
  this.minLon_ = minLon;
  this.maxLatP_ = maxLatP;
  this.maxLonP_ = maxLonP;
  this.minLatP_ = minLatP;
  this.minLonP_ = minLonP;
  this.fromLonLatTransform_ = ol.proj.getTransform(epsg4326Projection, projection);
  this.toLonLatTransform_ = ol.proj.getTransform(projection, epsg4326Projection);
  this.projectionCenterLonLat_ = this.toLonLatTransform_(ol.extent.getCenter(extent));
  this.projection_ = projection;
};
ol.Graticule.prototype.setMap = function(map) {
  if (this.map_) {
    this.map_.un(ol.render.EventType.POSTCOMPOSE, this.handlePostCompose_, this);
    this.map_.render();
  }
  if (map) {
    map.on(ol.render.EventType.POSTCOMPOSE, this.handlePostCompose_, this);
    map.render();
  }
  this.map_ = map;
};
goog.provide("ol.interaction.DragAndDrop");
goog.require("ol");
goog.require("ol.functions");
goog.require("ol.events");
goog.require("ol.events.Event");
goog.require("ol.events.EventType");
goog.require("ol.interaction.Interaction");
goog.require("ol.proj");
ol.interaction.DragAndDrop = function(opt_options) {
  var options = opt_options ? opt_options : {};
  ol.interaction.Interaction.call(this, {handleEvent:ol.interaction.DragAndDrop.handleEvent});
  this.formatConstructors_ = options.formatConstructors ? options.formatConstructors : [];
  this.projection_ = options.projection ? ol.proj.get(options.projection) : null;
  this.dropListenKeys_ = null;
  this.source_ = options.source || null;
  this.target = options.target ? options.target : null;
};
ol.inherits(ol.interaction.DragAndDrop, ol.interaction.Interaction);
ol.interaction.DragAndDrop.handleDrop_ = function(event) {
  var files = event.dataTransfer.files;
  var i, ii, file;
  for (i = 0, ii = files.length; i < ii; ++i) {
    file = files.item(i);
    var reader = new FileReader;
    reader.addEventListener(ol.events.EventType.LOAD, this.handleResult_.bind(this, file));
    reader.readAsText(file);
  }
};
ol.interaction.DragAndDrop.handleStop_ = function(event) {
  event.stopPropagation();
  event.preventDefault();
  event.dataTransfer.dropEffect = "copy";
};
ol.interaction.DragAndDrop.prototype.handleResult_ = function(file, event) {
  var result = event.target.result;
  var map = this.getMap();
  var projection = this.projection_;
  if (!projection) {
    var view = map.getView();
    projection = view.getProjection();
  }
  var formatConstructors = this.formatConstructors_;
  var features = [];
  var i, ii;
  for (i = 0, ii = formatConstructors.length; i < ii; ++i) {
    var formatConstructor = formatConstructors[i];
    var format = new formatConstructor;
    features = this.tryReadFeatures_(format, result, {featureProjection:projection});
    if (features && features.length > 0) {
      break;
    }
  }
  if (this.source_) {
    this.source_.clear();
    this.source_.addFeatures(features);
  }
  this.dispatchEvent(new ol.interaction.DragAndDrop.Event(ol.interaction.DragAndDrop.EventType_.ADD_FEATURES, file, features, projection));
};
ol.interaction.DragAndDrop.handleEvent = ol.functions.TRUE;
ol.interaction.DragAndDrop.prototype.registerListeners_ = function() {
  var map = this.getMap();
  if (map) {
    var dropArea = this.target ? this.target : map.getViewport();
    this.dropListenKeys_ = [ol.events.listen(dropArea, ol.events.EventType.DROP, ol.interaction.DragAndDrop.handleDrop_, this), ol.events.listen(dropArea, ol.events.EventType.DRAGENTER, ol.interaction.DragAndDrop.handleStop_, this), ol.events.listen(dropArea, ol.events.EventType.DRAGOVER, ol.interaction.DragAndDrop.handleStop_, this), ol.events.listen(dropArea, ol.events.EventType.DROP, ol.interaction.DragAndDrop.handleStop_, this)];
  }
};
ol.interaction.DragAndDrop.prototype.setActive = function(active) {
  ol.interaction.Interaction.prototype.setActive.call(this, active);
  if (active) {
    this.registerListeners_();
  } else {
    this.unregisterListeners_();
  }
};
ol.interaction.DragAndDrop.prototype.setMap = function(map) {
  this.unregisterListeners_();
  ol.interaction.Interaction.prototype.setMap.call(this, map);
  if (this.getActive()) {
    this.registerListeners_();
  }
};
ol.interaction.DragAndDrop.prototype.tryReadFeatures_ = function(format, text, options) {
  try {
    return format.readFeatures(text, options);
  } catch (e) {
    return null;
  }
};
ol.interaction.DragAndDrop.prototype.unregisterListeners_ = function() {
  if (this.dropListenKeys_) {
    this.dropListenKeys_.forEach(ol.events.unlistenByKey);
    this.dropListenKeys_ = null;
  }
};
ol.interaction.DragAndDrop.EventType_ = {ADD_FEATURES:"addfeatures"};
ol.interaction.DragAndDrop.Event = function(type, file, opt_features, opt_projection) {
  ol.events.Event.call(this, type);
  this.features = opt_features;
  this.file = file;
  this.projection = opt_projection;
};
ol.inherits(ol.interaction.DragAndDrop.Event, ol.events.Event);
goog.provide("ol.interaction.DragRotateAndZoom");
goog.require("ol");
goog.require("ol.RotationConstraint");
goog.require("ol.ViewHint");
goog.require("ol.events.condition");
goog.require("ol.interaction.Interaction");
goog.require("ol.interaction.Pointer");
ol.interaction.DragRotateAndZoom = function(opt_options) {
  var options = opt_options ? opt_options : {};
  ol.interaction.Pointer.call(this, {handleDownEvent:ol.interaction.DragRotateAndZoom.handleDownEvent_, handleDragEvent:ol.interaction.DragRotateAndZoom.handleDragEvent_, handleUpEvent:ol.interaction.DragRotateAndZoom.handleUpEvent_});
  this.condition_ = options.condition ? options.condition : ol.events.condition.shiftKeyOnly;
  this.lastAngle_ = undefined;
  this.lastMagnitude_ = undefined;
  this.lastScaleDelta_ = 0;
  this.duration_ = options.duration !== undefined ? options.duration : 400;
};
ol.inherits(ol.interaction.DragRotateAndZoom, ol.interaction.Pointer);
ol.interaction.DragRotateAndZoom.handleDragEvent_ = function(mapBrowserEvent) {
  if (!ol.events.condition.mouseOnly(mapBrowserEvent)) {
    return;
  }
  var map = mapBrowserEvent.map;
  var size = map.getSize();
  var offset = mapBrowserEvent.pixel;
  var deltaX = offset[0] - size[0] / 2;
  var deltaY = size[1] / 2 - offset[1];
  var theta = Math.atan2(deltaY, deltaX);
  var magnitude = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
  var view = map.getView();
  if (view.getConstraints().rotation !== ol.RotationConstraint.disable && this.lastAngle_ !== undefined) {
    var angleDelta = theta - this.lastAngle_;
    ol.interaction.Interaction.rotateWithoutConstraints(view, view.getRotation() - angleDelta);
  }
  this.lastAngle_ = theta;
  if (this.lastMagnitude_ !== undefined) {
    var resolution = this.lastMagnitude_ * (view.getResolution() / magnitude);
    ol.interaction.Interaction.zoomWithoutConstraints(view, resolution);
  }
  if (this.lastMagnitude_ !== undefined) {
    this.lastScaleDelta_ = this.lastMagnitude_ / magnitude;
  }
  this.lastMagnitude_ = magnitude;
};
ol.interaction.DragRotateAndZoom.handleUpEvent_ = function(mapBrowserEvent) {
  if (!ol.events.condition.mouseOnly(mapBrowserEvent)) {
    return true;
  }
  var map = mapBrowserEvent.map;
  var view = map.getView();
  view.setHint(ol.ViewHint.INTERACTING, -1);
  var direction = this.lastScaleDelta_ - 1;
  ol.interaction.Interaction.rotate(view, view.getRotation());
  ol.interaction.Interaction.zoom(view, view.getResolution(), undefined, this.duration_, direction);
  this.lastScaleDelta_ = 0;
  return false;
};
ol.interaction.DragRotateAndZoom.handleDownEvent_ = function(mapBrowserEvent) {
  if (!ol.events.condition.mouseOnly(mapBrowserEvent)) {
    return false;
  }
  if (this.condition_(mapBrowserEvent)) {
    mapBrowserEvent.map.getView().setHint(ol.ViewHint.INTERACTING, 1);
    this.lastAngle_ = undefined;
    this.lastMagnitude_ = undefined;
    return true;
  } else {
    return false;
  }
};
goog.provide("ol.interaction.DrawEventType");
ol.interaction.DrawEventType = {DRAWSTART:"drawstart", DRAWEND:"drawend"};
goog.provide("ol.interaction.Draw");
goog.require("ol");
goog.require("ol.Feature");
goog.require("ol.MapBrowserEventType");
goog.require("ol.Object");
goog.require("ol.coordinate");
goog.require("ol.events");
goog.require("ol.events.Event");
goog.require("ol.events.condition");
goog.require("ol.extent");
goog.require("ol.functions");
goog.require("ol.geom.Circle");
goog.require("ol.geom.GeometryType");
goog.require("ol.geom.LineString");
goog.require("ol.geom.MultiLineString");
goog.require("ol.geom.MultiPoint");
goog.require("ol.geom.MultiPolygon");
goog.require("ol.geom.Point");
goog.require("ol.geom.Polygon");
goog.require("ol.interaction.DrawEventType");
goog.require("ol.interaction.Pointer");
goog.require("ol.interaction.Property");
goog.require("ol.layer.Vector");
goog.require("ol.source.Vector");
goog.require("ol.style.Style");
ol.interaction.Draw = function(options) {
  ol.interaction.Pointer.call(this, {handleDownEvent:ol.interaction.Draw.handleDownEvent_, handleEvent:ol.interaction.Draw.handleEvent, handleUpEvent:ol.interaction.Draw.handleUpEvent_});
  this.shouldHandle_ = false;
  this.downPx_ = null;
  this.freehand_ = false;
  this.source_ = options.source ? options.source : null;
  this.features_ = options.features ? options.features : null;
  this.snapTolerance_ = options.snapTolerance ? options.snapTolerance : 12;
  this.type_ = options.type;
  this.mode_ = ol.interaction.Draw.getMode_(this.type_);
  this.stopClick_ = !!options.stopClick;
  this.minPoints_ = options.minPoints ? options.minPoints : this.mode_ === ol.interaction.Draw.Mode_.POLYGON ? 3 : 2;
  this.maxPoints_ = options.maxPoints ? options.maxPoints : Infinity;
  this.finishCondition_ = options.finishCondition ? options.finishCondition : ol.functions.TRUE;
  var geometryFunction = options.geometryFunction;
  if (!geometryFunction) {
    if (this.type_ === ol.geom.GeometryType.CIRCLE) {
      geometryFunction = function(coordinates, opt_geometry) {
        var circle = opt_geometry ? opt_geometry : new ol.geom.Circle([NaN, NaN]);
        var squaredLength = ol.coordinate.squaredDistance(coordinates[0], coordinates[1]);
        circle.setCenterAndRadius(coordinates[0], Math.sqrt(squaredLength));
        return circle;
      };
    } else {
      var Constructor;
      var mode = this.mode_;
      if (mode === ol.interaction.Draw.Mode_.POINT) {
        Constructor = ol.geom.Point;
      } else {
        if (mode === ol.interaction.Draw.Mode_.LINE_STRING) {
          Constructor = ol.geom.LineString;
        } else {
          if (mode === ol.interaction.Draw.Mode_.POLYGON) {
            Constructor = ol.geom.Polygon;
          }
        }
      }
      geometryFunction = function(coordinates, opt_geometry) {
        var geometry = opt_geometry;
        if (geometry) {
          if (mode === ol.interaction.Draw.Mode_.POLYGON) {
            if (coordinates[0].length) {
              geometry.setCoordinates([coordinates[0].concat([coordinates[0][0]])]);
            } else {
              geometry.setCoordinates([]);
            }
          } else {
            geometry.setCoordinates(coordinates);
          }
        } else {
          geometry = new Constructor(coordinates);
        }
        return geometry;
      };
    }
  }
  this.geometryFunction_ = geometryFunction;
  this.finishCoordinate_ = null;
  this.sketchFeature_ = null;
  this.sketchPoint_ = null;
  this.sketchCoords_ = null;
  this.sketchLine_ = null;
  this.sketchLineCoords_ = null;
  this.squaredClickTolerance_ = options.clickTolerance ? options.clickTolerance * options.clickTolerance : 36;
  this.overlay_ = new ol.layer.Vector({source:new ol.source.Vector({useSpatialIndex:false, wrapX:options.wrapX ? options.wrapX : false}), style:options.style ? options.style : ol.interaction.Draw.getDefaultStyleFunction()});
  this.geometryName_ = options.geometryName;
  this.condition_ = options.condition ? options.condition : ol.events.condition.noModifierKeys;
  this.freehandCondition_;
  if (options.freehand) {
    this.freehandCondition_ = ol.events.condition.always;
  } else {
    this.freehandCondition_ = options.freehandCondition ? options.freehandCondition : ol.events.condition.shiftKeyOnly;
  }
  ol.events.listen(this, ol.Object.getChangeEventType(ol.interaction.Property.ACTIVE), this.updateState_, this);
};
ol.inherits(ol.interaction.Draw, ol.interaction.Pointer);
ol.interaction.Draw.getDefaultStyleFunction = function() {
  var styles = ol.style.Style.createDefaultEditing();
  return function(feature, resolution) {
    return styles[feature.getGeometry().getType()];
  };
};
ol.interaction.Draw.prototype.setMap = function(map) {
  ol.interaction.Pointer.prototype.setMap.call(this, map);
  this.updateState_();
};
ol.interaction.Draw.handleEvent = function(event) {
  this.freehand_ = this.mode_ !== ol.interaction.Draw.Mode_.POINT && this.freehandCondition_(event);
  var pass = true;
  if (this.freehand_ && event.type === ol.MapBrowserEventType.POINTERDRAG && this.sketchFeature_ !== null) {
    this.addToDrawing_(event);
    pass = false;
  } else {
    if (this.freehand_ && event.type === ol.MapBrowserEventType.POINTERDOWN) {
      pass = false;
    } else {
      if (event.type === ol.MapBrowserEventType.POINTERMOVE) {
        pass = this.handlePointerMove_(event);
      } else {
        if (event.type === ol.MapBrowserEventType.DBLCLICK) {
          pass = false;
        }
      }
    }
  }
  return ol.interaction.Pointer.handleEvent.call(this, event) && pass;
};
ol.interaction.Draw.handleDownEvent_ = function(event) {
  this.shouldHandle_ = !this.freehand_;
  if (this.freehand_) {
    this.downPx_ = event.pixel;
    if (!this.finishCoordinate_) {
      this.startDrawing_(event);
    }
    return true;
  } else {
    if (this.condition_(event)) {
      this.downPx_ = event.pixel;
      return true;
    } else {
      return false;
    }
  }
};
ol.interaction.Draw.handleUpEvent_ = function(event) {
  var pass = true;
  this.handlePointerMove_(event);
  var circleMode = this.mode_ === ol.interaction.Draw.Mode_.CIRCLE;
  if (this.shouldHandle_) {
    if (!this.finishCoordinate_) {
      this.startDrawing_(event);
      if (this.mode_ === ol.interaction.Draw.Mode_.POINT) {
        this.finishDrawing();
      }
    } else {
      if (this.freehand_ || circleMode) {
        this.finishDrawing();
      } else {
        if (this.atFinish_(event)) {
          if (this.finishCondition_(event)) {
            this.finishDrawing();
          }
        } else {
          this.addToDrawing_(event);
        }
      }
    }
    pass = false;
  } else {
    if (this.freehand_) {
      this.finishCoordinate_ = null;
      this.abortDrawing_();
    }
  }
  if (!pass && this.stopClick_) {
    event.stopPropagation();
  }
  return pass;
};
ol.interaction.Draw.prototype.handlePointerMove_ = function(event) {
  if (this.downPx_ && (!this.freehand_ && this.shouldHandle_ || this.freehand_ && !this.shouldHandle_)) {
    var downPx = this.downPx_;
    var clickPx = event.pixel;
    var dx = downPx[0] - clickPx[0];
    var dy = downPx[1] - clickPx[1];
    var squaredDistance = dx * dx + dy * dy;
    this.shouldHandle_ = this.freehand_ ? squaredDistance > this.squaredClickTolerance_ : squaredDistance <= this.squaredClickTolerance_;
  }
  if (this.finishCoordinate_) {
    this.modifyDrawing_(event);
  } else {
    this.createOrUpdateSketchPoint_(event);
  }
  return true;
};
ol.interaction.Draw.prototype.atFinish_ = function(event) {
  var at = false;
  if (this.sketchFeature_) {
    var potentiallyDone = false;
    var potentiallyFinishCoordinates = [this.finishCoordinate_];
    if (this.mode_ === ol.interaction.Draw.Mode_.LINE_STRING) {
      potentiallyDone = this.sketchCoords_.length > this.minPoints_;
    } else {
      if (this.mode_ === ol.interaction.Draw.Mode_.POLYGON) {
        potentiallyDone = this.sketchCoords_[0].length > this.minPoints_;
        potentiallyFinishCoordinates = [this.sketchCoords_[0][0], this.sketchCoords_[0][this.sketchCoords_[0].length - 2]];
      }
    }
    if (potentiallyDone) {
      var map = event.map;
      for (var i = 0, ii = potentiallyFinishCoordinates.length; i < ii; i++) {
        var finishCoordinate = potentiallyFinishCoordinates[i];
        var finishPixel = map.getPixelFromCoordinate(finishCoordinate);
        var pixel = event.pixel;
        var dx = pixel[0] - finishPixel[0];
        var dy = pixel[1] - finishPixel[1];
        var snapTolerance = this.freehand_ ? 1 : this.snapTolerance_;
        at = Math.sqrt(dx * dx + dy * dy) <= snapTolerance;
        if (at) {
          this.finishCoordinate_ = finishCoordinate;
          break;
        }
      }
    }
  }
  return at;
};
ol.interaction.Draw.prototype.createOrUpdateSketchPoint_ = function(event) {
  var coordinates = event.coordinate.slice();
  if (!this.sketchPoint_) {
    this.sketchPoint_ = new ol.Feature(new ol.geom.Point(coordinates));
    this.updateSketchFeatures_();
  } else {
    var sketchPointGeom = this.sketchPoint_.getGeometry();
    sketchPointGeom.setCoordinates(coordinates);
  }
};
ol.interaction.Draw.prototype.startDrawing_ = function(event) {
  var start = event.coordinate;
  this.finishCoordinate_ = start;
  if (this.mode_ === ol.interaction.Draw.Mode_.POINT) {
    this.sketchCoords_ = start.slice();
  } else {
    if (this.mode_ === ol.interaction.Draw.Mode_.POLYGON) {
      this.sketchCoords_ = [[start.slice(), start.slice()]];
      this.sketchLineCoords_ = this.sketchCoords_[0];
    } else {
      this.sketchCoords_ = [start.slice(), start.slice()];
      if (this.mode_ === ol.interaction.Draw.Mode_.CIRCLE) {
        this.sketchLineCoords_ = this.sketchCoords_;
      }
    }
  }
  if (this.sketchLineCoords_) {
    this.sketchLine_ = new ol.Feature(new ol.geom.LineString(this.sketchLineCoords_));
  }
  var geometry = this.geometryFunction_(this.sketchCoords_);
  this.sketchFeature_ = new ol.Feature;
  if (this.geometryName_) {
    this.sketchFeature_.setGeometryName(this.geometryName_);
  }
  this.sketchFeature_.setGeometry(geometry);
  this.updateSketchFeatures_();
  this.dispatchEvent(new ol.interaction.Draw.Event(ol.interaction.DrawEventType.DRAWSTART, this.sketchFeature_));
};
ol.interaction.Draw.prototype.modifyDrawing_ = function(event) {
  var coordinate = event.coordinate;
  var geometry = this.sketchFeature_.getGeometry();
  var coordinates, last;
  if (this.mode_ === ol.interaction.Draw.Mode_.POINT) {
    last = this.sketchCoords_;
  } else {
    if (this.mode_ === ol.interaction.Draw.Mode_.POLYGON) {
      coordinates = this.sketchCoords_[0];
      last = coordinates[coordinates.length - 1];
      if (this.atFinish_(event)) {
        coordinate = this.finishCoordinate_.slice();
      }
    } else {
      coordinates = this.sketchCoords_;
      last = coordinates[coordinates.length - 1];
    }
  }
  last[0] = coordinate[0];
  last[1] = coordinate[1];
  this.geometryFunction_(this.sketchCoords_, geometry);
  if (this.sketchPoint_) {
    var sketchPointGeom = this.sketchPoint_.getGeometry();
    sketchPointGeom.setCoordinates(coordinate);
  }
  var sketchLineGeom;
  if (geometry instanceof ol.geom.Polygon && this.mode_ !== ol.interaction.Draw.Mode_.POLYGON) {
    if (!this.sketchLine_) {
      this.sketchLine_ = new ol.Feature(new ol.geom.LineString(null));
    }
    var ring = geometry.getLinearRing(0);
    sketchLineGeom = this.sketchLine_.getGeometry();
    sketchLineGeom.setFlatCoordinates(ring.getLayout(), ring.getFlatCoordinates());
  } else {
    if (this.sketchLineCoords_) {
      sketchLineGeom = this.sketchLine_.getGeometry();
      sketchLineGeom.setCoordinates(this.sketchLineCoords_);
    }
  }
  this.updateSketchFeatures_();
};
ol.interaction.Draw.prototype.addToDrawing_ = function(event) {
  var coordinate = event.coordinate;
  var geometry = this.sketchFeature_.getGeometry();
  var done;
  var coordinates;
  if (this.mode_ === ol.interaction.Draw.Mode_.LINE_STRING) {
    this.finishCoordinate_ = coordinate.slice();
    coordinates = this.sketchCoords_;
    if (coordinates.length >= this.maxPoints_) {
      if (this.freehand_) {
        coordinates.pop();
      } else {
        done = true;
      }
    }
    coordinates.push(coordinate.slice());
    this.geometryFunction_(coordinates, geometry);
  } else {
    if (this.mode_ === ol.interaction.Draw.Mode_.POLYGON) {
      coordinates = this.sketchCoords_[0];
      if (coordinates.length >= this.maxPoints_) {
        if (this.freehand_) {
          coordinates.pop();
        } else {
          done = true;
        }
      }
      coordinates.push(coordinate.slice());
      if (done) {
        this.finishCoordinate_ = coordinates[0];
      }
      this.geometryFunction_(this.sketchCoords_, geometry);
    }
  }
  this.updateSketchFeatures_();
  if (done) {
    this.finishDrawing();
  }
};
ol.interaction.Draw.prototype.removeLastPoint = function() {
  if (!this.sketchFeature_) {
    return;
  }
  var geometry = this.sketchFeature_.getGeometry();
  var coordinates, sketchLineGeom;
  if (this.mode_ === ol.interaction.Draw.Mode_.LINE_STRING) {
    coordinates = this.sketchCoords_;
    coordinates.splice(-2, 1);
    this.geometryFunction_(coordinates, geometry);
    if (coordinates.length >= 2) {
      this.finishCoordinate_ = coordinates[coordinates.length - 2].slice();
    }
  } else {
    if (this.mode_ === ol.interaction.Draw.Mode_.POLYGON) {
      coordinates = this.sketchCoords_[0];
      coordinates.splice(-2, 1);
      sketchLineGeom = this.sketchLine_.getGeometry();
      sketchLineGeom.setCoordinates(coordinates);
      this.geometryFunction_(this.sketchCoords_, geometry);
    }
  }
  if (coordinates.length === 0) {
    this.finishCoordinate_ = null;
  }
  this.updateSketchFeatures_();
};
ol.interaction.Draw.prototype.finishDrawing = function() {
  var sketchFeature = this.abortDrawing_();
  var coordinates = this.sketchCoords_;
  var geometry = sketchFeature.getGeometry();
  if (this.mode_ === ol.interaction.Draw.Mode_.LINE_STRING) {
    coordinates.pop();
    this.geometryFunction_(coordinates, geometry);
  } else {
    if (this.mode_ === ol.interaction.Draw.Mode_.POLYGON) {
      coordinates[0].pop();
      this.geometryFunction_(coordinates, geometry);
      coordinates = geometry.getCoordinates();
    }
  }
  if (this.type_ === ol.geom.GeometryType.MULTI_POINT) {
    sketchFeature.setGeometry(new ol.geom.MultiPoint([coordinates]));
  } else {
    if (this.type_ === ol.geom.GeometryType.MULTI_LINE_STRING) {
      sketchFeature.setGeometry(new ol.geom.MultiLineString([coordinates]));
    } else {
      if (this.type_ === ol.geom.GeometryType.MULTI_POLYGON) {
        sketchFeature.setGeometry(new ol.geom.MultiPolygon([coordinates]));
      }
    }
  }
  this.dispatchEvent(new ol.interaction.Draw.Event(ol.interaction.DrawEventType.DRAWEND, sketchFeature));
  if (this.features_) {
    this.features_.push(sketchFeature);
  }
  if (this.source_) {
    this.source_.addFeature(sketchFeature);
  }
};
ol.interaction.Draw.prototype.abortDrawing_ = function() {
  this.finishCoordinate_ = null;
  var sketchFeature = this.sketchFeature_;
  if (sketchFeature) {
    this.sketchFeature_ = null;
    this.sketchPoint_ = null;
    this.sketchLine_ = null;
    this.overlay_.getSource().clear(true);
  }
  return sketchFeature;
};
ol.interaction.Draw.prototype.extend = function(feature) {
  var geometry = feature.getGeometry();
  var lineString = geometry;
  this.sketchFeature_ = feature;
  this.sketchCoords_ = lineString.getCoordinates();
  var last = this.sketchCoords_[this.sketchCoords_.length - 1];
  this.finishCoordinate_ = last.slice();
  this.sketchCoords_.push(last.slice());
  this.updateSketchFeatures_();
  this.dispatchEvent(new ol.interaction.Draw.Event(ol.interaction.DrawEventType.DRAWSTART, this.sketchFeature_));
};
ol.interaction.Draw.prototype.shouldStopEvent = ol.functions.FALSE;
ol.interaction.Draw.prototype.updateSketchFeatures_ = function() {
  var sketchFeatures = [];
  if (this.sketchFeature_) {
    sketchFeatures.push(this.sketchFeature_);
  }
  if (this.sketchLine_) {
    sketchFeatures.push(this.sketchLine_);
  }
  if (this.sketchPoint_) {
    sketchFeatures.push(this.sketchPoint_);
  }
  var overlaySource = this.overlay_.getSource();
  overlaySource.clear(true);
  overlaySource.addFeatures(sketchFeatures);
};
ol.interaction.Draw.prototype.updateState_ = function() {
  var map = this.getMap();
  var active = this.getActive();
  if (!map || !active) {
    this.abortDrawing_();
  }
  this.overlay_.setMap(active ? map : null);
};
ol.interaction.Draw.createRegularPolygon = function(opt_sides, opt_angle) {
  return function(coordinates, opt_geometry) {
    var center = coordinates[0];
    var end = coordinates[1];
    var radius = Math.sqrt(ol.coordinate.squaredDistance(center, end));
    var geometry = opt_geometry ? opt_geometry : ol.geom.Polygon.fromCircle(new ol.geom.Circle(center), opt_sides);
    var angle = opt_angle ? opt_angle : Math.atan((end[1] - center[1]) / (end[0] - center[0]));
    ol.geom.Polygon.makeRegular(geometry, center, radius, angle);
    return geometry;
  };
};
ol.interaction.Draw.createBox = function() {
  return function(coordinates, opt_geometry) {
    var extent = ol.extent.boundingExtent(coordinates);
    var geometry = opt_geometry || new ol.geom.Polygon(null);
    geometry.setCoordinates([[ol.extent.getBottomLeft(extent), ol.extent.getBottomRight(extent), ol.extent.getTopRight(extent), ol.extent.getTopLeft(extent), ol.extent.getBottomLeft(extent)]]);
    return geometry;
  };
};
ol.interaction.Draw.getMode_ = function(type) {
  var mode;
  if (type === ol.geom.GeometryType.POINT || type === ol.geom.GeometryType.MULTI_POINT) {
    mode = ol.interaction.Draw.Mode_.POINT;
  } else {
    if (type === ol.geom.GeometryType.LINE_STRING || type === ol.geom.GeometryType.MULTI_LINE_STRING) {
      mode = ol.interaction.Draw.Mode_.LINE_STRING;
    } else {
      if (type === ol.geom.GeometryType.POLYGON || type === ol.geom.GeometryType.MULTI_POLYGON) {
        mode = ol.interaction.Draw.Mode_.POLYGON;
      } else {
        if (type === ol.geom.GeometryType.CIRCLE) {
          mode = ol.interaction.Draw.Mode_.CIRCLE;
        }
      }
    }
  }
  return mode;
};
ol.interaction.Draw.Mode_ = {POINT:"Point", LINE_STRING:"LineString", POLYGON:"Polygon", CIRCLE:"Circle"};
ol.interaction.Draw.Event = function(type, feature) {
  ol.events.Event.call(this, type);
  this.feature = feature;
};
ol.inherits(ol.interaction.Draw.Event, ol.events.Event);
goog.provide("ol.interaction.ExtentEventType");
ol.interaction.ExtentEventType = {EXTENTCHANGED:"extentchanged"};
goog.provide("ol.interaction.Extent");
goog.require("ol");
goog.require("ol.Feature");
goog.require("ol.MapBrowserEventType");
goog.require("ol.MapBrowserPointerEvent");
goog.require("ol.coordinate");
goog.require("ol.events.Event");
goog.require("ol.extent");
goog.require("ol.geom.GeometryType");
goog.require("ol.geom.Point");
goog.require("ol.geom.Polygon");
goog.require("ol.interaction.ExtentEventType");
goog.require("ol.interaction.Pointer");
goog.require("ol.layer.Vector");
goog.require("ol.source.Vector");
goog.require("ol.style.Style");
ol.interaction.Extent = function(opt_options) {
  var options = opt_options || {};
  this.extent_ = null;
  this.pointerHandler_ = null;
  this.pixelTolerance_ = options.pixelTolerance !== undefined ? options.pixelTolerance : 10;
  this.snappedToVertex_ = false;
  this.extentFeature_ = null;
  this.vertexFeature_ = null;
  if (!opt_options) {
    opt_options = {};
  }
  ol.interaction.Pointer.call(this, {handleDownEvent:ol.interaction.Extent.handleDownEvent_, handleDragEvent:ol.interaction.Extent.handleDragEvent_, handleEvent:ol.interaction.Extent.handleEvent_, handleUpEvent:ol.interaction.Extent.handleUpEvent_});
  this.extentOverlay_ = new ol.layer.Vector({source:new ol.source.Vector({useSpatialIndex:false, wrapX:!!opt_options.wrapX}), style:opt_options.boxStyle ? opt_options.boxStyle : ol.interaction.Extent.getDefaultExtentStyleFunction_(), updateWhileAnimating:true, updateWhileInteracting:true});
  this.vertexOverlay_ = new ol.layer.Vector({source:new ol.source.Vector({useSpatialIndex:false, wrapX:!!opt_options.wrapX}), style:opt_options.pointerStyle ? opt_options.pointerStyle : ol.interaction.Extent.getDefaultPointerStyleFunction_(), updateWhileAnimating:true, updateWhileInteracting:true});
  if (opt_options.extent) {
    this.setExtent(opt_options.extent);
  }
};
ol.inherits(ol.interaction.Extent, ol.interaction.Pointer);
ol.interaction.Extent.handleEvent_ = function(mapBrowserEvent) {
  if (!(mapBrowserEvent instanceof ol.MapBrowserPointerEvent)) {
    return true;
  }
  if (mapBrowserEvent.type == ol.MapBrowserEventType.POINTERMOVE && !this.handlingDownUpSequence) {
    this.handlePointerMove_(mapBrowserEvent);
  }
  ol.interaction.Pointer.handleEvent.call(this, mapBrowserEvent);
  return false;
};
ol.interaction.Extent.handleDownEvent_ = function(mapBrowserEvent) {
  var pixel = mapBrowserEvent.pixel;
  var map = mapBrowserEvent.map;
  var extent = this.getExtent();
  var vertex = this.snapToVertex_(pixel, map);
  var getOpposingPoint = function(point) {
    var x_ = null;
    var y_ = null;
    if (point[0] == extent[0]) {
      x_ = extent[2];
    } else {
      if (point[0] == extent[2]) {
        x_ = extent[0];
      }
    }
    if (point[1] == extent[1]) {
      y_ = extent[3];
    } else {
      if (point[1] == extent[3]) {
        y_ = extent[1];
      }
    }
    if (x_ !== null && y_ !== null) {
      return [x_, y_];
    }
    return null;
  };
  if (vertex && extent) {
    var x = vertex[0] == extent[0] || vertex[0] == extent[2] ? vertex[0] : null;
    var y = vertex[1] == extent[1] || vertex[1] == extent[3] ? vertex[1] : null;
    if (x !== null && y !== null) {
      this.pointerHandler_ = ol.interaction.Extent.getPointHandler_(getOpposingPoint(vertex));
    } else {
      if (x !== null) {
        this.pointerHandler_ = ol.interaction.Extent.getEdgeHandler_(getOpposingPoint([x, extent[1]]), getOpposingPoint([x, extent[3]]));
      } else {
        if (y !== null) {
          this.pointerHandler_ = ol.interaction.Extent.getEdgeHandler_(getOpposingPoint([extent[0], y]), getOpposingPoint([extent[2], y]));
        }
      }
    }
  } else {
    vertex = map.getCoordinateFromPixel(pixel);
    this.setExtent([vertex[0], vertex[1], vertex[0], vertex[1]]);
    this.pointerHandler_ = ol.interaction.Extent.getPointHandler_(vertex);
  }
  return true;
};
ol.interaction.Extent.handleDragEvent_ = function(mapBrowserEvent) {
  if (this.pointerHandler_) {
    var pixelCoordinate = mapBrowserEvent.coordinate;
    this.setExtent(this.pointerHandler_(pixelCoordinate));
    this.createOrUpdatePointerFeature_(pixelCoordinate);
  }
  return true;
};
ol.interaction.Extent.handleUpEvent_ = function(mapBrowserEvent) {
  this.pointerHandler_ = null;
  var extent = this.getExtent();
  if (!extent || ol.extent.getArea(extent) === 0) {
    this.setExtent(null);
  }
  return false;
};
ol.interaction.Extent.getDefaultExtentStyleFunction_ = function() {
  var style = ol.style.Style.createDefaultEditing();
  return function(feature, resolution) {
    return style[ol.geom.GeometryType.POLYGON];
  };
};
ol.interaction.Extent.getDefaultPointerStyleFunction_ = function() {
  var style = ol.style.Style.createDefaultEditing();
  return function(feature, resolution) {
    return style[ol.geom.GeometryType.POINT];
  };
};
ol.interaction.Extent.getPointHandler_ = function(fixedPoint) {
  return function(point) {
    return ol.extent.boundingExtent([fixedPoint, point]);
  };
};
ol.interaction.Extent.getEdgeHandler_ = function(fixedP1, fixedP2) {
  if (fixedP1[0] == fixedP2[0]) {
    return function(point) {
      return ol.extent.boundingExtent([fixedP1, [point[0], fixedP2[1]]]);
    };
  } else {
    if (fixedP1[1] == fixedP2[1]) {
      return function(point) {
        return ol.extent.boundingExtent([fixedP1, [fixedP2[0], point[1]]]);
      };
    } else {
      return null;
    }
  }
};
ol.interaction.Extent.getSegments_ = function(extent) {
  return [[[extent[0], extent[1]], [extent[0], extent[3]]], [[extent[0], extent[3]], [extent[2], extent[3]]], [[extent[2], extent[3]], [extent[2], extent[1]]], [[extent[2], extent[1]], [extent[0], extent[1]]]];
};
ol.interaction.Extent.prototype.snapToVertex_ = function(pixel, map) {
  var pixelCoordinate = map.getCoordinateFromPixel(pixel);
  var sortByDistance = function(a, b) {
    return ol.coordinate.squaredDistanceToSegment(pixelCoordinate, a) - ol.coordinate.squaredDistanceToSegment(pixelCoordinate, b);
  };
  var extent = this.getExtent();
  if (extent) {
    var segments = ol.interaction.Extent.getSegments_(extent);
    segments.sort(sortByDistance);
    var closestSegment = segments[0];
    var vertex = ol.coordinate.closestOnSegment(pixelCoordinate, closestSegment);
    var vertexPixel = map.getPixelFromCoordinate(vertex);
    if (ol.coordinate.distance(pixel, vertexPixel) <= this.pixelTolerance_) {
      var pixel1 = map.getPixelFromCoordinate(closestSegment[0]);
      var pixel2 = map.getPixelFromCoordinate(closestSegment[1]);
      var squaredDist1 = ol.coordinate.squaredDistance(vertexPixel, pixel1);
      var squaredDist2 = ol.coordinate.squaredDistance(vertexPixel, pixel2);
      var dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));
      this.snappedToVertex_ = dist <= this.pixelTolerance_;
      if (this.snappedToVertex_) {
        vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];
      }
      return vertex;
    }
  }
  return null;
};
ol.interaction.Extent.prototype.handlePointerMove_ = function(mapBrowserEvent) {
  var pixel = mapBrowserEvent.pixel;
  var map = mapBrowserEvent.map;
  var vertex = this.snapToVertex_(pixel, map);
  if (!vertex) {
    vertex = map.getCoordinateFromPixel(pixel);
  }
  this.createOrUpdatePointerFeature_(vertex);
};
ol.interaction.Extent.prototype.createOrUpdateExtentFeature_ = function(extent) {
  var extentFeature = this.extentFeature_;
  if (!extentFeature) {
    if (!extent) {
      extentFeature = new ol.Feature({});
    } else {
      extentFeature = new ol.Feature(ol.geom.Polygon.fromExtent(extent));
    }
    this.extentFeature_ = extentFeature;
    this.extentOverlay_.getSource().addFeature(extentFeature);
  } else {
    if (!extent) {
      extentFeature.setGeometry(undefined);
    } else {
      extentFeature.setGeometry(ol.geom.Polygon.fromExtent(extent));
    }
  }
  return extentFeature;
};
ol.interaction.Extent.prototype.createOrUpdatePointerFeature_ = function(vertex) {
  var vertexFeature = this.vertexFeature_;
  if (!vertexFeature) {
    vertexFeature = new ol.Feature(new ol.geom.Point(vertex));
    this.vertexFeature_ = vertexFeature;
    this.vertexOverlay_.getSource().addFeature(vertexFeature);
  } else {
    var geometry = vertexFeature.getGeometry();
    geometry.setCoordinates(vertex);
  }
  return vertexFeature;
};
ol.interaction.Extent.prototype.setMap = function(map) {
  this.extentOverlay_.setMap(map);
  this.vertexOverlay_.setMap(map);
  ol.interaction.Pointer.prototype.setMap.call(this, map);
};
ol.interaction.Extent.prototype.getExtent = function() {
  return this.extent_;
};
ol.interaction.Extent.prototype.setExtent = function(extent) {
  this.extent_ = extent ? extent : null;
  this.createOrUpdateExtentFeature_(extent);
  this.dispatchEvent(new ol.interaction.Extent.Event(this.extent_));
};
ol.interaction.Extent.Event = function(extent) {
  ol.events.Event.call(this, ol.interaction.ExtentEventType.EXTENTCHANGED);
  this.extent = extent;
};
ol.inherits(ol.interaction.Extent.Event, ol.events.Event);
goog.provide("ol.interaction.ModifyEventType");
ol.interaction.ModifyEventType = {MODIFYSTART:"modifystart", MODIFYEND:"modifyend"};
goog.provide("ol.interaction.Modify");
goog.require("ol");
goog.require("ol.Collection");
goog.require("ol.CollectionEventType");
goog.require("ol.Feature");
goog.require("ol.MapBrowserEventType");
goog.require("ol.MapBrowserPointerEvent");
goog.require("ol.array");
goog.require("ol.coordinate");
goog.require("ol.events");
goog.require("ol.events.Event");
goog.require("ol.events.EventType");
goog.require("ol.events.condition");
goog.require("ol.extent");
goog.require("ol.geom.GeometryType");
goog.require("ol.geom.Point");
goog.require("ol.interaction.ModifyEventType");
goog.require("ol.interaction.Pointer");
goog.require("ol.layer.Vector");
goog.require("ol.source.Vector");
goog.require("ol.source.VectorEventType");
goog.require("ol.structs.RBush");
goog.require("ol.style.Style");
ol.interaction.Modify = function(options) {
  ol.interaction.Pointer.call(this, {handleDownEvent:ol.interaction.Modify.handleDownEvent_, handleDragEvent:ol.interaction.Modify.handleDragEvent_, handleEvent:ol.interaction.Modify.handleEvent, handleUpEvent:ol.interaction.Modify.handleUpEvent_});
  this.condition_ = options.condition ? options.condition : ol.events.condition.primaryAction;
  this.defaultDeleteCondition_ = function(mapBrowserEvent) {
    return ol.events.condition.altKeyOnly(mapBrowserEvent) && ol.events.condition.singleClick(mapBrowserEvent);
  };
  this.deleteCondition_ = options.deleteCondition ? options.deleteCondition : this.defaultDeleteCondition_;
  this.insertVertexCondition_ = options.insertVertexCondition ? options.insertVertexCondition : ol.events.condition.always;
  this.vertexFeature_ = null;
  this.vertexSegments_ = null;
  this.lastPixel_ = [0, 0];
  this.ignoreNextSingleClick_ = false;
  this.modified_ = false;
  this.rBush_ = new ol.structs.RBush;
  this.pixelTolerance_ = options.pixelTolerance !== undefined ? options.pixelTolerance : 10;
  this.snappedToVertex_ = false;
  this.changingFeature_ = false;
  this.dragSegments_ = [];
  this.overlay_ = new ol.layer.Vector({source:new ol.source.Vector({useSpatialIndex:false, wrapX:!!options.wrapX}), style:options.style ? options.style : ol.interaction.Modify.getDefaultStyleFunction(), updateWhileAnimating:true, updateWhileInteracting:true});
  this.SEGMENT_WRITERS_ = {"Point":this.writePointGeometry_, "LineString":this.writeLineStringGeometry_, "LinearRing":this.writeLineStringGeometry_, "Polygon":this.writePolygonGeometry_, "MultiPoint":this.writeMultiPointGeometry_, "MultiLineString":this.writeMultiLineStringGeometry_, "MultiPolygon":this.writeMultiPolygonGeometry_, "Circle":this.writeCircleGeometry_, "GeometryCollection":this.writeGeometryCollectionGeometry_};
  this.source_ = null;
  var features;
  if (options.source) {
    this.source_ = options.source;
    features = new ol.Collection(this.source_.getFeatures());
    ol.events.listen(this.source_, ol.source.VectorEventType.ADDFEATURE, this.handleSourceAdd_, this);
    ol.events.listen(this.source_, ol.source.VectorEventType.REMOVEFEATURE, this.handleSourceRemove_, this);
  } else {
    features = options.features;
  }
  if (!features) {
    throw new Error("The modify interaction requires features or a source");
  }
  this.features_ = features;
  this.features_.forEach(this.addFeature_, this);
  ol.events.listen(this.features_, ol.CollectionEventType.ADD, this.handleFeatureAdd_, this);
  ol.events.listen(this.features_, ol.CollectionEventType.REMOVE, this.handleFeatureRemove_, this);
  this.lastPointerEvent_ = null;
};
ol.inherits(ol.interaction.Modify, ol.interaction.Pointer);
ol.interaction.Modify.MODIFY_SEGMENT_CIRCLE_CENTER_INDEX = 0;
ol.interaction.Modify.MODIFY_SEGMENT_CIRCLE_CIRCUMFERENCE_INDEX = 1;
ol.interaction.Modify.prototype.addFeature_ = function(feature) {
  var geometry = feature.getGeometry();
  if (geometry && geometry.getType() in this.SEGMENT_WRITERS_) {
    this.SEGMENT_WRITERS_[geometry.getType()].call(this, feature, geometry);
  }
  var map = this.getMap();
  if (map && map.isRendered() && this.getActive()) {
    this.handlePointerAtPixel_(this.lastPixel_, map);
  }
  ol.events.listen(feature, ol.events.EventType.CHANGE, this.handleFeatureChange_, this);
};
ol.interaction.Modify.prototype.willModifyFeatures_ = function(evt) {
  if (!this.modified_) {
    this.modified_ = true;
    this.dispatchEvent(new ol.interaction.Modify.Event(ol.interaction.ModifyEventType.MODIFYSTART, this.features_, evt));
  }
};
ol.interaction.Modify.prototype.removeFeature_ = function(feature) {
  this.removeFeatureSegmentData_(feature);
  if (this.vertexFeature_ && this.features_.getLength() === 0) {
    this.overlay_.getSource().removeFeature(this.vertexFeature_);
    this.vertexFeature_ = null;
  }
  ol.events.unlisten(feature, ol.events.EventType.CHANGE, this.handleFeatureChange_, this);
};
ol.interaction.Modify.prototype.removeFeatureSegmentData_ = function(feature) {
  var rBush = this.rBush_;
  var nodesToRemove = [];
  rBush.forEach(function(node) {
    if (feature === node.feature) {
      nodesToRemove.push(node);
    }
  });
  for (var i = nodesToRemove.length - 1; i >= 0; --i) {
    rBush.remove(nodesToRemove[i]);
  }
};
ol.interaction.Modify.prototype.setActive = function(active) {
  if (this.vertexFeature_ && !active) {
    this.overlay_.getSource().removeFeature(this.vertexFeature_);
    this.vertexFeature_ = null;
  }
  ol.interaction.Pointer.prototype.setActive.call(this, active);
};
ol.interaction.Modify.prototype.setMap = function(map) {
  this.overlay_.setMap(map);
  ol.interaction.Pointer.prototype.setMap.call(this, map);
};
ol.interaction.Modify.prototype.handleSourceAdd_ = function(event) {
  if (event.feature) {
    this.features_.push(event.feature);
  }
};
ol.interaction.Modify.prototype.handleSourceRemove_ = function(event) {
  if (event.feature) {
    this.features_.remove(event.feature);
  }
};
ol.interaction.Modify.prototype.handleFeatureAdd_ = function(evt) {
  this.addFeature_(evt.element);
};
ol.interaction.Modify.prototype.handleFeatureChange_ = function(evt) {
  if (!this.changingFeature_) {
    var feature = evt.target;
    this.removeFeature_(feature);
    this.addFeature_(feature);
  }
};
ol.interaction.Modify.prototype.handleFeatureRemove_ = function(evt) {
  var feature = evt.element;
  this.removeFeature_(feature);
};
ol.interaction.Modify.prototype.writePointGeometry_ = function(feature, geometry) {
  var coordinates = geometry.getCoordinates();
  var segmentData = {feature:feature, geometry:geometry, segment:[coordinates, coordinates]};
  this.rBush_.insert(geometry.getExtent(), segmentData);
};
ol.interaction.Modify.prototype.writeMultiPointGeometry_ = function(feature, geometry) {
  var points = geometry.getCoordinates();
  var coordinates, i, ii, segmentData;
  for (i = 0, ii = points.length; i < ii; ++i) {
    coordinates = points[i];
    segmentData = {feature:feature, geometry:geometry, depth:[i], index:i, segment:[coordinates, coordinates]};
    this.rBush_.insert(geometry.getExtent(), segmentData);
  }
};
ol.interaction.Modify.prototype.writeLineStringGeometry_ = function(feature, geometry) {
  var coordinates = geometry.getCoordinates();
  var i, ii, segment, segmentData;
  for (i = 0, ii = coordinates.length - 1; i < ii; ++i) {
    segment = coordinates.slice(i, i + 2);
    segmentData = {feature:feature, geometry:geometry, index:i, segment:segment};
    this.rBush_.insert(ol.extent.boundingExtent(segment), segmentData);
  }
};
ol.interaction.Modify.prototype.writeMultiLineStringGeometry_ = function(feature, geometry) {
  var lines = geometry.getCoordinates();
  var coordinates, i, ii, j, jj, segment, segmentData;
  for (j = 0, jj = lines.length; j < jj; ++j) {
    coordinates = lines[j];
    for (i = 0, ii = coordinates.length - 1; i < ii; ++i) {
      segment = coordinates.slice(i, i + 2);
      segmentData = {feature:feature, geometry:geometry, depth:[j], index:i, segment:segment};
      this.rBush_.insert(ol.extent.boundingExtent(segment), segmentData);
    }
  }
};
ol.interaction.Modify.prototype.writePolygonGeometry_ = function(feature, geometry) {
  var rings = geometry.getCoordinates();
  var coordinates, i, ii, j, jj, segment, segmentData;
  for (j = 0, jj = rings.length; j < jj; ++j) {
    coordinates = rings[j];
    for (i = 0, ii = coordinates.length - 1; i < ii; ++i) {
      segment = coordinates.slice(i, i + 2);
      segmentData = {feature:feature, geometry:geometry, depth:[j], index:i, segment:segment};
      this.rBush_.insert(ol.extent.boundingExtent(segment), segmentData);
    }
  }
};
ol.interaction.Modify.prototype.writeMultiPolygonGeometry_ = function(feature, geometry) {
  var polygons = geometry.getCoordinates();
  var coordinates, i, ii, j, jj, k, kk, rings, segment, segmentData;
  for (k = 0, kk = polygons.length; k < kk; ++k) {
    rings = polygons[k];
    for (j = 0, jj = rings.length; j < jj; ++j) {
      coordinates = rings[j];
      for (i = 0, ii = coordinates.length - 1; i < ii; ++i) {
        segment = coordinates.slice(i, i + 2);
        segmentData = {feature:feature, geometry:geometry, depth:[j, k], index:i, segment:segment};
        this.rBush_.insert(ol.extent.boundingExtent(segment), segmentData);
      }
    }
  }
};
ol.interaction.Modify.prototype.writeCircleGeometry_ = function(feature, geometry) {
  var coordinates = geometry.getCenter();
  var centerSegmentData = {feature:feature, geometry:geometry, index:ol.interaction.Modify.MODIFY_SEGMENT_CIRCLE_CENTER_INDEX, segment:[coordinates, coordinates]};
  var circumferenceSegmentData = {feature:feature, geometry:geometry, index:ol.interaction.Modify.MODIFY_SEGMENT_CIRCLE_CIRCUMFERENCE_INDEX, segment:[coordinates, coordinates]};
  var featureSegments = [centerSegmentData, circumferenceSegmentData];
  centerSegmentData.featureSegments = circumferenceSegmentData.featureSegments = featureSegments;
  this.rBush_.insert(ol.extent.createOrUpdateFromCoordinate(coordinates), centerSegmentData);
  this.rBush_.insert(geometry.getExtent(), circumferenceSegmentData);
};
ol.interaction.Modify.prototype.writeGeometryCollectionGeometry_ = function(feature, geometry) {
  var i, geometries = geometry.getGeometriesArray();
  for (i = 0; i < geometries.length; ++i) {
    this.SEGMENT_WRITERS_[geometries[i].getType()].call(this, feature, geometries[i]);
  }
};
ol.interaction.Modify.prototype.createOrUpdateVertexFeature_ = function(coordinates) {
  var vertexFeature = this.vertexFeature_;
  if (!vertexFeature) {
    vertexFeature = new ol.Feature(new ol.geom.Point(coordinates));
    this.vertexFeature_ = vertexFeature;
    this.overlay_.getSource().addFeature(vertexFeature);
  } else {
    var geometry = vertexFeature.getGeometry();
    geometry.setCoordinates(coordinates);
  }
  return vertexFeature;
};
ol.interaction.Modify.compareIndexes_ = function(a, b) {
  return a.index - b.index;
};
ol.interaction.Modify.handleDownEvent_ = function(evt) {
  if (!this.condition_(evt)) {
    return false;
  }
  this.handlePointerAtPixel_(evt.pixel, evt.map);
  var pixelCoordinate = evt.map.getCoordinateFromPixel(evt.pixel);
  this.dragSegments_.length = 0;
  this.modified_ = false;
  var vertexFeature = this.vertexFeature_;
  if (vertexFeature) {
    var insertVertices = [];
    var geometry = vertexFeature.getGeometry();
    var vertex = geometry.getCoordinates();
    var vertexExtent = ol.extent.boundingExtent([vertex]);
    var segmentDataMatches = this.rBush_.getInExtent(vertexExtent);
    var componentSegments = {};
    segmentDataMatches.sort(ol.interaction.Modify.compareIndexes_);
    for (var i = 0, ii = segmentDataMatches.length; i < ii; ++i) {
      var segmentDataMatch = segmentDataMatches[i];
      var segment = segmentDataMatch.segment;
      var uid = ol.getUid(segmentDataMatch.feature);
      var depth = segmentDataMatch.depth;
      if (depth) {
        uid += "-" + depth.join("-");
      }
      if (!componentSegments[uid]) {
        componentSegments[uid] = new Array(2);
      }
      if (segmentDataMatch.geometry.getType() === ol.geom.GeometryType.CIRCLE && segmentDataMatch.index === ol.interaction.Modify.MODIFY_SEGMENT_CIRCLE_CIRCUMFERENCE_INDEX) {
        var closestVertex = ol.interaction.Modify.closestOnSegmentData_(pixelCoordinate, segmentDataMatch);
        if (ol.coordinate.equals(closestVertex, vertex) && !componentSegments[uid][0]) {
          this.dragSegments_.push([segmentDataMatch, 0]);
          componentSegments[uid][0] = segmentDataMatch;
        }
      } else {
        if (ol.coordinate.equals(segment[0], vertex) && !componentSegments[uid][0]) {
          this.dragSegments_.push([segmentDataMatch, 0]);
          componentSegments[uid][0] = segmentDataMatch;
        } else {
          if (ol.coordinate.equals(segment[1], vertex) && !componentSegments[uid][1]) {
            if ((segmentDataMatch.geometry.getType() === ol.geom.GeometryType.LINE_STRING || segmentDataMatch.geometry.getType() === ol.geom.GeometryType.MULTI_LINE_STRING) && componentSegments[uid][0] && componentSegments[uid][0].index === 0) {
              continue;
            }
            this.dragSegments_.push([segmentDataMatch, 1]);
            componentSegments[uid][1] = segmentDataMatch;
          } else {
            if (this.insertVertexCondition_(evt) && ol.getUid(segment) in this.vertexSegments_ && (!componentSegments[uid][0] && !componentSegments[uid][1])) {
              insertVertices.push([segmentDataMatch, vertex]);
            }
          }
        }
      }
    }
    if (insertVertices.length) {
      this.willModifyFeatures_(evt);
    }
    for (var j = insertVertices.length - 1; j >= 0; --j) {
      this.insertVertex_.apply(this, insertVertices[j]);
    }
  }
  return !!this.vertexFeature_;
};
ol.interaction.Modify.handleDragEvent_ = function(evt) {
  this.ignoreNextSingleClick_ = false;
  this.willModifyFeatures_(evt);
  var vertex = evt.coordinate;
  for (var i = 0, ii = this.dragSegments_.length; i < ii; ++i) {
    var dragSegment = this.dragSegments_[i];
    var segmentData = dragSegment[0];
    var depth = segmentData.depth;
    var geometry = segmentData.geometry;
    var coordinates;
    var segment = segmentData.segment;
    var index = dragSegment[1];
    while (vertex.length < geometry.getStride()) {
      vertex.push(segment[index][vertex.length]);
    }
    switch(geometry.getType()) {
      case ol.geom.GeometryType.POINT:
        coordinates = vertex;
        segment[0] = segment[1] = vertex;
        break;
      case ol.geom.GeometryType.MULTI_POINT:
        coordinates = geometry.getCoordinates();
        coordinates[segmentData.index] = vertex;
        segment[0] = segment[1] = vertex;
        break;
      case ol.geom.GeometryType.LINE_STRING:
        coordinates = geometry.getCoordinates();
        coordinates[segmentData.index + index] = vertex;
        segment[index] = vertex;
        break;
      case ol.geom.GeometryType.MULTI_LINE_STRING:
        coordinates = geometry.getCoordinates();
        coordinates[depth[0]][segmentData.index + index] = vertex;
        segment[index] = vertex;
        break;
      case ol.geom.GeometryType.POLYGON:
        coordinates = geometry.getCoordinates();
        coordinates[depth[0]][segmentData.index + index] = vertex;
        segment[index] = vertex;
        break;
      case ol.geom.GeometryType.MULTI_POLYGON:
        coordinates = geometry.getCoordinates();
        coordinates[depth[1]][depth[0]][segmentData.index + index] = vertex;
        segment[index] = vertex;
        break;
      case ol.geom.GeometryType.CIRCLE:
        segment[0] = segment[1] = vertex;
        if (segmentData.index === ol.interaction.Modify.MODIFY_SEGMENT_CIRCLE_CENTER_INDEX) {
          this.changingFeature_ = true;
          geometry.setCenter(vertex);
          this.changingFeature_ = false;
        } else {
          this.changingFeature_ = true;
          geometry.setRadius(ol.coordinate.distance(geometry.getCenter(), vertex));
          this.changingFeature_ = false;
        }
        break;
      default:
    }
    if (coordinates) {
      this.setGeometryCoordinates_(geometry, coordinates);
    }
  }
  this.createOrUpdateVertexFeature_(vertex);
};
ol.interaction.Modify.handleUpEvent_ = function(evt) {
  var segmentData;
  var geometry;
  for (var i = this.dragSegments_.length - 1; i >= 0; --i) {
    segmentData = this.dragSegments_[i][0];
    geometry = segmentData.geometry;
    if (geometry.getType() === ol.geom.GeometryType.CIRCLE) {
      var coordinates = geometry.getCenter();
      var centerSegmentData = segmentData.featureSegments[0];
      var circumferenceSegmentData = segmentData.featureSegments[1];
      centerSegmentData.segment[0] = centerSegmentData.segment[1] = coordinates;
      circumferenceSegmentData.segment[0] = circumferenceSegmentData.segment[1] = coordinates;
      this.rBush_.update(ol.extent.createOrUpdateFromCoordinate(coordinates), centerSegmentData);
      this.rBush_.update(geometry.getExtent(), circumferenceSegmentData);
    } else {
      this.rBush_.update(ol.extent.boundingExtent(segmentData.segment), segmentData);
    }
  }
  if (this.modified_) {
    this.dispatchEvent(new ol.interaction.Modify.Event(ol.interaction.ModifyEventType.MODIFYEND, this.features_, evt));
    this.modified_ = false;
  }
  return false;
};
ol.interaction.Modify.handleEvent = function(mapBrowserEvent) {
  if (!(mapBrowserEvent instanceof ol.MapBrowserPointerEvent)) {
    return true;
  }
  this.lastPointerEvent_ = mapBrowserEvent;
  var handled;
  if (!mapBrowserEvent.map.getView().getInteracting() && mapBrowserEvent.type == ol.MapBrowserEventType.POINTERMOVE && !this.handlingDownUpSequence) {
    this.handlePointerMove_(mapBrowserEvent);
  }
  if (this.vertexFeature_ && this.deleteCondition_(mapBrowserEvent)) {
    if (mapBrowserEvent.type != ol.MapBrowserEventType.SINGLECLICK || !this.ignoreNextSingleClick_) {
      handled = this.removePoint();
    } else {
      handled = true;
    }
  }
  if (mapBrowserEvent.type == ol.MapBrowserEventType.SINGLECLICK) {
    this.ignoreNextSingleClick_ = false;
  }
  return ol.interaction.Pointer.handleEvent.call(this, mapBrowserEvent) && !handled;
};
ol.interaction.Modify.prototype.handlePointerMove_ = function(evt) {
  this.lastPixel_ = evt.pixel;
  this.handlePointerAtPixel_(evt.pixel, evt.map);
};
ol.interaction.Modify.prototype.handlePointerAtPixel_ = function(pixel, map) {
  var pixelCoordinate = map.getCoordinateFromPixel(pixel);
  var sortByDistance = function(a, b) {
    return ol.interaction.Modify.pointDistanceToSegmentDataSquared_(pixelCoordinate, a) - ol.interaction.Modify.pointDistanceToSegmentDataSquared_(pixelCoordinate, b);
  };
  var box = ol.extent.buffer(ol.extent.createOrUpdateFromCoordinate(pixelCoordinate), map.getView().getResolution() * this.pixelTolerance_);
  var rBush = this.rBush_;
  var nodes = rBush.getInExtent(box);
  if (nodes.length > 0) {
    nodes.sort(sortByDistance);
    var node = nodes[0];
    var closestSegment = node.segment;
    var vertex = ol.interaction.Modify.closestOnSegmentData_(pixelCoordinate, node);
    var vertexPixel = map.getPixelFromCoordinate(vertex);
    var dist = ol.coordinate.distance(pixel, vertexPixel);
    if (dist <= this.pixelTolerance_) {
      var vertexSegments = {};
      if (node.geometry.getType() === ol.geom.GeometryType.CIRCLE && node.index === ol.interaction.Modify.MODIFY_SEGMENT_CIRCLE_CIRCUMFERENCE_INDEX) {
        this.snappedToVertex_ = true;
        this.createOrUpdateVertexFeature_(vertex);
      } else {
        var pixel1 = map.getPixelFromCoordinate(closestSegment[0]);
        var pixel2 = map.getPixelFromCoordinate(closestSegment[1]);
        var squaredDist1 = ol.coordinate.squaredDistance(vertexPixel, pixel1);
        var squaredDist2 = ol.coordinate.squaredDistance(vertexPixel, pixel2);
        dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));
        this.snappedToVertex_ = dist <= this.pixelTolerance_;
        if (this.snappedToVertex_) {
          vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];
        }
        this.createOrUpdateVertexFeature_(vertex);
        var segment;
        for (var i = 1, ii = nodes.length; i < ii; ++i) {
          segment = nodes[i].segment;
          if (ol.coordinate.equals(closestSegment[0], segment[0]) && ol.coordinate.equals(closestSegment[1], segment[1]) || ol.coordinate.equals(closestSegment[0], segment[1]) && ol.coordinate.equals(closestSegment[1], segment[0])) {
            vertexSegments[ol.getUid(segment)] = true;
          } else {
            break;
          }
        }
      }
      vertexSegments[ol.getUid(closestSegment)] = true;
      this.vertexSegments_ = vertexSegments;
      return;
    }
  }
  if (this.vertexFeature_) {
    this.overlay_.getSource().removeFeature(this.vertexFeature_);
    this.vertexFeature_ = null;
  }
};
ol.interaction.Modify.pointDistanceToSegmentDataSquared_ = function(pointCoordinates, segmentData) {
  var geometry = segmentData.geometry;
  if (geometry.getType() === ol.geom.GeometryType.CIRCLE) {
    var circleGeometry = geometry;
    if (segmentData.index === ol.interaction.Modify.MODIFY_SEGMENT_CIRCLE_CIRCUMFERENCE_INDEX) {
      var distanceToCenterSquared = ol.coordinate.squaredDistance(circleGeometry.getCenter(), pointCoordinates);
      var distanceToCircumference = Math.sqrt(distanceToCenterSquared) - circleGeometry.getRadius();
      return distanceToCircumference * distanceToCircumference;
    }
  }
  return ol.coordinate.squaredDistanceToSegment(pointCoordinates, segmentData.segment);
};
ol.interaction.Modify.closestOnSegmentData_ = function(pointCoordinates, segmentData) {
  var geometry = segmentData.geometry;
  if (geometry.getType() === ol.geom.GeometryType.CIRCLE && segmentData.index === ol.interaction.Modify.MODIFY_SEGMENT_CIRCLE_CIRCUMFERENCE_INDEX) {
    return geometry.getClosestPoint(pointCoordinates);
  }
  return ol.coordinate.closestOnSegment(pointCoordinates, segmentData.segment);
};
ol.interaction.Modify.prototype.insertVertex_ = function(segmentData, vertex) {
  var segment = segmentData.segment;
  var feature = segmentData.feature;
  var geometry = segmentData.geometry;
  var depth = segmentData.depth;
  var index = segmentData.index;
  var coordinates;
  while (vertex.length < geometry.getStride()) {
    vertex.push(0);
  }
  switch(geometry.getType()) {
    case ol.geom.GeometryType.MULTI_LINE_STRING:
      coordinates = geometry.getCoordinates();
      coordinates[depth[0]].splice(index + 1, 0, vertex);
      break;
    case ol.geom.GeometryType.POLYGON:
      coordinates = geometry.getCoordinates();
      coordinates[depth[0]].splice(index + 1, 0, vertex);
      break;
    case ol.geom.GeometryType.MULTI_POLYGON:
      coordinates = geometry.getCoordinates();
      coordinates[depth[1]][depth[0]].splice(index + 1, 0, vertex);
      break;
    case ol.geom.GeometryType.LINE_STRING:
      coordinates = geometry.getCoordinates();
      coordinates.splice(index + 1, 0, vertex);
      break;
    default:
      return;
  }
  this.setGeometryCoordinates_(geometry, coordinates);
  var rTree = this.rBush_;
  rTree.remove(segmentData);
  this.updateSegmentIndices_(geometry, index, depth, 1);
  var newSegmentData = {segment:[segment[0], vertex], feature:feature, geometry:geometry, depth:depth, index:index};
  rTree.insert(ol.extent.boundingExtent(newSegmentData.segment), newSegmentData);
  this.dragSegments_.push([newSegmentData, 1]);
  var newSegmentData2 = {segment:[vertex, segment[1]], feature:feature, geometry:geometry, depth:depth, index:index + 1};
  rTree.insert(ol.extent.boundingExtent(newSegmentData2.segment), newSegmentData2);
  this.dragSegments_.push([newSegmentData2, 0]);
  this.ignoreNextSingleClick_ = true;
};
ol.interaction.Modify.prototype.removePoint = function() {
  if (this.lastPointerEvent_ && this.lastPointerEvent_.type != ol.MapBrowserEventType.POINTERDRAG) {
    var evt = this.lastPointerEvent_;
    this.willModifyFeatures_(evt);
    this.removeVertex_();
    this.dispatchEvent(new ol.interaction.Modify.Event(ol.interaction.ModifyEventType.MODIFYEND, this.features_, evt));
    this.modified_ = false;
    return true;
  }
  return false;
};
ol.interaction.Modify.prototype.removeVertex_ = function() {
  var dragSegments = this.dragSegments_;
  var segmentsByFeature = {};
  var deleted = false;
  var component, coordinates, dragSegment, geometry, i, index, left;
  var newIndex, right, segmentData, uid;
  for (i = dragSegments.length - 1; i >= 0; --i) {
    dragSegment = dragSegments[i];
    segmentData = dragSegment[0];
    uid = ol.getUid(segmentData.feature);
    if (segmentData.depth) {
      uid += "-" + segmentData.depth.join("-");
    }
    if (!(uid in segmentsByFeature)) {
      segmentsByFeature[uid] = {};
    }
    if (dragSegment[1] === 0) {
      segmentsByFeature[uid].right = segmentData;
      segmentsByFeature[uid].index = segmentData.index;
    } else {
      if (dragSegment[1] == 1) {
        segmentsByFeature[uid].left = segmentData;
        segmentsByFeature[uid].index = segmentData.index + 1;
      }
    }
  }
  for (uid in segmentsByFeature) {
    right = segmentsByFeature[uid].right;
    left = segmentsByFeature[uid].left;
    index = segmentsByFeature[uid].index;
    newIndex = index - 1;
    if (left !== undefined) {
      segmentData = left;
    } else {
      segmentData = right;
    }
    if (newIndex < 0) {
      newIndex = 0;
    }
    geometry = segmentData.geometry;
    coordinates = geometry.getCoordinates();
    component = coordinates;
    deleted = false;
    switch(geometry.getType()) {
      case ol.geom.GeometryType.MULTI_LINE_STRING:
        if (coordinates[segmentData.depth[0]].length > 2) {
          coordinates[segmentData.depth[0]].splice(index, 1);
          deleted = true;
        }
        break;
      case ol.geom.GeometryType.LINE_STRING:
        if (coordinates.length > 2) {
          coordinates.splice(index, 1);
          deleted = true;
        }
        break;
      case ol.geom.GeometryType.MULTI_POLYGON:
        component = component[segmentData.depth[1]];
      case ol.geom.GeometryType.POLYGON:
        component = component[segmentData.depth[0]];
        if (component.length > 4) {
          if (index == component.length - 1) {
            index = 0;
          }
          component.splice(index, 1);
          deleted = true;
          if (index === 0) {
            component.pop();
            component.push(component[0]);
            newIndex = component.length - 1;
          }
        }
        break;
      default:
    }
    if (deleted) {
      this.setGeometryCoordinates_(geometry, coordinates);
      var segments = [];
      if (left !== undefined) {
        this.rBush_.remove(left);
        segments.push(left.segment[0]);
      }
      if (right !== undefined) {
        this.rBush_.remove(right);
        segments.push(right.segment[1]);
      }
      if (left !== undefined && right !== undefined) {
        var newSegmentData = {depth:segmentData.depth, feature:segmentData.feature, geometry:segmentData.geometry, index:newIndex, segment:segments};
        this.rBush_.insert(ol.extent.boundingExtent(newSegmentData.segment), newSegmentData);
      }
      this.updateSegmentIndices_(geometry, index, segmentData.depth, -1);
      if (this.vertexFeature_) {
        this.overlay_.getSource().removeFeature(this.vertexFeature_);
        this.vertexFeature_ = null;
      }
      dragSegments.length = 0;
    }
  }
  return deleted;
};
ol.interaction.Modify.prototype.setGeometryCoordinates_ = function(geometry, coordinates) {
  this.changingFeature_ = true;
  geometry.setCoordinates(coordinates);
  this.changingFeature_ = false;
};
ol.interaction.Modify.prototype.updateSegmentIndices_ = function(geometry, index, depth, delta) {
  this.rBush_.forEachInExtent(geometry.getExtent(), function(segmentDataMatch) {
    if (segmentDataMatch.geometry === geometry && (depth === undefined || segmentDataMatch.depth === undefined || ol.array.equals(segmentDataMatch.depth, depth)) && segmentDataMatch.index > index) {
      segmentDataMatch.index += delta;
    }
  });
};
ol.interaction.Modify.getDefaultStyleFunction = function() {
  var style = ol.style.Style.createDefaultEditing();
  return function(feature, resolution) {
    return style[ol.geom.GeometryType.POINT];
  };
};
ol.interaction.Modify.Event = function(type, features, mapBrowserPointerEvent) {
  ol.events.Event.call(this, type);
  this.features = features;
  this.mapBrowserEvent = mapBrowserPointerEvent;
};
ol.inherits(ol.interaction.Modify.Event, ol.events.Event);
goog.provide("ol.interaction.Select");
goog.require("ol");
goog.require("ol.CollectionEventType");
goog.require("ol.array");
goog.require("ol.events");
goog.require("ol.events.Event");
goog.require("ol.events.condition");
goog.require("ol.functions");
goog.require("ol.geom.GeometryType");
goog.require("ol.interaction.Interaction");
goog.require("ol.layer.Vector");
goog.require("ol.obj");
goog.require("ol.source.Vector");
goog.require("ol.style.Style");
ol.interaction.Select = function(opt_options) {
  ol.interaction.Interaction.call(this, {handleEvent:ol.interaction.Select.handleEvent});
  var options = opt_options ? opt_options : {};
  this.condition_ = options.condition ? options.condition : ol.events.condition.singleClick;
  this.addCondition_ = options.addCondition ? options.addCondition : ol.events.condition.never;
  this.removeCondition_ = options.removeCondition ? options.removeCondition : ol.events.condition.never;
  this.toggleCondition_ = options.toggleCondition ? options.toggleCondition : ol.events.condition.shiftKeyOnly;
  this.multi_ = options.multi ? options.multi : false;
  this.filter_ = options.filter ? options.filter : ol.functions.TRUE;
  this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;
  var featureOverlay = new ol.layer.Vector({source:new ol.source.Vector({useSpatialIndex:false, features:options.features, wrapX:options.wrapX}), style:options.style ? options.style : ol.interaction.Select.getDefaultStyleFunction(), updateWhileAnimating:true, updateWhileInteracting:true});
  this.featureOverlay_ = featureOverlay;
  var layerFilter;
  if (options.layers) {
    if (typeof options.layers === "function") {
      layerFilter = options.layers;
    } else {
      var layers = options.layers;
      layerFilter = function(layer) {
        return ol.array.includes(layers, layer);
      };
    }
  } else {
    layerFilter = ol.functions.TRUE;
  }
  this.layerFilter_ = layerFilter;
  this.featureLayerAssociation_ = {};
  var features = this.featureOverlay_.getSource().getFeaturesCollection();
  ol.events.listen(features, ol.CollectionEventType.ADD, this.addFeature_, this);
  ol.events.listen(features, ol.CollectionEventType.REMOVE, this.removeFeature_, this);
};
ol.inherits(ol.interaction.Select, ol.interaction.Interaction);
ol.interaction.Select.prototype.addFeatureLayerAssociation_ = function(feature, layer) {
  var key = ol.getUid(feature);
  this.featureLayerAssociation_[key] = layer;
};
ol.interaction.Select.prototype.getFeatures = function() {
  return this.featureOverlay_.getSource().getFeaturesCollection();
};
ol.interaction.Select.prototype.getHitTolerance = function() {
  return this.hitTolerance_;
};
ol.interaction.Select.prototype.getLayer = function(feature) {
  var key = ol.getUid(feature);
  return this.featureLayerAssociation_[key];
};
ol.interaction.Select.handleEvent = function(mapBrowserEvent) {
  if (!this.condition_(mapBrowserEvent)) {
    return true;
  }
  var add = this.addCondition_(mapBrowserEvent);
  var remove = this.removeCondition_(mapBrowserEvent);
  var toggle = this.toggleCondition_(mapBrowserEvent);
  var set = !add && !remove && !toggle;
  var map = mapBrowserEvent.map;
  var features = this.featureOverlay_.getSource().getFeaturesCollection();
  var deselected = [];
  var selected = [];
  if (set) {
    ol.obj.clear(this.featureLayerAssociation_);
    map.forEachFeatureAtPixel(mapBrowserEvent.pixel, function(feature, layer) {
      if (this.filter_(feature, layer)) {
        selected.push(feature);
        this.addFeatureLayerAssociation_(feature, layer);
        return !this.multi_;
      }
    }.bind(this), {layerFilter:this.layerFilter_, hitTolerance:this.hitTolerance_});
    var i;
    for (i = features.getLength() - 1; i >= 0; --i) {
      var feature = features.item(i);
      var index = selected.indexOf(feature);
      if (index > -1) {
        selected.splice(index, 1);
      } else {
        features.remove(feature);
        deselected.push(feature);
      }
    }
    if (selected.length !== 0) {
      features.extend(selected);
    }
  } else {
    map.forEachFeatureAtPixel(mapBrowserEvent.pixel, function(feature, layer) {
      if (this.filter_(feature, layer)) {
        if ((add || toggle) && !ol.array.includes(features.getArray(), feature)) {
          selected.push(feature);
          this.addFeatureLayerAssociation_(feature, layer);
        } else {
          if ((remove || toggle) && ol.array.includes(features.getArray(), feature)) {
            deselected.push(feature);
            this.removeFeatureLayerAssociation_(feature);
          }
        }
        return !this.multi_;
      }
    }.bind(this), {layerFilter:this.layerFilter_, hitTolerance:this.hitTolerance_});
    var j;
    for (j = deselected.length - 1; j >= 0; --j) {
      features.remove(deselected[j]);
    }
    features.extend(selected);
  }
  if (selected.length > 0 || deselected.length > 0) {
    this.dispatchEvent(new ol.interaction.Select.Event(ol.interaction.Select.EventType_.SELECT, selected, deselected, mapBrowserEvent));
  }
  return ol.events.condition.pointerMove(mapBrowserEvent);
};
ol.interaction.Select.prototype.setHitTolerance = function(hitTolerance) {
  this.hitTolerance_ = hitTolerance;
};
ol.interaction.Select.prototype.setMap = function(map) {
  var currentMap = this.getMap();
  var selectedFeatures = this.featureOverlay_.getSource().getFeaturesCollection();
  if (currentMap) {
    selectedFeatures.forEach(currentMap.unskipFeature, currentMap);
  }
  ol.interaction.Interaction.prototype.setMap.call(this, map);
  this.featureOverlay_.setMap(map);
  if (map) {
    selectedFeatures.forEach(map.skipFeature, map);
  }
};
ol.interaction.Select.getDefaultStyleFunction = function() {
  var styles = ol.style.Style.createDefaultEditing();
  ol.array.extend(styles[ol.geom.GeometryType.POLYGON], styles[ol.geom.GeometryType.LINE_STRING]);
  ol.array.extend(styles[ol.geom.GeometryType.GEOMETRY_COLLECTION], styles[ol.geom.GeometryType.LINE_STRING]);
  return function(feature, resolution) {
    if (!feature.getGeometry()) {
      return null;
    }
    return styles[feature.getGeometry().getType()];
  };
};
ol.interaction.Select.prototype.addFeature_ = function(evt) {
  var map = this.getMap();
  if (map) {
    map.skipFeature(evt.element);
  }
};
ol.interaction.Select.prototype.removeFeature_ = function(evt) {
  var map = this.getMap();
  if (map) {
    map.unskipFeature(evt.element);
  }
};
ol.interaction.Select.prototype.removeFeatureLayerAssociation_ = function(feature) {
  var key = ol.getUid(feature);
  delete this.featureLayerAssociation_[key];
};
ol.interaction.Select.Event = function(type, selected, deselected, mapBrowserEvent) {
  ol.events.Event.call(this, type);
  this.selected = selected;
  this.deselected = deselected;
  this.mapBrowserEvent = mapBrowserEvent;
};
ol.inherits(ol.interaction.Select.Event, ol.events.Event);
ol.interaction.Select.EventType_ = {SELECT:"select"};
goog.provide("ol.interaction.Snap");
goog.require("ol");
goog.require("ol.Collection");
goog.require("ol.CollectionEventType");
goog.require("ol.coordinate");
goog.require("ol.events");
goog.require("ol.events.EventType");
goog.require("ol.extent");
goog.require("ol.functions");
goog.require("ol.geom.GeometryType");
goog.require("ol.geom.Polygon");
goog.require("ol.interaction.Pointer");
goog.require("ol.obj");
goog.require("ol.source.Vector");
goog.require("ol.source.VectorEventType");
goog.require("ol.structs.RBush");
ol.interaction.Snap = function(opt_options) {
  ol.interaction.Pointer.call(this, {handleEvent:ol.interaction.Snap.handleEvent_, handleDownEvent:ol.functions.TRUE, handleUpEvent:ol.interaction.Snap.handleUpEvent_});
  var options = opt_options ? opt_options : {};
  this.source_ = options.source ? options.source : null;
  this.vertex_ = options.vertex !== undefined ? options.vertex : true;
  this.edge_ = options.edge !== undefined ? options.edge : true;
  this.features_ = options.features ? options.features : null;
  this.featuresListenerKeys_ = [];
  this.featureChangeListenerKeys_ = {};
  this.indexedFeaturesExtents_ = {};
  this.pendingFeatures_ = {};
  this.pixelCoordinate_ = null;
  this.pixelTolerance_ = options.pixelTolerance !== undefined ? options.pixelTolerance : 10;
  this.sortByDistance_ = ol.interaction.Snap.sortByDistance.bind(this);
  this.rBush_ = new ol.structs.RBush;
  this.SEGMENT_WRITERS_ = {"Point":this.writePointGeometry_, "LineString":this.writeLineStringGeometry_, "LinearRing":this.writeLineStringGeometry_, "Polygon":this.writePolygonGeometry_, "MultiPoint":this.writeMultiPointGeometry_, "MultiLineString":this.writeMultiLineStringGeometry_, "MultiPolygon":this.writeMultiPolygonGeometry_, "GeometryCollection":this.writeGeometryCollectionGeometry_, "Circle":this.writeCircleGeometry_};
};
ol.inherits(ol.interaction.Snap, ol.interaction.Pointer);
ol.interaction.Snap.prototype.addFeature = function(feature, opt_listen) {
  var listen = opt_listen !== undefined ? opt_listen : true;
  var feature_uid = ol.getUid(feature);
  var geometry = feature.getGeometry();
  if (geometry) {
    var segmentWriter = this.SEGMENT_WRITERS_[geometry.getType()];
    if (segmentWriter) {
      this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent(ol.extent.createEmpty());
      segmentWriter.call(this, feature, geometry);
    }
  }
  if (listen) {
    this.featureChangeListenerKeys_[feature_uid] = ol.events.listen(feature, ol.events.EventType.CHANGE, this.handleFeatureChange_, this);
  }
};
ol.interaction.Snap.prototype.forEachFeatureAdd_ = function(feature) {
  this.addFeature(feature);
};
ol.interaction.Snap.prototype.forEachFeatureRemove_ = function(feature) {
  this.removeFeature(feature);
};
ol.interaction.Snap.prototype.getFeatures_ = function() {
  var features;
  if (this.features_) {
    features = this.features_;
  } else {
    if (this.source_) {
      features = this.source_.getFeatures();
    }
  }
  return features;
};
ol.interaction.Snap.prototype.handleFeatureAdd_ = function(evt) {
  var feature;
  if (evt instanceof ol.source.Vector.Event) {
    feature = evt.feature;
  } else {
    if (evt instanceof ol.Collection.Event) {
      feature = evt.element;
    }
  }
  this.addFeature(feature);
};
ol.interaction.Snap.prototype.handleFeatureRemove_ = function(evt) {
  var feature;
  if (evt instanceof ol.source.Vector.Event) {
    feature = evt.feature;
  } else {
    if (evt instanceof ol.Collection.Event) {
      feature = evt.element;
    }
  }
  this.removeFeature(feature);
};
ol.interaction.Snap.prototype.handleFeatureChange_ = function(evt) {
  var feature = evt.target;
  if (this.handlingDownUpSequence) {
    var uid = ol.getUid(feature);
    if (!(uid in this.pendingFeatures_)) {
      this.pendingFeatures_[uid] = feature;
    }
  } else {
    this.updateFeature_(feature);
  }
};
ol.interaction.Snap.prototype.removeFeature = function(feature, opt_unlisten) {
  var unlisten = opt_unlisten !== undefined ? opt_unlisten : true;
  var feature_uid = ol.getUid(feature);
  var extent = this.indexedFeaturesExtents_[feature_uid];
  if (extent) {
    var rBush = this.rBush_;
    var i, nodesToRemove = [];
    rBush.forEachInExtent(extent, function(node) {
      if (feature === node.feature) {
        nodesToRemove.push(node);
      }
    });
    for (i = nodesToRemove.length - 1; i >= 0; --i) {
      rBush.remove(nodesToRemove[i]);
    }
  }
  if (unlisten) {
    ol.events.unlistenByKey(this.featureChangeListenerKeys_[feature_uid]);
    delete this.featureChangeListenerKeys_[feature_uid];
  }
};
ol.interaction.Snap.prototype.setMap = function(map) {
  var currentMap = this.getMap();
  var keys = this.featuresListenerKeys_;
  var features = this.getFeatures_();
  if (currentMap) {
    keys.forEach(ol.events.unlistenByKey);
    keys.length = 0;
    features.forEach(this.forEachFeatureRemove_, this);
  }
  ol.interaction.Pointer.prototype.setMap.call(this, map);
  if (map) {
    if (this.features_) {
      keys.push(ol.events.listen(this.features_, ol.CollectionEventType.ADD, this.handleFeatureAdd_, this), ol.events.listen(this.features_, ol.CollectionEventType.REMOVE, this.handleFeatureRemove_, this));
    } else {
      if (this.source_) {
        keys.push(ol.events.listen(this.source_, ol.source.VectorEventType.ADDFEATURE, this.handleFeatureAdd_, this), ol.events.listen(this.source_, ol.source.VectorEventType.REMOVEFEATURE, this.handleFeatureRemove_, this));
      }
    }
    features.forEach(this.forEachFeatureAdd_, this);
  }
};
ol.interaction.Snap.prototype.shouldStopEvent = ol.functions.FALSE;
ol.interaction.Snap.prototype.snapTo = function(pixel, pixelCoordinate, map) {
  var lowerLeft = map.getCoordinateFromPixel([pixel[0] - this.pixelTolerance_, pixel[1] + this.pixelTolerance_]);
  var upperRight = map.getCoordinateFromPixel([pixel[0] + this.pixelTolerance_, pixel[1] - this.pixelTolerance_]);
  var box = ol.extent.boundingExtent([lowerLeft, upperRight]);
  var segments = this.rBush_.getInExtent(box);
  if (this.vertex_ && !this.edge_) {
    segments = segments.filter(function(segment) {
      return segment.feature.getGeometry().getType() !== ol.geom.GeometryType.CIRCLE;
    });
  }
  var snappedToVertex = false;
  var snapped = false;
  var vertex = null;
  var vertexPixel = null;
  var dist, pixel1, pixel2, squaredDist1, squaredDist2;
  if (segments.length > 0) {
    this.pixelCoordinate_ = pixelCoordinate;
    segments.sort(this.sortByDistance_);
    var closestSegment = segments[0].segment;
    var isCircle = segments[0].feature.getGeometry().getType() === ol.geom.GeometryType.CIRCLE;
    if (this.vertex_ && !this.edge_) {
      pixel1 = map.getPixelFromCoordinate(closestSegment[0]);
      pixel2 = map.getPixelFromCoordinate(closestSegment[1]);
      squaredDist1 = ol.coordinate.squaredDistance(pixel, pixel1);
      squaredDist2 = ol.coordinate.squaredDistance(pixel, pixel2);
      dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));
      snappedToVertex = dist <= this.pixelTolerance_;
      if (snappedToVertex) {
        snapped = true;
        vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];
        vertexPixel = map.getPixelFromCoordinate(vertex);
      }
    } else {
      if (this.edge_) {
        if (isCircle) {
          vertex = ol.coordinate.closestOnCircle(pixelCoordinate, segments[0].feature.getGeometry());
        } else {
          vertex = ol.coordinate.closestOnSegment(pixelCoordinate, closestSegment);
        }
        vertexPixel = map.getPixelFromCoordinate(vertex);
        if (ol.coordinate.distance(pixel, vertexPixel) <= this.pixelTolerance_) {
          snapped = true;
          if (this.vertex_ && !isCircle) {
            pixel1 = map.getPixelFromCoordinate(closestSegment[0]);
            pixel2 = map.getPixelFromCoordinate(closestSegment[1]);
            squaredDist1 = ol.coordinate.squaredDistance(vertexPixel, pixel1);
            squaredDist2 = ol.coordinate.squaredDistance(vertexPixel, pixel2);
            dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));
            snappedToVertex = dist <= this.pixelTolerance_;
            if (snappedToVertex) {
              vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];
              vertexPixel = map.getPixelFromCoordinate(vertex);
            }
          }
        }
      }
    }
    if (snapped) {
      vertexPixel = [Math.round(vertexPixel[0]), Math.round(vertexPixel[1])];
    }
  }
  return {snapped:snapped, vertex:vertex, vertexPixel:vertexPixel};
};
ol.interaction.Snap.prototype.updateFeature_ = function(feature) {
  this.removeFeature(feature, false);
  this.addFeature(feature, false);
};
ol.interaction.Snap.prototype.writeCircleGeometry_ = function(feature, geometry) {
  var polygon = ol.geom.Polygon.fromCircle(geometry);
  var coordinates = polygon.getCoordinates()[0];
  var i, ii, segment, segmentData;
  for (i = 0, ii = coordinates.length - 1; i < ii; ++i) {
    segment = coordinates.slice(i, i + 2);
    segmentData = {feature:feature, segment:segment};
    this.rBush_.insert(ol.extent.boundingExtent(segment), segmentData);
  }
};
ol.interaction.Snap.prototype.writeGeometryCollectionGeometry_ = function(feature, geometry) {
  var i, geometries = geometry.getGeometriesArray();
  for (i = 0; i < geometries.length; ++i) {
    var segmentWriter = this.SEGMENT_WRITERS_[geometries[i].getType()];
    if (segmentWriter) {
      segmentWriter.call(this, feature, geometries[i]);
    }
  }
};
ol.interaction.Snap.prototype.writeLineStringGeometry_ = function(feature, geometry) {
  var coordinates = geometry.getCoordinates();
  var i, ii, segment, segmentData;
  for (i = 0, ii = coordinates.length - 1; i < ii; ++i) {
    segment = coordinates.slice(i, i + 2);
    segmentData = {feature:feature, segment:segment};
    this.rBush_.insert(ol.extent.boundingExtent(segment), segmentData);
  }
};
ol.interaction.Snap.prototype.writeMultiLineStringGeometry_ = function(feature, geometry) {
  var lines = geometry.getCoordinates();
  var coordinates, i, ii, j, jj, segment, segmentData;
  for (j = 0, jj = lines.length; j < jj; ++j) {
    coordinates = lines[j];
    for (i = 0, ii = coordinates.length - 1; i < ii; ++i) {
      segment = coordinates.slice(i, i + 2);
      segmentData = {feature:feature, segment:segment};
      this.rBush_.insert(ol.extent.boundingExtent(segment), segmentData);
    }
  }
};
ol.interaction.Snap.prototype.writeMultiPointGeometry_ = function(feature, geometry) {
  var points = geometry.getCoordinates();
  var coordinates, i, ii, segmentData;
  for (i = 0, ii = points.length; i < ii; ++i) {
    coordinates = points[i];
    segmentData = {feature:feature, segment:[coordinates, coordinates]};
    this.rBush_.insert(geometry.getExtent(), segmentData);
  }
};
ol.interaction.Snap.prototype.writeMultiPolygonGeometry_ = function(feature, geometry) {
  var polygons = geometry.getCoordinates();
  var coordinates, i, ii, j, jj, k, kk, rings, segment, segmentData;
  for (k = 0, kk = polygons.length; k < kk; ++k) {
    rings = polygons[k];
    for (j = 0, jj = rings.length; j < jj; ++j) {
      coordinates = rings[j];
      for (i = 0, ii = coordinates.length - 1; i < ii; ++i) {
        segment = coordinates.slice(i, i + 2);
        segmentData = {feature:feature, segment:segment};
        this.rBush_.insert(ol.extent.boundingExtent(segment), segmentData);
      }
    }
  }
};
ol.interaction.Snap.prototype.writePointGeometry_ = function(feature, geometry) {
  var coordinates = geometry.getCoordinates();
  var segmentData = {feature:feature, segment:[coordinates, coordinates]};
  this.rBush_.insert(geometry.getExtent(), segmentData);
};
ol.interaction.Snap.prototype.writePolygonGeometry_ = function(feature, geometry) {
  var rings = geometry.getCoordinates();
  var coordinates, i, ii, j, jj, segment, segmentData;
  for (j = 0, jj = rings.length; j < jj; ++j) {
    coordinates = rings[j];
    for (i = 0, ii = coordinates.length - 1; i < ii; ++i) {
      segment = coordinates.slice(i, i + 2);
      segmentData = {feature:feature, segment:segment};
      this.rBush_.insert(ol.extent.boundingExtent(segment), segmentData);
    }
  }
};
ol.interaction.Snap.handleEvent_ = function(evt) {
  var result = this.snapTo(evt.pixel, evt.coordinate, evt.map);
  if (result.snapped) {
    evt.coordinate = result.vertex.slice(0, 2);
    evt.pixel = result.vertexPixel;
  }
  return ol.interaction.Pointer.handleEvent.call(this, evt);
};
ol.interaction.Snap.handleUpEvent_ = function(evt) {
  var featuresToUpdate = ol.obj.getValues(this.pendingFeatures_);
  if (featuresToUpdate.length) {
    featuresToUpdate.forEach(this.updateFeature_, this);
    this.pendingFeatures_ = {};
  }
  return false;
};
ol.interaction.Snap.sortByDistance = function(a, b) {
  return ol.coordinate.squaredDistanceToSegment(this.pixelCoordinate_, a.segment) - ol.coordinate.squaredDistanceToSegment(this.pixelCoordinate_, b.segment);
};
goog.provide("ol.interaction.TranslateEventType");
ol.interaction.TranslateEventType = {TRANSLATESTART:"translatestart", TRANSLATING:"translating", TRANSLATEEND:"translateend"};
goog.provide("ol.interaction.Translate");
goog.require("ol");
goog.require("ol.Collection");
goog.require("ol.Object");
goog.require("ol.events");
goog.require("ol.events.Event");
goog.require("ol.functions");
goog.require("ol.array");
goog.require("ol.interaction.Pointer");
goog.require("ol.interaction.Property");
goog.require("ol.interaction.TranslateEventType");
ol.interaction.Translate = function(opt_options) {
  ol.interaction.Pointer.call(this, {handleDownEvent:ol.interaction.Translate.handleDownEvent_, handleDragEvent:ol.interaction.Translate.handleDragEvent_, handleMoveEvent:ol.interaction.Translate.handleMoveEvent_, handleUpEvent:ol.interaction.Translate.handleUpEvent_});
  var options = opt_options ? opt_options : {};
  this.lastCoordinate_ = null;
  this.features_ = options.features !== undefined ? options.features : null;
  var layerFilter;
  if (options.layers) {
    if (typeof options.layers === "function") {
      layerFilter = options.layers;
    } else {
      var layers = options.layers;
      layerFilter = function(layer) {
        return ol.array.includes(layers, layer);
      };
    }
  } else {
    layerFilter = ol.functions.TRUE;
  }
  this.layerFilter_ = layerFilter;
  this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;
  this.lastFeature_ = null;
  ol.events.listen(this, ol.Object.getChangeEventType(ol.interaction.Property.ACTIVE), this.handleActiveChanged_, this);
};
ol.inherits(ol.interaction.Translate, ol.interaction.Pointer);
ol.interaction.Translate.handleDownEvent_ = function(event) {
  this.lastFeature_ = this.featuresAtPixel_(event.pixel, event.map);
  if (!this.lastCoordinate_ && this.lastFeature_) {
    this.lastCoordinate_ = event.coordinate;
    ol.interaction.Translate.handleMoveEvent_.call(this, event);
    var features = this.features_ || new ol.Collection([this.lastFeature_]);
    this.dispatchEvent(new ol.interaction.Translate.Event(ol.interaction.TranslateEventType.TRANSLATESTART, features, event.coordinate));
    return true;
  }
  return false;
};
ol.interaction.Translate.handleUpEvent_ = function(event) {
  if (this.lastCoordinate_) {
    this.lastCoordinate_ = null;
    ol.interaction.Translate.handleMoveEvent_.call(this, event);
    var features = this.features_ || new ol.Collection([this.lastFeature_]);
    this.dispatchEvent(new ol.interaction.Translate.Event(ol.interaction.TranslateEventType.TRANSLATEEND, features, event.coordinate));
    return true;
  }
  return false;
};
ol.interaction.Translate.handleDragEvent_ = function(event) {
  if (this.lastCoordinate_) {
    var newCoordinate = event.coordinate;
    var deltaX = newCoordinate[0] - this.lastCoordinate_[0];
    var deltaY = newCoordinate[1] - this.lastCoordinate_[1];
    var features = this.features_ || new ol.Collection([this.lastFeature_]);
    features.forEach(function(feature) {
      var geom = feature.getGeometry();
      geom.translate(deltaX, deltaY);
      feature.setGeometry(geom);
    });
    this.lastCoordinate_ = newCoordinate;
    this.dispatchEvent(new ol.interaction.Translate.Event(ol.interaction.TranslateEventType.TRANSLATING, features, newCoordinate));
  }
};
ol.interaction.Translate.handleMoveEvent_ = function(event) {
  var elem = event.map.getViewport();
  if (this.featuresAtPixel_(event.pixel, event.map)) {
    elem.classList.remove(this.lastCoordinate_ ? "ol-grab" : "ol-grabbing");
    elem.classList.add(this.lastCoordinate_ ? "ol-grabbing" : "ol-grab");
  } else {
    elem.classList.remove("ol-grab", "ol-grabbing");
  }
};
ol.interaction.Translate.prototype.featuresAtPixel_ = function(pixel, map) {
  return map.forEachFeatureAtPixel(pixel, function(feature) {
    if (!this.features_ || ol.array.includes(this.features_.getArray(), feature)) {
      return feature;
    }
  }.bind(this), {layerFilter:this.layerFilter_, hitTolerance:this.hitTolerance_});
};
ol.interaction.Translate.prototype.getHitTolerance = function() {
  return this.hitTolerance_;
};
ol.interaction.Translate.prototype.setHitTolerance = function(hitTolerance) {
  this.hitTolerance_ = hitTolerance;
};
ol.interaction.Translate.prototype.setMap = function(map) {
  var oldMap = this.getMap();
  ol.interaction.Pointer.prototype.setMap.call(this, map);
  this.updateState_(oldMap);
};
ol.interaction.Translate.prototype.handleActiveChanged_ = function() {
  this.updateState_(null);
};
ol.interaction.Translate.prototype.updateState_ = function(oldMap) {
  var map = this.getMap();
  var active = this.getActive();
  if (!map || !active) {
    map = map || oldMap;
    if (map) {
      var elem = map.getViewport();
      elem.classList.remove("ol-grab", "ol-grabbing");
    }
  }
};
ol.interaction.Translate.Event = function(type, features, coordinate) {
  ol.events.Event.call(this, type);
  this.features = features;
  this.coordinate = coordinate;
};
ol.inherits(ol.interaction.Translate.Event, ol.events.Event);
goog.provide("ol.layer.Heatmap");
goog.require("ol.events");
goog.require("ol");
goog.require("ol.Object");
goog.require("ol.dom");
goog.require("ol.layer.Vector");
goog.require("ol.math");
goog.require("ol.obj");
goog.require("ol.render.EventType");
goog.require("ol.style.Icon");
goog.require("ol.style.Style");
ol.layer.Heatmap = function(opt_options) {
  var options = opt_options ? opt_options : {};
  var baseOptions = ol.obj.assign({}, options);
  delete baseOptions.gradient;
  delete baseOptions.radius;
  delete baseOptions.blur;
  delete baseOptions.shadow;
  delete baseOptions.weight;
  ol.layer.Vector.call(this, baseOptions);
  this.gradient_ = null;
  this.shadow_ = options.shadow !== undefined ? options.shadow : 250;
  this.circleImage_ = undefined;
  this.styleCache_ = null;
  ol.events.listen(this, ol.Object.getChangeEventType(ol.layer.Heatmap.Property_.GRADIENT), this.handleGradientChanged_, this);
  this.setGradient(options.gradient ? options.gradient : ol.layer.Heatmap.DEFAULT_GRADIENT);
  this.setBlur(options.blur !== undefined ? options.blur : 15);
  this.setRadius(options.radius !== undefined ? options.radius : 8);
  ol.events.listen(this, ol.Object.getChangeEventType(ol.layer.Heatmap.Property_.BLUR), this.handleStyleChanged_, this);
  ol.events.listen(this, ol.Object.getChangeEventType(ol.layer.Heatmap.Property_.RADIUS), this.handleStyleChanged_, this);
  this.handleStyleChanged_();
  var weight = options.weight ? options.weight : "weight";
  var weightFunction;
  if (typeof weight === "string") {
    weightFunction = function(feature) {
      return feature.get(weight);
    };
  } else {
    weightFunction = weight;
  }
  this.setStyle(function(feature, resolution) {
    var weight = weightFunction(feature);
    var opacity = weight !== undefined ? ol.math.clamp(weight, 0, 1) : 1;
    var index = 255 * opacity | 0;
    var style = this.styleCache_[index];
    if (!style) {
      style = [new ol.style.Style({image:new ol.style.Icon({opacity:opacity, src:this.circleImage_})})];
      this.styleCache_[index] = style;
    }
    return style;
  }.bind(this));
  this.setRenderOrder(null);
  ol.events.listen(this, ol.render.EventType.RENDER, this.handleRender_, this);
};
ol.inherits(ol.layer.Heatmap, ol.layer.Vector);
ol.layer.Heatmap.DEFAULT_GRADIENT = ["#00f", "#0ff", "#0f0", "#ff0", "#f00"];
ol.layer.Heatmap.createGradient_ = function(colors) {
  var width = 1;
  var height = 256;
  var context = ol.dom.createCanvasContext2D(width, height);
  var gradient = context.createLinearGradient(0, 0, width, height);
  var step = 1 / (colors.length - 1);
  for (var i = 0, ii = colors.length; i < ii; ++i) {
    gradient.addColorStop(i * step, colors[i]);
  }
  context.fillStyle = gradient;
  context.fillRect(0, 0, width, height);
  return context.getImageData(0, 0, width, height).data;
};
ol.layer.Heatmap.prototype.createCircle_ = function() {
  var radius = this.getRadius();
  var blur = this.getBlur();
  var halfSize = radius + blur + 1;
  var size = 2 * halfSize;
  var context = ol.dom.createCanvasContext2D(size, size);
  context.shadowOffsetX = context.shadowOffsetY = this.shadow_;
  context.shadowBlur = blur;
  context.shadowColor = "#000";
  context.beginPath();
  var center = halfSize - this.shadow_;
  context.arc(center, center, radius, 0, Math.PI * 2, true);
  context.fill();
  return context.canvas.toDataURL();
};
ol.layer.Heatmap.prototype.getBlur = function() {
  return this.get(ol.layer.Heatmap.Property_.BLUR);
};
ol.layer.Heatmap.prototype.getGradient = function() {
  return this.get(ol.layer.Heatmap.Property_.GRADIENT);
};
ol.layer.Heatmap.prototype.getRadius = function() {
  return this.get(ol.layer.Heatmap.Property_.RADIUS);
};
ol.layer.Heatmap.prototype.handleGradientChanged_ = function() {
  this.gradient_ = ol.layer.Heatmap.createGradient_(this.getGradient());
};
ol.layer.Heatmap.prototype.handleStyleChanged_ = function() {
  this.circleImage_ = this.createCircle_();
  this.styleCache_ = new Array(256);
  this.changed();
};
ol.layer.Heatmap.prototype.handleRender_ = function(event) {
  var context = event.context;
  var canvas = context.canvas;
  var image = context.getImageData(0, 0, canvas.width, canvas.height);
  var view8 = image.data;
  var i, ii, alpha;
  for (i = 0, ii = view8.length; i < ii; i += 4) {
    alpha = view8[i + 3] * 4;
    if (alpha) {
      view8[i] = this.gradient_[alpha];
      view8[i + 1] = this.gradient_[alpha + 1];
      view8[i + 2] = this.gradient_[alpha + 2];
    }
  }
  context.putImageData(image, 0, 0);
};
ol.layer.Heatmap.prototype.setBlur = function(blur) {
  this.set(ol.layer.Heatmap.Property_.BLUR, blur);
};
ol.layer.Heatmap.prototype.setGradient = function(colors) {
  this.set(ol.layer.Heatmap.Property_.GRADIENT, colors);
};
ol.layer.Heatmap.prototype.setRadius = function(radius) {
  this.set(ol.layer.Heatmap.Property_.RADIUS, radius);
};
ol.layer.Heatmap.Property_ = {BLUR:"blur", GRADIENT:"gradient", RADIUS:"radius"};
goog.provide("ol.layer.VectorTile");
goog.require("ol");
goog.require("ol.LayerType");
goog.require("ol.asserts");
goog.require("ol.layer.TileProperty");
goog.require("ol.layer.Vector");
goog.require("ol.layer.VectorTileRenderType");
goog.require("ol.obj");
ol.layer.VectorTile = function(opt_options) {
  var options = opt_options ? opt_options : {};
  var renderMode = options.renderMode || ol.layer.VectorTileRenderType.HYBRID;
  ol.asserts.assert(renderMode == undefined || renderMode == ol.layer.VectorTileRenderType.IMAGE || renderMode == ol.layer.VectorTileRenderType.HYBRID || renderMode == ol.layer.VectorTileRenderType.VECTOR, 28);
  if (options.declutter && renderMode == ol.layer.VectorTileRenderType.IMAGE) {
    renderMode = ol.layer.VectorTileRenderType.HYBRID;
  }
  options.renderMode = renderMode;
  var baseOptions = ol.obj.assign({}, options);
  delete baseOptions.preload;
  delete baseOptions.useInterimTilesOnError;
  ol.layer.Vector.call(this, baseOptions);
  this.setPreload(options.preload ? options.preload : 0);
  this.setUseInterimTilesOnError(options.useInterimTilesOnError ? options.useInterimTilesOnError : true);
  this.type = ol.LayerType.VECTOR_TILE;
};
ol.inherits(ol.layer.VectorTile, ol.layer.Vector);
ol.layer.VectorTile.prototype.getPreload = function() {
  return this.get(ol.layer.TileProperty.PRELOAD);
};
ol.layer.VectorTile.prototype.getUseInterimTilesOnError = function() {
  return this.get(ol.layer.TileProperty.USE_INTERIM_TILES_ON_ERROR);
};
ol.layer.VectorTile.prototype.setPreload = function(preload) {
  this.set(ol.layer.TileProperty.PRELOAD, preload);
};
ol.layer.VectorTile.prototype.setUseInterimTilesOnError = function(useInterimTilesOnError) {
  this.set(ol.layer.TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
};
ol.layer.VectorTile.prototype.getSource;
goog.provide("ol.webgl.Shader");
goog.require("ol.functions");
ol.webgl.Shader = function(source) {
  this.source_ = source;
};
ol.webgl.Shader.prototype.getType = function() {
};
ol.webgl.Shader.prototype.getSource = function() {
  return this.source_;
};
ol.webgl.Shader.prototype.isAnimated = ol.functions.FALSE;
goog.provide("ol.webgl.Fragment");
goog.require("ol");
goog.require("ol.webgl");
goog.require("ol.webgl.Shader");
ol.webgl.Fragment = function(source) {
  ol.webgl.Shader.call(this, source);
};
ol.inherits(ol.webgl.Fragment, ol.webgl.Shader);
ol.webgl.Fragment.prototype.getType = function() {
  return ol.webgl.FRAGMENT_SHADER;
};
goog.provide("ol.webgl.Vertex");
goog.require("ol");
goog.require("ol.webgl");
goog.require("ol.webgl.Shader");
ol.webgl.Vertex = function(source) {
  ol.webgl.Shader.call(this, source);
};
ol.inherits(ol.webgl.Vertex, ol.webgl.Shader);
ol.webgl.Vertex.prototype.getType = function() {
  return ol.webgl.VERTEX_SHADER;
};
goog.provide("ol.render.webgl.circlereplay.defaultshader");
goog.require("ol");
goog.require("ol.webgl.Fragment");
goog.require("ol.webgl.Vertex");
ol.render.webgl.circlereplay.defaultshader.fragment = new ol.webgl.Fragment(ol.DEBUG_WEBGL ? "precision mediump float;\nvarying vec2 v_center;\nvarying vec2 v_offset;\nvarying float v_halfWidth;\nvarying float v_pixelRatio;\n\n\n\nuniform float u_opacity;\nuniform vec4 u_fillColor;\nuniform vec4 u_strokeColor;\nuniform vec2 u_size;\n\nvoid main(void) {\n  vec2 windowCenter = vec2((v_center.x + 1.0) / 2.0 * u_size.x * v_pixelRatio,\n      (v_center.y + 1.0) / 2.0 * u_size.y * v_pixelRatio);\n  vec2 windowOffset = vec2((v_offset.x + 1.0) / 2.0 * u_size.x * v_pixelRatio,\n      (v_offset.y + 1.0) / 2.0 * u_size.y * v_pixelRatio);\n  float radius = length(windowCenter - windowOffset);\n  float dist = length(windowCenter - gl_FragCoord.xy);\n  if (dist > radius + v_halfWidth) {\n    if (u_strokeColor.a == 0.0) {\n      gl_FragColor = u_fillColor;\n    } else {\n      gl_FragColor = u_strokeColor;\n    }\n    gl_FragColor.a = gl_FragColor.a - (dist - (radius + v_halfWidth));\n  } else if (u_fillColor.a == 0.0) {\n    // Hooray, no fill, just stroke. We can use real antialiasing.\n    gl_FragColor = u_strokeColor;\n    if (dist < radius - v_halfWidth) {\n      gl_FragColor.a = gl_FragColor.a - (radius - v_halfWidth - dist);\n    }\n  } else {\n    gl_FragColor = u_fillColor;\n    float strokeDist = radius - v_halfWidth;\n    float antialias = 2.0 * v_pixelRatio;\n    if (dist > strokeDist) {\n      gl_FragColor = u_strokeColor;\n    } else if (dist >= strokeDist - antialias) {\n      float step = smoothstep(strokeDist - antialias, strokeDist, dist);\n      gl_FragColor = mix(u_fillColor, u_strokeColor, step);\n    }\n  }\n  gl_FragColor.a = gl_FragColor.a * u_opacity;\n  if (gl_FragColor.a <= 0.0) {\n    discard;\n  }\n}\n" : 
"precision mediump float;varying vec2 a;varying vec2 b;varying float c;varying float d;uniform float m;uniform vec4 n;uniform vec4 o;uniform vec2 p;void main(void){vec2 windowCenter=vec2((a.x+1.0)/2.0*p.x*d,(a.y+1.0)/2.0*p.y*d);vec2 windowOffset=vec2((b.x+1.0)/2.0*p.x*d,(b.y+1.0)/2.0*p.y*d);float radius=length(windowCenter-windowOffset);float dist=length(windowCenter-gl_FragCoord.xy);if(dist>radius+c){if(o.a==0.0){gl_FragColor=n;}else{gl_FragColor=o;}gl_FragColor.a=gl_FragColor.a-(dist-(radius+c));}else if(n.a==0.0){gl_FragColor=o;if(dist<radius-c){gl_FragColor.a=gl_FragColor.a-(radius-c-dist);}} else{gl_FragColor=n;float strokeDist=radius-c;float antialias=2.0*d;if(dist>strokeDist){gl_FragColor=o;}else if(dist>=strokeDist-antialias){float step=smoothstep(strokeDist-antialias,strokeDist,dist);gl_FragColor=mix(n,o,step);}} gl_FragColor.a=gl_FragColor.a*m;if(gl_FragColor.a<=0.0){discard;}}");
ol.render.webgl.circlereplay.defaultshader.vertex = new ol.webgl.Vertex(ol.DEBUG_WEBGL ? "varying vec2 v_center;\nvarying vec2 v_offset;\nvarying float v_halfWidth;\nvarying float v_pixelRatio;\n\n\nattribute vec2 a_position;\nattribute float a_instruction;\nattribute float a_radius;\n\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_offsetScaleMatrix;\nuniform mat4 u_offsetRotateMatrix;\nuniform float u_lineWidth;\nuniform float u_pixelRatio;\n\nvoid main(void) {\n  mat4 offsetMatrix = u_offsetScaleMatrix * u_offsetRotateMatrix;\n  v_center = vec4(u_projectionMatrix * vec4(a_position, 0.0, 1.0)).xy;\n  v_pixelRatio = u_pixelRatio;\n  float lineWidth = u_lineWidth * u_pixelRatio;\n  v_halfWidth = lineWidth / 2.0;\n  if (lineWidth == 0.0) {\n    lineWidth = 2.0 * u_pixelRatio;\n  }\n  vec2 offset;\n  // Radius with anitaliasing (roughly).\n  float radius = a_radius + 3.0 * u_pixelRatio;\n  // Until we get gl_VertexID in WebGL, we store an instruction.\n  if (a_instruction == 0.0) {\n    // Offsetting the edges of the triangle by lineWidth / 2 is necessary, however\n    // we should also leave some space for the antialiasing, thus we offset by lineWidth.\n    offset = vec2(-1.0, 1.0);\n  } else if (a_instruction == 1.0) {\n    offset = vec2(-1.0, -1.0);\n  } else if (a_instruction == 2.0) {\n    offset = vec2(1.0, -1.0);\n  } else {\n    offset = vec2(1.0, 1.0);\n  }\n\n  gl_Position = u_projectionMatrix * vec4(a_position + offset * radius, 0.0, 1.0) +\n      offsetMatrix * vec4(offset * lineWidth, 0.0, 0.0);\n  v_offset = vec4(u_projectionMatrix * vec4(a_position.x + a_radius, a_position.y,\n      0.0, 1.0)).xy;\n\n  if (distance(v_center, v_offset) > 20000.0) {\n    gl_Position = vec4(v_center, 0.0, 1.0);\n  }\n}\n\n\n" : 
"varying vec2 a;varying vec2 b;varying float c;varying float d;attribute vec2 e;attribute float f;attribute float g;uniform mat4 h;uniform mat4 i;uniform mat4 j;uniform float k;uniform float l;void main(void){mat4 offsetMatrix=i*j;a=vec4(h*vec4(e,0.0,1.0)).xy;d=l;float lineWidth=k*l;c=lineWidth/2.0;if(lineWidth==0.0){lineWidth=2.0*l;}vec2 offset;float radius=g+3.0*l;//Until we get gl_VertexID in WebGL,we store an instruction.if(f==0.0){//Offsetting the edges of the triangle by lineWidth/2 is necessary,however//we should also leave some space for the antialiasing,thus we offset by lineWidth.offset=vec2(-1.0,1.0);}else if(f==1.0){offset=vec2(-1.0,-1.0);}else if(f==2.0){offset=vec2(1.0,-1.0);}else{offset=vec2(1.0,1.0);}gl_Position=h*vec4(e+offset*radius,0.0,1.0)+offsetMatrix*vec4(offset*lineWidth,0.0,0.0);b=vec4(h*vec4(e.x+g,e.y,0.0,1.0)).xy;if(distance(a,b)>20000.0){gl_Position=vec4(a,0.0,1.0);}}");
goog.provide("ol.render.webgl.circlereplay.defaultshader.Locations");
goog.require("ol");
ol.render.webgl.circlereplay.defaultshader.Locations = function(gl, program) {
  this.u_projectionMatrix = gl.getUniformLocation(program, ol.DEBUG_WEBGL ? "u_projectionMatrix" : "h");
  this.u_offsetScaleMatrix = gl.getUniformLocation(program, ol.DEBUG_WEBGL ? "u_offsetScaleMatrix" : "i");
  this.u_offsetRotateMatrix = gl.getUniformLocation(program, ol.DEBUG_WEBGL ? "u_offsetRotateMatrix" : "j");
  this.u_lineWidth = gl.getUniformLocation(program, ol.DEBUG_WEBGL ? "u_lineWidth" : "k");
  this.u_pixelRatio = gl.getUniformLocation(program, ol.DEBUG_WEBGL ? "u_pixelRatio" : "l");
  this.u_opacity = gl.getUniformLocation(program, ol.DEBUG_WEBGL ? "u_opacity" : "m");
  this.u_fillColor = gl.getUniformLocation(program, ol.DEBUG_WEBGL ? "u_fillColor" : "n");
  this.u_strokeColor = gl.getUniformLocation(program, ol.DEBUG_WEBGL ? "u_strokeColor" : "o");
  this.u_size = gl.getUniformLocation(program, ol.DEBUG_WEBGL ? "u_size" : "p");
  this.a_position = gl.getAttribLocation(program, ol.DEBUG_WEBGL ? "a_position" : "e");
  this.a_instruction = gl.getAttribLocation(program, ol.DEBUG_WEBGL ? "a_instruction" : "f");
  this.a_radius = gl.getAttribLocation(program, ol.DEBUG_WEBGL ? "a_radius" : "g");
};
goog.provide("ol.vec.Mat4");
ol.vec.Mat4.create = function() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
};
ol.vec.Mat4.fromTransform = function(mat4, transform) {
  mat4[0] = transform[0];
  mat4[1] = transform[1];
  mat4[4] = transform[2];
  mat4[5] = transform[3];
  mat4[12] = transform[4];
  mat4[13] = transform[5];
  return mat4;
};
goog.provide("ol.render.webgl.Replay");
goog.require("ol");
goog.require("ol.extent");
goog.require("ol.render.VectorContext");
goog.require("ol.transform");
goog.require("ol.vec.Mat4");
goog.require("ol.webgl");
ol.render.webgl.Replay = function(tolerance, maxExtent) {
  ol.render.VectorContext.call(this);
  this.tolerance = tolerance;
  this.maxExtent = maxExtent;
  this.origin = ol.extent.getCenter(maxExtent);
  this.projectionMatrix_ = ol.transform.create();
  this.offsetRotateMatrix_ = ol.transform.create();
  this.offsetScaleMatrix_ = ol.transform.create();
  this.tmpMat4_ = ol.vec.Mat4.create();
  this.indices = [];
  this.indicesBuffer = null;
  this.startIndices = [];
  this.startIndicesFeature = [];
  this.vertices = [];
  this.verticesBuffer = null;
  this.lineStringReplay = undefined;
};
ol.inherits(ol.render.webgl.Replay, ol.render.VectorContext);
ol.render.webgl.Replay.prototype.getDeleteResourcesFunction = function(context) {
};
ol.render.webgl.Replay.prototype.finish = function(context) {
};
ol.render.webgl.Replay.prototype.setUpProgram = function(gl, context, size, pixelRatio) {
};
ol.render.webgl.Replay.prototype.shutDownProgram = function(gl, locations) {
};
ol.render.webgl.Replay.prototype.drawReplay = function(gl, context, skippedFeaturesHash, hitDetection) {
};
ol.render.webgl.Replay.prototype.drawHitDetectionReplayOneByOne = function(gl, context, skippedFeaturesHash, featureCallback, opt_hitExtent) {
};
ol.render.webgl.Replay.prototype.drawHitDetectionReplay = function(gl, context, skippedFeaturesHash, featureCallback, oneByOne, opt_hitExtent) {
  if (!oneByOne) {
    return this.drawHitDetectionReplayAll(gl, context, skippedFeaturesHash, featureCallback);
  } else {
    return this.drawHitDetectionReplayOneByOne(gl, context, skippedFeaturesHash, featureCallback, opt_hitExtent);
  }
};
ol.render.webgl.Replay.prototype.drawHitDetectionReplayAll = function(gl, context, skippedFeaturesHash, featureCallback) {
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  this.drawReplay(gl, context, skippedFeaturesHash, true);
  var result = featureCallback(null);
  if (result) {
    return result;
  } else {
    return undefined;
  }
};
ol.render.webgl.Replay.prototype.replay = function(context, center, resolution, rotation, size, pixelRatio, opacity, skippedFeaturesHash, featureCallback, oneByOne, opt_hitExtent) {
  var gl = context.getGL();
  var tmpStencil, tmpStencilFunc, tmpStencilMaskVal, tmpStencilRef, tmpStencilMask, tmpStencilOpFail, tmpStencilOpPass, tmpStencilOpZFail;
  if (this.lineStringReplay) {
    tmpStencil = gl.isEnabled(gl.STENCIL_TEST);
    tmpStencilFunc = gl.getParameter(gl.STENCIL_FUNC);
    tmpStencilMaskVal = gl.getParameter(gl.STENCIL_VALUE_MASK);
    tmpStencilRef = gl.getParameter(gl.STENCIL_REF);
    tmpStencilMask = gl.getParameter(gl.STENCIL_WRITEMASK);
    tmpStencilOpFail = gl.getParameter(gl.STENCIL_FAIL);
    tmpStencilOpPass = gl.getParameter(gl.STENCIL_PASS_DEPTH_PASS);
    tmpStencilOpZFail = gl.getParameter(gl.STENCIL_PASS_DEPTH_FAIL);
    gl.enable(gl.STENCIL_TEST);
    gl.clear(gl.STENCIL_BUFFER_BIT);
    gl.stencilMask(255);
    gl.stencilFunc(gl.ALWAYS, 1, 255);
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);
    this.lineStringReplay.replay(context, center, resolution, rotation, size, pixelRatio, opacity, skippedFeaturesHash, featureCallback, oneByOne, opt_hitExtent);
    gl.stencilMask(0);
    gl.stencilFunc(gl.NOTEQUAL, 1, 255);
  }
  context.bindBuffer(ol.webgl.ARRAY_BUFFER, this.verticesBuffer);
  context.bindBuffer(ol.webgl.ELEMENT_ARRAY_BUFFER, this.indicesBuffer);
  var locations = this.setUpProgram(gl, context, size, pixelRatio);
  var projectionMatrix = ol.transform.reset(this.projectionMatrix_);
  ol.transform.scale(projectionMatrix, 2 / (resolution * size[0]), 2 / (resolution * size[1]));
  ol.transform.rotate(projectionMatrix, -rotation);
  ol.transform.translate(projectionMatrix, -(center[0] - this.origin[0]), -(center[1] - this.origin[1]));
  var offsetScaleMatrix = ol.transform.reset(this.offsetScaleMatrix_);
  ol.transform.scale(offsetScaleMatrix, 2 / size[0], 2 / size[1]);
  var offsetRotateMatrix = ol.transform.reset(this.offsetRotateMatrix_);
  if (rotation !== 0) {
    ol.transform.rotate(offsetRotateMatrix, -rotation);
  }
  gl.uniformMatrix4fv(locations.u_projectionMatrix, false, ol.vec.Mat4.fromTransform(this.tmpMat4_, projectionMatrix));
  gl.uniformMatrix4fv(locations.u_offsetScaleMatrix, false, ol.vec.Mat4.fromTransform(this.tmpMat4_, offsetScaleMatrix));
  gl.uniformMatrix4fv(locations.u_offsetRotateMatrix, false, ol.vec.Mat4.fromTransform(this.tmpMat4_, offsetRotateMatrix));
  gl.uniform1f(locations.u_opacity, opacity);
  var result;
  if (featureCallback === undefined) {
    this.drawReplay(gl, context, skippedFeaturesHash, false);
  } else {
    result = this.drawHitDetectionReplay(gl, context, skippedFeaturesHash, featureCallback, oneByOne, opt_hitExtent);
  }
  this.shutDownProgram(gl, locations);
  if (this.lineStringReplay) {
    if (!tmpStencil) {
      gl.disable(gl.STENCIL_TEST);
    }
    gl.clear(gl.STENCIL_BUFFER_BIT);
    gl.stencilFunc(tmpStencilFunc, tmpStencilRef, tmpStencilMaskVal);
    gl.stencilMask(tmpStencilMask);
    gl.stencilOp(tmpStencilOpFail, tmpStencilOpZFail, tmpStencilOpPass);
  }
  return result;
};
ol.render.webgl.Replay.prototype.drawElements = function(gl, context, start, end) {
  var elementType = context.hasOESElementIndexUint ? ol.webgl.UNSIGNED_INT : ol.webgl.UNSIGNED_SHORT;
  var elementSize = context.hasOESElementIndexUint ? 4 : 2;
  var numItems = end - start;
  var offsetInBytes = start * elementSize;
  gl.drawElements(ol.webgl.TRIANGLES, numItems, elementType, offsetInBytes);
};
goog.provide("ol.render.webgl");
ol.render.webgl.defaultFont = "10px sans-serif";
ol.render.webgl.defaultFillStyle = [0.0, 0.0, 0.0, 1.0];
ol.render.webgl.defaultLineCap = "round";
ol.render.webgl.defaultLineDash = [];
ol.render.webgl.defaultLineDashOffset = 0;
ol.render.webgl.defaultLineJoin = "round";
ol.render.webgl.defaultMiterLimit = 10;
ol.render.webgl.defaultStrokeStyle = [0.0, 0.0, 0.0, 1.0];
ol.render.webgl.defaultTextAlign = 0.5;
ol.render.webgl.defaultTextBaseline = 0.5;
ol.render.webgl.defaultLineWidth = 1;
ol.render.webgl.triangleIsCounterClockwise = function(x1, y1, x2, y2, x3, y3) {
  var area = (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1);
  return area <= ol.render.webgl.EPSILON && area >= -ol.render.webgl.EPSILON ? undefined : area > 0;
};
ol.render.webgl.EPSILON = Number.EPSILON || 2.220446049250313e-16;
goog.provide("ol.webgl.Buffer");
goog.require("ol.webgl");
ol.webgl.Buffer = function(opt_arr, opt_usage) {
  this.arr_ = opt_arr !== undefined ? opt_arr : [];
  this.usage_ = opt_usage !== undefined ? opt_usage : ol.webgl.Buffer.Usage_.STATIC_DRAW;
};
ol.webgl.Buffer.prototype.getArray = function() {
  return this.arr_;
};
ol.webgl.Buffer.prototype.getUsage = function() {
  return this.usage_;
};
ol.webgl.Buffer.Usage_ = {STATIC_DRAW:ol.webgl.STATIC_DRAW, STREAM_DRAW:ol.webgl.STREAM_DRAW, DYNAMIC_DRAW:ol.webgl.DYNAMIC_DRAW};
goog.provide("ol.render.webgl.CircleReplay");
goog.require("ol");
goog.require("ol.array");
goog.require("ol.color");
goog.require("ol.extent");
goog.require("ol.obj");
goog.require("ol.geom.flat.transform");
goog.require("ol.render.webgl.circlereplay.defaultshader");
goog.require("ol.render.webgl.circlereplay.defaultshader.Locations");
goog.require("ol.render.webgl.Replay");
goog.require("ol.render.webgl");
goog.require("ol.webgl");
goog.require("ol.webgl.Buffer");
ol.render.webgl.CircleReplay = function(tolerance, maxExtent) {
  ol.render.webgl.Replay.call(this, tolerance, maxExtent);
  this.defaultLocations_ = null;
  this.styles_ = [];
  this.styleIndices_ = [];
  this.radius_ = 0;
  this.state_ = {fillColor:null, strokeColor:null, lineDash:null, lineDashOffset:undefined, lineWidth:undefined, changed:false};
};
ol.inherits(ol.render.webgl.CircleReplay, ol.render.webgl.Replay);
ol.render.webgl.CircleReplay.prototype.drawCoordinates_ = function(flatCoordinates, offset, end, stride) {
  var numVertices = this.vertices.length;
  var numIndices = this.indices.length;
  var n = numVertices / 4;
  var i, ii;
  for (i = offset, ii = end; i < ii; i += stride) {
    this.vertices[numVertices++] = flatCoordinates[i];
    this.vertices[numVertices++] = flatCoordinates[i + 1];
    this.vertices[numVertices++] = 0;
    this.vertices[numVertices++] = this.radius_;
    this.vertices[numVertices++] = flatCoordinates[i];
    this.vertices[numVertices++] = flatCoordinates[i + 1];
    this.vertices[numVertices++] = 1;
    this.vertices[numVertices++] = this.radius_;
    this.vertices[numVertices++] = flatCoordinates[i];
    this.vertices[numVertices++] = flatCoordinates[i + 1];
    this.vertices[numVertices++] = 2;
    this.vertices[numVertices++] = this.radius_;
    this.vertices[numVertices++] = flatCoordinates[i];
    this.vertices[numVertices++] = flatCoordinates[i + 1];
    this.vertices[numVertices++] = 3;
    this.vertices[numVertices++] = this.radius_;
    this.indices[numIndices++] = n;
    this.indices[numIndices++] = n + 1;
    this.indices[numIndices++] = n + 2;
    this.indices[numIndices++] = n + 2;
    this.indices[numIndices++] = n + 3;
    this.indices[numIndices++] = n;
    n += 4;
  }
};
ol.render.webgl.CircleReplay.prototype.drawCircle = function(circleGeometry, feature) {
  var radius = circleGeometry.getRadius();
  var stride = circleGeometry.getStride();
  if (radius) {
    this.startIndices.push(this.indices.length);
    this.startIndicesFeature.push(feature);
    if (this.state_.changed) {
      this.styleIndices_.push(this.indices.length);
      this.state_.changed = false;
    }
    this.radius_ = radius;
    var flatCoordinates = circleGeometry.getFlatCoordinates();
    flatCoordinates = ol.geom.flat.transform.translate(flatCoordinates, 0, 2, stride, -this.origin[0], -this.origin[1]);
    this.drawCoordinates_(flatCoordinates, 0, 2, stride);
  } else {
    if (this.state_.changed) {
      this.styles_.pop();
      if (this.styles_.length) {
        var lastState = this.styles_[this.styles_.length - 1];
        this.state_.fillColor = lastState[0];
        this.state_.strokeColor = lastState[1];
        this.state_.lineWidth = lastState[2];
        this.state_.changed = false;
      }
    }
  }
};
ol.render.webgl.CircleReplay.prototype.finish = function(context) {
  this.verticesBuffer = new ol.webgl.Buffer(this.vertices);
  this.indicesBuffer = new ol.webgl.Buffer(this.indices);
  this.startIndices.push(this.indices.length);
  if (this.styleIndices_.length === 0 && this.styles_.length > 0) {
    this.styles_ = [];
  }
  this.vertices = null;
  this.indices = null;
};
ol.render.webgl.CircleReplay.prototype.getDeleteResourcesFunction = function(context) {
  var verticesBuffer = this.verticesBuffer;
  var indicesBuffer = this.indicesBuffer;
  return function() {
    context.deleteBuffer(verticesBuffer);
    context.deleteBuffer(indicesBuffer);
  };
};
ol.render.webgl.CircleReplay.prototype.setUpProgram = function(gl, context, size, pixelRatio) {
  var fragmentShader, vertexShader;
  fragmentShader = ol.render.webgl.circlereplay.defaultshader.fragment;
  vertexShader = ol.render.webgl.circlereplay.defaultshader.vertex;
  var program = context.getProgram(fragmentShader, vertexShader);
  var locations;
  if (!this.defaultLocations_) {
    locations = new ol.render.webgl.circlereplay.defaultshader.Locations(gl, program);
    this.defaultLocations_ = locations;
  } else {
    locations = this.defaultLocations_;
  }
  context.useProgram(program);
  gl.enableVertexAttribArray(locations.a_position);
  gl.vertexAttribPointer(locations.a_position, 2, ol.webgl.FLOAT, false, 16, 0);
  gl.enableVertexAttribArray(locations.a_instruction);
  gl.vertexAttribPointer(locations.a_instruction, 1, ol.webgl.FLOAT, false, 16, 8);
  gl.enableVertexAttribArray(locations.a_radius);
  gl.vertexAttribPointer(locations.a_radius, 1, ol.webgl.FLOAT, false, 16, 12);
  gl.uniform2fv(locations.u_size, size);
  gl.uniform1f(locations.u_pixelRatio, pixelRatio);
  return locations;
};
ol.render.webgl.CircleReplay.prototype.shutDownProgram = function(gl, locations) {
  gl.disableVertexAttribArray(locations.a_position);
  gl.disableVertexAttribArray(locations.a_instruction);
  gl.disableVertexAttribArray(locations.a_radius);
};
ol.render.webgl.CircleReplay.prototype.drawReplay = function(gl, context, skippedFeaturesHash, hitDetection) {
  if (!ol.obj.isEmpty(skippedFeaturesHash)) {
    this.drawReplaySkipping_(gl, context, skippedFeaturesHash);
  } else {
    var i, start, end, nextStyle;
    end = this.startIndices[this.startIndices.length - 1];
    for (i = this.styleIndices_.length - 1; i >= 0; --i) {
      start = this.styleIndices_[i];
      nextStyle = this.styles_[i];
      this.setFillStyle_(gl, nextStyle[0]);
      this.setStrokeStyle_(gl, nextStyle[1], nextStyle[2]);
      this.drawElements(gl, context, start, end);
      end = start;
    }
  }
};
ol.render.webgl.CircleReplay.prototype.drawHitDetectionReplayOneByOne = function(gl, context, skippedFeaturesHash, featureCallback, opt_hitExtent) {
  var i, start, end, nextStyle, groupStart, feature, featureUid, featureIndex;
  featureIndex = this.startIndices.length - 2;
  end = this.startIndices[featureIndex + 1];
  for (i = this.styleIndices_.length - 1; i >= 0; --i) {
    nextStyle = this.styles_[i];
    this.setFillStyle_(gl, nextStyle[0]);
    this.setStrokeStyle_(gl, nextStyle[1], nextStyle[2]);
    groupStart = this.styleIndices_[i];
    while (featureIndex >= 0 && this.startIndices[featureIndex] >= groupStart) {
      start = this.startIndices[featureIndex];
      feature = this.startIndicesFeature[featureIndex];
      featureUid = ol.getUid(feature).toString();
      if (skippedFeaturesHash[featureUid] === undefined && feature.getGeometry() && (opt_hitExtent === undefined || ol.extent.intersects(opt_hitExtent, feature.getGeometry().getExtent()))) {
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        this.drawElements(gl, context, start, end);
        var result = featureCallback(feature);
        if (result) {
          return result;
        }
      }
      featureIndex--;
      end = start;
    }
  }
  return undefined;
};
ol.render.webgl.CircleReplay.prototype.drawReplaySkipping_ = function(gl, context, skippedFeaturesHash) {
  var i, start, end, nextStyle, groupStart, feature, featureUid, featureIndex, featureStart;
  featureIndex = this.startIndices.length - 2;
  end = start = this.startIndices[featureIndex + 1];
  for (i = this.styleIndices_.length - 1; i >= 0; --i) {
    nextStyle = this.styles_[i];
    this.setFillStyle_(gl, nextStyle[0]);
    this.setStrokeStyle_(gl, nextStyle[1], nextStyle[2]);
    groupStart = this.styleIndices_[i];
    while (featureIndex >= 0 && this.startIndices[featureIndex] >= groupStart) {
      featureStart = this.startIndices[featureIndex];
      feature = this.startIndicesFeature[featureIndex];
      featureUid = ol.getUid(feature).toString();
      if (skippedFeaturesHash[featureUid]) {
        if (start !== end) {
          this.drawElements(gl, context, start, end);
        }
        end = featureStart;
      }
      featureIndex--;
      start = featureStart;
    }
    if (start !== end) {
      this.drawElements(gl, context, start, end);
    }
    start = end = groupStart;
  }
};
ol.render.webgl.CircleReplay.prototype.setFillStyle_ = function(gl, color) {
  gl.uniform4fv(this.defaultLocations_.u_fillColor, color);
};
ol.render.webgl.CircleReplay.prototype.setStrokeStyle_ = function(gl, color, lineWidth) {
  gl.uniform4fv(this.defaultLocations_.u_strokeColor, color);
  gl.uniform1f(this.defaultLocations_.u_lineWidth, lineWidth);
};
ol.render.webgl.CircleReplay.prototype.setFillStrokeStyle = function(fillStyle, strokeStyle) {
  var strokeStyleColor, strokeStyleWidth;
  if (strokeStyle) {
    var strokeStyleLineDash = strokeStyle.getLineDash();
    this.state_.lineDash = strokeStyleLineDash ? strokeStyleLineDash : ol.render.webgl.defaultLineDash;
    var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
    this.state_.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : ol.render.webgl.defaultLineDashOffset;
    strokeStyleColor = strokeStyle.getColor();
    if (!(strokeStyleColor instanceof CanvasGradient) && !(strokeStyleColor instanceof CanvasPattern)) {
      strokeStyleColor = ol.color.asArray(strokeStyleColor).map(function(c, i) {
        return i != 3 ? c / 255 : c;
      }) || ol.render.webgl.defaultStrokeStyle;
    } else {
      strokeStyleColor = ol.render.webgl.defaultStrokeStyle;
    }
    strokeStyleWidth = strokeStyle.getWidth();
    strokeStyleWidth = strokeStyleWidth !== undefined ? strokeStyleWidth : ol.render.webgl.defaultLineWidth;
  } else {
    strokeStyleColor = [0, 0, 0, 0];
    strokeStyleWidth = 0;
  }
  var fillStyleColor = fillStyle ? fillStyle.getColor() : [0, 0, 0, 0];
  if (!(fillStyleColor instanceof CanvasGradient) && !(fillStyleColor instanceof CanvasPattern)) {
    fillStyleColor = ol.color.asArray(fillStyleColor).map(function(c, i) {
      return i != 3 ? c / 255 : c;
    }) || ol.render.webgl.defaultFillStyle;
  } else {
    fillStyleColor = ol.render.webgl.defaultFillStyle;
  }
  if (!this.state_.strokeColor || !ol.array.equals(this.state_.strokeColor, strokeStyleColor) || !this.state_.fillColor || !ol.array.equals(this.state_.fillColor, fillStyleColor) || this.state_.lineWidth !== strokeStyleWidth) {
    this.state_.changed = true;
    this.state_.fillColor = fillStyleColor;
    this.state_.strokeColor = strokeStyleColor;
    this.state_.lineWidth = strokeStyleWidth;
    this.styles_.push([fillStyleColor, strokeStyleColor, strokeStyleWidth]);
  }
};
goog.provide("ol.render.webgl.texturereplay.defaultshader");
goog.require("ol");
goog.require("ol.webgl.Fragment");
goog.require("ol.webgl.Vertex");
ol.render.webgl.texturereplay.defaultshader.fragment = new ol.webgl.Fragment(ol.DEBUG_WEBGL ? "precision mediump float;\nvarying vec2 v_texCoord;\nvarying float v_opacity;\n\nuniform float u_opacity;\nuniform sampler2D u_image;\n\nvoid main(void) {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  gl_FragColor.rgb = texColor.rgb;\n  float alpha = texColor.a * v_opacity * u_opacity;\n  if (alpha == 0.0) {\n    discard;\n  }\n  gl_FragColor.a = alpha;\n}\n" : "precision mediump float;varying vec2 a;varying float b;uniform float k;uniform sampler2D l;void main(void){vec4 texColor=texture2D(l,a);gl_FragColor.rgb=texColor.rgb;float alpha=texColor.a*b*k;if(alpha==0.0){discard;}gl_FragColor.a=alpha;}");
ol.render.webgl.texturereplay.defaultshader.vertex = new ol.webgl.Vertex(ol.DEBUG_WEBGL ? "varying vec2 v_texCoord;\nvarying float v_opacity;\n\nattribute vec2 a_position;\nattribute vec2 a_texCoord;\nattribute vec2 a_offsets;\nattribute float a_opacity;\nattribute float a_rotateWithView;\n\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_offsetScaleMatrix;\nuniform mat4 u_offsetRotateMatrix;\n\nvoid main(void) {\n  mat4 offsetMatrix = u_offsetScaleMatrix;\n  if (a_rotateWithView == 1.0) {\n    offsetMatrix = u_offsetScaleMatrix * u_offsetRotateMatrix;\n  }\n  vec4 offsets = offsetMatrix * vec4(a_offsets, 0.0, 0.0);\n  gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\n  v_texCoord = a_texCoord;\n  v_opacity = a_opacity;\n}\n\n\n" : 
"varying vec2 a;varying float b;attribute vec2 c;attribute vec2 d;attribute vec2 e;attribute float f;attribute float g;uniform mat4 h;uniform mat4 i;uniform mat4 j;void main(void){mat4 offsetMatrix=i;if(g==1.0){offsetMatrix=i*j;}vec4 offsets=offsetMatrix*vec4(e,0.0,0.0);gl_Position=h*vec4(c,0.0,1.0)+offsets;a=d;b=f;}");
goog.provide("ol.render.webgl.texturereplay.defaultshader.Locations");
goog.require("ol");
ol.render.webgl.texturereplay.defaultshader.Locations = function(gl, program) {
  this.u_projectionMatrix = gl.getUniformLocation(program, ol.DEBUG_WEBGL ? "u_projectionMatrix" : "h");
  this.u_offsetScaleMatrix = gl.getUniformLocation(program, ol.DEBUG_WEBGL ? "u_offsetScaleMatrix" : "i");
  this.u_offsetRotateMatrix = gl.getUniformLocation(program, ol.DEBUG_WEBGL ? "u_offsetRotateMatrix" : "j");
  this.u_opacity = gl.getUniformLocation(program, ol.DEBUG_WEBGL ? "u_opacity" : "k");
  this.u_image = gl.getUniformLocation(program, ol.DEBUG_WEBGL ? "u_image" : "l");
  this.a_position = gl.getAttribLocation(program, ol.DEBUG_WEBGL ? "a_position" : "c");
  this.a_texCoord = gl.getAttribLocation(program, ol.DEBUG_WEBGL ? "a_texCoord" : "d");
  this.a_offsets = gl.getAttribLocation(program, ol.DEBUG_WEBGL ? "a_offsets" : "e");
  this.a_opacity = gl.getAttribLocation(program, ol.DEBUG_WEBGL ? "a_opacity" : "f");
  this.a_rotateWithView = gl.getAttribLocation(program, ol.DEBUG_WEBGL ? "a_rotateWithView" : "g");
};
goog.provide("ol.webgl.ContextEventType");
ol.webgl.ContextEventType = {LOST:"webglcontextlost", RESTORED:"webglcontextrestored"};
goog.provide("ol.webgl.Context");
goog.require("ol");
goog.require("ol.Disposable");
goog.require("ol.array");
goog.require("ol.events");
goog.require("ol.obj");
goog.require("ol.webgl");
goog.require("ol.webgl.ContextEventType");
ol.webgl.Context = function(canvas, gl) {
  this.canvas_ = canvas;
  this.gl_ = gl;
  this.bufferCache_ = {};
  this.shaderCache_ = {};
  this.programCache_ = {};
  this.currentProgram_ = null;
  this.hitDetectionFramebuffer_ = null;
  this.hitDetectionTexture_ = null;
  this.hitDetectionRenderbuffer_ = null;
  this.hasOESElementIndexUint = ol.array.includes(ol.WEBGL_EXTENSIONS, "OES_element_index_uint");
  if (this.hasOESElementIndexUint) {
    gl.getExtension("OES_element_index_uint");
  }
  ol.events.listen(this.canvas_, ol.webgl.ContextEventType.LOST, this.handleWebGLContextLost, this);
  ol.events.listen(this.canvas_, ol.webgl.ContextEventType.RESTORED, this.handleWebGLContextRestored, this);
};
ol.inherits(ol.webgl.Context, ol.Disposable);
ol.webgl.Context.prototype.bindBuffer = function(target, buf) {
  var gl = this.getGL();
  var arr = buf.getArray();
  var bufferKey = String(ol.getUid(buf));
  if (bufferKey in this.bufferCache_) {
    var bufferCacheEntry = this.bufferCache_[bufferKey];
    gl.bindBuffer(target, bufferCacheEntry.buffer);
  } else {
    var buffer = gl.createBuffer();
    gl.bindBuffer(target, buffer);
    var arrayBuffer;
    if (target == ol.webgl.ARRAY_BUFFER) {
      arrayBuffer = new Float32Array(arr);
    } else {
      if (target == ol.webgl.ELEMENT_ARRAY_BUFFER) {
        arrayBuffer = this.hasOESElementIndexUint ? new Uint32Array(arr) : new Uint16Array(arr);
      }
    }
    gl.bufferData(target, arrayBuffer, buf.getUsage());
    this.bufferCache_[bufferKey] = {buf:buf, buffer:buffer};
  }
};
ol.webgl.Context.prototype.deleteBuffer = function(buf) {
  var gl = this.getGL();
  var bufferKey = String(ol.getUid(buf));
  var bufferCacheEntry = this.bufferCache_[bufferKey];
  if (!gl.isContextLost()) {
    gl.deleteBuffer(bufferCacheEntry.buffer);
  }
  delete this.bufferCache_[bufferKey];
};
ol.webgl.Context.prototype.disposeInternal = function() {
  ol.events.unlistenAll(this.canvas_);
  var gl = this.getGL();
  if (!gl.isContextLost()) {
    var key;
    for (key in this.bufferCache_) {
      gl.deleteBuffer(this.bufferCache_[key].buffer);
    }
    for (key in this.programCache_) {
      gl.deleteProgram(this.programCache_[key]);
    }
    for (key in this.shaderCache_) {
      gl.deleteShader(this.shaderCache_[key]);
    }
    gl.deleteFramebuffer(this.hitDetectionFramebuffer_);
    gl.deleteRenderbuffer(this.hitDetectionRenderbuffer_);
    gl.deleteTexture(this.hitDetectionTexture_);
  }
};
ol.webgl.Context.prototype.getCanvas = function() {
  return this.canvas_;
};
ol.webgl.Context.prototype.getGL = function() {
  return this.gl_;
};
ol.webgl.Context.prototype.getHitDetectionFramebuffer = function() {
  if (!this.hitDetectionFramebuffer_) {
    this.initHitDetectionFramebuffer_();
  }
  return this.hitDetectionFramebuffer_;
};
ol.webgl.Context.prototype.getShader = function(shaderObject) {
  var shaderKey = String(ol.getUid(shaderObject));
  if (shaderKey in this.shaderCache_) {
    return this.shaderCache_[shaderKey];
  } else {
    var gl = this.getGL();
    var shader = gl.createShader(shaderObject.getType());
    gl.shaderSource(shader, shaderObject.getSource());
    gl.compileShader(shader);
    this.shaderCache_[shaderKey] = shader;
    return shader;
  }
};
ol.webgl.Context.prototype.getProgram = function(fragmentShaderObject, vertexShaderObject) {
  var programKey = ol.getUid(fragmentShaderObject) + "/" + ol.getUid(vertexShaderObject);
  if (programKey in this.programCache_) {
    return this.programCache_[programKey];
  } else {
    var gl = this.getGL();
    var program = gl.createProgram();
    gl.attachShader(program, this.getShader(fragmentShaderObject));
    gl.attachShader(program, this.getShader(vertexShaderObject));
    gl.linkProgram(program);
    this.programCache_[programKey] = program;
    return program;
  }
};
ol.webgl.Context.prototype.handleWebGLContextLost = function() {
  ol.obj.clear(this.bufferCache_);
  ol.obj.clear(this.shaderCache_);
  ol.obj.clear(this.programCache_);
  this.currentProgram_ = null;
  this.hitDetectionFramebuffer_ = null;
  this.hitDetectionTexture_ = null;
  this.hitDetectionRenderbuffer_ = null;
};
ol.webgl.Context.prototype.handleWebGLContextRestored = function() {
};
ol.webgl.Context.prototype.initHitDetectionFramebuffer_ = function() {
  var gl = this.gl_;
  var framebuffer = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
  var texture = ol.webgl.Context.createEmptyTexture(gl, 1, 1);
  var renderbuffer = gl.createRenderbuffer();
  gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
  gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, 1, 1);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
  gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);
  gl.bindTexture(gl.TEXTURE_2D, null);
  gl.bindRenderbuffer(gl.RENDERBUFFER, null);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  this.hitDetectionFramebuffer_ = framebuffer;
  this.hitDetectionTexture_ = texture;
  this.hitDetectionRenderbuffer_ = renderbuffer;
};
ol.webgl.Context.prototype.useProgram = function(program) {
  if (program == this.currentProgram_) {
    return false;
  } else {
    var gl = this.getGL();
    gl.useProgram(program);
    this.currentProgram_ = program;
    return true;
  }
};
ol.webgl.Context.createTexture_ = function(gl, opt_wrapS, opt_wrapT) {
  var texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  if (opt_wrapS !== undefined) {
    gl.texParameteri(ol.webgl.TEXTURE_2D, ol.webgl.TEXTURE_WRAP_S, opt_wrapS);
  }
  if (opt_wrapT !== undefined) {
    gl.texParameteri(ol.webgl.TEXTURE_2D, ol.webgl.TEXTURE_WRAP_T, opt_wrapT);
  }
  return texture;
};
ol.webgl.Context.createEmptyTexture = function(gl, width, height, opt_wrapS, opt_wrapT) {
  var texture = ol.webgl.Context.createTexture_(gl, opt_wrapS, opt_wrapT);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
  return texture;
};
ol.webgl.Context.createTexture = function(gl, image, opt_wrapS, opt_wrapT) {
  var texture = ol.webgl.Context.createTexture_(gl, opt_wrapS, opt_wrapT);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
  return texture;
};
goog.provide("ol.render.webgl.TextureReplay");
goog.require("ol");
goog.require("ol.extent");
goog.require("ol.obj");
goog.require("ol.render.webgl.texturereplay.defaultshader");
goog.require("ol.render.webgl.texturereplay.defaultshader.Locations");
goog.require("ol.render.webgl.Replay");
goog.require("ol.webgl");
goog.require("ol.webgl.Context");
ol.render.webgl.TextureReplay = function(tolerance, maxExtent) {
  ol.render.webgl.Replay.call(this, tolerance, maxExtent);
  this.anchorX = undefined;
  this.anchorY = undefined;
  this.groupIndices = [];
  this.hitDetectionGroupIndices = [];
  this.height = undefined;
  this.imageHeight = undefined;
  this.imageWidth = undefined;
  this.defaultLocations = null;
  this.opacity = undefined;
  this.originX = undefined;
  this.originY = undefined;
  this.rotateWithView = undefined;
  this.rotation = undefined;
  this.scale = undefined;
  this.width = undefined;
};
ol.inherits(ol.render.webgl.TextureReplay, ol.render.webgl.Replay);
ol.render.webgl.TextureReplay.prototype.getDeleteResourcesFunction = function(context) {
  var verticesBuffer = this.verticesBuffer;
  var indicesBuffer = this.indicesBuffer;
  var textures = this.getTextures(true);
  var gl = context.getGL();
  return function() {
    if (!gl.isContextLost()) {
      var i, ii;
      for (i = 0, ii = textures.length; i < ii; ++i) {
        gl.deleteTexture(textures[i]);
      }
    }
    context.deleteBuffer(verticesBuffer);
    context.deleteBuffer(indicesBuffer);
  };
};
ol.render.webgl.TextureReplay.prototype.drawCoordinates = function(flatCoordinates, offset, end, stride) {
  var anchorX = this.anchorX;
  var anchorY = this.anchorY;
  var height = this.height;
  var imageHeight = this.imageHeight;
  var imageWidth = this.imageWidth;
  var opacity = this.opacity;
  var originX = this.originX;
  var originY = this.originY;
  var rotateWithView = this.rotateWithView ? 1.0 : 0.0;
  var rotation = -this.rotation;
  var scale = this.scale;
  var width = this.width;
  var cos = Math.cos(rotation);
  var sin = Math.sin(rotation);
  var numIndices = this.indices.length;
  var numVertices = this.vertices.length;
  var i, n, offsetX, offsetY, x, y;
  for (i = offset; i < end; i += stride) {
    x = flatCoordinates[i] - this.origin[0];
    y = flatCoordinates[i + 1] - this.origin[1];
    n = numVertices / 8;
    offsetX = -scale * anchorX;
    offsetY = -scale * (height - anchorY);
    this.vertices[numVertices++] = x;
    this.vertices[numVertices++] = y;
    this.vertices[numVertices++] = offsetX * cos - offsetY * sin;
    this.vertices[numVertices++] = offsetX * sin + offsetY * cos;
    this.vertices[numVertices++] = originX / imageWidth;
    this.vertices[numVertices++] = (originY + height) / imageHeight;
    this.vertices[numVertices++] = opacity;
    this.vertices[numVertices++] = rotateWithView;
    offsetX = scale * (width - anchorX);
    offsetY = -scale * (height - anchorY);
    this.vertices[numVertices++] = x;
    this.vertices[numVertices++] = y;
    this.vertices[numVertices++] = offsetX * cos - offsetY * sin;
    this.vertices[numVertices++] = offsetX * sin + offsetY * cos;
    this.vertices[numVertices++] = (originX + width) / imageWidth;
    this.vertices[numVertices++] = (originY + height) / imageHeight;
    this.vertices[numVertices++] = opacity;
    this.vertices[numVertices++] = rotateWithView;
    offsetX = scale * (width - anchorX);
    offsetY = scale * anchorY;
    this.vertices[numVertices++] = x;
    this.vertices[numVertices++] = y;
    this.vertices[numVertices++] = offsetX * cos - offsetY * sin;
    this.vertices[numVertices++] = offsetX * sin + offsetY * cos;
    this.vertices[numVertices++] = (originX + width) / imageWidth;
    this.vertices[numVertices++] = originY / imageHeight;
    this.vertices[numVertices++] = opacity;
    this.vertices[numVertices++] = rotateWithView;
    offsetX = -scale * anchorX;
    offsetY = scale * anchorY;
    this.vertices[numVertices++] = x;
    this.vertices[numVertices++] = y;
    this.vertices[numVertices++] = offsetX * cos - offsetY * sin;
    this.vertices[numVertices++] = offsetX * sin + offsetY * cos;
    this.vertices[numVertices++] = originX / imageWidth;
    this.vertices[numVertices++] = originY / imageHeight;
    this.vertices[numVertices++] = opacity;
    this.vertices[numVertices++] = rotateWithView;
    this.indices[numIndices++] = n;
    this.indices[numIndices++] = n + 1;
    this.indices[numIndices++] = n + 2;
    this.indices[numIndices++] = n;
    this.indices[numIndices++] = n + 2;
    this.indices[numIndices++] = n + 3;
  }
  return numVertices;
};
ol.render.webgl.TextureReplay.prototype.createTextures = function(textures, images, texturePerImage, gl) {
  var texture, image, uid, i;
  var ii = images.length;
  for (i = 0; i < ii; ++i) {
    image = images[i];
    uid = ol.getUid(image).toString();
    if (uid in texturePerImage) {
      texture = texturePerImage[uid];
    } else {
      texture = ol.webgl.Context.createTexture(gl, image, ol.webgl.CLAMP_TO_EDGE, ol.webgl.CLAMP_TO_EDGE);
      texturePerImage[uid] = texture;
    }
    textures[i] = texture;
  }
};
ol.render.webgl.TextureReplay.prototype.setUpProgram = function(gl, context, size, pixelRatio) {
  var fragmentShader = ol.render.webgl.texturereplay.defaultshader.fragment;
  var vertexShader = ol.render.webgl.texturereplay.defaultshader.vertex;
  var program = context.getProgram(fragmentShader, vertexShader);
  var locations;
  if (!this.defaultLocations) {
    locations = new ol.render.webgl.texturereplay.defaultshader.Locations(gl, program);
    this.defaultLocations = locations;
  } else {
    locations = this.defaultLocations;
  }
  context.useProgram(program);
  gl.enableVertexAttribArray(locations.a_position);
  gl.vertexAttribPointer(locations.a_position, 2, ol.webgl.FLOAT, false, 32, 0);
  gl.enableVertexAttribArray(locations.a_offsets);
  gl.vertexAttribPointer(locations.a_offsets, 2, ol.webgl.FLOAT, false, 32, 8);
  gl.enableVertexAttribArray(locations.a_texCoord);
  gl.vertexAttribPointer(locations.a_texCoord, 2, ol.webgl.FLOAT, false, 32, 16);
  gl.enableVertexAttribArray(locations.a_opacity);
  gl.vertexAttribPointer(locations.a_opacity, 1, ol.webgl.FLOAT, false, 32, 24);
  gl.enableVertexAttribArray(locations.a_rotateWithView);
  gl.vertexAttribPointer(locations.a_rotateWithView, 1, ol.webgl.FLOAT, false, 32, 28);
  return locations;
};
ol.render.webgl.TextureReplay.prototype.shutDownProgram = function(gl, locations) {
  gl.disableVertexAttribArray(locations.a_position);
  gl.disableVertexAttribArray(locations.a_offsets);
  gl.disableVertexAttribArray(locations.a_texCoord);
  gl.disableVertexAttribArray(locations.a_opacity);
  gl.disableVertexAttribArray(locations.a_rotateWithView);
};
ol.render.webgl.TextureReplay.prototype.drawReplay = function(gl, context, skippedFeaturesHash, hitDetection) {
  var textures = hitDetection ? this.getHitDetectionTextures() : this.getTextures();
  var groupIndices = hitDetection ? this.hitDetectionGroupIndices : this.groupIndices;
  if (!ol.obj.isEmpty(skippedFeaturesHash)) {
    this.drawReplaySkipping(gl, context, skippedFeaturesHash, textures, groupIndices);
  } else {
    var i, ii, start;
    for (i = 0, ii = textures.length, start = 0; i < ii; ++i) {
      gl.bindTexture(ol.webgl.TEXTURE_2D, textures[i]);
      var end = groupIndices[i];
      this.drawElements(gl, context, start, end);
      start = end;
    }
  }
};
ol.render.webgl.TextureReplay.prototype.drawReplaySkipping = function(gl, context, skippedFeaturesHash, textures, groupIndices) {
  var featureIndex = 0;
  var i, ii;
  for (i = 0, ii = textures.length; i < ii; ++i) {
    gl.bindTexture(ol.webgl.TEXTURE_2D, textures[i]);
    var groupStart = i > 0 ? groupIndices[i - 1] : 0;
    var groupEnd = groupIndices[i];
    var start = groupStart;
    var end = groupStart;
    while (featureIndex < this.startIndices.length && this.startIndices[featureIndex] <= groupEnd) {
      var feature = this.startIndicesFeature[featureIndex];
      var featureUid = ol.getUid(feature).toString();
      if (skippedFeaturesHash[featureUid] !== undefined) {
        if (start !== end) {
          this.drawElements(gl, context, start, end);
        }
        start = featureIndex === this.startIndices.length - 1 ? groupEnd : this.startIndices[featureIndex + 1];
        end = start;
      } else {
        end = featureIndex === this.startIndices.length - 1 ? groupEnd : this.startIndices[featureIndex + 1];
      }
      featureIndex++;
    }
    if (start !== end) {
      this.drawElements(gl, context, start, end);
    }
  }
};
ol.render.webgl.TextureReplay.prototype.drawHitDetectionReplayOneByOne = function(gl, context, skippedFeaturesHash, featureCallback, opt_hitExtent) {
  var i, groupStart, start, end, feature, featureUid;
  var featureIndex = this.startIndices.length - 1;
  var hitDetectionTextures = this.getHitDetectionTextures();
  for (i = hitDetectionTextures.length - 1; i >= 0; --i) {
    gl.bindTexture(ol.webgl.TEXTURE_2D, hitDetectionTextures[i]);
    groupStart = i > 0 ? this.hitDetectionGroupIndices[i - 1] : 0;
    end = this.hitDetectionGroupIndices[i];
    while (featureIndex >= 0 && this.startIndices[featureIndex] >= groupStart) {
      start = this.startIndices[featureIndex];
      feature = this.startIndicesFeature[featureIndex];
      featureUid = ol.getUid(feature).toString();
      if (skippedFeaturesHash[featureUid] === undefined && feature.getGeometry() && (opt_hitExtent === undefined || ol.extent.intersects(opt_hitExtent, feature.getGeometry().getExtent()))) {
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        this.drawElements(gl, context, start, end);
        var result = featureCallback(feature);
        if (result) {
          return result;
        }
      }
      end = start;
      featureIndex--;
    }
  }
  return undefined;
};
ol.render.webgl.TextureReplay.prototype.finish = function(context) {
  this.anchorX = undefined;
  this.anchorY = undefined;
  this.height = undefined;
  this.imageHeight = undefined;
  this.imageWidth = undefined;
  this.indices = null;
  this.opacity = undefined;
  this.originX = undefined;
  this.originY = undefined;
  this.rotateWithView = undefined;
  this.rotation = undefined;
  this.scale = undefined;
  this.vertices = null;
  this.width = undefined;
};
ol.render.webgl.TextureReplay.prototype.getTextures = function(opt_all) {
};
ol.render.webgl.TextureReplay.prototype.getHitDetectionTextures = function() {
};
goog.provide("ol.render.webgl.ImageReplay");
goog.require("ol");
goog.require("ol.render.webgl.TextureReplay");
goog.require("ol.webgl.Buffer");
ol.render.webgl.ImageReplay = function(tolerance, maxExtent) {
  ol.render.webgl.TextureReplay.call(this, tolerance, maxExtent);
  this.images_ = [];
  this.hitDetectionImages_ = [];
  this.textures_ = [];
  this.hitDetectionTextures_ = [];
};
ol.inherits(ol.render.webgl.ImageReplay, ol.render.webgl.TextureReplay);
ol.render.webgl.ImageReplay.prototype.drawMultiPoint = function(multiPointGeometry, feature) {
  this.startIndices.push(this.indices.length);
  this.startIndicesFeature.push(feature);
  var flatCoordinates = multiPointGeometry.getFlatCoordinates();
  var stride = multiPointGeometry.getStride();
  this.drawCoordinates(flatCoordinates, 0, flatCoordinates.length, stride);
};
ol.render.webgl.ImageReplay.prototype.drawPoint = function(pointGeometry, feature) {
  this.startIndices.push(this.indices.length);
  this.startIndicesFeature.push(feature);
  var flatCoordinates = pointGeometry.getFlatCoordinates();
  var stride = pointGeometry.getStride();
  this.drawCoordinates(flatCoordinates, 0, flatCoordinates.length, stride);
};
ol.render.webgl.ImageReplay.prototype.finish = function(context) {
  var gl = context.getGL();
  this.groupIndices.push(this.indices.length);
  this.hitDetectionGroupIndices.push(this.indices.length);
  this.verticesBuffer = new ol.webgl.Buffer(this.vertices);
  var indices = this.indices;
  this.indicesBuffer = new ol.webgl.Buffer(indices);
  var texturePerImage = {};
  this.createTextures(this.textures_, this.images_, texturePerImage, gl);
  this.createTextures(this.hitDetectionTextures_, this.hitDetectionImages_, texturePerImage, gl);
  this.images_ = null;
  this.hitDetectionImages_ = null;
  ol.render.webgl.TextureReplay.prototype.finish.call(this, context);
};
ol.render.webgl.ImageReplay.prototype.setImageStyle = function(imageStyle) {
  var anchor = imageStyle.getAnchor();
  var image = imageStyle.getImage(1);
  var imageSize = imageStyle.getImageSize();
  var hitDetectionImage = imageStyle.getHitDetectionImage(1);
  var opacity = imageStyle.getOpacity();
  var origin = imageStyle.getOrigin();
  var rotateWithView = imageStyle.getRotateWithView();
  var rotation = imageStyle.getRotation();
  var size = imageStyle.getSize();
  var scale = imageStyle.getScale();
  var currentImage;
  if (this.images_.length === 0) {
    this.images_.push(image);
  } else {
    currentImage = this.images_[this.images_.length - 1];
    if (ol.getUid(currentImage) != ol.getUid(image)) {
      this.groupIndices.push(this.indices.length);
      this.images_.push(image);
    }
  }
  if (this.hitDetectionImages_.length === 0) {
    this.hitDetectionImages_.push(hitDetectionImage);
  } else {
    currentImage = this.hitDetectionImages_[this.hitDetectionImages_.length - 1];
    if (ol.getUid(currentImage) != ol.getUid(hitDetectionImage)) {
      this.hitDetectionGroupIndices.push(this.indices.length);
      this.hitDetectionImages_.push(hitDetectionImage);
    }
  }
  this.anchorX = anchor[0];
  this.anchorY = anchor[1];
  this.height = size[1];
  this.imageHeight = imageSize[1];
  this.imageWidth = imageSize[0];
  this.opacity = opacity;
  this.originX = origin[0];
  this.originY = origin[1];
  this.rotation = rotation;
  this.rotateWithView = rotateWithView;
  this.scale = scale;
  this.width = size[0];
};
ol.render.webgl.ImageReplay.prototype.getTextures = function(opt_all) {
  return opt_all ? this.textures_.concat(this.hitDetectionTextures_) : this.textures_;
};
ol.render.webgl.ImageReplay.prototype.getHitDetectionTextures = function() {
  return this.hitDetectionTextures_;
};
goog.provide("ol.render.webgl.linestringreplay.defaultshader");
goog.require("ol");
goog.require("ol.webgl.Fragment");
goog.require("ol.webgl.Vertex");
ol.render.webgl.linestringreplay.defaultshader.fragment = new ol.webgl.Fragment(ol.DEBUG_WEBGL ? "precision mediump float;\nvarying float v_round;\nvarying vec2 v_roundVertex;\nvarying float v_halfWidth;\n\n\n\nuniform float u_opacity;\nuniform vec4 u_color;\nuniform vec2 u_size;\nuniform float u_pixelRatio;\n\nvoid main(void) {\n  if (v_round > 0.0) {\n    vec2 windowCoords = vec2((v_roundVertex.x + 1.0) / 2.0 * u_size.x * u_pixelRatio,\n        (v_roundVertex.y + 1.0) / 2.0 * u_size.y * u_pixelRatio);\n    if (length(windowCoords - gl_FragCoord.xy) > v_halfWidth * u_pixelRatio) {\n      discard;\n    }\n  }\n  gl_FragColor = u_color;\n  float alpha = u_color.a * u_opacity;\n  if (alpha == 0.0) {\n    discard;\n  }\n  gl_FragColor.a = alpha;\n}\n" : 
"precision mediump float;varying float a;varying vec2 aVertex;varying float c;uniform float m;uniform vec4 n;uniform vec2 o;uniform float p;void main(void){if(a>0.0){vec2 windowCoords=vec2((aVertex.x+1.0)/2.0*o.x*p,(aVertex.y+1.0)/2.0*o.y*p);if(length(windowCoords-gl_FragCoord.xy)>c*p){discard;}} gl_FragColor=n;float alpha=n.a*m;if(alpha==0.0){discard;}gl_FragColor.a=alpha;}");
ol.render.webgl.linestringreplay.defaultshader.vertex = new ol.webgl.Vertex(ol.DEBUG_WEBGL ? "varying float v_round;\nvarying vec2 v_roundVertex;\nvarying float v_halfWidth;\n\n\nattribute vec2 a_lastPos;\nattribute vec2 a_position;\nattribute vec2 a_nextPos;\nattribute float a_direction;\n\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_offsetScaleMatrix;\nuniform mat4 u_offsetRotateMatrix;\nuniform float u_lineWidth;\nuniform float u_miterLimit;\n\nbool nearlyEquals(in float value, in float ref) {\n  float epsilon = 0.000000000001;\n  return value >= ref - epsilon && value <= ref + epsilon;\n}\n\nvoid alongNormal(out vec2 offset, in vec2 nextP, in float turnDir, in float direction) {\n  vec2 dirVect = nextP - a_position;\n  vec2 normal = normalize(vec2(-turnDir * dirVect.y, turnDir * dirVect.x));\n  offset = u_lineWidth / 2.0 * normal * direction;\n}\n\nvoid miterUp(out vec2 offset, out float round, in bool isRound, in float direction) {\n  float halfWidth = u_lineWidth / 2.0;\n  vec2 tangent = normalize(normalize(a_nextPos - a_position) + normalize(a_position - a_lastPos));\n  vec2 normal = vec2(-tangent.y, tangent.x);\n  vec2 dirVect = a_nextPos - a_position;\n  vec2 tmpNormal = normalize(vec2(-dirVect.y, dirVect.x));\n  float miterLength = abs(halfWidth / dot(normal, tmpNormal));\n  offset = normal * direction * miterLength;\n  round = 0.0;\n  if (isRound) {\n    round = 1.0;\n  } else if (miterLength > u_miterLimit + u_lineWidth) {\n    offset = halfWidth * tmpNormal * direction;\n  }\n}\n\nbool miterDown(out vec2 offset, in vec4 projPos, in mat4 offsetMatrix, in float direction) {\n  bool degenerate = false;\n  vec2 tangent = normalize(normalize(a_nextPos - a_position) + normalize(a_position - a_lastPos));\n  vec2 normal = vec2(-tangent.y, tangent.x);\n  vec2 dirVect = a_lastPos - a_position;\n  vec2 tmpNormal = normalize(vec2(-dirVect.y, dirVect.x));\n  vec2 longOffset, shortOffset, longVertex;\n  vec4 shortProjVertex;\n  float halfWidth = u_lineWidth / 2.0;\n  if (length(a_nextPos - a_position) > length(a_lastPos - a_position)) {\n    longOffset = tmpNormal * direction * halfWidth;\n    shortOffset = normalize(vec2(dirVect.y, -dirVect.x)) * direction * halfWidth;\n    longVertex = a_nextPos;\n    shortProjVertex = u_projectionMatrix * vec4(a_lastPos, 0.0, 1.0);\n  } else {\n    shortOffset = tmpNormal * direction * halfWidth;\n    longOffset = normalize(vec2(dirVect.y, -dirVect.x)) * direction * halfWidth;\n    longVertex = a_lastPos;\n    shortProjVertex = u_projectionMatrix * vec4(a_nextPos, 0.0, 1.0);\n  }\n  //Intersection algorithm based on theory by Paul Bourke (http://paulbourke.net/geometry/pointlineplane/).\n  vec4 p1 = u_projectionMatrix * vec4(longVertex, 0.0, 1.0) + offsetMatrix * vec4(longOffset, 0.0, 0.0);\n  vec4 p2 = projPos + offsetMatrix * vec4(longOffset, 0.0, 0.0);\n  vec4 p3 = shortProjVertex + offsetMatrix * vec4(-shortOffset, 0.0, 0.0);\n  vec4 p4 = shortProjVertex + offsetMatrix * vec4(shortOffset, 0.0, 0.0);\n  float denom = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);\n  float firstU = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denom;\n  float secondU = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denom;\n  float epsilon = 0.000000000001;\n  if (firstU > epsilon && firstU < 1.0 - epsilon && secondU > epsilon && secondU < 1.0 - epsilon) {\n    shortProjVertex.x = p1.x + firstU * (p2.x - p1.x);\n    shortProjVertex.y = p1.y + firstU * (p2.y - p1.y);\n    offset = shortProjVertex.xy;\n    degenerate = true;\n  } else {\n    float miterLength = abs(halfWidth / dot(normal, tmpNormal));\n    offset = normal * direction * miterLength;\n  }\n  return degenerate;\n}\n\nvoid squareCap(out vec2 offset, out float round, in bool isRound, in vec2 nextP,\n    in float turnDir, in float direction) {\n  round = 0.0;\n  vec2 dirVect = a_position - nextP;\n  vec2 firstNormal = normalize(dirVect);\n  vec2 secondNormal = vec2(turnDir * firstNormal.y * direction, -turnDir * firstNormal.x * direction);\n  vec2 hypotenuse = normalize(firstNormal - secondNormal);\n  vec2 normal = vec2(turnDir * hypotenuse.y * direction, -turnDir * hypotenuse.x * direction);\n  float length = sqrt(v_halfWidth * v_halfWidth * 2.0);\n  offset = normal * length;\n  if (isRound) {\n    round = 1.0;\n  }\n}\n\nvoid main(void) {\n  bool degenerate = false;\n  float direction = float(sign(a_direction));\n  mat4 offsetMatrix = u_offsetScaleMatrix * u_offsetRotateMatrix;\n  vec2 offset;\n  vec4 projPos = u_projectionMatrix * vec4(a_position, 0.0, 1.0);\n  bool round = nearlyEquals(mod(a_direction, 2.0), 0.0);\n\n  v_round = 0.0;\n  v_halfWidth = u_lineWidth / 2.0;\n  v_roundVertex = projPos.xy;\n\n  if (nearlyEquals(mod(a_direction, 3.0), 0.0) || nearlyEquals(mod(a_direction, 17.0), 0.0)) {\n    alongNormal(offset, a_nextPos, 1.0, direction);\n  } else if (nearlyEquals(mod(a_direction, 5.0), 0.0) || nearlyEquals(mod(a_direction, 13.0), 0.0)) {\n    alongNormal(offset, a_lastPos, -1.0, direction);\n  } else if (nearlyEquals(mod(a_direction, 23.0), 0.0)) {\n    miterUp(offset, v_round, round, direction);\n  } else if (nearlyEquals(mod(a_direction, 19.0), 0.0)) {\n    degenerate = miterDown(offset, projPos, offsetMatrix, direction);\n  } else if (nearlyEquals(mod(a_direction, 7.0), 0.0)) {\n    squareCap(offset, v_round, round, a_nextPos, 1.0, direction);\n  } else if (nearlyEquals(mod(a_direction, 11.0), 0.0)) {\n    squareCap(offset, v_round, round, a_lastPos, -1.0, direction);\n  }\n  if (!degenerate) {\n    vec4 offsets = offsetMatrix * vec4(offset, 0.0, 0.0);\n    gl_Position = projPos + offsets;\n  } else {\n    gl_Position = vec4(offset, 0.0, 1.0);\n  }\n}\n\n\n" : 
"varying float a;varying vec2 aVertex;varying float c;attribute vec2 d;attribute vec2 e;attribute vec2 f;attribute float g;uniform mat4 h;uniform mat4 i;uniform mat4 j;uniform float k;uniform float l;bool nearlyEquals(in float value,in float ref){float epsilon=0.000000000001;return value>=ref-epsilon&&value<=ref+epsilon;}void alongNormal(out vec2 offset,in vec2 nextP,in float turnDir,in float direction){vec2 dirVect=nextP-e;vec2 normal=normalize(vec2(-turnDir*dirVect.y,turnDir*dirVect.x));offset=k/2.0*normal*direction;}void miterUp(out vec2 offset,out float round,in bool isRound,in float direction){float halfWidth=k/2.0;vec2 tangent=normalize(normalize(f-e)+normalize(e-d));vec2 normal=vec2(-tangent.y,tangent.x);vec2 dirVect=f-e;vec2 tmpNormal=normalize(vec2(-dirVect.y,dirVect.x));float miterLength=abs(halfWidth/dot(normal,tmpNormal));offset=normal*direction*miterLength;round=0.0;if(isRound){round=1.0;}else if(miterLength>l+k){offset=halfWidth*tmpNormal*direction;}} bool miterDown(out vec2 offset,in vec4 projPos,in mat4 offsetMatrix,in float direction){bool degenerate=false;vec2 tangent=normalize(normalize(f-e)+normalize(e-d));vec2 normal=vec2(-tangent.y,tangent.x);vec2 dirVect=d-e;vec2 tmpNormal=normalize(vec2(-dirVect.y,dirVect.x));vec2 longOffset,shortOffset,longVertex;vec4 shortProjVertex;float halfWidth=k/2.0;if(length(f-e)>length(d-e)){longOffset=tmpNormal*direction*halfWidth;shortOffset=normalize(vec2(dirVect.y,-dirVect.x))*direction*halfWidth;longVertex=f;shortProjVertex=h*vec4(d,0.0,1.0);}else{shortOffset=tmpNormal*direction*halfWidth;longOffset=normalize(vec2(dirVect.y,-dirVect.x))*direction*halfWidth;longVertex=d;shortProjVertex=h*vec4(f,0.0,1.0);}vec4 p1=h*vec4(longVertex,0.0,1.0)+offsetMatrix*vec4(longOffset,0.0,0.0);vec4 p2=projPos+offsetMatrix*vec4(longOffset,0.0,0.0);vec4 p3=shortProjVertex+offsetMatrix*vec4(-shortOffset,0.0,0.0);vec4 p4=shortProjVertex+offsetMatrix*vec4(shortOffset,0.0,0.0);float denom=(p4.y-p3.y)*(p2.x-p1.x)-(p4.x-p3.x)*(p2.y-p1.y);float firstU=((p4.x-p3.x)*(p1.y-p3.y)-(p4.y-p3.y)*(p1.x-p3.x))/denom;float secondU=((p2.x-p1.x)*(p1.y-p3.y)-(p2.y-p1.y)*(p1.x-p3.x))/denom;float epsilon=0.000000000001;if(firstU>epsilon&&firstU<1.0-epsilon&&secondU>epsilon&&secondU<1.0-epsilon){shortProjVertex.x=p1.x+firstU*(p2.x-p1.x);shortProjVertex.y=p1.y+firstU*(p2.y-p1.y);offset=shortProjVertex.xy;degenerate=true;}else{float miterLength=abs(halfWidth/dot(normal,tmpNormal));offset=normal*direction*miterLength;}return degenerate;}void squareCap(out vec2 offset,out float round,in bool isRound,in vec2 nextP,in float turnDir,in float direction){round=0.0;vec2 dirVect=e-nextP;vec2 firstNormal=normalize(dirVect);vec2 secondNormal=vec2(turnDir*firstNormal.y*direction,-turnDir*firstNormal.x*direction);vec2 hypotenuse=normalize(firstNormal-secondNormal);vec2 normal=vec2(turnDir*hypotenuse.y*direction,-turnDir*hypotenuse.x*direction);float length=sqrt(c*c*2.0);offset=normal*length;if(isRound){round=1.0;}} void main(void){bool degenerate=false;float direction=float(sign(g));mat4 offsetMatrix=i*j;vec2 offset;vec4 projPos=h*vec4(e,0.0,1.0);bool round=nearlyEquals(mod(g,2.0),0.0);a=0.0;c=k/2.0;aVertex=projPos.xy;if(nearlyEquals(mod(g,3.0),0.0)||nearlyEquals(mod(g,17.0),0.0)){alongNormal(offset,f,1.0,direction);}else if(nearlyEquals(mod(g,5.0),0.0)||nearlyEquals(mod(g,13.0),0.0)){alongNormal(offset,d,-1.0,direction);}else if(nearlyEquals(mod(g,23.0),0.0)){miterUp(offset,a,round,direction);}else if(nearlyEquals(mod(g,19.0),0.0)){degenerate=miterDown(offset,projPos,offsetMatrix,direction);}else if(nearlyEquals(mod(g,7.0),0.0)){squareCap(offset,a,round,f,1.0,direction);}else if(nearlyEquals(mod(g,11.0),0.0)){squareCap(offset,a,round,d,-1.0,direction);}if(!degenerate){vec4 offsets=offsetMatrix*vec4(offset,0.0,0.0);gl_Position=projPos+offsets;}else{gl_Position=vec4(offset,0.0,1.0);}}");
goog.provide("ol.render.webgl.linestringreplay.defaultshader.Locations");
goog.require("ol");
ol.render.webgl.linestringreplay.defaultshader.Locations = function(gl, program) {
  this.u_projectionMatrix = gl.getUniformLocation(program, ol.DEBUG_WEBGL ? "u_projectionMatrix" : "h");
  this.u_offsetScaleMatrix = gl.getUniformLocation(program, ol.DEBUG_WEBGL ? "u_offsetScaleMatrix" : "i");
  this.u_offsetRotateMatrix = gl.getUniformLocation(program, ol.DEBUG_WEBGL ? "u_offsetRotateMatrix" : "j");
  this.u_lineWidth = gl.getUniformLocation(program, ol.DEBUG_WEBGL ? "u_lineWidth" : "k");
  this.u_miterLimit = gl.getUniformLocation(program, ol.DEBUG_WEBGL ? "u_miterLimit" : "l");
  this.u_opacity = gl.getUniformLocation(program, ol.DEBUG_WEBGL ? "u_opacity" : "m");
  this.u_color = gl.getUniformLocation(program, ol.DEBUG_WEBGL ? "u_color" : "n");
  this.u_size = gl.getUniformLocation(program, ol.DEBUG_WEBGL ? "u_size" : "o");
  this.u_pixelRatio = gl.getUniformLocation(program, ol.DEBUG_WEBGL ? "u_pixelRatio" : "p");
  this.a_lastPos = gl.getAttribLocation(program, ol.DEBUG_WEBGL ? "a_lastPos" : "d");
  this.a_position = gl.getAttribLocation(program, ol.DEBUG_WEBGL ? "a_position" : "e");
  this.a_nextPos = gl.getAttribLocation(program, ol.DEBUG_WEBGL ? "a_nextPos" : "f");
  this.a_direction = gl.getAttribLocation(program, ol.DEBUG_WEBGL ? "a_direction" : "g");
};
goog.provide("ol.render.webgl.LineStringReplay");
goog.require("ol");
goog.require("ol.array");
goog.require("ol.color");
goog.require("ol.extent");
goog.require("ol.geom.flat.orient");
goog.require("ol.geom.flat.transform");
goog.require("ol.geom.flat.topology");
goog.require("ol.obj");
goog.require("ol.render.webgl");
goog.require("ol.render.webgl.Replay");
goog.require("ol.render.webgl.linestringreplay.defaultshader");
goog.require("ol.render.webgl.linestringreplay.defaultshader.Locations");
goog.require("ol.webgl");
goog.require("ol.webgl.Buffer");
ol.render.webgl.LineStringReplay = function(tolerance, maxExtent) {
  ol.render.webgl.Replay.call(this, tolerance, maxExtent);
  this.defaultLocations_ = null;
  this.styles_ = [];
  this.styleIndices_ = [];
  this.state_ = {strokeColor:null, lineCap:undefined, lineDash:null, lineDashOffset:undefined, lineJoin:undefined, lineWidth:undefined, miterLimit:undefined, changed:false};
};
ol.inherits(ol.render.webgl.LineStringReplay, ol.render.webgl.Replay);
ol.render.webgl.LineStringReplay.prototype.drawCoordinates_ = function(flatCoordinates, offset, end, stride) {
  var i, ii;
  var numVertices = this.vertices.length;
  var numIndices = this.indices.length;
  var lineJoin = this.state_.lineJoin === "bevel" ? 0 : this.state_.lineJoin === "miter" ? 1 : 2;
  var lineCap = this.state_.lineCap === "butt" ? 0 : this.state_.lineCap === "square" ? 1 : 2;
  var closed = ol.geom.flat.topology.lineStringIsClosed(flatCoordinates, offset, end, stride);
  var startCoords, sign, n;
  var lastIndex = numIndices;
  var lastSign = 1;
  var p0, p1, p2;
  for (i = offset, ii = end; i < ii; i += stride) {
    n = numVertices / 7;
    p0 = p1;
    p1 = p2 || [flatCoordinates[i], flatCoordinates[i + 1]];
    if (i === offset) {
      p2 = [flatCoordinates[i + stride], flatCoordinates[i + stride + 1]];
      if (end - offset === stride * 2 && ol.array.equals(p1, p2)) {
        break;
      }
      if (closed) {
        p0 = [flatCoordinates[end - stride * 2], flatCoordinates[end - stride * 2 + 1]];
        startCoords = p2;
      } else {
        if (lineCap) {
          numVertices = this.addVertices_([0, 0], p1, p2, lastSign * ol.render.webgl.LineStringReplay.Instruction_.BEGIN_LINE_CAP * lineCap, numVertices);
          numVertices = this.addVertices_([0, 0], p1, p2, -lastSign * ol.render.webgl.LineStringReplay.Instruction_.BEGIN_LINE_CAP * lineCap, numVertices);
          this.indices[numIndices++] = n + 2;
          this.indices[numIndices++] = n;
          this.indices[numIndices++] = n + 1;
          this.indices[numIndices++] = n + 1;
          this.indices[numIndices++] = n + 3;
          this.indices[numIndices++] = n + 2;
        }
        numVertices = this.addVertices_([0, 0], p1, p2, lastSign * ol.render.webgl.LineStringReplay.Instruction_.BEGIN_LINE * (lineCap || 1), numVertices);
        numVertices = this.addVertices_([0, 0], p1, p2, -lastSign * ol.render.webgl.LineStringReplay.Instruction_.BEGIN_LINE * (lineCap || 1), numVertices);
        lastIndex = numVertices / 7 - 1;
        continue;
      }
    } else {
      if (i === end - stride) {
        if (closed) {
          p2 = startCoords;
          break;
        } else {
          p0 = p0 || [0, 0];
          numVertices = this.addVertices_(p0, p1, [0, 0], lastSign * ol.render.webgl.LineStringReplay.Instruction_.END_LINE * (lineCap || 1), numVertices);
          numVertices = this.addVertices_(p0, p1, [0, 0], -lastSign * ol.render.webgl.LineStringReplay.Instruction_.END_LINE * (lineCap || 1), numVertices);
          this.indices[numIndices++] = n;
          this.indices[numIndices++] = lastIndex - 1;
          this.indices[numIndices++] = lastIndex;
          this.indices[numIndices++] = lastIndex;
          this.indices[numIndices++] = n + 1;
          this.indices[numIndices++] = n;
          if (lineCap) {
            numVertices = this.addVertices_(p0, p1, [0, 0], lastSign * ol.render.webgl.LineStringReplay.Instruction_.END_LINE_CAP * lineCap, numVertices);
            numVertices = this.addVertices_(p0, p1, [0, 0], -lastSign * ol.render.webgl.LineStringReplay.Instruction_.END_LINE_CAP * lineCap, numVertices);
            this.indices[numIndices++] = n + 2;
            this.indices[numIndices++] = n;
            this.indices[numIndices++] = n + 1;
            this.indices[numIndices++] = n + 1;
            this.indices[numIndices++] = n + 3;
            this.indices[numIndices++] = n + 2;
          }
          break;
        }
      } else {
        p2 = [flatCoordinates[i + stride], flatCoordinates[i + stride + 1]];
      }
    }
    sign = ol.render.webgl.triangleIsCounterClockwise(p0[0], p0[1], p1[0], p1[1], p2[0], p2[1]) ? -1 : 1;
    numVertices = this.addVertices_(p0, p1, p2, sign * ol.render.webgl.LineStringReplay.Instruction_.BEVEL_FIRST * (lineJoin || 1), numVertices);
    numVertices = this.addVertices_(p0, p1, p2, sign * ol.render.webgl.LineStringReplay.Instruction_.BEVEL_SECOND * (lineJoin || 1), numVertices);
    numVertices = this.addVertices_(p0, p1, p2, -sign * ol.render.webgl.LineStringReplay.Instruction_.MITER_BOTTOM * (lineJoin || 1), numVertices);
    if (i > offset) {
      this.indices[numIndices++] = n;
      this.indices[numIndices++] = lastIndex - 1;
      this.indices[numIndices++] = lastIndex;
      this.indices[numIndices++] = n + 2;
      this.indices[numIndices++] = n;
      this.indices[numIndices++] = lastSign * sign > 0 ? lastIndex : lastIndex - 1;
    }
    this.indices[numIndices++] = n;
    this.indices[numIndices++] = n + 2;
    this.indices[numIndices++] = n + 1;
    lastIndex = n + 2;
    lastSign = sign;
    if (lineJoin) {
      numVertices = this.addVertices_(p0, p1, p2, sign * ol.render.webgl.LineStringReplay.Instruction_.MITER_TOP * lineJoin, numVertices);
      this.indices[numIndices++] = n + 1;
      this.indices[numIndices++] = n + 3;
      this.indices[numIndices++] = n;
    }
  }
  if (closed) {
    n = n || numVertices / 7;
    sign = ol.geom.flat.orient.linearRingIsClockwise([p0[0], p0[1], p1[0], p1[1], p2[0], p2[1]], 0, 6, 2) ? 1 : -1;
    numVertices = this.addVertices_(p0, p1, p2, sign * ol.render.webgl.LineStringReplay.Instruction_.BEVEL_FIRST * (lineJoin || 1), numVertices);
    numVertices = this.addVertices_(p0, p1, p2, -sign * ol.render.webgl.LineStringReplay.Instruction_.MITER_BOTTOM * (lineJoin || 1), numVertices);
    this.indices[numIndices++] = n;
    this.indices[numIndices++] = lastIndex - 1;
    this.indices[numIndices++] = lastIndex;
    this.indices[numIndices++] = n + 1;
    this.indices[numIndices++] = n;
    this.indices[numIndices++] = lastSign * sign > 0 ? lastIndex : lastIndex - 1;
  }
};
ol.render.webgl.LineStringReplay.prototype.addVertices_ = function(p0, p1, p2, product, numVertices) {
  this.vertices[numVertices++] = p0[0];
  this.vertices[numVertices++] = p0[1];
  this.vertices[numVertices++] = p1[0];
  this.vertices[numVertices++] = p1[1];
  this.vertices[numVertices++] = p2[0];
  this.vertices[numVertices++] = p2[1];
  this.vertices[numVertices++] = product;
  return numVertices;
};
ol.render.webgl.LineStringReplay.prototype.isValid_ = function(flatCoordinates, offset, end, stride) {
  var range = end - offset;
  if (range < stride * 2) {
    return false;
  } else {
    if (range === stride * 2) {
      var firstP = [flatCoordinates[offset], flatCoordinates[offset + 1]];
      var lastP = [flatCoordinates[offset + stride], flatCoordinates[offset + stride + 1]];
      return !ol.array.equals(firstP, lastP);
    }
  }
  return true;
};
ol.render.webgl.LineStringReplay.prototype.drawLineString = function(lineStringGeometry, feature) {
  var flatCoordinates = lineStringGeometry.getFlatCoordinates();
  var stride = lineStringGeometry.getStride();
  if (this.isValid_(flatCoordinates, 0, flatCoordinates.length, stride)) {
    flatCoordinates = ol.geom.flat.transform.translate(flatCoordinates, 0, flatCoordinates.length, stride, -this.origin[0], -this.origin[1]);
    if (this.state_.changed) {
      this.styleIndices_.push(this.indices.length);
      this.state_.changed = false;
    }
    this.startIndices.push(this.indices.length);
    this.startIndicesFeature.push(feature);
    this.drawCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
  }
};
ol.render.webgl.LineStringReplay.prototype.drawMultiLineString = function(multiLineStringGeometry, feature) {
  var indexCount = this.indices.length;
  var ends = multiLineStringGeometry.getEnds();
  ends.unshift(0);
  var flatCoordinates = multiLineStringGeometry.getFlatCoordinates();
  var stride = multiLineStringGeometry.getStride();
  var i, ii;
  if (ends.length > 1) {
    for (i = 1, ii = ends.length; i < ii; ++i) {
      if (this.isValid_(flatCoordinates, ends[i - 1], ends[i], stride)) {
        var lineString = ol.geom.flat.transform.translate(flatCoordinates, ends[i - 1], ends[i], stride, -this.origin[0], -this.origin[1]);
        this.drawCoordinates_(lineString, 0, lineString.length, stride);
      }
    }
  }
  if (this.indices.length > indexCount) {
    this.startIndices.push(indexCount);
    this.startIndicesFeature.push(feature);
    if (this.state_.changed) {
      this.styleIndices_.push(indexCount);
      this.state_.changed = false;
    }
  }
};
ol.render.webgl.LineStringReplay.prototype.drawPolygonCoordinates = function(flatCoordinates, holeFlatCoordinates, stride) {
  if (!ol.geom.flat.topology.lineStringIsClosed(flatCoordinates, 0, flatCoordinates.length, stride)) {
    flatCoordinates.push(flatCoordinates[0]);
    flatCoordinates.push(flatCoordinates[1]);
  }
  this.drawCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
  if (holeFlatCoordinates.length) {
    var i, ii;
    for (i = 0, ii = holeFlatCoordinates.length; i < ii; ++i) {
      if (!ol.geom.flat.topology.lineStringIsClosed(holeFlatCoordinates[i], 0, holeFlatCoordinates[i].length, stride)) {
        holeFlatCoordinates[i].push(holeFlatCoordinates[i][0]);
        holeFlatCoordinates[i].push(holeFlatCoordinates[i][1]);
      }
      this.drawCoordinates_(holeFlatCoordinates[i], 0, holeFlatCoordinates[i].length, stride);
    }
  }
};
ol.render.webgl.LineStringReplay.prototype.setPolygonStyle = function(feature, opt_index) {
  var index = opt_index === undefined ? this.indices.length : opt_index;
  this.startIndices.push(index);
  this.startIndicesFeature.push(feature);
  if (this.state_.changed) {
    this.styleIndices_.push(index);
    this.state_.changed = false;
  }
};
ol.render.webgl.LineStringReplay.prototype.getCurrentIndex = function() {
  return this.indices.length;
};
ol.render.webgl.LineStringReplay.prototype.finish = function(context) {
  this.verticesBuffer = new ol.webgl.Buffer(this.vertices);
  this.indicesBuffer = new ol.webgl.Buffer(this.indices);
  this.startIndices.push(this.indices.length);
  if (this.styleIndices_.length === 0 && this.styles_.length > 0) {
    this.styles_ = [];
  }
  this.vertices = null;
  this.indices = null;
};
ol.render.webgl.LineStringReplay.prototype.getDeleteResourcesFunction = function(context) {
  var verticesBuffer = this.verticesBuffer;
  var indicesBuffer = this.indicesBuffer;
  return function() {
    context.deleteBuffer(verticesBuffer);
    context.deleteBuffer(indicesBuffer);
  };
};
ol.render.webgl.LineStringReplay.prototype.setUpProgram = function(gl, context, size, pixelRatio) {
  var fragmentShader, vertexShader;
  fragmentShader = ol.render.webgl.linestringreplay.defaultshader.fragment;
  vertexShader = ol.render.webgl.linestringreplay.defaultshader.vertex;
  var program = context.getProgram(fragmentShader, vertexShader);
  var locations;
  if (!this.defaultLocations_) {
    locations = new ol.render.webgl.linestringreplay.defaultshader.Locations(gl, program);
    this.defaultLocations_ = locations;
  } else {
    locations = this.defaultLocations_;
  }
  context.useProgram(program);
  gl.enableVertexAttribArray(locations.a_lastPos);
  gl.vertexAttribPointer(locations.a_lastPos, 2, ol.webgl.FLOAT, false, 28, 0);
  gl.enableVertexAttribArray(locations.a_position);
  gl.vertexAttribPointer(locations.a_position, 2, ol.webgl.FLOAT, false, 28, 8);
  gl.enableVertexAttribArray(locations.a_nextPos);
  gl.vertexAttribPointer(locations.a_nextPos, 2, ol.webgl.FLOAT, false, 28, 16);
  gl.enableVertexAttribArray(locations.a_direction);
  gl.vertexAttribPointer(locations.a_direction, 1, ol.webgl.FLOAT, false, 28, 24);
  gl.uniform2fv(locations.u_size, size);
  gl.uniform1f(locations.u_pixelRatio, pixelRatio);
  return locations;
};
ol.render.webgl.LineStringReplay.prototype.shutDownProgram = function(gl, locations) {
  gl.disableVertexAttribArray(locations.a_lastPos);
  gl.disableVertexAttribArray(locations.a_position);
  gl.disableVertexAttribArray(locations.a_nextPos);
  gl.disableVertexAttribArray(locations.a_direction);
};
ol.render.webgl.LineStringReplay.prototype.drawReplay = function(gl, context, skippedFeaturesHash, hitDetection) {
  var tmpDepthFunc = gl.getParameter(gl.DEPTH_FUNC);
  var tmpDepthMask = gl.getParameter(gl.DEPTH_WRITEMASK);
  if (!hitDetection) {
    gl.enable(gl.DEPTH_TEST);
    gl.depthMask(true);
    gl.depthFunc(gl.NOTEQUAL);
  }
  if (!ol.obj.isEmpty(skippedFeaturesHash)) {
    this.drawReplaySkipping_(gl, context, skippedFeaturesHash);
  } else {
    var i, start, end, nextStyle;
    end = this.startIndices[this.startIndices.length - 1];
    for (i = this.styleIndices_.length - 1; i >= 0; --i) {
      start = this.styleIndices_[i];
      nextStyle = this.styles_[i];
      this.setStrokeStyle_(gl, nextStyle[0], nextStyle[1], nextStyle[2]);
      this.drawElements(gl, context, start, end);
      gl.clear(gl.DEPTH_BUFFER_BIT);
      end = start;
    }
  }
  if (!hitDetection) {
    gl.disable(gl.DEPTH_TEST);
    gl.clear(gl.DEPTH_BUFFER_BIT);
    gl.depthMask(tmpDepthMask);
    gl.depthFunc(tmpDepthFunc);
  }
};
ol.render.webgl.LineStringReplay.prototype.drawReplaySkipping_ = function(gl, context, skippedFeaturesHash) {
  var i, start, end, nextStyle, groupStart, feature, featureUid, featureIndex, featureStart;
  featureIndex = this.startIndices.length - 2;
  end = start = this.startIndices[featureIndex + 1];
  for (i = this.styleIndices_.length - 1; i >= 0; --i) {
    nextStyle = this.styles_[i];
    this.setStrokeStyle_(gl, nextStyle[0], nextStyle[1], nextStyle[2]);
    groupStart = this.styleIndices_[i];
    while (featureIndex >= 0 && this.startIndices[featureIndex] >= groupStart) {
      featureStart = this.startIndices[featureIndex];
      feature = this.startIndicesFeature[featureIndex];
      featureUid = ol.getUid(feature).toString();
      if (skippedFeaturesHash[featureUid]) {
        if (start !== end) {
          this.drawElements(gl, context, start, end);
          gl.clear(gl.DEPTH_BUFFER_BIT);
        }
        end = featureStart;
      }
      featureIndex--;
      start = featureStart;
    }
    if (start !== end) {
      this.drawElements(gl, context, start, end);
      gl.clear(gl.DEPTH_BUFFER_BIT);
    }
    start = end = groupStart;
  }
};
ol.render.webgl.LineStringReplay.prototype.drawHitDetectionReplayOneByOne = function(gl, context, skippedFeaturesHash, featureCallback, opt_hitExtent) {
  var i, start, end, nextStyle, groupStart, feature, featureUid, featureIndex;
  featureIndex = this.startIndices.length - 2;
  end = this.startIndices[featureIndex + 1];
  for (i = this.styleIndices_.length - 1; i >= 0; --i) {
    nextStyle = this.styles_[i];
    this.setStrokeStyle_(gl, nextStyle[0], nextStyle[1], nextStyle[2]);
    groupStart = this.styleIndices_[i];
    while (featureIndex >= 0 && this.startIndices[featureIndex] >= groupStart) {
      start = this.startIndices[featureIndex];
      feature = this.startIndicesFeature[featureIndex];
      featureUid = ol.getUid(feature).toString();
      if (skippedFeaturesHash[featureUid] === undefined && feature.getGeometry() && (opt_hitExtent === undefined || ol.extent.intersects(opt_hitExtent, feature.getGeometry().getExtent()))) {
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        this.drawElements(gl, context, start, end);
        var result = featureCallback(feature);
        if (result) {
          return result;
        }
      }
      featureIndex--;
      end = start;
    }
  }
  return undefined;
};
ol.render.webgl.LineStringReplay.prototype.setStrokeStyle_ = function(gl, color, lineWidth, miterLimit) {
  gl.uniform4fv(this.defaultLocations_.u_color, color);
  gl.uniform1f(this.defaultLocations_.u_lineWidth, lineWidth);
  gl.uniform1f(this.defaultLocations_.u_miterLimit, miterLimit);
};
ol.render.webgl.LineStringReplay.prototype.setFillStrokeStyle = function(fillStyle, strokeStyle) {
  var strokeStyleLineCap = strokeStyle.getLineCap();
  this.state_.lineCap = strokeStyleLineCap !== undefined ? strokeStyleLineCap : ol.render.webgl.defaultLineCap;
  var strokeStyleLineDash = strokeStyle.getLineDash();
  this.state_.lineDash = strokeStyleLineDash ? strokeStyleLineDash : ol.render.webgl.defaultLineDash;
  var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
  this.state_.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : ol.render.webgl.defaultLineDashOffset;
  var strokeStyleLineJoin = strokeStyle.getLineJoin();
  this.state_.lineJoin = strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : ol.render.webgl.defaultLineJoin;
  var strokeStyleColor = strokeStyle.getColor();
  if (!(strokeStyleColor instanceof CanvasGradient) && !(strokeStyleColor instanceof CanvasPattern)) {
    strokeStyleColor = ol.color.asArray(strokeStyleColor).map(function(c, i) {
      return i != 3 ? c / 255 : c;
    }) || ol.render.webgl.defaultStrokeStyle;
  } else {
    strokeStyleColor = ol.render.webgl.defaultStrokeStyle;
  }
  var strokeStyleWidth = strokeStyle.getWidth();
  strokeStyleWidth = strokeStyleWidth !== undefined ? strokeStyleWidth : ol.render.webgl.defaultLineWidth;
  var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
  strokeStyleMiterLimit = strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : ol.render.webgl.defaultMiterLimit;
  if (!this.state_.strokeColor || !ol.array.equals(this.state_.strokeColor, strokeStyleColor) || this.state_.lineWidth !== strokeStyleWidth || this.state_.miterLimit !== strokeStyleMiterLimit) {
    this.state_.changed = true;
    this.state_.strokeColor = strokeStyleColor;
    this.state_.lineWidth = strokeStyleWidth;
    this.state_.miterLimit = strokeStyleMiterLimit;
    this.styles_.push([strokeStyleColor, strokeStyleWidth, strokeStyleMiterLimit]);
  }
};
ol.render.webgl.LineStringReplay.Instruction_ = {ROUND:2, BEGIN_LINE:3, END_LINE:5, BEGIN_LINE_CAP:7, END_LINE_CAP:11, BEVEL_FIRST:13, BEVEL_SECOND:17, MITER_BOTTOM:19, MITER_TOP:23};
goog.provide("ol.render.webgl.polygonreplay.defaultshader");
goog.require("ol");
goog.require("ol.webgl.Fragment");
goog.require("ol.webgl.Vertex");
ol.render.webgl.polygonreplay.defaultshader.fragment = new ol.webgl.Fragment(ol.DEBUG_WEBGL ? "precision mediump float;\n\n\n\nuniform vec4 u_color;\nuniform float u_opacity;\n\nvoid main(void) {\n  gl_FragColor = u_color;\n  float alpha = u_color.a * u_opacity;\n  if (alpha == 0.0) {\n    discard;\n  }\n  gl_FragColor.a = alpha;\n}\n" : "precision mediump float;uniform vec4 e;uniform float f;void main(void){gl_FragColor=e;float alpha=e.a*f;if(alpha==0.0){discard;}gl_FragColor.a=alpha;}");
ol.render.webgl.polygonreplay.defaultshader.vertex = new ol.webgl.Vertex(ol.DEBUG_WEBGL ? "\n\nattribute vec2 a_position;\n\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_offsetScaleMatrix;\nuniform mat4 u_offsetRotateMatrix;\n\nvoid main(void) {\n  gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0);\n}\n\n\n" : "attribute vec2 a;uniform mat4 b;uniform mat4 c;uniform mat4 d;void main(void){gl_Position=b*vec4(a,0.0,1.0);}");
goog.provide("ol.render.webgl.polygonreplay.defaultshader.Locations");
goog.require("ol");
ol.render.webgl.polygonreplay.defaultshader.Locations = function(gl, program) {
  this.u_projectionMatrix = gl.getUniformLocation(program, ol.DEBUG_WEBGL ? "u_projectionMatrix" : "b");
  this.u_offsetScaleMatrix = gl.getUniformLocation(program, ol.DEBUG_WEBGL ? "u_offsetScaleMatrix" : "c");
  this.u_offsetRotateMatrix = gl.getUniformLocation(program, ol.DEBUG_WEBGL ? "u_offsetRotateMatrix" : "d");
  this.u_color = gl.getUniformLocation(program, ol.DEBUG_WEBGL ? "u_color" : "e");
  this.u_opacity = gl.getUniformLocation(program, ol.DEBUG_WEBGL ? "u_opacity" : "f");
  this.a_position = gl.getAttribLocation(program, ol.DEBUG_WEBGL ? "a_position" : "a");
};
goog.provide("ol.structs.LinkedList");
ol.structs.LinkedList = function(opt_circular) {
  this.first_ = undefined;
  this.last_ = undefined;
  this.head_ = undefined;
  this.circular_ = opt_circular === undefined ? true : opt_circular;
  this.length_ = 0;
};
ol.structs.LinkedList.prototype.insertItem = function(data) {
  var item = {prev:undefined, next:undefined, data:data};
  var head = this.head_;
  if (!head) {
    this.first_ = item;
    this.last_ = item;
    if (this.circular_) {
      item.next = item;
      item.prev = item;
    }
  } else {
    var next = head.next;
    item.prev = head;
    item.next = next;
    head.next = item;
    if (next) {
      next.prev = item;
    }
    if (head === this.last_) {
      this.last_ = item;
    }
  }
  this.head_ = item;
  this.length_++;
};
ol.structs.LinkedList.prototype.removeItem = function() {
  var head = this.head_;
  if (head) {
    var next = head.next;
    var prev = head.prev;
    if (next) {
      next.prev = prev;
    }
    if (prev) {
      prev.next = next;
    }
    this.head_ = next || prev;
    if (this.first_ === this.last_) {
      this.head_ = undefined;
      this.first_ = undefined;
      this.last_ = undefined;
    } else {
      if (this.first_ === head) {
        this.first_ = this.head_;
      } else {
        if (this.last_ === head) {
          this.last_ = prev ? this.head_.prev : this.head_;
        }
      }
    }
    this.length_--;
  }
};
ol.structs.LinkedList.prototype.firstItem = function() {
  this.head_ = this.first_;
  if (this.head_) {
    return this.head_.data;
  }
  return undefined;
};
ol.structs.LinkedList.prototype.lastItem = function() {
  this.head_ = this.last_;
  if (this.head_) {
    return this.head_.data;
  }
  return undefined;
};
ol.structs.LinkedList.prototype.nextItem = function() {
  if (this.head_ && this.head_.next) {
    this.head_ = this.head_.next;
    return this.head_.data;
  }
  return undefined;
};
ol.structs.LinkedList.prototype.getNextItem = function() {
  if (this.head_ && this.head_.next) {
    return this.head_.next.data;
  }
  return undefined;
};
ol.structs.LinkedList.prototype.prevItem = function() {
  if (this.head_ && this.head_.prev) {
    this.head_ = this.head_.prev;
    return this.head_.data;
  }
  return undefined;
};
ol.structs.LinkedList.prototype.getPrevItem = function() {
  if (this.head_ && this.head_.prev) {
    return this.head_.prev.data;
  }
  return undefined;
};
ol.structs.LinkedList.prototype.getCurrItem = function() {
  if (this.head_) {
    return this.head_.data;
  }
  return undefined;
};
ol.structs.LinkedList.prototype.setFirstItem = function() {
  if (this.circular_ && this.head_) {
    this.first_ = this.head_;
    this.last_ = this.head_.prev;
  }
};
ol.structs.LinkedList.prototype.concat = function(list) {
  if (list.head_) {
    if (this.head_) {
      var end = this.head_.next;
      this.head_.next = list.first_;
      list.first_.prev = this.head_;
      end.prev = list.last_;
      list.last_.next = end;
      this.length_ += list.length_;
    } else {
      this.head_ = list.head_;
      this.first_ = list.first_;
      this.last_ = list.last_;
      this.length_ = list.length_;
    }
    list.head_ = undefined;
    list.first_ = undefined;
    list.last_ = undefined;
    list.length_ = 0;
  }
};
ol.structs.LinkedList.prototype.getLength = function() {
  return this.length_;
};
goog.provide("ol.render.webgl.PolygonReplay");
goog.require("ol");
goog.require("ol.array");
goog.require("ol.color");
goog.require("ol.extent");
goog.require("ol.obj");
goog.require("ol.geom.flat.contains");
goog.require("ol.geom.flat.orient");
goog.require("ol.geom.flat.transform");
goog.require("ol.render.webgl.polygonreplay.defaultshader");
goog.require("ol.render.webgl.polygonreplay.defaultshader.Locations");
goog.require("ol.render.webgl.LineStringReplay");
goog.require("ol.render.webgl.Replay");
goog.require("ol.render.webgl");
goog.require("ol.style.Stroke");
goog.require("ol.structs.LinkedList");
goog.require("ol.structs.RBush");
goog.require("ol.webgl");
goog.require("ol.webgl.Buffer");
ol.render.webgl.PolygonReplay = function(tolerance, maxExtent) {
  ol.render.webgl.Replay.call(this, tolerance, maxExtent);
  this.lineStringReplay = new ol.render.webgl.LineStringReplay(tolerance, maxExtent);
  this.defaultLocations_ = null;
  this.styles_ = [];
  this.styleIndices_ = [];
  this.state_ = {fillColor:null, changed:false};
};
ol.inherits(ol.render.webgl.PolygonReplay, ol.render.webgl.Replay);
ol.render.webgl.PolygonReplay.prototype.drawCoordinates_ = function(flatCoordinates, holeFlatCoordinates, stride) {
  var outerRing = new ol.structs.LinkedList;
  var rtree = new ol.structs.RBush;
  this.processFlatCoordinates_(flatCoordinates, stride, outerRing, rtree, true);
  var maxCoords = this.getMaxCoords_(outerRing);
  if (holeFlatCoordinates.length) {
    var i, ii;
    var holeLists = [];
    for (i = 0, ii = holeFlatCoordinates.length; i < ii; ++i) {
      var holeList = {list:new ol.structs.LinkedList, maxCoords:undefined, rtree:new ol.structs.RBush};
      holeLists.push(holeList);
      this.processFlatCoordinates_(holeFlatCoordinates[i], stride, holeList.list, holeList.rtree, false);
      this.classifyPoints_(holeList.list, holeList.rtree, true);
      holeList.maxCoords = this.getMaxCoords_(holeList.list);
    }
    holeLists.sort(function(a, b) {
      return b.maxCoords[0] === a.maxCoords[0] ? a.maxCoords[1] - b.maxCoords[1] : b.maxCoords[0] - a.maxCoords[0];
    });
    for (i = 0; i < holeLists.length; ++i) {
      var currList = holeLists[i].list;
      var start = currList.firstItem();
      var currItem = start;
      var intersection;
      do {
        if (this.getIntersections_(currItem, rtree).length) {
          intersection = true;
          break;
        }
        currItem = currList.nextItem();
      } while (start !== currItem);
      if (!intersection) {
        if (this.bridgeHole_(currList, holeLists[i].maxCoords[0], outerRing, maxCoords[0], rtree)) {
          rtree.concat(holeLists[i].rtree);
          this.classifyPoints_(outerRing, rtree, false);
        }
      }
    }
  } else {
    this.classifyPoints_(outerRing, rtree, false);
  }
  this.triangulate_(outerRing, rtree);
};
ol.render.webgl.PolygonReplay.prototype.processFlatCoordinates_ = function(flatCoordinates, stride, list, rtree, clockwise) {
  var isClockwise = ol.geom.flat.orient.linearRingIsClockwise(flatCoordinates, 0, flatCoordinates.length, stride);
  var i, ii;
  var n = this.vertices.length / 2;
  var start;
  var p0;
  var p1;
  var extents = [];
  var segments = [];
  if (clockwise === isClockwise) {
    start = this.createPoint_(flatCoordinates[0], flatCoordinates[1], n++);
    p0 = start;
    for (i = stride, ii = flatCoordinates.length; i < ii; i += stride) {
      p1 = this.createPoint_(flatCoordinates[i], flatCoordinates[i + 1], n++);
      segments.push(this.insertItem_(p0, p1, list));
      extents.push([Math.min(p0.x, p1.x), Math.min(p0.y, p1.y), Math.max(p0.x, p1.x), Math.max(p0.y, p1.y)]);
      p0 = p1;
    }
    segments.push(this.insertItem_(p1, start, list));
    extents.push([Math.min(p0.x, p1.x), Math.min(p0.y, p1.y), Math.max(p0.x, p1.x), Math.max(p0.y, p1.y)]);
  } else {
    var end = flatCoordinates.length - stride;
    start = this.createPoint_(flatCoordinates[end], flatCoordinates[end + 1], n++);
    p0 = start;
    for (i = end - stride, ii = 0; i >= ii; i -= stride) {
      p1 = this.createPoint_(flatCoordinates[i], flatCoordinates[i + 1], n++);
      segments.push(this.insertItem_(p0, p1, list));
      extents.push([Math.min(p0.x, p1.x), Math.min(p0.y, p1.y), Math.max(p0.x, p1.x), Math.max(p0.y, p1.y)]);
      p0 = p1;
    }
    segments.push(this.insertItem_(p1, start, list));
    extents.push([Math.min(p0.x, p1.x), Math.min(p0.y, p1.y), Math.max(p0.x, p1.x), Math.max(p0.y, p1.y)]);
  }
  rtree.load(extents, segments);
};
ol.render.webgl.PolygonReplay.prototype.getMaxCoords_ = function(list) {
  var start = list.firstItem();
  var seg = start;
  var maxCoords = [seg.p0.x, seg.p0.y];
  do {
    seg = list.nextItem();
    if (seg.p0.x > maxCoords[0]) {
      maxCoords = [seg.p0.x, seg.p0.y];
    }
  } while (seg !== start);
  return maxCoords;
};
ol.render.webgl.PolygonReplay.prototype.classifyPoints_ = function(list, rtree, ccw) {
  var start = list.firstItem();
  var s0 = start;
  var s1 = list.nextItem();
  var pointsReclassified = false;
  do {
    var reflex = ccw ? ol.render.webgl.triangleIsCounterClockwise(s1.p1.x, s1.p1.y, s0.p1.x, s0.p1.y, s0.p0.x, s0.p0.y) : ol.render.webgl.triangleIsCounterClockwise(s0.p0.x, s0.p0.y, s0.p1.x, s0.p1.y, s1.p1.x, s1.p1.y);
    if (reflex === undefined) {
      this.removeItem_(s0, s1, list, rtree);
      pointsReclassified = true;
      if (s1 === start) {
        start = list.getNextItem();
      }
      s1 = s0;
      list.prevItem();
    } else {
      if (s0.p1.reflex !== reflex) {
        s0.p1.reflex = reflex;
        pointsReclassified = true;
      }
    }
    s0 = s1;
    s1 = list.nextItem();
  } while (s0 !== start);
  return pointsReclassified;
};
ol.render.webgl.PolygonReplay.prototype.bridgeHole_ = function(hole, holeMaxX, list, listMaxX, rtree) {
  var seg = hole.firstItem();
  while (seg.p1.x !== holeMaxX) {
    seg = hole.nextItem();
  }
  var p1 = seg.p1;
  var p2 = {x:listMaxX, y:p1.y, i:-1};
  var minDist = Infinity;
  var i, ii, bestPoint;
  var p5;
  var intersectingSegments = this.getIntersections_({p0:p1, p1:p2}, rtree, true);
  for (i = 0, ii = intersectingSegments.length; i < ii; ++i) {
    var currSeg = intersectingSegments[i];
    var intersection = this.calculateIntersection_(p1, p2, currSeg.p0, currSeg.p1, true);
    var dist = Math.abs(p1.x - intersection[0]);
    if (dist < minDist && ol.render.webgl.triangleIsCounterClockwise(p1.x, p1.y, currSeg.p0.x, currSeg.p0.y, currSeg.p1.x, currSeg.p1.y) !== undefined) {
      minDist = dist;
      p5 = {x:intersection[0], y:intersection[1], i:-1};
      seg = currSeg;
    }
  }
  if (minDist === Infinity) {
    return false;
  }
  bestPoint = seg.p1;
  if (minDist > 0) {
    var pointsInTriangle = this.getPointsInTriangle_(p1, p5, seg.p1, rtree);
    if (pointsInTriangle.length) {
      var theta = Infinity;
      for (i = 0, ii = pointsInTriangle.length; i < ii; ++i) {
        var currPoint = pointsInTriangle[i];
        var currTheta = Math.atan2(p1.y - currPoint.y, p2.x - currPoint.x);
        if (currTheta < theta || currTheta === theta && currPoint.x < bestPoint.x) {
          theta = currTheta;
          bestPoint = currPoint;
        }
      }
    }
  }
  seg = list.firstItem();
  while (seg.p1.x !== bestPoint.x || seg.p1.y !== bestPoint.y) {
    seg = list.nextItem();
  }
  var p0Bridge = {x:p1.x, y:p1.y, i:p1.i, reflex:undefined};
  var p1Bridge = {x:seg.p1.x, y:seg.p1.y, i:seg.p1.i, reflex:undefined};
  hole.getNextItem().p0 = p0Bridge;
  this.insertItem_(p1, seg.p1, hole, rtree);
  this.insertItem_(p1Bridge, p0Bridge, hole, rtree);
  seg.p1 = p1Bridge;
  hole.setFirstItem();
  list.concat(hole);
  return true;
};
ol.render.webgl.PolygonReplay.prototype.triangulate_ = function(list, rtree) {
  var ccw = false;
  var simple = this.isSimple_(list, rtree);
  while (list.getLength() > 3) {
    if (simple) {
      if (!this.clipEars_(list, rtree, simple, ccw)) {
        if (!this.classifyPoints_(list, rtree, ccw)) {
          if (!this.resolveSelfIntersections_(list, rtree, true)) {
            break;
          }
        }
      }
    } else {
      if (!this.clipEars_(list, rtree, simple, ccw)) {
        if (!this.classifyPoints_(list, rtree, ccw)) {
          if (!this.resolveSelfIntersections_(list, rtree)) {
            simple = this.isSimple_(list, rtree);
            if (!simple) {
              this.splitPolygon_(list, rtree);
              break;
            } else {
              ccw = !this.isClockwise_(list);
              this.classifyPoints_(list, rtree, ccw);
            }
          }
        }
      }
    }
  }
  if (list.getLength() === 3) {
    var numIndices = this.indices.length;
    this.indices[numIndices++] = list.getPrevItem().p0.i;
    this.indices[numIndices++] = list.getCurrItem().p0.i;
    this.indices[numIndices++] = list.getNextItem().p0.i;
  }
};
ol.render.webgl.PolygonReplay.prototype.clipEars_ = function(list, rtree, simple, ccw) {
  var numIndices = this.indices.length;
  var start = list.firstItem();
  var s0 = list.getPrevItem();
  var s1 = start;
  var s2 = list.nextItem();
  var s3 = list.getNextItem();
  var p0, p1, p2;
  var processedEars = false;
  do {
    p0 = s1.p0;
    p1 = s1.p1;
    p2 = s2.p1;
    if (p1.reflex === false) {
      var variableCriterion;
      if (simple) {
        variableCriterion = this.getPointsInTriangle_(p0, p1, p2, rtree, true).length === 0;
      } else {
        variableCriterion = ccw ? this.diagonalIsInside_(s3.p1, p2, p1, p0, s0.p0) : this.diagonalIsInside_(s0.p0, p0, p1, p2, s3.p1);
      }
      if ((simple || this.getIntersections_({p0:p0, p1:p2}, rtree).length === 0) && variableCriterion) {
        if (simple || p0.reflex === false || p2.reflex === false || ol.geom.flat.orient.linearRingIsClockwise([s0.p0.x, s0.p0.y, p0.x, p0.y, p1.x, p1.y, p2.x, p2.y, s3.p1.x, s3.p1.y], 0, 10, 2) === !ccw) {
          this.indices[numIndices++] = p0.i;
          this.indices[numIndices++] = p1.i;
          this.indices[numIndices++] = p2.i;
          this.removeItem_(s1, s2, list, rtree);
          if (s2 === start) {
            start = s3;
          }
          processedEars = true;
        }
      }
    }
    s0 = list.getPrevItem();
    s1 = list.getCurrItem();
    s2 = list.nextItem();
    s3 = list.getNextItem();
  } while (s1 !== start && list.getLength() > 3);
  return processedEars;
};
ol.render.webgl.PolygonReplay.prototype.resolveSelfIntersections_ = function(list, rtree, opt_touch) {
  var start = list.firstItem();
  list.nextItem();
  var s0 = start;
  var s1 = list.nextItem();
  var resolvedIntersections = false;
  do {
    var intersection = this.calculateIntersection_(s0.p0, s0.p1, s1.p0, s1.p1, opt_touch);
    if (intersection) {
      var breakCond = false;
      var numVertices = this.vertices.length;
      var numIndices = this.indices.length;
      var n = numVertices / 2;
      var seg = list.prevItem();
      list.removeItem();
      rtree.remove(seg);
      breakCond = seg === start;
      var p;
      if (opt_touch) {
        if (intersection[0] === s0.p0.x && intersection[1] === s0.p0.y) {
          list.prevItem();
          p = s0.p0;
          s1.p0 = p;
          rtree.remove(s0);
          breakCond = breakCond || s0 === start;
        } else {
          p = s1.p1;
          s0.p1 = p;
          rtree.remove(s1);
          breakCond = breakCond || s1 === start;
        }
        list.removeItem();
      } else {
        p = this.createPoint_(intersection[0], intersection[1], n);
        s0.p1 = p;
        s1.p0 = p;
        rtree.update([Math.min(s0.p0.x, s0.p1.x), Math.min(s0.p0.y, s0.p1.y), Math.max(s0.p0.x, s0.p1.x), Math.max(s0.p0.y, s0.p1.y)], s0);
        rtree.update([Math.min(s1.p0.x, s1.p1.x), Math.min(s1.p0.y, s1.p1.y), Math.max(s1.p0.x, s1.p1.x), Math.max(s1.p0.y, s1.p1.y)], s1);
      }
      this.indices[numIndices++] = seg.p0.i;
      this.indices[numIndices++] = seg.p1.i;
      this.indices[numIndices++] = p.i;
      resolvedIntersections = true;
      if (breakCond) {
        break;
      }
    }
    s0 = list.getPrevItem();
    s1 = list.nextItem();
  } while (s0 !== start);
  return resolvedIntersections;
};
ol.render.webgl.PolygonReplay.prototype.isSimple_ = function(list, rtree) {
  var start = list.firstItem();
  var seg = start;
  do {
    if (this.getIntersections_(seg, rtree).length) {
      return false;
    }
    seg = list.nextItem();
  } while (seg !== start);
  return true;
};
ol.render.webgl.PolygonReplay.prototype.isClockwise_ = function(list) {
  var length = list.getLength() * 2;
  var flatCoordinates = new Array(length);
  var start = list.firstItem();
  var seg = start;
  var i = 0;
  do {
    flatCoordinates[i++] = seg.p0.x;
    flatCoordinates[i++] = seg.p0.y;
    seg = list.nextItem();
  } while (seg !== start);
  return ol.geom.flat.orient.linearRingIsClockwise(flatCoordinates, 0, length, 2);
};
ol.render.webgl.PolygonReplay.prototype.splitPolygon_ = function(list, rtree) {
  var start = list.firstItem();
  var s0 = start;
  do {
    var intersections = this.getIntersections_(s0, rtree);
    if (intersections.length) {
      var s1 = intersections[0];
      var n = this.vertices.length / 2;
      var intersection = this.calculateIntersection_(s0.p0, s0.p1, s1.p0, s1.p1);
      var p = this.createPoint_(intersection[0], intersection[1], n);
      var newPolygon = new ol.structs.LinkedList;
      var newRtree = new ol.structs.RBush;
      this.insertItem_(p, s0.p1, newPolygon, newRtree);
      s0.p1 = p;
      rtree.update([Math.min(s0.p0.x, p.x), Math.min(s0.p0.y, p.y), Math.max(s0.p0.x, p.x), Math.max(s0.p0.y, p.y)], s0);
      var currItem = list.nextItem();
      while (currItem !== s1) {
        this.insertItem_(currItem.p0, currItem.p1, newPolygon, newRtree);
        rtree.remove(currItem);
        list.removeItem();
        currItem = list.getCurrItem();
      }
      this.insertItem_(s1.p0, p, newPolygon, newRtree);
      s1.p0 = p;
      rtree.update([Math.min(s1.p1.x, p.x), Math.min(s1.p1.y, p.y), Math.max(s1.p1.x, p.x), Math.max(s1.p1.y, p.y)], s1);
      this.classifyPoints_(list, rtree, false);
      this.triangulate_(list, rtree);
      this.classifyPoints_(newPolygon, newRtree, false);
      this.triangulate_(newPolygon, newRtree);
      break;
    }
    s0 = list.nextItem();
  } while (s0 !== start);
};
ol.render.webgl.PolygonReplay.prototype.createPoint_ = function(x, y, i) {
  var numVertices = this.vertices.length;
  this.vertices[numVertices++] = x;
  this.vertices[numVertices++] = y;
  var p = {x:x, y:y, i:i, reflex:undefined};
  return p;
};
ol.render.webgl.PolygonReplay.prototype.insertItem_ = function(p0, p1, list, opt_rtree) {
  var seg = {p0:p0, p1:p1};
  list.insertItem(seg);
  if (opt_rtree) {
    opt_rtree.insert([Math.min(p0.x, p1.x), Math.min(p0.y, p1.y), Math.max(p0.x, p1.x), Math.max(p0.y, p1.y)], seg);
  }
  return seg;
};
ol.render.webgl.PolygonReplay.prototype.removeItem_ = function(s0, s1, list, rtree) {
  if (list.getCurrItem() === s1) {
    list.removeItem();
    s0.p1 = s1.p1;
    rtree.remove(s1);
    rtree.update([Math.min(s0.p0.x, s0.p1.x), Math.min(s0.p0.y, s0.p1.y), Math.max(s0.p0.x, s0.p1.x), Math.max(s0.p0.y, s0.p1.y)], s0);
  }
};
ol.render.webgl.PolygonReplay.prototype.getPointsInTriangle_ = function(p0, p1, p2, rtree, opt_reflex) {
  var i, ii, j, p;
  var result = [];
  var segmentsInExtent = rtree.getInExtent([Math.min(p0.x, p1.x, p2.x), Math.min(p0.y, p1.y, p2.y), Math.max(p0.x, p1.x, p2.x), Math.max(p0.y, p1.y, p2.y)]);
  for (i = 0, ii = segmentsInExtent.length; i < ii; ++i) {
    for (j in segmentsInExtent[i]) {
      p = segmentsInExtent[i][j];
      if (typeof p === "object" && (!opt_reflex || p.reflex)) {
        if ((p.x !== p0.x || p.y !== p0.y) && (p.x !== p1.x || p.y !== p1.y) && (p.x !== p2.x || p.y !== p2.y) && result.indexOf(p) === -1 && ol.geom.flat.contains.linearRingContainsXY([p0.x, p0.y, p1.x, p1.y, p2.x, p2.y], 0, 6, 2, p.x, p.y)) {
          result.push(p);
        }
      }
    }
  }
  return result;
};
ol.render.webgl.PolygonReplay.prototype.getIntersections_ = function(segment, rtree, opt_touch) {
  var p0 = segment.p0;
  var p1 = segment.p1;
  var segmentsInExtent = rtree.getInExtent([Math.min(p0.x, p1.x), Math.min(p0.y, p1.y), Math.max(p0.x, p1.x), Math.max(p0.y, p1.y)]);
  var result = [];
  var i, ii;
  for (i = 0, ii = segmentsInExtent.length; i < ii; ++i) {
    var currSeg = segmentsInExtent[i];
    if (segment !== currSeg && (opt_touch || currSeg.p0 !== p1 || currSeg.p1 !== p0) && this.calculateIntersection_(p0, p1, currSeg.p0, currSeg.p1, opt_touch)) {
      result.push(currSeg);
    }
  }
  return result;
};
ol.render.webgl.PolygonReplay.prototype.calculateIntersection_ = function(p0, p1, p2, p3, opt_touch) {
  var denom = (p3.y - p2.y) * (p1.x - p0.x) - (p3.x - p2.x) * (p1.y - p0.y);
  if (denom !== 0) {
    var ua = ((p3.x - p2.x) * (p0.y - p2.y) - (p3.y - p2.y) * (p0.x - p2.x)) / denom;
    var ub = ((p1.x - p0.x) * (p0.y - p2.y) - (p1.y - p0.y) * (p0.x - p2.x)) / denom;
    if (!opt_touch && ua > ol.render.webgl.EPSILON && ua < 1 - ol.render.webgl.EPSILON && ub > ol.render.webgl.EPSILON && ub < 1 - ol.render.webgl.EPSILON || opt_touch && ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
      return [p0.x + ua * (p1.x - p0.x), p0.y + ua * (p1.y - p0.y)];
    }
  }
  return undefined;
};
ol.render.webgl.PolygonReplay.prototype.diagonalIsInside_ = function(p0, p1, p2, p3, p4) {
  if (p1.reflex === undefined || p3.reflex === undefined) {
    return false;
  }
  var p1IsLeftOf = (p2.x - p3.x) * (p1.y - p3.y) > (p2.y - p3.y) * (p1.x - p3.x);
  var p1IsRightOf = (p4.x - p3.x) * (p1.y - p3.y) < (p4.y - p3.y) * (p1.x - p3.x);
  var p3IsLeftOf = (p0.x - p1.x) * (p3.y - p1.y) > (p0.y - p1.y) * (p3.x - p1.x);
  var p3IsRightOf = (p2.x - p1.x) * (p3.y - p1.y) < (p2.y - p1.y) * (p3.x - p1.x);
  var p1InCone = p3.reflex ? p1IsRightOf || p1IsLeftOf : p1IsRightOf && p1IsLeftOf;
  var p3InCone = p1.reflex ? p3IsRightOf || p3IsLeftOf : p3IsRightOf && p3IsLeftOf;
  return p1InCone && p3InCone;
};
ol.render.webgl.PolygonReplay.prototype.drawMultiPolygon = function(multiPolygonGeometry, feature) {
  var endss = multiPolygonGeometry.getEndss();
  var stride = multiPolygonGeometry.getStride();
  var currIndex = this.indices.length;
  var currLineIndex = this.lineStringReplay.getCurrentIndex();
  var flatCoordinates = multiPolygonGeometry.getFlatCoordinates();
  var i, ii, j, jj;
  var start = 0;
  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    if (ends.length > 0) {
      var outerRing = ol.geom.flat.transform.translate(flatCoordinates, start, ends[0], stride, -this.origin[0], -this.origin[1]);
      if (outerRing.length) {
        var holes = [];
        var holeFlatCoords;
        for (j = 1, jj = ends.length; j < jj; ++j) {
          if (ends[j] !== ends[j - 1]) {
            holeFlatCoords = ol.geom.flat.transform.translate(flatCoordinates, ends[j - 1], ends[j], stride, -this.origin[0], -this.origin[1]);
            holes.push(holeFlatCoords);
          }
        }
        this.lineStringReplay.drawPolygonCoordinates(outerRing, holes, stride);
        this.drawCoordinates_(outerRing, holes, stride);
      }
    }
    start = ends[ends.length - 1];
  }
  if (this.indices.length > currIndex) {
    this.startIndices.push(currIndex);
    this.startIndicesFeature.push(feature);
    if (this.state_.changed) {
      this.styleIndices_.push(currIndex);
      this.state_.changed = false;
    }
  }
  if (this.lineStringReplay.getCurrentIndex() > currLineIndex) {
    this.lineStringReplay.setPolygonStyle(feature, currLineIndex);
  }
};
ol.render.webgl.PolygonReplay.prototype.drawPolygon = function(polygonGeometry, feature) {
  var ends = polygonGeometry.getEnds();
  var stride = polygonGeometry.getStride();
  if (ends.length > 0) {
    var flatCoordinates = polygonGeometry.getFlatCoordinates().map(Number);
    var outerRing = ol.geom.flat.transform.translate(flatCoordinates, 0, ends[0], stride, -this.origin[0], -this.origin[1]);
    if (outerRing.length) {
      var holes = [];
      var i, ii, holeFlatCoords;
      for (i = 1, ii = ends.length; i < ii; ++i) {
        if (ends[i] !== ends[i - 1]) {
          holeFlatCoords = ol.geom.flat.transform.translate(flatCoordinates, ends[i - 1], ends[i], stride, -this.origin[0], -this.origin[1]);
          holes.push(holeFlatCoords);
        }
      }
      this.startIndices.push(this.indices.length);
      this.startIndicesFeature.push(feature);
      if (this.state_.changed) {
        this.styleIndices_.push(this.indices.length);
        this.state_.changed = false;
      }
      this.lineStringReplay.setPolygonStyle(feature);
      this.lineStringReplay.drawPolygonCoordinates(outerRing, holes, stride);
      this.drawCoordinates_(outerRing, holes, stride);
    }
  }
};
ol.render.webgl.PolygonReplay.prototype.finish = function(context) {
  this.verticesBuffer = new ol.webgl.Buffer(this.vertices);
  this.indicesBuffer = new ol.webgl.Buffer(this.indices);
  this.startIndices.push(this.indices.length);
  this.lineStringReplay.finish(context);
  if (this.styleIndices_.length === 0 && this.styles_.length > 0) {
    this.styles_ = [];
  }
  this.vertices = null;
  this.indices = null;
};
ol.render.webgl.PolygonReplay.prototype.getDeleteResourcesFunction = function(context) {
  var verticesBuffer = this.verticesBuffer;
  var indicesBuffer = this.indicesBuffer;
  var lineDeleter = this.lineStringReplay.getDeleteResourcesFunction(context);
  return function() {
    context.deleteBuffer(verticesBuffer);
    context.deleteBuffer(indicesBuffer);
    lineDeleter();
  };
};
ol.render.webgl.PolygonReplay.prototype.setUpProgram = function(gl, context, size, pixelRatio) {
  var fragmentShader, vertexShader;
  fragmentShader = ol.render.webgl.polygonreplay.defaultshader.fragment;
  vertexShader = ol.render.webgl.polygonreplay.defaultshader.vertex;
  var program = context.getProgram(fragmentShader, vertexShader);
  var locations;
  if (!this.defaultLocations_) {
    locations = new ol.render.webgl.polygonreplay.defaultshader.Locations(gl, program);
    this.defaultLocations_ = locations;
  } else {
    locations = this.defaultLocations_;
  }
  context.useProgram(program);
  gl.enableVertexAttribArray(locations.a_position);
  gl.vertexAttribPointer(locations.a_position, 2, ol.webgl.FLOAT, false, 8, 0);
  return locations;
};
ol.render.webgl.PolygonReplay.prototype.shutDownProgram = function(gl, locations) {
  gl.disableVertexAttribArray(locations.a_position);
};
ol.render.webgl.PolygonReplay.prototype.drawReplay = function(gl, context, skippedFeaturesHash, hitDetection) {
  var tmpDepthFunc = gl.getParameter(gl.DEPTH_FUNC);
  var tmpDepthMask = gl.getParameter(gl.DEPTH_WRITEMASK);
  if (!hitDetection) {
    gl.enable(gl.DEPTH_TEST);
    gl.depthMask(true);
    gl.depthFunc(gl.NOTEQUAL);
  }
  if (!ol.obj.isEmpty(skippedFeaturesHash)) {
    this.drawReplaySkipping_(gl, context, skippedFeaturesHash);
  } else {
    var i, start, end, nextStyle;
    end = this.startIndices[this.startIndices.length - 1];
    for (i = this.styleIndices_.length - 1; i >= 0; --i) {
      start = this.styleIndices_[i];
      nextStyle = this.styles_[i];
      this.setFillStyle_(gl, nextStyle);
      this.drawElements(gl, context, start, end);
      end = start;
    }
  }
  if (!hitDetection) {
    gl.disable(gl.DEPTH_TEST);
    gl.clear(gl.DEPTH_BUFFER_BIT);
    gl.depthMask(tmpDepthMask);
    gl.depthFunc(tmpDepthFunc);
  }
};
ol.render.webgl.PolygonReplay.prototype.drawHitDetectionReplayOneByOne = function(gl, context, skippedFeaturesHash, featureCallback, opt_hitExtent) {
  var i, start, end, nextStyle, groupStart, feature, featureUid, featureIndex;
  featureIndex = this.startIndices.length - 2;
  end = this.startIndices[featureIndex + 1];
  for (i = this.styleIndices_.length - 1; i >= 0; --i) {
    nextStyle = this.styles_[i];
    this.setFillStyle_(gl, nextStyle);
    groupStart = this.styleIndices_[i];
    while (featureIndex >= 0 && this.startIndices[featureIndex] >= groupStart) {
      start = this.startIndices[featureIndex];
      feature = this.startIndicesFeature[featureIndex];
      featureUid = ol.getUid(feature).toString();
      if (skippedFeaturesHash[featureUid] === undefined && feature.getGeometry() && (opt_hitExtent === undefined || ol.extent.intersects(opt_hitExtent, feature.getGeometry().getExtent()))) {
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        this.drawElements(gl, context, start, end);
        var result = featureCallback(feature);
        if (result) {
          return result;
        }
      }
      featureIndex--;
      end = start;
    }
  }
  return undefined;
};
ol.render.webgl.PolygonReplay.prototype.drawReplaySkipping_ = function(gl, context, skippedFeaturesHash) {
  var i, start, end, nextStyle, groupStart, feature, featureUid, featureIndex, featureStart;
  featureIndex = this.startIndices.length - 2;
  end = start = this.startIndices[featureIndex + 1];
  for (i = this.styleIndices_.length - 1; i >= 0; --i) {
    nextStyle = this.styles_[i];
    this.setFillStyle_(gl, nextStyle);
    groupStart = this.styleIndices_[i];
    while (featureIndex >= 0 && this.startIndices[featureIndex] >= groupStart) {
      featureStart = this.startIndices[featureIndex];
      feature = this.startIndicesFeature[featureIndex];
      featureUid = ol.getUid(feature).toString();
      if (skippedFeaturesHash[featureUid]) {
        if (start !== end) {
          this.drawElements(gl, context, start, end);
          gl.clear(gl.DEPTH_BUFFER_BIT);
        }
        end = featureStart;
      }
      featureIndex--;
      start = featureStart;
    }
    if (start !== end) {
      this.drawElements(gl, context, start, end);
      gl.clear(gl.DEPTH_BUFFER_BIT);
    }
    start = end = groupStart;
  }
};
ol.render.webgl.PolygonReplay.prototype.setFillStyle_ = function(gl, color) {
  gl.uniform4fv(this.defaultLocations_.u_color, color);
};
ol.render.webgl.PolygonReplay.prototype.setFillStrokeStyle = function(fillStyle, strokeStyle) {
  var fillStyleColor = fillStyle ? fillStyle.getColor() : [0, 0, 0, 0];
  if (!(fillStyleColor instanceof CanvasGradient) && !(fillStyleColor instanceof CanvasPattern)) {
    fillStyleColor = ol.color.asArray(fillStyleColor).map(function(c, i) {
      return i != 3 ? c / 255 : c;
    }) || ol.render.webgl.defaultFillStyle;
  } else {
    fillStyleColor = ol.render.webgl.defaultFillStyle;
  }
  if (!this.state_.fillColor || !ol.array.equals(fillStyleColor, this.state_.fillColor)) {
    this.state_.fillColor = fillStyleColor;
    this.state_.changed = true;
    this.styles_.push(fillStyleColor);
  }
  if (strokeStyle) {
    this.lineStringReplay.setFillStrokeStyle(null, strokeStyle);
  } else {
    var nullStrokeStyle = new ol.style.Stroke({color:[0, 0, 0, 0], lineWidth:0});
    this.lineStringReplay.setFillStrokeStyle(null, nullStrokeStyle);
  }
};
goog.provide("ol.style.Atlas");
goog.require("ol.dom");
ol.style.Atlas = function(size, space) {
  this.space_ = space;
  this.emptyBlocks_ = [{x:0, y:0, width:size, height:size}];
  this.entries_ = {};
  this.context_ = ol.dom.createCanvasContext2D(size, size);
  this.canvas_ = this.context_.canvas;
};
ol.style.Atlas.prototype.get = function(id) {
  return this.entries_[id] || null;
};
ol.style.Atlas.prototype.add = function(id, width, height, renderCallback, opt_this) {
  var block, i, ii;
  for (i = 0, ii = this.emptyBlocks_.length; i < ii; ++i) {
    block = this.emptyBlocks_[i];
    if (block.width >= width + this.space_ && block.height >= height + this.space_) {
      var entry = {offsetX:block.x + this.space_, offsetY:block.y + this.space_, image:this.canvas_};
      this.entries_[id] = entry;
      renderCallback.call(opt_this, this.context_, block.x + this.space_, block.y + this.space_);
      this.split_(i, block, width + this.space_, height + this.space_);
      return entry;
    }
  }
  return null;
};
ol.style.Atlas.prototype.split_ = function(index, block, width, height) {
  var deltaWidth = block.width - width;
  var deltaHeight = block.height - height;
  var newBlock1;
  var newBlock2;
  if (deltaWidth > deltaHeight) {
    newBlock1 = {x:block.x + width, y:block.y, width:block.width - width, height:block.height};
    newBlock2 = {x:block.x, y:block.y + height, width:width, height:block.height - height};
    this.updateBlocks_(index, newBlock1, newBlock2);
  } else {
    newBlock1 = {x:block.x + width, y:block.y, width:block.width - width, height:height};
    newBlock2 = {x:block.x, y:block.y + height, width:block.width, height:block.height - height};
    this.updateBlocks_(index, newBlock1, newBlock2);
  }
};
ol.style.Atlas.prototype.updateBlocks_ = function(index, newBlock1, newBlock2) {
  var args = [index, 1];
  if (newBlock1.width > 0 && newBlock1.height > 0) {
    args.push(newBlock1);
  }
  if (newBlock2.width > 0 && newBlock2.height > 0) {
    args.push(newBlock2);
  }
  this.emptyBlocks_.splice.apply(this.emptyBlocks_, args);
};
goog.provide("ol.style.AtlasManager");
goog.require("ol");
goog.require("ol.style.Atlas");
ol.style.AtlasManager = function(opt_options) {
  var options = opt_options || {};
  this.currentSize_ = options.initialSize !== undefined ? options.initialSize : ol.INITIAL_ATLAS_SIZE;
  this.maxSize_ = options.maxSize !== undefined ? options.maxSize : ol.MAX_ATLAS_SIZE != -1 ? ol.MAX_ATLAS_SIZE : ol.WEBGL_MAX_TEXTURE_SIZE !== undefined ? ol.WEBGL_MAX_TEXTURE_SIZE : 2048;
  this.space_ = options.space !== undefined ? options.space : 1;
  this.atlases_ = [new ol.style.Atlas(this.currentSize_, this.space_)];
  this.currentHitSize_ = this.currentSize_;
  this.hitAtlases_ = [new ol.style.Atlas(this.currentHitSize_, this.space_)];
};
ol.style.AtlasManager.prototype.getInfo = function(id) {
  var info = this.getInfo_(this.atlases_, id);
  if (!info) {
    return null;
  }
  var hitInfo = this.getInfo_(this.hitAtlases_, id);
  return this.mergeInfos_(info, hitInfo);
};
ol.style.AtlasManager.prototype.getInfo_ = function(atlases, id) {
  var atlas, info, i, ii;
  for (i = 0, ii = atlases.length; i < ii; ++i) {
    atlas = atlases[i];
    info = atlas.get(id);
    if (info) {
      return info;
    }
  }
  return null;
};
ol.style.AtlasManager.prototype.mergeInfos_ = function(info, hitInfo) {
  return {offsetX:info.offsetX, offsetY:info.offsetY, image:info.image, hitImage:hitInfo.image};
};
ol.style.AtlasManager.prototype.add = function(id, width, height, renderCallback, opt_renderHitCallback, opt_this) {
  if (width + this.space_ > this.maxSize_ || height + this.space_ > this.maxSize_) {
    return null;
  }
  var info = this.add_(false, id, width, height, renderCallback, opt_this);
  if (!info) {
    return null;
  }
  var renderHitCallback = opt_renderHitCallback !== undefined ? opt_renderHitCallback : ol.nullFunction;
  var hitInfo = this.add_(true, id, width, height, renderHitCallback, opt_this);
  return this.mergeInfos_(info, hitInfo);
};
ol.style.AtlasManager.prototype.add_ = function(isHitAtlas, id, width, height, renderCallback, opt_this) {
  var atlases = isHitAtlas ? this.hitAtlases_ : this.atlases_;
  var atlas, info, i, ii;
  for (i = 0, ii = atlases.length; i < ii; ++i) {
    atlas = atlases[i];
    info = atlas.add(id, width, height, renderCallback, opt_this);
    if (info) {
      return info;
    } else {
      if (!info && i === ii - 1) {
        var size;
        if (isHitAtlas) {
          size = Math.min(this.currentHitSize_ * 2, this.maxSize_);
          this.currentHitSize_ = size;
        } else {
          size = Math.min(this.currentSize_ * 2, this.maxSize_);
          this.currentSize_ = size;
        }
        atlas = new ol.style.Atlas(size, this.space_);
        atlases.push(atlas);
        ++ii;
      }
    }
  }
  return null;
};
goog.provide("ol.render.webgl.TextReplay");
goog.require("ol");
goog.require("ol.colorlike");
goog.require("ol.dom");
goog.require("ol.geom.GeometryType");
goog.require("ol.has");
goog.require("ol.render.replay");
goog.require("ol.render.webgl");
goog.require("ol.render.webgl.TextureReplay");
goog.require("ol.style.AtlasManager");
goog.require("ol.webgl.Buffer");
ol.render.webgl.TextReplay = function(tolerance, maxExtent) {
  ol.render.webgl.TextureReplay.call(this, tolerance, maxExtent);
  this.images_ = [];
  this.textures_ = [];
  this.measureCanvas_ = ol.dom.createCanvasContext2D(0, 0).canvas;
  this.state_ = {strokeColor:null, lineCap:undefined, lineDash:null, lineDashOffset:undefined, lineJoin:undefined, lineWidth:0, miterLimit:undefined, fillColor:null, font:undefined, scale:undefined};
  this.text_ = "";
  this.textAlign_ = undefined;
  this.textBaseline_ = undefined;
  this.offsetX_ = undefined;
  this.offsetY_ = undefined;
  this.atlases_ = {};
  this.currAtlas_ = undefined;
  this.scale = 1;
  this.opacity = 1;
};
ol.inherits(ol.render.webgl.TextReplay, ol.render.webgl.TextureReplay);
ol.render.webgl.TextReplay.prototype.drawText = function(geometry, feature) {
  if (this.text_) {
    var flatCoordinates = null;
    var offset = 0;
    var end = 2;
    var stride = 2;
    switch(geometry.getType()) {
      case ol.geom.GeometryType.POINT:
      case ol.geom.GeometryType.MULTI_POINT:
        flatCoordinates = geometry.getFlatCoordinates();
        end = flatCoordinates.length;
        stride = geometry.getStride();
        break;
      case ol.geom.GeometryType.CIRCLE:
        flatCoordinates = geometry.getCenter();
        break;
      case ol.geom.GeometryType.LINE_STRING:
        flatCoordinates = geometry.getFlatMidpoint();
        break;
      case ol.geom.GeometryType.MULTI_LINE_STRING:
        flatCoordinates = geometry.getFlatMidpoints();
        end = flatCoordinates.length;
        break;
      case ol.geom.GeometryType.POLYGON:
        flatCoordinates = geometry.getFlatInteriorPoint();
        break;
      case ol.geom.GeometryType.MULTI_POLYGON:
        flatCoordinates = geometry.getFlatInteriorPoints();
        end = flatCoordinates.length;
        break;
      default:
    }
    this.startIndices.push(this.indices.length);
    this.startIndicesFeature.push(feature);
    var glyphAtlas = this.currAtlas_;
    var lines = this.text_.split("\n");
    var textSize = this.getTextSize_(lines);
    var i, ii, j, jj, currX, currY, charArr, charInfo;
    var anchorX = Math.round(textSize[0] * this.textAlign_ - this.offsetX_);
    var anchorY = Math.round(textSize[1] * this.textBaseline_ - this.offsetY_);
    var lineWidth = this.state_.lineWidth / 2 * this.state_.scale;
    for (i = 0, ii = lines.length; i < ii; ++i) {
      currX = 0;
      currY = glyphAtlas.height * i;
      charArr = lines[i].split("");
      for (j = 0, jj = charArr.length; j < jj; ++j) {
        charInfo = glyphAtlas.atlas.getInfo(charArr[j]);
        if (charInfo) {
          var image = charInfo.image;
          this.anchorX = anchorX - currX;
          this.anchorY = anchorY - currY;
          this.originX = j === 0 ? charInfo.offsetX - lineWidth : charInfo.offsetX;
          this.originY = charInfo.offsetY;
          this.height = glyphAtlas.height;
          this.width = j === 0 || j === charArr.length - 1 ? glyphAtlas.width[charArr[j]] + lineWidth : glyphAtlas.width[charArr[j]];
          this.imageHeight = image.height;
          this.imageWidth = image.width;
          var currentImage;
          if (this.images_.length === 0) {
            this.images_.push(image);
          } else {
            currentImage = this.images_[this.images_.length - 1];
            if (ol.getUid(currentImage) != ol.getUid(image)) {
              this.groupIndices.push(this.indices.length);
              this.images_.push(image);
            }
          }
          this.drawText_(flatCoordinates, offset, end, stride);
        }
        currX += this.width;
      }
    }
  }
};
ol.render.webgl.TextReplay.prototype.getTextSize_ = function(lines) {
  var self = this;
  var glyphAtlas = this.currAtlas_;
  var textHeight = lines.length * glyphAtlas.height;
  var textWidth = lines.map(function(str) {
    var sum = 0;
    var i, ii;
    for (i = 0, ii = str.length; i < ii; ++i) {
      var curr = str[i];
      if (!glyphAtlas.width[curr]) {
        self.addCharToAtlas_(curr);
      }
      sum += glyphAtlas.width[curr] ? glyphAtlas.width[curr] : 0;
    }
    return sum;
  }).reduce(function(max, curr) {
    return Math.max(max, curr);
  });
  return [textWidth, textHeight];
};
ol.render.webgl.TextReplay.prototype.drawText_ = function(flatCoordinates, offset, end, stride) {
  var i, ii;
  for (i = offset, ii = end; i < ii; i += stride) {
    this.drawCoordinates(flatCoordinates, offset, end, stride);
  }
};
ol.render.webgl.TextReplay.prototype.addCharToAtlas_ = function(char) {
  if (char.length === 1) {
    var glyphAtlas = this.currAtlas_;
    var state = this.state_;
    var mCtx = this.measureCanvas_.getContext("2d");
    mCtx.font = state.font;
    var width = Math.ceil(mCtx.measureText(char).width * state.scale);
    var info = glyphAtlas.atlas.add(char, width, glyphAtlas.height, function(ctx, x, y) {
      ctx.font = state.font;
      ctx.fillStyle = state.fillColor;
      ctx.strokeStyle = state.strokeColor;
      ctx.lineWidth = state.lineWidth;
      ctx.lineCap = state.lineCap;
      ctx.lineJoin = state.lineJoin;
      ctx.miterLimit = state.miterLimit;
      ctx.textAlign = "left";
      ctx.textBaseline = "top";
      if (ol.has.CANVAS_LINE_DASH && state.lineDash) {
        ctx.setLineDash(state.lineDash);
        ctx.lineDashOffset = state.lineDashOffset;
      }
      if (state.scale !== 1) {
        ctx.setTransform(state.scale, 0, 0, state.scale, 0, 0);
      }
      if (state.strokeColor) {
        ctx.strokeText(char, x, y);
      }
      if (state.fillColor) {
        ctx.fillText(char, x, y);
      }
    });
    if (info) {
      glyphAtlas.width[char] = width;
    }
  }
};
ol.render.webgl.TextReplay.prototype.finish = function(context) {
  var gl = context.getGL();
  this.groupIndices.push(this.indices.length);
  this.hitDetectionGroupIndices = this.groupIndices;
  this.verticesBuffer = new ol.webgl.Buffer(this.vertices);
  this.indicesBuffer = new ol.webgl.Buffer(this.indices);
  var texturePerImage = {};
  this.createTextures(this.textures_, this.images_, texturePerImage, gl);
  this.state_ = {strokeColor:null, lineCap:undefined, lineDash:null, lineDashOffset:undefined, lineJoin:undefined, lineWidth:0, miterLimit:undefined, fillColor:null, font:undefined, scale:undefined};
  this.text_ = "";
  this.textAlign_ = undefined;
  this.textBaseline_ = undefined;
  this.offsetX_ = undefined;
  this.offsetY_ = undefined;
  this.images_ = null;
  this.atlases_ = {};
  this.currAtlas_ = undefined;
  ol.render.webgl.TextureReplay.prototype.finish.call(this, context);
};
ol.render.webgl.TextReplay.prototype.setTextStyle = function(textStyle) {
  var state = this.state_;
  var textFillStyle = textStyle.getFill();
  var textStrokeStyle = textStyle.getStroke();
  if (!textStyle || !textStyle.getText() || !textFillStyle && !textStrokeStyle) {
    this.text_ = "";
  } else {
    if (!textFillStyle) {
      state.fillColor = null;
    } else {
      var textFillStyleColor = textFillStyle.getColor();
      state.fillColor = ol.colorlike.asColorLike(textFillStyleColor ? textFillStyleColor : ol.render.webgl.defaultFillStyle);
    }
    if (!textStrokeStyle) {
      state.strokeColor = null;
      state.lineWidth = 0;
    } else {
      var textStrokeStyleColor = textStrokeStyle.getColor();
      state.strokeColor = ol.colorlike.asColorLike(textStrokeStyleColor ? textStrokeStyleColor : ol.render.webgl.defaultStrokeStyle);
      state.lineWidth = textStrokeStyle.getWidth() || ol.render.webgl.defaultLineWidth;
      state.lineCap = textStrokeStyle.getLineCap() || ol.render.webgl.defaultLineCap;
      state.lineDashOffset = textStrokeStyle.getLineDashOffset() || ol.render.webgl.defaultLineDashOffset;
      state.lineJoin = textStrokeStyle.getLineJoin() || ol.render.webgl.defaultLineJoin;
      state.miterLimit = textStrokeStyle.getMiterLimit() || ol.render.webgl.defaultMiterLimit;
      var lineDash = textStrokeStyle.getLineDash();
      state.lineDash = lineDash ? lineDash.slice() : ol.render.webgl.defaultLineDash;
    }
    state.font = textStyle.getFont() || ol.render.webgl.defaultFont;
    state.scale = textStyle.getScale() || 1;
    this.text_ = textStyle.getText();
    var textAlign = ol.render.replay.TEXT_ALIGN[textStyle.getTextAlign()];
    var textBaseline = ol.render.replay.TEXT_ALIGN[textStyle.getTextBaseline()];
    this.textAlign_ = textAlign === undefined ? ol.render.webgl.defaultTextAlign : textAlign;
    this.textBaseline_ = textBaseline === undefined ? ol.render.webgl.defaultTextBaseline : textBaseline;
    this.offsetX_ = textStyle.getOffsetX() || 0;
    this.offsetY_ = textStyle.getOffsetY() || 0;
    this.rotateWithView = !!textStyle.getRotateWithView();
    this.rotation = textStyle.getRotation() || 0;
    this.currAtlas_ = this.getAtlas_(state);
  }
};
ol.render.webgl.TextReplay.prototype.getAtlas_ = function(state) {
  var params = [];
  var i;
  for (i in state) {
    if (state[i] || state[i] === 0) {
      if (Array.isArray(state[i])) {
        params = params.concat(state[i]);
      } else {
        params.push(state[i]);
      }
    }
  }
  var hash = this.calculateHash_(params);
  if (!this.atlases_[hash]) {
    var mCtx = this.measureCanvas_.getContext("2d");
    mCtx.font = state.font;
    var height = Math.ceil((mCtx.measureText("M").width * 1.5 + state.lineWidth / 2) * state.scale);
    this.atlases_[hash] = {atlas:new ol.style.AtlasManager({space:state.lineWidth + 1}), width:{}, height:height};
  }
  return this.atlases_[hash];
};
ol.render.webgl.TextReplay.prototype.calculateHash_ = function(params) {
  var i, ii;
  var hash = "";
  for (i = 0, ii = params.length; i < ii; ++i) {
    hash += params[i];
  }
  return hash;
};
ol.render.webgl.TextReplay.prototype.getTextures = function(opt_all) {
  return this.textures_;
};
ol.render.webgl.TextReplay.prototype.getHitDetectionTextures = function() {
  return this.textures_;
};
goog.provide("ol.render.webgl.ReplayGroup");
goog.require("ol");
goog.require("ol.array");
goog.require("ol.extent");
goog.require("ol.obj");
goog.require("ol.render.replay");
goog.require("ol.render.ReplayGroup");
goog.require("ol.render.webgl.CircleReplay");
goog.require("ol.render.webgl.ImageReplay");
goog.require("ol.render.webgl.LineStringReplay");
goog.require("ol.render.webgl.PolygonReplay");
goog.require("ol.render.webgl.TextReplay");
ol.render.webgl.ReplayGroup = function(tolerance, maxExtent, opt_renderBuffer) {
  ol.render.ReplayGroup.call(this);
  this.maxExtent_ = maxExtent;
  this.tolerance_ = tolerance;
  this.renderBuffer_ = opt_renderBuffer;
  this.replaysByZIndex_ = {};
};
ol.inherits(ol.render.webgl.ReplayGroup, ol.render.ReplayGroup);
ol.render.webgl.ReplayGroup.prototype.addDeclutter = function(style, group) {
};
ol.render.webgl.ReplayGroup.prototype.getDeleteResourcesFunction = function(context) {
  var functions = [];
  var zKey;
  for (zKey in this.replaysByZIndex_) {
    var replays = this.replaysByZIndex_[zKey];
    var replayKey;
    for (replayKey in replays) {
      functions.push(replays[replayKey].getDeleteResourcesFunction(context));
    }
  }
  return function() {
    var length = functions.length;
    var result;
    for (var i = 0; i < length; i++) {
      result = functions[i].apply(this, arguments);
    }
    return result;
  };
};
ol.render.webgl.ReplayGroup.prototype.finish = function(context) {
  var zKey;
  for (zKey in this.replaysByZIndex_) {
    var replays = this.replaysByZIndex_[zKey];
    var replayKey;
    for (replayKey in replays) {
      replays[replayKey].finish(context);
    }
  }
};
ol.render.webgl.ReplayGroup.prototype.getReplay = function(zIndex, replayType) {
  var zIndexKey = zIndex !== undefined ? zIndex.toString() : "0";
  var replays = this.replaysByZIndex_[zIndexKey];
  if (replays === undefined) {
    replays = {};
    this.replaysByZIndex_[zIndexKey] = replays;
  }
  var replay = replays[replayType];
  if (replay === undefined) {
    var Constructor = ol.render.webgl.ReplayGroup.BATCH_CONSTRUCTORS_[replayType];
    replay = new Constructor(this.tolerance_, this.maxExtent_);
    replays[replayType] = replay;
  }
  return replay;
};
ol.render.webgl.ReplayGroup.prototype.isEmpty = function() {
  return ol.obj.isEmpty(this.replaysByZIndex_);
};
ol.render.webgl.ReplayGroup.prototype.replay = function(context, center, resolution, rotation, size, pixelRatio, opacity, skippedFeaturesHash) {
  var zs = Object.keys(this.replaysByZIndex_).map(Number);
  zs.sort(ol.array.numberSafeCompareFunction);
  var i, ii, j, jj, replays, replay;
  for (i = 0, ii = zs.length; i < ii; ++i) {
    replays = this.replaysByZIndex_[zs[i].toString()];
    for (j = 0, jj = ol.render.replay.ORDER.length; j < jj; ++j) {
      replay = replays[ol.render.replay.ORDER[j]];
      if (replay !== undefined) {
        replay.replay(context, center, resolution, rotation, size, pixelRatio, opacity, skippedFeaturesHash, undefined, false);
      }
    }
  }
};
ol.render.webgl.ReplayGroup.prototype.replayHitDetection_ = function(context, center, resolution, rotation, size, pixelRatio, opacity, skippedFeaturesHash, featureCallback, oneByOne, opt_hitExtent) {
  var zs = Object.keys(this.replaysByZIndex_).map(Number);
  zs.sort(function(a, b) {
    return b - a;
  });
  var i, ii, j, replays, replay, result;
  for (i = 0, ii = zs.length; i < ii; ++i) {
    replays = this.replaysByZIndex_[zs[i].toString()];
    for (j = ol.render.replay.ORDER.length - 1; j >= 0; --j) {
      replay = replays[ol.render.replay.ORDER[j]];
      if (replay !== undefined) {
        result = replay.replay(context, center, resolution, rotation, size, pixelRatio, opacity, skippedFeaturesHash, featureCallback, oneByOne, opt_hitExtent);
        if (result) {
          return result;
        }
      }
    }
  }
  return undefined;
};
ol.render.webgl.ReplayGroup.prototype.forEachFeatureAtCoordinate = function(coordinate, context, center, resolution, rotation, size, pixelRatio, opacity, skippedFeaturesHash, callback) {
  var gl = context.getGL();
  gl.bindFramebuffer(gl.FRAMEBUFFER, context.getHitDetectionFramebuffer());
  var hitExtent;
  if (this.renderBuffer_ !== undefined) {
    hitExtent = ol.extent.buffer(ol.extent.createOrUpdateFromCoordinate(coordinate), resolution * this.renderBuffer_);
  }
  return this.replayHitDetection_(context, coordinate, resolution, rotation, ol.render.webgl.ReplayGroup.HIT_DETECTION_SIZE_, pixelRatio, opacity, skippedFeaturesHash, function(feature) {
    var imageData = new Uint8Array(4);
    gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, imageData);
    if (imageData[3] > 0) {
      var result = callback(feature);
      if (result) {
        return result;
      }
    }
  }, true, hitExtent);
};
ol.render.webgl.ReplayGroup.prototype.hasFeatureAtCoordinate = function(coordinate, context, center, resolution, rotation, size, pixelRatio, opacity, skippedFeaturesHash) {
  var gl = context.getGL();
  gl.bindFramebuffer(gl.FRAMEBUFFER, context.getHitDetectionFramebuffer());
  var hasFeature = this.replayHitDetection_(context, coordinate, resolution, rotation, ol.render.webgl.ReplayGroup.HIT_DETECTION_SIZE_, pixelRatio, opacity, skippedFeaturesHash, function(feature) {
    var imageData = new Uint8Array(4);
    gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, imageData);
    return imageData[3] > 0;
  }, false);
  return hasFeature !== undefined;
};
ol.render.webgl.ReplayGroup.HIT_DETECTION_SIZE_ = [1, 1];
ol.render.webgl.ReplayGroup.BATCH_CONSTRUCTORS_ = {"Circle":ol.render.webgl.CircleReplay, "Image":ol.render.webgl.ImageReplay, "LineString":ol.render.webgl.LineStringReplay, "Polygon":ol.render.webgl.PolygonReplay, "Text":ol.render.webgl.TextReplay};
goog.provide("ol.render.webgl.Immediate");
goog.require("ol");
goog.require("ol.extent");
goog.require("ol.geom.GeometryType");
goog.require("ol.render.ReplayType");
goog.require("ol.render.VectorContext");
goog.require("ol.render.webgl.ReplayGroup");
ol.render.webgl.Immediate = function(context, center, resolution, rotation, size, extent, pixelRatio) {
  ol.render.VectorContext.call(this);
  this.context_ = context;
  this.center_ = center;
  this.extent_ = extent;
  this.pixelRatio_ = pixelRatio;
  this.size_ = size;
  this.rotation_ = rotation;
  this.resolution_ = resolution;
  this.imageStyle_ = null;
  this.fillStyle_ = null;
  this.strokeStyle_ = null;
  this.textStyle_ = null;
};
ol.inherits(ol.render.webgl.Immediate, ol.render.VectorContext);
ol.render.webgl.Immediate.prototype.drawText_ = function(replayGroup, geometry) {
  var context = this.context_;
  var replay = replayGroup.getReplay(0, ol.render.ReplayType.TEXT);
  replay.setTextStyle(this.textStyle_);
  replay.drawText(geometry, null);
  replay.finish(context);
  var opacity = 1;
  var skippedFeatures = {};
  var featureCallback;
  var oneByOne = false;
  replay.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback, oneByOne);
  replay.getDeleteResourcesFunction(context)();
};
ol.render.webgl.Immediate.prototype.setStyle = function(style) {
  this.setFillStrokeStyle(style.getFill(), style.getStroke());
  this.setImageStyle(style.getImage());
  this.setTextStyle(style.getText());
};
ol.render.webgl.Immediate.prototype.drawGeometry = function(geometry) {
  var type = geometry.getType();
  switch(type) {
    case ol.geom.GeometryType.POINT:
      this.drawPoint(geometry, null);
      break;
    case ol.geom.GeometryType.LINE_STRING:
      this.drawLineString(geometry, null);
      break;
    case ol.geom.GeometryType.POLYGON:
      this.drawPolygon(geometry, null);
      break;
    case ol.geom.GeometryType.MULTI_POINT:
      this.drawMultiPoint(geometry, null);
      break;
    case ol.geom.GeometryType.MULTI_LINE_STRING:
      this.drawMultiLineString(geometry, null);
      break;
    case ol.geom.GeometryType.MULTI_POLYGON:
      this.drawMultiPolygon(geometry, null);
      break;
    case ol.geom.GeometryType.GEOMETRY_COLLECTION:
      this.drawGeometryCollection(geometry, null);
      break;
    case ol.geom.GeometryType.CIRCLE:
      this.drawCircle(geometry, null);
      break;
    default:
  }
};
ol.render.webgl.Immediate.prototype.drawFeature = function(feature, style) {
  var geometry = style.getGeometryFunction()(feature);
  if (!geometry || !ol.extent.intersects(this.extent_, geometry.getExtent())) {
    return;
  }
  this.setStyle(style);
  this.drawGeometry(geometry);
};
ol.render.webgl.Immediate.prototype.drawGeometryCollection = function(geometry, data) {
  var geometries = geometry.getGeometriesArray();
  var i, ii;
  for (i = 0, ii = geometries.length; i < ii; ++i) {
    this.drawGeometry(geometries[i]);
  }
};
ol.render.webgl.Immediate.prototype.drawPoint = function(geometry, data) {
  var context = this.context_;
  var replayGroup = new ol.render.webgl.ReplayGroup(1, this.extent_);
  var replay = replayGroup.getReplay(0, ol.render.ReplayType.IMAGE);
  replay.setImageStyle(this.imageStyle_);
  replay.drawPoint(geometry, data);
  replay.finish(context);
  var opacity = 1;
  var skippedFeatures = {};
  var featureCallback;
  var oneByOne = false;
  replay.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback, oneByOne);
  replay.getDeleteResourcesFunction(context)();
  if (this.textStyle_) {
    this.drawText_(replayGroup, geometry);
  }
};
ol.render.webgl.Immediate.prototype.drawMultiPoint = function(geometry, data) {
  var context = this.context_;
  var replayGroup = new ol.render.webgl.ReplayGroup(1, this.extent_);
  var replay = replayGroup.getReplay(0, ol.render.ReplayType.IMAGE);
  replay.setImageStyle(this.imageStyle_);
  replay.drawMultiPoint(geometry, data);
  replay.finish(context);
  var opacity = 1;
  var skippedFeatures = {};
  var featureCallback;
  var oneByOne = false;
  replay.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback, oneByOne);
  replay.getDeleteResourcesFunction(context)();
  if (this.textStyle_) {
    this.drawText_(replayGroup, geometry);
  }
};
ol.render.webgl.Immediate.prototype.drawLineString = function(geometry, data) {
  var context = this.context_;
  var replayGroup = new ol.render.webgl.ReplayGroup(1, this.extent_);
  var replay = replayGroup.getReplay(0, ol.render.ReplayType.LINE_STRING);
  replay.setFillStrokeStyle(null, this.strokeStyle_);
  replay.drawLineString(geometry, data);
  replay.finish(context);
  var opacity = 1;
  var skippedFeatures = {};
  var featureCallback;
  var oneByOne = false;
  replay.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback, oneByOne);
  replay.getDeleteResourcesFunction(context)();
  if (this.textStyle_) {
    this.drawText_(replayGroup, geometry);
  }
};
ol.render.webgl.Immediate.prototype.drawMultiLineString = function(geometry, data) {
  var context = this.context_;
  var replayGroup = new ol.render.webgl.ReplayGroup(1, this.extent_);
  var replay = replayGroup.getReplay(0, ol.render.ReplayType.LINE_STRING);
  replay.setFillStrokeStyle(null, this.strokeStyle_);
  replay.drawMultiLineString(geometry, data);
  replay.finish(context);
  var opacity = 1;
  var skippedFeatures = {};
  var featureCallback;
  var oneByOne = false;
  replay.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback, oneByOne);
  replay.getDeleteResourcesFunction(context)();
  if (this.textStyle_) {
    this.drawText_(replayGroup, geometry);
  }
};
ol.render.webgl.Immediate.prototype.drawPolygon = function(geometry, data) {
  var context = this.context_;
  var replayGroup = new ol.render.webgl.ReplayGroup(1, this.extent_);
  var replay = replayGroup.getReplay(0, ol.render.ReplayType.POLYGON);
  replay.setFillStrokeStyle(this.fillStyle_, this.strokeStyle_);
  replay.drawPolygon(geometry, data);
  replay.finish(context);
  var opacity = 1;
  var skippedFeatures = {};
  var featureCallback;
  var oneByOne = false;
  replay.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback, oneByOne);
  replay.getDeleteResourcesFunction(context)();
  if (this.textStyle_) {
    this.drawText_(replayGroup, geometry);
  }
};
ol.render.webgl.Immediate.prototype.drawMultiPolygon = function(geometry, data) {
  var context = this.context_;
  var replayGroup = new ol.render.webgl.ReplayGroup(1, this.extent_);
  var replay = replayGroup.getReplay(0, ol.render.ReplayType.POLYGON);
  replay.setFillStrokeStyle(this.fillStyle_, this.strokeStyle_);
  replay.drawMultiPolygon(geometry, data);
  replay.finish(context);
  var opacity = 1;
  var skippedFeatures = {};
  var featureCallback;
  var oneByOne = false;
  replay.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback, oneByOne);
  replay.getDeleteResourcesFunction(context)();
  if (this.textStyle_) {
    this.drawText_(replayGroup, geometry);
  }
};
ol.render.webgl.Immediate.prototype.drawCircle = function(geometry, data) {
  var context = this.context_;
  var replayGroup = new ol.render.webgl.ReplayGroup(1, this.extent_);
  var replay = replayGroup.getReplay(0, ol.render.ReplayType.CIRCLE);
  replay.setFillStrokeStyle(this.fillStyle_, this.strokeStyle_);
  replay.drawCircle(geometry, data);
  replay.finish(context);
  var opacity = 1;
  var skippedFeatures = {};
  var featureCallback;
  var oneByOne = false;
  replay.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback, oneByOne);
  replay.getDeleteResourcesFunction(context)();
  if (this.textStyle_) {
    this.drawText_(replayGroup, geometry);
  }
};
ol.render.webgl.Immediate.prototype.setImageStyle = function(imageStyle) {
  this.imageStyle_ = imageStyle;
};
ol.render.webgl.Immediate.prototype.setFillStrokeStyle = function(fillStyle, strokeStyle) {
  this.fillStyle_ = fillStyle;
  this.strokeStyle_ = strokeStyle;
};
ol.render.webgl.Immediate.prototype.setTextStyle = function(textStyle) {
  this.textStyle_ = textStyle;
};
goog.provide("ol.renderer.webgl.defaultmapshader");
goog.require("ol");
goog.require("ol.webgl.Fragment");
goog.require("ol.webgl.Vertex");
ol.renderer.webgl.defaultmapshader.fragment = new ol.webgl.Fragment(ol.DEBUG_WEBGL ? "precision mediump float;\nvarying vec2 v_texCoord;\n\n\nuniform float u_opacity;\nuniform sampler2D u_texture;\n\nvoid main(void) {\n  vec4 texColor = texture2D(u_texture, v_texCoord);\n  gl_FragColor.rgb = texColor.rgb;\n  gl_FragColor.a = texColor.a * u_opacity;\n}\n" : "precision mediump float;varying vec2 a;uniform float f;uniform sampler2D g;void main(void){vec4 texColor=texture2D(g,a);gl_FragColor.rgb=texColor.rgb;gl_FragColor.a=texColor.a*f;}");
ol.renderer.webgl.defaultmapshader.vertex = new ol.webgl.Vertex(ol.DEBUG_WEBGL ? "varying vec2 v_texCoord;\n\n\nattribute vec2 a_position;\nattribute vec2 a_texCoord;\n\nuniform mat4 u_texCoordMatrix;\nuniform mat4 u_projectionMatrix;\n\nvoid main(void) {\n  gl_Position = u_projectionMatrix * vec4(a_position, 0., 1.);\n  v_texCoord = (u_texCoordMatrix * vec4(a_texCoord, 0., 1.)).st;\n}\n\n\n" : "varying vec2 a;attribute vec2 b;attribute vec2 c;uniform mat4 d;uniform mat4 e;void main(void){gl_Position=e*vec4(b,0.,1.);a=(d*vec4(c,0.,1.)).st;}");
goog.provide("ol.renderer.webgl.defaultmapshader.Locations");
goog.require("ol");
ol.renderer.webgl.defaultmapshader.Locations = function(gl, program) {
  this.u_texCoordMatrix = gl.getUniformLocation(program, ol.DEBUG_WEBGL ? "u_texCoordMatrix" : "d");
  this.u_projectionMatrix = gl.getUniformLocation(program, ol.DEBUG_WEBGL ? "u_projectionMatrix" : "e");
  this.u_opacity = gl.getUniformLocation(program, ol.DEBUG_WEBGL ? "u_opacity" : "f");
  this.u_texture = gl.getUniformLocation(program, ol.DEBUG_WEBGL ? "u_texture" : "g");
  this.a_position = gl.getAttribLocation(program, ol.DEBUG_WEBGL ? "a_position" : "b");
  this.a_texCoord = gl.getAttribLocation(program, ol.DEBUG_WEBGL ? "a_texCoord" : "c");
};
goog.provide("ol.renderer.webgl.Layer");
goog.require("ol");
goog.require("ol.render.Event");
goog.require("ol.render.EventType");
goog.require("ol.render.webgl.Immediate");
goog.require("ol.renderer.Layer");
goog.require("ol.renderer.webgl.defaultmapshader");
goog.require("ol.renderer.webgl.defaultmapshader.Locations");
goog.require("ol.transform");
goog.require("ol.vec.Mat4");
goog.require("ol.webgl");
goog.require("ol.webgl.Buffer");
goog.require("ol.webgl.Context");
ol.renderer.webgl.Layer = function(mapRenderer, layer) {
  ol.renderer.Layer.call(this, layer);
  this.mapRenderer = mapRenderer;
  this.arrayBuffer_ = new ol.webgl.Buffer([-1, -1, 0, 0, 1, -1, 1, 0, -1, 1, 0, 1, 1, 1, 1, 1]);
  this.texture = null;
  this.framebuffer = null;
  this.framebufferDimension = undefined;
  this.texCoordMatrix = ol.transform.create();
  this.projectionMatrix = ol.transform.create();
  this.tmpMat4_ = ol.vec.Mat4.create();
  this.defaultLocations_ = null;
};
ol.inherits(ol.renderer.webgl.Layer, ol.renderer.Layer);
ol.renderer.webgl.Layer.prototype.bindFramebuffer = function(frameState, framebufferDimension) {
  var gl = this.mapRenderer.getGL();
  if (this.framebufferDimension === undefined || this.framebufferDimension != framebufferDimension) {
    var postRenderFunction = function(gl, framebuffer, texture) {
      if (!gl.isContextLost()) {
        gl.deleteFramebuffer(framebuffer);
        gl.deleteTexture(texture);
      }
    }.bind(null, gl, this.framebuffer, this.texture);
    frameState.postRenderFunctions.push(postRenderFunction);
    var texture = ol.webgl.Context.createEmptyTexture(gl, framebufferDimension, framebufferDimension);
    var framebuffer = gl.createFramebuffer();
    gl.bindFramebuffer(ol.webgl.FRAMEBUFFER, framebuffer);
    gl.framebufferTexture2D(ol.webgl.FRAMEBUFFER, ol.webgl.COLOR_ATTACHMENT0, ol.webgl.TEXTURE_2D, texture, 0);
    this.texture = texture;
    this.framebuffer = framebuffer;
    this.framebufferDimension = framebufferDimension;
  } else {
    gl.bindFramebuffer(ol.webgl.FRAMEBUFFER, this.framebuffer);
  }
};
ol.renderer.webgl.Layer.prototype.composeFrame = function(frameState, layerState, context) {
  this.dispatchComposeEvent_(ol.render.EventType.PRECOMPOSE, context, frameState);
  context.bindBuffer(ol.webgl.ARRAY_BUFFER, this.arrayBuffer_);
  var gl = context.getGL();
  var fragmentShader = ol.renderer.webgl.defaultmapshader.fragment;
  var vertexShader = ol.renderer.webgl.defaultmapshader.vertex;
  var program = context.getProgram(fragmentShader, vertexShader);
  var locations;
  if (!this.defaultLocations_) {
    locations = new ol.renderer.webgl.defaultmapshader.Locations(gl, program);
    this.defaultLocations_ = locations;
  } else {
    locations = this.defaultLocations_;
  }
  if (context.useProgram(program)) {
    gl.enableVertexAttribArray(locations.a_position);
    gl.vertexAttribPointer(locations.a_position, 2, ol.webgl.FLOAT, false, 16, 0);
    gl.enableVertexAttribArray(locations.a_texCoord);
    gl.vertexAttribPointer(locations.a_texCoord, 2, ol.webgl.FLOAT, false, 16, 8);
    gl.uniform1i(locations.u_texture, 0);
  }
  gl.uniformMatrix4fv(locations.u_texCoordMatrix, false, ol.vec.Mat4.fromTransform(this.tmpMat4_, this.getTexCoordMatrix()));
  gl.uniformMatrix4fv(locations.u_projectionMatrix, false, ol.vec.Mat4.fromTransform(this.tmpMat4_, this.getProjectionMatrix()));
  gl.uniform1f(locations.u_opacity, layerState.opacity);
  gl.bindTexture(ol.webgl.TEXTURE_2D, this.getTexture());
  gl.drawArrays(ol.webgl.TRIANGLE_STRIP, 0, 4);
  this.dispatchComposeEvent_(ol.render.EventType.POSTCOMPOSE, context, frameState);
};
ol.renderer.webgl.Layer.prototype.dispatchComposeEvent_ = function(type, context, frameState) {
  var layer = this.getLayer();
  if (layer.hasListener(type)) {
    var viewState = frameState.viewState;
    var resolution = viewState.resolution;
    var pixelRatio = frameState.pixelRatio;
    var extent = frameState.extent;
    var center = viewState.center;
    var rotation = viewState.rotation;
    var size = frameState.size;
    var render = new ol.render.webgl.Immediate(context, center, resolution, rotation, size, extent, pixelRatio);
    var composeEvent = new ol.render.Event(type, render, frameState, null, context);
    layer.dispatchEvent(composeEvent);
  }
};
ol.renderer.webgl.Layer.prototype.getTexCoordMatrix = function() {
  return this.texCoordMatrix;
};
ol.renderer.webgl.Layer.prototype.getTexture = function() {
  return this.texture;
};
ol.renderer.webgl.Layer.prototype.getProjectionMatrix = function() {
  return this.projectionMatrix;
};
ol.renderer.webgl.Layer.prototype.handleWebGLContextLost = function() {
  this.texture = null;
  this.framebuffer = null;
  this.framebufferDimension = undefined;
};
ol.renderer.webgl.Layer.prototype.prepareFrame = function(frameState, layerState, context) {
};
ol.renderer.webgl.Layer.prototype.forEachLayerAtPixel = function(pixel, frameState, callback, thisArg) {
};
goog.provide("ol.renderer.webgl.ImageLayer");
goog.require("ol");
goog.require("ol.LayerType");
goog.require("ol.ViewHint");
goog.require("ol.dom");
goog.require("ol.extent");
goog.require("ol.functions");
goog.require("ol.renderer.Type");
goog.require("ol.renderer.webgl.Layer");
goog.require("ol.transform");
goog.require("ol.webgl");
goog.require("ol.webgl.Context");
ol.renderer.webgl.ImageLayer = function(mapRenderer, imageLayer) {
  ol.renderer.webgl.Layer.call(this, mapRenderer, imageLayer);
  this.image_ = null;
  this.hitCanvasContext_ = null;
  this.hitTransformationMatrix_ = null;
};
ol.inherits(ol.renderer.webgl.ImageLayer, ol.renderer.webgl.Layer);
ol.renderer.webgl.ImageLayer["handles"] = function(type, layer) {
  return type === ol.renderer.Type.WEBGL && layer.getType() === ol.LayerType.IMAGE;
};
ol.renderer.webgl.ImageLayer["create"] = function(mapRenderer, layer) {
  return new ol.renderer.webgl.ImageLayer(mapRenderer, layer);
};
ol.renderer.webgl.ImageLayer.prototype.createTexture_ = function(image) {
  var imageElement = image.getImage();
  var gl = this.mapRenderer.getGL();
  return ol.webgl.Context.createTexture(gl, imageElement, ol.webgl.CLAMP_TO_EDGE, ol.webgl.CLAMP_TO_EDGE);
};
ol.renderer.webgl.ImageLayer.prototype.forEachFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, callback, thisArg) {
  var layer = this.getLayer();
  var source = layer.getSource();
  var resolution = frameState.viewState.resolution;
  var rotation = frameState.viewState.rotation;
  var skippedFeatureUids = frameState.skippedFeatureUids;
  return source.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, skippedFeatureUids, function(feature) {
    return callback.call(thisArg, feature, layer);
  });
};
ol.renderer.webgl.ImageLayer.prototype.prepareFrame = function(frameState, layerState, context) {
  var gl = this.mapRenderer.getGL();
  var pixelRatio = frameState.pixelRatio;
  var viewState = frameState.viewState;
  var viewCenter = viewState.center;
  var viewResolution = viewState.resolution;
  var viewRotation = viewState.rotation;
  var image = this.image_;
  var texture = this.texture;
  var imageLayer = this.getLayer();
  var imageSource = imageLayer.getSource();
  var hints = frameState.viewHints;
  var renderedExtent = frameState.extent;
  if (layerState.extent !== undefined) {
    renderedExtent = ol.extent.getIntersection(renderedExtent, layerState.extent);
  }
  if (!hints[ol.ViewHint.ANIMATING] && !hints[ol.ViewHint.INTERACTING] && !ol.extent.isEmpty(renderedExtent)) {
    var projection = viewState.projection;
    if (!ol.ENABLE_RASTER_REPROJECTION) {
      var sourceProjection = imageSource.getProjection();
      if (sourceProjection) {
        projection = sourceProjection;
      }
    }
    var image_ = imageSource.getImage(renderedExtent, viewResolution, pixelRatio, projection);
    if (image_) {
      var loaded = this.loadImage(image_);
      if (loaded) {
        image = image_;
        texture = this.createTexture_(image_);
        if (this.texture) {
          var postRenderFunction = function(gl, texture) {
            if (!gl.isContextLost()) {
              gl.deleteTexture(texture);
            }
          }.bind(null, gl, this.texture);
          frameState.postRenderFunctions.push(postRenderFunction);
        }
      }
    }
  }
  if (image) {
    var canvas = this.mapRenderer.getContext().getCanvas();
    this.updateProjectionMatrix_(canvas.width, canvas.height, pixelRatio, viewCenter, viewResolution, viewRotation, image.getExtent());
    this.hitTransformationMatrix_ = null;
    var texCoordMatrix = this.texCoordMatrix;
    ol.transform.reset(texCoordMatrix);
    ol.transform.scale(texCoordMatrix, 1, -1);
    ol.transform.translate(texCoordMatrix, 0, -1);
    this.image_ = image;
    this.texture = texture;
    this.updateLogos(frameState, imageSource);
  }
  return !!image;
};
ol.renderer.webgl.ImageLayer.prototype.updateProjectionMatrix_ = function(canvasWidth, canvasHeight, pixelRatio, viewCenter, viewResolution, viewRotation, imageExtent) {
  var canvasExtentWidth = canvasWidth * viewResolution;
  var canvasExtentHeight = canvasHeight * viewResolution;
  var projectionMatrix = this.projectionMatrix;
  ol.transform.reset(projectionMatrix);
  ol.transform.scale(projectionMatrix, pixelRatio * 2 / canvasExtentWidth, pixelRatio * 2 / canvasExtentHeight);
  ol.transform.rotate(projectionMatrix, -viewRotation);
  ol.transform.translate(projectionMatrix, imageExtent[0] - viewCenter[0], imageExtent[1] - viewCenter[1]);
  ol.transform.scale(projectionMatrix, (imageExtent[2] - imageExtent[0]) / 2, (imageExtent[3] - imageExtent[1]) / 2);
  ol.transform.translate(projectionMatrix, 1, 1);
};
ol.renderer.webgl.ImageLayer.prototype.hasFeatureAtCoordinate = function(coordinate, frameState) {
  var hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, 0, ol.functions.TRUE, this);
  return hasFeature !== undefined;
};
ol.renderer.webgl.ImageLayer.prototype.forEachLayerAtPixel = function(pixel, frameState, callback, thisArg) {
  if (!this.image_ || !this.image_.getImage()) {
    return undefined;
  }
  if (this.getLayer().getSource().forEachFeatureAtCoordinate !== ol.nullFunction) {
    var coordinate = ol.transform.apply(frameState.pixelToCoordinateTransform, pixel.slice());
    var hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, 0, ol.functions.TRUE, this);
    if (hasFeature) {
      return callback.call(thisArg, this.getLayer(), null);
    } else {
      return undefined;
    }
  } else {
    var imageSize = [this.image_.getImage().width, this.image_.getImage().height];
    if (!this.hitTransformationMatrix_) {
      this.hitTransformationMatrix_ = this.getHitTransformationMatrix_(frameState.size, imageSize);
    }
    var pixelOnFrameBuffer = ol.transform.apply(this.hitTransformationMatrix_, pixel.slice());
    if (pixelOnFrameBuffer[0] < 0 || pixelOnFrameBuffer[0] > imageSize[0] || pixelOnFrameBuffer[1] < 0 || pixelOnFrameBuffer[1] > imageSize[1]) {
      return undefined;
    }
    if (!this.hitCanvasContext_) {
      this.hitCanvasContext_ = ol.dom.createCanvasContext2D(1, 1);
    }
    this.hitCanvasContext_.clearRect(0, 0, 1, 1);
    this.hitCanvasContext_.drawImage(this.image_.getImage(), pixelOnFrameBuffer[0], pixelOnFrameBuffer[1], 1, 1, 0, 0, 1, 1);
    var imageData = this.hitCanvasContext_.getImageData(0, 0, 1, 1).data;
    if (imageData[3] > 0) {
      return callback.call(thisArg, this.getLayer(), imageData);
    } else {
      return undefined;
    }
  }
};
ol.renderer.webgl.ImageLayer.prototype.getHitTransformationMatrix_ = function(mapSize, imageSize) {
  var mapCoordTransform = ol.transform.create();
  ol.transform.translate(mapCoordTransform, -1, -1);
  ol.transform.scale(mapCoordTransform, 2 / mapSize[0], 2 / mapSize[1]);
  ol.transform.translate(mapCoordTransform, 0, mapSize[1]);
  ol.transform.scale(mapCoordTransform, 1, -1);
  var projectionMatrixInv = ol.transform.invert(this.projectionMatrix.slice());
  var transform = ol.transform.create();
  ol.transform.translate(transform, 0, imageSize[1]);
  ol.transform.scale(transform, 1, -1);
  ol.transform.scale(transform, imageSize[0] / 2, imageSize[1] / 2);
  ol.transform.translate(transform, 1, 1);
  ol.transform.multiply(transform, projectionMatrixInv);
  ol.transform.multiply(transform, mapCoordTransform);
  return transform;
};
goog.provide("ol.renderer.webgl.Map");
goog.require("ol");
goog.require("ol.array");
goog.require("ol.css");
goog.require("ol.dom");
goog.require("ol.events");
goog.require("ol.has");
goog.require("ol.layer.Layer");
goog.require("ol.render.Event");
goog.require("ol.render.EventType");
goog.require("ol.render.webgl.Immediate");
goog.require("ol.renderer.Map");
goog.require("ol.renderer.Type");
goog.require("ol.source.State");
goog.require("ol.structs.LRUCache");
goog.require("ol.structs.PriorityQueue");
goog.require("ol.webgl");
goog.require("ol.webgl.Context");
goog.require("ol.webgl.ContextEventType");
ol.renderer.webgl.Map = function(container, map) {
  ol.renderer.Map.call(this, container, map);
  this.canvas_ = document.createElement("CANVAS");
  this.canvas_.style.width = "100%";
  this.canvas_.style.height = "100%";
  this.canvas_.style.display = "block";
  this.canvas_.className = ol.css.CLASS_UNSELECTABLE;
  container.insertBefore(this.canvas_, container.childNodes[0] || null);
  this.clipTileCanvasWidth_ = 0;
  this.clipTileCanvasHeight_ = 0;
  this.clipTileContext_ = ol.dom.createCanvasContext2D();
  this.renderedVisible_ = true;
  this.gl_ = ol.webgl.getContext(this.canvas_, {antialias:true, depth:true, failIfMajorPerformanceCaveat:true, preserveDrawingBuffer:false, stencil:true});
  this.context_ = new ol.webgl.Context(this.canvas_, this.gl_);
  ol.events.listen(this.canvas_, ol.webgl.ContextEventType.LOST, this.handleWebGLContextLost, this);
  ol.events.listen(this.canvas_, ol.webgl.ContextEventType.RESTORED, this.handleWebGLContextRestored, this);
  this.textureCache_ = new ol.structs.LRUCache;
  this.focus_ = null;
  this.tileTextureQueue_ = new ol.structs.PriorityQueue(function(element) {
    var tileCenter = element[1];
    var tileResolution = element[2];
    var deltaX = tileCenter[0] - this.focus_[0];
    var deltaY = tileCenter[1] - this.focus_[1];
    return 65536 * Math.log(tileResolution) + Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;
  }.bind(this), function(element) {
    return element[0].getKey();
  });
  this.loadNextTileTexture_ = function(map, frameState) {
    if (!this.tileTextureQueue_.isEmpty()) {
      this.tileTextureQueue_.reprioritize();
      var element = this.tileTextureQueue_.dequeue();
      var tile = element[0];
      var tileSize = element[3];
      var tileGutter = element[4];
      this.bindTileTexture(tile, tileSize, tileGutter, ol.webgl.LINEAR, ol.webgl.LINEAR);
    }
    return false;
  }.bind(this);
  this.textureCacheFrameMarkerCount_ = 0;
  this.initializeGL_();
};
ol.inherits(ol.renderer.webgl.Map, ol.renderer.Map);
ol.renderer.webgl.Map["handles"] = function(type) {
  return ol.has.WEBGL && type === ol.renderer.Type.WEBGL;
};
ol.renderer.webgl.Map["create"] = function(container, map) {
  return new ol.renderer.webgl.Map(container, map);
};
ol.renderer.webgl.Map.prototype.bindTileTexture = function(tile, tileSize, tileGutter, magFilter, minFilter) {
  var gl = this.getGL();
  var tileKey = tile.getKey();
  if (this.textureCache_.containsKey(tileKey)) {
    var textureCacheEntry = this.textureCache_.get(tileKey);
    gl.bindTexture(ol.webgl.TEXTURE_2D, textureCacheEntry.texture);
    if (textureCacheEntry.magFilter != magFilter) {
      gl.texParameteri(ol.webgl.TEXTURE_2D, ol.webgl.TEXTURE_MAG_FILTER, magFilter);
      textureCacheEntry.magFilter = magFilter;
    }
    if (textureCacheEntry.minFilter != minFilter) {
      gl.texParameteri(ol.webgl.TEXTURE_2D, ol.webgl.TEXTURE_MIN_FILTER, minFilter);
      textureCacheEntry.minFilter = minFilter;
    }
  } else {
    var texture = gl.createTexture();
    gl.bindTexture(ol.webgl.TEXTURE_2D, texture);
    if (tileGutter > 0) {
      var clipTileCanvas = this.clipTileContext_.canvas;
      var clipTileContext = this.clipTileContext_;
      if (this.clipTileCanvasWidth_ !== tileSize[0] || this.clipTileCanvasHeight_ !== tileSize[1]) {
        clipTileCanvas.width = tileSize[0];
        clipTileCanvas.height = tileSize[1];
        this.clipTileCanvasWidth_ = tileSize[0];
        this.clipTileCanvasHeight_ = tileSize[1];
      } else {
        clipTileContext.clearRect(0, 0, tileSize[0], tileSize[1]);
      }
      clipTileContext.drawImage(tile.getImage(), tileGutter, tileGutter, tileSize[0], tileSize[1], 0, 0, tileSize[0], tileSize[1]);
      gl.texImage2D(ol.webgl.TEXTURE_2D, 0, ol.webgl.RGBA, ol.webgl.RGBA, ol.webgl.UNSIGNED_BYTE, clipTileCanvas);
    } else {
      gl.texImage2D(ol.webgl.TEXTURE_2D, 0, ol.webgl.RGBA, ol.webgl.RGBA, ol.webgl.UNSIGNED_BYTE, tile.getImage());
    }
    gl.texParameteri(ol.webgl.TEXTURE_2D, ol.webgl.TEXTURE_MAG_FILTER, magFilter);
    gl.texParameteri(ol.webgl.TEXTURE_2D, ol.webgl.TEXTURE_MIN_FILTER, minFilter);
    gl.texParameteri(ol.webgl.TEXTURE_2D, ol.webgl.TEXTURE_WRAP_S, ol.webgl.CLAMP_TO_EDGE);
    gl.texParameteri(ol.webgl.TEXTURE_2D, ol.webgl.TEXTURE_WRAP_T, ol.webgl.CLAMP_TO_EDGE);
    this.textureCache_.set(tileKey, {texture:texture, magFilter:magFilter, minFilter:minFilter});
  }
};
ol.renderer.webgl.Map.prototype.dispatchComposeEvent_ = function(type, frameState) {
  var map = this.getMap();
  if (map.hasListener(type)) {
    var context = this.context_;
    var extent = frameState.extent;
    var size = frameState.size;
    var viewState = frameState.viewState;
    var pixelRatio = frameState.pixelRatio;
    var resolution = viewState.resolution;
    var center = viewState.center;
    var rotation = viewState.rotation;
    var vectorContext = new ol.render.webgl.Immediate(context, center, resolution, rotation, size, extent, pixelRatio);
    var composeEvent = new ol.render.Event(type, vectorContext, frameState, null, context);
    map.dispatchEvent(composeEvent);
  }
};
ol.renderer.webgl.Map.prototype.disposeInternal = function() {
  var gl = this.getGL();
  if (!gl.isContextLost()) {
    this.textureCache_.forEach(function(textureCacheEntry) {
      if (textureCacheEntry) {
        gl.deleteTexture(textureCacheEntry.texture);
      }
    });
  }
  this.context_.dispose();
  ol.renderer.Map.prototype.disposeInternal.call(this);
};
ol.renderer.webgl.Map.prototype.expireCache_ = function(map, frameState) {
  var gl = this.getGL();
  var textureCacheEntry;
  while (this.textureCache_.getCount() - this.textureCacheFrameMarkerCount_ > ol.WEBGL_TEXTURE_CACHE_HIGH_WATER_MARK) {
    textureCacheEntry = this.textureCache_.peekLast();
    if (!textureCacheEntry) {
      if (+this.textureCache_.peekLastKey() == frameState.index) {
        break;
      } else {
        --this.textureCacheFrameMarkerCount_;
      }
    } else {
      gl.deleteTexture(textureCacheEntry.texture);
    }
    this.textureCache_.pop();
  }
};
ol.renderer.webgl.Map.prototype.getContext = function() {
  return this.context_;
};
ol.renderer.webgl.Map.prototype.getGL = function() {
  return this.gl_;
};
ol.renderer.webgl.Map.prototype.getTileTextureQueue = function() {
  return this.tileTextureQueue_;
};
ol.renderer.webgl.Map.prototype.getType = function() {
  return ol.renderer.Type.WEBGL;
};
ol.renderer.webgl.Map.prototype.handleWebGLContextLost = function(event) {
  event.preventDefault();
  this.textureCache_.clear();
  this.textureCacheFrameMarkerCount_ = 0;
  var renderers = this.getLayerRenderers();
  for (var id in renderers) {
    var renderer = renderers[id];
    renderer.handleWebGLContextLost();
  }
};
ol.renderer.webgl.Map.prototype.handleWebGLContextRestored = function() {
  this.initializeGL_();
  this.getMap().render();
};
ol.renderer.webgl.Map.prototype.initializeGL_ = function() {
  var gl = this.gl_;
  gl.activeTexture(ol.webgl.TEXTURE0);
  gl.blendFuncSeparate(ol.webgl.SRC_ALPHA, ol.webgl.ONE_MINUS_SRC_ALPHA, ol.webgl.ONE, ol.webgl.ONE_MINUS_SRC_ALPHA);
  gl.disable(ol.webgl.CULL_FACE);
  gl.disable(ol.webgl.DEPTH_TEST);
  gl.disable(ol.webgl.SCISSOR_TEST);
  gl.disable(ol.webgl.STENCIL_TEST);
};
ol.renderer.webgl.Map.prototype.isTileTextureLoaded = function(tile) {
  return this.textureCache_.containsKey(tile.getKey());
};
ol.renderer.webgl.Map.prototype.renderFrame = function(frameState) {
  var context = this.getContext();
  var gl = this.getGL();
  if (gl.isContextLost()) {
    return false;
  }
  if (!frameState) {
    if (this.renderedVisible_) {
      this.canvas_.style.display = "none";
      this.renderedVisible_ = false;
    }
    return false;
  }
  this.focus_ = frameState.focus;
  this.textureCache_.set((-frameState.index).toString(), null);
  ++this.textureCacheFrameMarkerCount_;
  this.dispatchComposeEvent_(ol.render.EventType.PRECOMPOSE, frameState);
  var layerStatesToDraw = [];
  var layerStatesArray = frameState.layerStatesArray;
  ol.array.stableSort(layerStatesArray, ol.renderer.Map.sortByZIndex);
  var viewResolution = frameState.viewState.resolution;
  var i, ii, layerRenderer, layerState;
  for (i = 0, ii = layerStatesArray.length; i < ii; ++i) {
    layerState = layerStatesArray[i];
    if (ol.layer.Layer.visibleAtResolution(layerState, viewResolution) && layerState.sourceState == ol.source.State.READY) {
      layerRenderer = this.getLayerRenderer(layerState.layer);
      if (layerRenderer.prepareFrame(frameState, layerState, context)) {
        layerStatesToDraw.push(layerState);
      }
    }
  }
  var width = frameState.size[0] * frameState.pixelRatio;
  var height = frameState.size[1] * frameState.pixelRatio;
  if (this.canvas_.width != width || this.canvas_.height != height) {
    this.canvas_.width = width;
    this.canvas_.height = height;
  }
  gl.bindFramebuffer(ol.webgl.FRAMEBUFFER, null);
  gl.clearColor(0, 0, 0, 0);
  gl.clear(ol.webgl.COLOR_BUFFER_BIT);
  gl.enable(ol.webgl.BLEND);
  gl.viewport(0, 0, this.canvas_.width, this.canvas_.height);
  for (i = 0, ii = layerStatesToDraw.length; i < ii; ++i) {
    layerState = layerStatesToDraw[i];
    layerRenderer = this.getLayerRenderer(layerState.layer);
    layerRenderer.composeFrame(frameState, layerState, context);
  }
  if (!this.renderedVisible_) {
    this.canvas_.style.display = "";
    this.renderedVisible_ = true;
  }
  this.calculateMatrices2D(frameState);
  if (this.textureCache_.getCount() - this.textureCacheFrameMarkerCount_ > ol.WEBGL_TEXTURE_CACHE_HIGH_WATER_MARK) {
    frameState.postRenderFunctions.push(this.expireCache_.bind(this));
  }
  if (!this.tileTextureQueue_.isEmpty()) {
    frameState.postRenderFunctions.push(this.loadNextTileTexture_);
    frameState.animate = true;
  }
  this.dispatchComposeEvent_(ol.render.EventType.POSTCOMPOSE, frameState);
  this.scheduleRemoveUnusedLayerRenderers(frameState);
  this.scheduleExpireIconCache(frameState);
};
ol.renderer.webgl.Map.prototype.forEachFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, callback, thisArg, layerFilter, thisArg2) {
  var result;
  if (this.getGL().isContextLost()) {
    return false;
  }
  var viewState = frameState.viewState;
  var layerStates = frameState.layerStatesArray;
  var numLayers = layerStates.length;
  var i;
  for (i = numLayers - 1; i >= 0; --i) {
    var layerState = layerStates[i];
    var layer = layerState.layer;
    if (ol.layer.Layer.visibleAtResolution(layerState, viewState.resolution) && layerFilter.call(thisArg2, layer)) {
      var layerRenderer = this.getLayerRenderer(layer);
      result = layerRenderer.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, thisArg);
      if (result) {
        return result;
      }
    }
  }
  return undefined;
};
ol.renderer.webgl.Map.prototype.hasFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, layerFilter, thisArg) {
  var hasFeature = false;
  if (this.getGL().isContextLost()) {
    return false;
  }
  var viewState = frameState.viewState;
  var layerStates = frameState.layerStatesArray;
  var numLayers = layerStates.length;
  var i;
  for (i = numLayers - 1; i >= 0; --i) {
    var layerState = layerStates[i];
    var layer = layerState.layer;
    if (ol.layer.Layer.visibleAtResolution(layerState, viewState.resolution) && layerFilter.call(thisArg, layer)) {
      var layerRenderer = this.getLayerRenderer(layer);
      hasFeature = layerRenderer.hasFeatureAtCoordinate(coordinate, frameState);
      if (hasFeature) {
        return true;
      }
    }
  }
  return hasFeature;
};
ol.renderer.webgl.Map.prototype.forEachLayerAtPixel = function(pixel, frameState, callback, thisArg, layerFilter, thisArg2) {
  if (this.getGL().isContextLost()) {
    return false;
  }
  var viewState = frameState.viewState;
  var result;
  var layerStates = frameState.layerStatesArray;
  var numLayers = layerStates.length;
  var i;
  for (i = numLayers - 1; i >= 0; --i) {
    var layerState = layerStates[i];
    var layer = layerState.layer;
    if (ol.layer.Layer.visibleAtResolution(layerState, viewState.resolution) && layerFilter.call(thisArg, layer)) {
      var layerRenderer = this.getLayerRenderer(layer);
      result = layerRenderer.forEachLayerAtPixel(pixel, frameState, callback, thisArg);
      if (result) {
        return result;
      }
    }
  }
  return undefined;
};
goog.provide("ol.renderer.webgl.tilelayershader");
goog.require("ol");
goog.require("ol.webgl.Fragment");
goog.require("ol.webgl.Vertex");
ol.renderer.webgl.tilelayershader.fragment = new ol.webgl.Fragment(ol.DEBUG_WEBGL ? "precision mediump float;\nvarying vec2 v_texCoord;\n\n\nuniform sampler2D u_texture;\n\nvoid main(void) {\n  gl_FragColor = texture2D(u_texture, v_texCoord);\n}\n" : "precision mediump float;varying vec2 a;uniform sampler2D e;void main(void){gl_FragColor=texture2D(e,a);}");
ol.renderer.webgl.tilelayershader.vertex = new ol.webgl.Vertex(ol.DEBUG_WEBGL ? "varying vec2 v_texCoord;\n\n\nattribute vec2 a_position;\nattribute vec2 a_texCoord;\nuniform vec4 u_tileOffset;\n\nvoid main(void) {\n  gl_Position = vec4(a_position * u_tileOffset.xy + u_tileOffset.zw, 0., 1.);\n  v_texCoord = a_texCoord;\n}\n\n\n" : "varying vec2 a;attribute vec2 b;attribute vec2 c;uniform vec4 d;void main(void){gl_Position=vec4(b*d.xy+d.zw,0.,1.);a=c;}");
goog.provide("ol.renderer.webgl.tilelayershader.Locations");
goog.require("ol");
ol.renderer.webgl.tilelayershader.Locations = function(gl, program) {
  this.u_tileOffset = gl.getUniformLocation(program, ol.DEBUG_WEBGL ? "u_tileOffset" : "d");
  this.u_texture = gl.getUniformLocation(program, ol.DEBUG_WEBGL ? "u_texture" : "e");
  this.a_position = gl.getAttribLocation(program, ol.DEBUG_WEBGL ? "a_position" : "b");
  this.a_texCoord = gl.getAttribLocation(program, ol.DEBUG_WEBGL ? "a_texCoord" : "c");
};
goog.provide("ol.renderer.webgl.TileLayer");
goog.require("ol");
goog.require("ol.LayerType");
goog.require("ol.TileRange");
goog.require("ol.TileState");
goog.require("ol.array");
goog.require("ol.extent");
goog.require("ol.math");
goog.require("ol.renderer.Type");
goog.require("ol.renderer.webgl.Layer");
goog.require("ol.renderer.webgl.tilelayershader");
goog.require("ol.renderer.webgl.tilelayershader.Locations");
goog.require("ol.size");
goog.require("ol.transform");
goog.require("ol.webgl");
goog.require("ol.webgl.Buffer");
ol.renderer.webgl.TileLayer = function(mapRenderer, tileLayer) {
  ol.renderer.webgl.Layer.call(this, mapRenderer, tileLayer);
  this.fragmentShader_ = ol.renderer.webgl.tilelayershader.fragment;
  this.vertexShader_ = ol.renderer.webgl.tilelayershader.vertex;
  this.locations_ = null;
  this.renderArrayBuffer_ = new ol.webgl.Buffer([0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0]);
  this.renderedTileRange_ = null;
  this.renderedFramebufferExtent_ = null;
  this.renderedRevision_ = -1;
  this.tmpSize_ = [0, 0];
};
ol.inherits(ol.renderer.webgl.TileLayer, ol.renderer.webgl.Layer);
ol.renderer.webgl.TileLayer["handles"] = function(type, layer) {
  return type === ol.renderer.Type.WEBGL && layer.getType() === ol.LayerType.TILE;
};
ol.renderer.webgl.TileLayer["create"] = function(mapRenderer, layer) {
  return new ol.renderer.webgl.TileLayer(mapRenderer, layer);
};
ol.renderer.webgl.TileLayer.prototype.disposeInternal = function() {
  var context = this.mapRenderer.getContext();
  context.deleteBuffer(this.renderArrayBuffer_);
  ol.renderer.webgl.Layer.prototype.disposeInternal.call(this);
};
ol.renderer.webgl.TileLayer.prototype.createLoadedTileFinder = function(source, projection, tiles) {
  var mapRenderer = this.mapRenderer;
  return function(zoom, tileRange) {
    function callback(tile) {
      var loaded = mapRenderer.isTileTextureLoaded(tile);
      if (loaded) {
        if (!tiles[zoom]) {
          tiles[zoom] = {};
        }
        tiles[zoom][tile.tileCoord.toString()] = tile;
      }
      return loaded;
    }
    return source.forEachLoadedTile(projection, zoom, tileRange, callback);
  };
};
ol.renderer.webgl.TileLayer.prototype.handleWebGLContextLost = function() {
  ol.renderer.webgl.Layer.prototype.handleWebGLContextLost.call(this);
  this.locations_ = null;
};
ol.renderer.webgl.TileLayer.prototype.prepareFrame = function(frameState, layerState, context) {
  var mapRenderer = this.mapRenderer;
  var gl = context.getGL();
  var viewState = frameState.viewState;
  var projection = viewState.projection;
  var tileLayer = this.getLayer();
  var tileSource = tileLayer.getSource();
  var tileGrid = tileSource.getTileGridForProjection(projection);
  var z = tileGrid.getZForResolution(viewState.resolution);
  var tileResolution = tileGrid.getResolution(z);
  var tilePixelSize = tileSource.getTilePixelSize(z, frameState.pixelRatio, projection);
  var pixelRatio = tilePixelSize[0] / ol.size.toSize(tileGrid.getTileSize(z), this.tmpSize_)[0];
  var tilePixelResolution = tileResolution / pixelRatio;
  var tileGutter = tileSource.getTilePixelRatio(pixelRatio) * tileSource.getGutter(projection);
  var center = viewState.center;
  var extent = frameState.extent;
  var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
  var framebufferExtent;
  if (this.renderedTileRange_ && this.renderedTileRange_.equals(tileRange) && this.renderedRevision_ == tileSource.getRevision()) {
    framebufferExtent = this.renderedFramebufferExtent_;
  } else {
    var tileRangeSize = tileRange.getSize();
    var maxDimension = Math.max(tileRangeSize[0] * tilePixelSize[0], tileRangeSize[1] * tilePixelSize[1]);
    var framebufferDimension = ol.math.roundUpToPowerOfTwo(maxDimension);
    var framebufferExtentDimension = tilePixelResolution * framebufferDimension;
    var origin = tileGrid.getOrigin(z);
    var minX = origin[0] + tileRange.minX * tilePixelSize[0] * tilePixelResolution;
    var minY = origin[1] + tileRange.minY * tilePixelSize[1] * tilePixelResolution;
    framebufferExtent = [minX, minY, minX + framebufferExtentDimension, minY + framebufferExtentDimension];
    this.bindFramebuffer(frameState, framebufferDimension);
    gl.viewport(0, 0, framebufferDimension, framebufferDimension);
    gl.clearColor(0, 0, 0, 0);
    gl.clear(ol.webgl.COLOR_BUFFER_BIT);
    gl.disable(ol.webgl.BLEND);
    var program = context.getProgram(this.fragmentShader_, this.vertexShader_);
    context.useProgram(program);
    if (!this.locations_) {
      this.locations_ = new ol.renderer.webgl.tilelayershader.Locations(gl, program);
    }
    context.bindBuffer(ol.webgl.ARRAY_BUFFER, this.renderArrayBuffer_);
    gl.enableVertexAttribArray(this.locations_.a_position);
    gl.vertexAttribPointer(this.locations_.a_position, 2, ol.webgl.FLOAT, false, 16, 0);
    gl.enableVertexAttribArray(this.locations_.a_texCoord);
    gl.vertexAttribPointer(this.locations_.a_texCoord, 2, ol.webgl.FLOAT, false, 16, 8);
    gl.uniform1i(this.locations_.u_texture, 0);
    var tilesToDrawByZ = {};
    tilesToDrawByZ[z] = {};
    var findLoadedTiles = this.createLoadedTileFinder(tileSource, projection, tilesToDrawByZ);
    var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();
    var allTilesLoaded = true;
    var tmpExtent = ol.extent.createEmpty();
    var tmpTileRange = new ol.TileRange(0, 0, 0, 0);
    var childTileRange, drawable, fullyLoaded, tile, tileState;
    var x, y, tileExtent;
    for (x = tileRange.minX; x <= tileRange.maxX; ++x) {
      for (y = tileRange.minY; y <= tileRange.maxY; ++y) {
        tile = tileSource.getTile(z, x, y, pixelRatio, projection);
        if (layerState.extent !== undefined) {
          tileExtent = tileGrid.getTileCoordExtent(tile.tileCoord, tmpExtent);
          if (!ol.extent.intersects(tileExtent, layerState.extent)) {
            continue;
          }
        }
        tileState = tile.getState();
        drawable = tileState == ol.TileState.LOADED || tileState == ol.TileState.EMPTY || tileState == ol.TileState.ERROR && !useInterimTilesOnError;
        if (!drawable) {
          tile = tile.getInterimTile();
        }
        tileState = tile.getState();
        if (tileState == ol.TileState.LOADED) {
          if (mapRenderer.isTileTextureLoaded(tile)) {
            tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;
            continue;
          }
        } else {
          if (tileState == ol.TileState.EMPTY || tileState == ol.TileState.ERROR && !useInterimTilesOnError) {
            continue;
          }
        }
        allTilesLoaded = false;
        fullyLoaded = tileGrid.forEachTileCoordParentTileRange(tile.tileCoord, findLoadedTiles, null, tmpTileRange, tmpExtent);
        if (!fullyLoaded) {
          childTileRange = tileGrid.getTileCoordChildTileRange(tile.tileCoord, tmpTileRange, tmpExtent);
          if (childTileRange) {
            findLoadedTiles(z + 1, childTileRange);
          }
        }
      }
    }
    var zs = Object.keys(tilesToDrawByZ).map(Number);
    zs.sort(ol.array.numberSafeCompareFunction);
    var u_tileOffset = new Float32Array(4);
    var i, ii, tileKey, tilesToDraw;
    for (i = 0, ii = zs.length; i < ii; ++i) {
      tilesToDraw = tilesToDrawByZ[zs[i]];
      for (tileKey in tilesToDraw) {
        tile = tilesToDraw[tileKey];
        tileExtent = tileGrid.getTileCoordExtent(tile.tileCoord, tmpExtent);
        u_tileOffset[0] = 2 * (tileExtent[2] - tileExtent[0]) / framebufferExtentDimension;
        u_tileOffset[1] = 2 * (tileExtent[3] - tileExtent[1]) / framebufferExtentDimension;
        u_tileOffset[2] = 2 * (tileExtent[0] - framebufferExtent[0]) / framebufferExtentDimension - 1;
        u_tileOffset[3] = 2 * (tileExtent[1] - framebufferExtent[1]) / framebufferExtentDimension - 1;
        gl.uniform4fv(this.locations_.u_tileOffset, u_tileOffset);
        mapRenderer.bindTileTexture(tile, tilePixelSize, tileGutter * pixelRatio, ol.webgl.LINEAR, ol.webgl.LINEAR);
        gl.drawArrays(ol.webgl.TRIANGLE_STRIP, 0, 4);
      }
    }
    if (allTilesLoaded) {
      this.renderedTileRange_ = tileRange;
      this.renderedFramebufferExtent_ = framebufferExtent;
      this.renderedRevision_ = tileSource.getRevision();
    } else {
      this.renderedTileRange_ = null;
      this.renderedFramebufferExtent_ = null;
      this.renderedRevision_ = -1;
      frameState.animate = true;
    }
  }
  this.updateUsedTiles(frameState.usedTiles, tileSource, z, tileRange);
  var tileTextureQueue = mapRenderer.getTileTextureQueue();
  this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, z, tileLayer.getPreload(), function(tile) {
    if (tile.getState() == ol.TileState.LOADED && !mapRenderer.isTileTextureLoaded(tile) && !tileTextureQueue.isKeyQueued(tile.getKey())) {
      tileTextureQueue.enqueue([tile, tileGrid.getTileCoordCenter(tile.tileCoord), tileGrid.getResolution(tile.tileCoord[0]), tilePixelSize, tileGutter * pixelRatio]);
    }
  }, this);
  this.scheduleExpireCache(frameState, tileSource);
  this.updateLogos(frameState, tileSource);
  var texCoordMatrix = this.texCoordMatrix;
  ol.transform.reset(texCoordMatrix);
  ol.transform.translate(texCoordMatrix, (Math.round(center[0] / tileResolution) * tileResolution - framebufferExtent[0]) / (framebufferExtent[2] - framebufferExtent[0]), (Math.round(center[1] / tileResolution) * tileResolution - framebufferExtent[1]) / (framebufferExtent[3] - framebufferExtent[1]));
  if (viewState.rotation !== 0) {
    ol.transform.rotate(texCoordMatrix, viewState.rotation);
  }
  ol.transform.scale(texCoordMatrix, frameState.size[0] * viewState.resolution / (framebufferExtent[2] - framebufferExtent[0]), frameState.size[1] * viewState.resolution / (framebufferExtent[3] - framebufferExtent[1]));
  ol.transform.translate(texCoordMatrix, -0.5, -0.5);
  return true;
};
ol.renderer.webgl.TileLayer.prototype.forEachLayerAtPixel = function(pixel, frameState, callback, thisArg) {
  if (!this.framebuffer) {
    return undefined;
  }
  var pixelOnMapScaled = [pixel[0] / frameState.size[0], (frameState.size[1] - pixel[1]) / frameState.size[1]];
  var pixelOnFrameBufferScaled = ol.transform.apply(this.texCoordMatrix, pixelOnMapScaled.slice());
  var pixelOnFrameBuffer = [pixelOnFrameBufferScaled[0] * this.framebufferDimension, pixelOnFrameBufferScaled[1] * this.framebufferDimension];
  var gl = this.mapRenderer.getContext().getGL();
  gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
  var imageData = new Uint8Array(4);
  gl.readPixels(pixelOnFrameBuffer[0], pixelOnFrameBuffer[1], 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, imageData);
  if (imageData[3] > 0) {
    return callback.call(thisArg, this.getLayer(), imageData);
  } else {
    return undefined;
  }
};
goog.provide("ol.renderer.webgl.VectorLayer");
goog.require("ol");
goog.require("ol.LayerType");
goog.require("ol.ViewHint");
goog.require("ol.extent");
goog.require("ol.render.webgl.ReplayGroup");
goog.require("ol.renderer.Type");
goog.require("ol.renderer.vector");
goog.require("ol.renderer.webgl.Layer");
goog.require("ol.transform");
ol.renderer.webgl.VectorLayer = function(mapRenderer, vectorLayer) {
  ol.renderer.webgl.Layer.call(this, mapRenderer, vectorLayer);
  this.dirty_ = false;
  this.renderedRevision_ = -1;
  this.renderedResolution_ = NaN;
  this.renderedExtent_ = ol.extent.createEmpty();
  this.renderedRenderOrder_ = null;
  this.replayGroup_ = null;
  this.layerState_ = null;
};
ol.inherits(ol.renderer.webgl.VectorLayer, ol.renderer.webgl.Layer);
ol.renderer.webgl.VectorLayer["handles"] = function(type, layer) {
  return type === ol.renderer.Type.WEBGL && layer.getType() === ol.LayerType.VECTOR;
};
ol.renderer.webgl.VectorLayer["create"] = function(mapRenderer, layer) {
  return new ol.renderer.webgl.VectorLayer(mapRenderer, layer);
};
ol.renderer.webgl.VectorLayer.prototype.composeFrame = function(frameState, layerState, context) {
  this.layerState_ = layerState;
  var viewState = frameState.viewState;
  var replayGroup = this.replayGroup_;
  var size = frameState.size;
  var pixelRatio = frameState.pixelRatio;
  var gl = this.mapRenderer.getGL();
  if (replayGroup && !replayGroup.isEmpty()) {
    gl.enable(gl.SCISSOR_TEST);
    gl.scissor(0, 0, size[0] * pixelRatio, size[1] * pixelRatio);
    replayGroup.replay(context, viewState.center, viewState.resolution, viewState.rotation, size, pixelRatio, layerState.opacity, layerState.managed ? frameState.skippedFeatureUids : {});
    gl.disable(gl.SCISSOR_TEST);
  }
};
ol.renderer.webgl.VectorLayer.prototype.disposeInternal = function() {
  var replayGroup = this.replayGroup_;
  if (replayGroup) {
    var context = this.mapRenderer.getContext();
    replayGroup.getDeleteResourcesFunction(context)();
    this.replayGroup_ = null;
  }
  ol.renderer.webgl.Layer.prototype.disposeInternal.call(this);
};
ol.renderer.webgl.VectorLayer.prototype.forEachFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, callback, thisArg) {
  if (!this.replayGroup_ || !this.layerState_) {
    return undefined;
  } else {
    var context = this.mapRenderer.getContext();
    var viewState = frameState.viewState;
    var layer = this.getLayer();
    var layerState = this.layerState_;
    var features = {};
    return this.replayGroup_.forEachFeatureAtCoordinate(coordinate, context, viewState.center, viewState.resolution, viewState.rotation, frameState.size, frameState.pixelRatio, layerState.opacity, {}, function(feature) {
      var key = ol.getUid(feature).toString();
      if (!(key in features)) {
        features[key] = true;
        return callback.call(thisArg, feature, layer);
      }
    });
  }
};
ol.renderer.webgl.VectorLayer.prototype.hasFeatureAtCoordinate = function(coordinate, frameState) {
  if (!this.replayGroup_ || !this.layerState_) {
    return false;
  } else {
    var context = this.mapRenderer.getContext();
    var viewState = frameState.viewState;
    var layerState = this.layerState_;
    return this.replayGroup_.hasFeatureAtCoordinate(coordinate, context, viewState.center, viewState.resolution, viewState.rotation, frameState.size, frameState.pixelRatio, layerState.opacity, frameState.skippedFeatureUids);
  }
};
ol.renderer.webgl.VectorLayer.prototype.forEachLayerAtPixel = function(pixel, frameState, callback, thisArg) {
  var coordinate = ol.transform.apply(frameState.pixelToCoordinateTransform, pixel.slice());
  var hasFeature = this.hasFeatureAtCoordinate(coordinate, frameState);
  if (hasFeature) {
    return callback.call(thisArg, this.getLayer(), null);
  } else {
    return undefined;
  }
};
ol.renderer.webgl.VectorLayer.prototype.handleStyleImageChange_ = function(event) {
  this.renderIfReadyAndVisible();
};
ol.renderer.webgl.VectorLayer.prototype.prepareFrame = function(frameState, layerState, context) {
  var vectorLayer = this.getLayer();
  var vectorSource = vectorLayer.getSource();
  this.updateLogos(frameState, vectorSource);
  var animating = frameState.viewHints[ol.ViewHint.ANIMATING];
  var interacting = frameState.viewHints[ol.ViewHint.INTERACTING];
  var updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();
  var updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();
  if (!this.dirty_ && (!updateWhileAnimating && animating) || !updateWhileInteracting && interacting) {
    return true;
  }
  var frameStateExtent = frameState.extent;
  var viewState = frameState.viewState;
  var projection = viewState.projection;
  var resolution = viewState.resolution;
  var pixelRatio = frameState.pixelRatio;
  var vectorLayerRevision = vectorLayer.getRevision();
  var vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();
  var vectorLayerRenderOrder = vectorLayer.getRenderOrder();
  if (vectorLayerRenderOrder === undefined) {
    vectorLayerRenderOrder = ol.renderer.vector.defaultOrder;
  }
  var extent = ol.extent.buffer(frameStateExtent, vectorLayerRenderBuffer * resolution);
  if (!this.dirty_ && this.renderedResolution_ == resolution && this.renderedRevision_ == vectorLayerRevision && this.renderedRenderOrder_ == vectorLayerRenderOrder && ol.extent.containsExtent(this.renderedExtent_, extent)) {
    return true;
  }
  if (this.replayGroup_) {
    frameState.postRenderFunctions.push(this.replayGroup_.getDeleteResourcesFunction(context));
  }
  this.dirty_ = false;
  var replayGroup = new ol.render.webgl.ReplayGroup(ol.renderer.vector.getTolerance(resolution, pixelRatio), extent, vectorLayer.getRenderBuffer());
  vectorSource.loadFeatures(extent, resolution, projection);
  var renderFeature = function(feature) {
    var styles;
    var styleFunction = feature.getStyleFunction();
    if (styleFunction) {
      styles = styleFunction.call(feature, resolution);
    } else {
      styleFunction = vectorLayer.getStyleFunction();
      if (styleFunction) {
        styles = styleFunction(feature, resolution);
      }
    }
    if (styles) {
      var dirty = this.renderFeature(feature, resolution, pixelRatio, styles, replayGroup);
      this.dirty_ = this.dirty_ || dirty;
    }
  };
  if (vectorLayerRenderOrder) {
    var features = [];
    vectorSource.forEachFeatureInExtent(extent, function(feature) {
      features.push(feature);
    }, this);
    features.sort(vectorLayerRenderOrder);
    features.forEach(renderFeature, this);
  } else {
    vectorSource.forEachFeatureInExtent(extent, renderFeature, this);
  }
  replayGroup.finish(context);
  this.renderedResolution_ = resolution;
  this.renderedRevision_ = vectorLayerRevision;
  this.renderedRenderOrder_ = vectorLayerRenderOrder;
  this.renderedExtent_ = extent;
  this.replayGroup_ = replayGroup;
  return true;
};
ol.renderer.webgl.VectorLayer.prototype.renderFeature = function(feature, resolution, pixelRatio, styles, replayGroup) {
  if (!styles) {
    return false;
  }
  var loading = false;
  if (Array.isArray(styles)) {
    for (var i = styles.length - 1, ii = 0; i >= ii; --i) {
      loading = ol.renderer.vector.renderFeature(replayGroup, feature, styles[i], ol.renderer.vector.getSquaredTolerance(resolution, pixelRatio), this.handleStyleImageChange_, this) || loading;
    }
  } else {
    loading = ol.renderer.vector.renderFeature(replayGroup, feature, styles, ol.renderer.vector.getSquaredTolerance(resolution, pixelRatio), this.handleStyleImageChange_, this) || loading;
  }
  return loading;
};
goog.provide("ol.Map");
goog.require("ol");
goog.require("ol.PluggableMap");
goog.require("ol.PluginType");
goog.require("ol.control");
goog.require("ol.interaction");
goog.require("ol.obj");
goog.require("ol.plugins");
goog.require("ol.renderer.canvas.ImageLayer");
goog.require("ol.renderer.canvas.Map");
goog.require("ol.renderer.canvas.TileLayer");
goog.require("ol.renderer.canvas.VectorLayer");
goog.require("ol.renderer.canvas.VectorTileLayer");
goog.require("ol.renderer.webgl.ImageLayer");
goog.require("ol.renderer.webgl.Map");
goog.require("ol.renderer.webgl.TileLayer");
goog.require("ol.renderer.webgl.VectorLayer");
if (ol.ENABLE_CANVAS) {
  ol.plugins.register(ol.PluginType.MAP_RENDERER, ol.renderer.canvas.Map);
  ol.plugins.registerMultiple(ol.PluginType.LAYER_RENDERER, [ol.renderer.canvas.ImageLayer, ol.renderer.canvas.TileLayer, ol.renderer.canvas.VectorLayer, ol.renderer.canvas.VectorTileLayer]);
}
if (ol.ENABLE_WEBGL) {
  ol.plugins.register(ol.PluginType.MAP_RENDERER, ol.renderer.webgl.Map);
  ol.plugins.registerMultiple(ol.PluginType.LAYER_RENDERER, [ol.renderer.webgl.ImageLayer, ol.renderer.webgl.TileLayer, ol.renderer.webgl.VectorLayer]);
}
ol.Map = function(options) {
  options = ol.obj.assign({}, options);
  if (!options.controls) {
    options.controls = ol.control.defaults();
  }
  if (!options.interactions) {
    options.interactions = ol.interaction.defaults();
  }
  ol.PluggableMap.call(this, options);
};
ol.inherits(ol.Map, ol.PluggableMap);
goog.provide("ol.net");
goog.require("ol");
ol.net.jsonp = function(url, callback, opt_errback, opt_callbackParam) {
  var script = document.createElement("script");
  var key = "olc_" + ol.getUid(callback);
  function cleanup() {
    delete window[key];
    script.parentNode.removeChild(script);
  }
  script.async = true;
  script.src = url + (url.indexOf("?") == -1 ? "?" : "&") + (opt_callbackParam || "callback") + "=" + key;
  var timer = setTimeout(function() {
    cleanup();
    if (opt_errback) {
      opt_errback();
    }
  }, 10000);
  window[key] = function(data) {
    clearTimeout(timer);
    cleanup();
    callback(data);
  };
  document.getElementsByTagName("head")[0].appendChild(script);
};
goog.provide("ol.proj.common");
goog.require("ol.proj");
ol.proj.common.add = ol.proj.addCommon;
goog.provide("ol.render");
goog.require("ol.has");
goog.require("ol.transform");
goog.require("ol.render.canvas.Immediate");
ol.render.toContext = function(context, opt_options) {
  var canvas = context.canvas;
  var options = opt_options ? opt_options : {};
  var pixelRatio = options.pixelRatio || ol.has.DEVICE_PIXEL_RATIO;
  var size = options.size;
  if (size) {
    canvas.width = size[0] * pixelRatio;
    canvas.height = size[1] * pixelRatio;
    canvas.style.width = size[0] + "px";
    canvas.style.height = size[1] + "px";
  }
  var extent = [0, 0, canvas.width, canvas.height];
  var transform = ol.transform.scale(ol.transform.create(), pixelRatio, pixelRatio);
  return new ol.render.canvas.Immediate(context, pixelRatio, extent, transform, 0);
};
goog.provide("ol.source.BingMaps");
goog.require("ol");
goog.require("ol.TileUrlFunction");
goog.require("ol.extent");
goog.require("ol.net");
goog.require("ol.proj");
goog.require("ol.source.State");
goog.require("ol.source.TileImage");
goog.require("ol.tilecoord");
goog.require("ol.tilegrid");
ol.source.BingMaps = function(options) {
  this.hidpi_ = options.hidpi !== undefined ? options.hidpi : false;
  ol.source.TileImage.call(this, {cacheSize:options.cacheSize, crossOrigin:"anonymous", opaque:true, projection:ol.proj.get("EPSG:3857"), reprojectionErrorThreshold:options.reprojectionErrorThreshold, state:ol.source.State.LOADING, tileLoadFunction:options.tileLoadFunction, tilePixelRatio:this.hidpi_ ? 2 : 1, wrapX:options.wrapX !== undefined ? options.wrapX : true, transition:options.transition});
  this.culture_ = options.culture !== undefined ? options.culture : "en-us";
  this.maxZoom_ = options.maxZoom !== undefined ? options.maxZoom : -1;
  this.apiKey_ = options.key;
  this.imagerySet_ = options.imagerySet;
  var url = "https://dev.virtualearth.net/REST/v1/Imagery/Metadata/" + this.imagerySet_ + "?uriScheme=https&include=ImageryProviders&key=" + this.apiKey_ + "&c=" + this.culture_;
  ol.net.jsonp(url, this.handleImageryMetadataResponse.bind(this), undefined, "jsonp");
};
ol.inherits(ol.source.BingMaps, ol.source.TileImage);
ol.source.BingMaps.TOS_ATTRIBUTION = '<a class="ol-attribution-bing-tos" ' + 'href="https://www.microsoft.com/maps/product/terms.html">' + "Terms of Use</a>";
ol.source.BingMaps.prototype.getApiKey = function() {
  return this.apiKey_;
};
ol.source.BingMaps.prototype.getImagerySet = function() {
  return this.imagerySet_;
};
ol.source.BingMaps.prototype.handleImageryMetadataResponse = function(response) {
  if (response.statusCode != 200 || response.statusDescription != "OK" || response.authenticationResultCode != "ValidCredentials" || response.resourceSets.length != 1 || response.resourceSets[0].resources.length != 1) {
    this.setState(ol.source.State.ERROR);
    return;
  }
  var brandLogoUri = response.brandLogoUri;
  if (brandLogoUri.indexOf("https") == -1) {
    brandLogoUri = brandLogoUri.replace("http", "https");
  }
  var resource = response.resourceSets[0].resources[0];
  var maxZoom = this.maxZoom_ == -1 ? resource.zoomMax : this.maxZoom_;
  var sourceProjection = this.getProjection();
  var extent = ol.tilegrid.extentFromProjection(sourceProjection);
  var tileSize = resource.imageWidth == resource.imageHeight ? resource.imageWidth : [resource.imageWidth, resource.imageHeight];
  var tileGrid = ol.tilegrid.createXYZ({extent:extent, minZoom:resource.zoomMin, maxZoom:maxZoom, tileSize:tileSize / (this.hidpi_ ? 2 : 1)});
  this.tileGrid = tileGrid;
  var culture = this.culture_;
  var hidpi = this.hidpi_;
  this.tileUrlFunction = ol.TileUrlFunction.createFromTileUrlFunctions(resource.imageUrlSubdomains.map(function(subdomain) {
    var quadKeyTileCoord = [0, 0, 0];
    var imageUrl = resource.imageUrl.replace("{subdomain}", subdomain).replace("{culture}", culture);
    return function(tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return undefined;
      } else {
        ol.tilecoord.createOrUpdate(tileCoord[0], tileCoord[1], -tileCoord[2] - 1, quadKeyTileCoord);
        var url = imageUrl;
        if (hidpi) {
          url += "&dpi=d1&device=mobile";
        }
        return url.replace("{quadkey}", ol.tilecoord.quadKey(quadKeyTileCoord));
      }
    };
  }));
  if (resource.imageryProviders) {
    var transform = ol.proj.getTransformFromProjections(ol.proj.get("EPSG:4326"), this.getProjection());
    this.setAttributions(function(frameState) {
      var attributions = [];
      var zoom = frameState.viewState.zoom;
      resource.imageryProviders.map(function(imageryProvider) {
        var intersects = false;
        var coverageAreas = imageryProvider.coverageAreas;
        for (var i = 0, ii = coverageAreas.length; i < ii; ++i) {
          var coverageArea = coverageAreas[i];
          if (zoom >= coverageArea.zoomMin && zoom <= coverageArea.zoomMax) {
            var bbox = coverageArea.bbox;
            var epsg4326Extent = [bbox[1], bbox[0], bbox[3], bbox[2]];
            var extent = ol.extent.applyTransform(epsg4326Extent, transform);
            if (ol.extent.intersects(extent, frameState.extent)) {
              intersects = true;
              break;
            }
          }
        }
        if (intersects) {
          attributions.push(imageryProvider.attribution);
        }
      });
      attributions.push(ol.source.BingMaps.TOS_ATTRIBUTION);
      return attributions;
    });
  }
  this.setLogo(brandLogoUri);
  this.setState(ol.source.State.READY);
};
goog.provide("ol.source.XYZ");
goog.require("ol");
goog.require("ol.source.TileImage");
goog.require("ol.tilegrid");
ol.source.XYZ = function(opt_options) {
  var options = opt_options || {};
  var projection = options.projection !== undefined ? options.projection : "EPSG:3857";
  var tileGrid = options.tileGrid !== undefined ? options.tileGrid : ol.tilegrid.createXYZ({extent:ol.tilegrid.extentFromProjection(projection), maxZoom:options.maxZoom, minZoom:options.minZoom, tileSize:options.tileSize});
  ol.source.TileImage.call(this, {attributions:options.attributions, cacheSize:options.cacheSize, crossOrigin:options.crossOrigin, logo:options.logo, opaque:options.opaque, projection:projection, reprojectionErrorThreshold:options.reprojectionErrorThreshold, tileGrid:tileGrid, tileLoadFunction:options.tileLoadFunction, tilePixelRatio:options.tilePixelRatio, tileUrlFunction:options.tileUrlFunction, url:options.url, urls:options.urls, wrapX:options.wrapX !== undefined ? options.wrapX : true, transition:options.transition});
};
ol.inherits(ol.source.XYZ, ol.source.TileImage);
goog.provide("ol.source.CartoDB");
goog.require("ol");
goog.require("ol.obj");
goog.require("ol.source.State");
goog.require("ol.source.XYZ");
ol.source.CartoDB = function(options) {
  this.account_ = options.account;
  this.mapId_ = options.map || "";
  this.config_ = options.config || {};
  this.templateCache_ = {};
  ol.source.XYZ.call(this, {attributions:options.attributions, cacheSize:options.cacheSize, crossOrigin:options.crossOrigin, logo:options.logo, maxZoom:options.maxZoom !== undefined ? options.maxZoom : 18, minZoom:options.minZoom, projection:options.projection, state:ol.source.State.LOADING, wrapX:options.wrapX});
  this.initializeMap_();
};
ol.inherits(ol.source.CartoDB, ol.source.XYZ);
ol.source.CartoDB.prototype.getConfig = function() {
  return this.config_;
};
ol.source.CartoDB.prototype.updateConfig = function(config) {
  ol.obj.assign(this.config_, config);
  this.initializeMap_();
};
ol.source.CartoDB.prototype.setConfig = function(config) {
  this.config_ = config || {};
  this.initializeMap_();
};
ol.source.CartoDB.prototype.initializeMap_ = function() {
  var paramHash = JSON.stringify(this.config_);
  if (this.templateCache_[paramHash]) {
    this.applyTemplate_(this.templateCache_[paramHash]);
    return;
  }
  var mapUrl = "https://" + this.account_ + ".carto.com/api/v1/map";
  if (this.mapId_) {
    mapUrl += "/named/" + this.mapId_;
  }
  var client = new XMLHttpRequest;
  client.addEventListener("load", this.handleInitResponse_.bind(this, paramHash));
  client.addEventListener("error", this.handleInitError_.bind(this));
  client.open("POST", mapUrl);
  client.setRequestHeader("Content-type", "application/json");
  client.send(JSON.stringify(this.config_));
};
ol.source.CartoDB.prototype.handleInitResponse_ = function(paramHash, event) {
  var client = event.target;
  if (!client.status || client.status >= 200 && client.status < 300) {
    var response;
    try {
      response = JSON.parse(client.responseText);
    } catch (err) {
      this.setState(ol.source.State.ERROR);
      return;
    }
    this.applyTemplate_(response);
    this.templateCache_[paramHash] = response;
    this.setState(ol.source.State.READY);
  } else {
    this.setState(ol.source.State.ERROR);
  }
};
ol.source.CartoDB.prototype.handleInitError_ = function(event) {
  this.setState(ol.source.State.ERROR);
};
ol.source.CartoDB.prototype.applyTemplate_ = function(data) {
  var tilesUrl = "https://" + data.cdn_url.https + "/" + this.account_ + "/api/v1/map/" + data.layergroupid + "/{z}/{x}/{y}.png";
  this.setUrl(tilesUrl);
};
goog.provide("ol.source.ImageArcGISRest");
goog.require("ol");
goog.require("ol.Image");
goog.require("ol.asserts");
goog.require("ol.events");
goog.require("ol.events.EventType");
goog.require("ol.extent");
goog.require("ol.obj");
goog.require("ol.source.Image");
goog.require("ol.uri");
ol.source.ImageArcGISRest = function(opt_options) {
  var options = opt_options || {};
  ol.source.Image.call(this, {attributions:options.attributions, logo:options.logo, projection:options.projection, resolutions:options.resolutions});
  this.crossOrigin_ = options.crossOrigin !== undefined ? options.crossOrigin : null;
  this.hidpi_ = options.hidpi !== undefined ? options.hidpi : true;
  this.url_ = options.url;
  this.imageLoadFunction_ = options.imageLoadFunction !== undefined ? options.imageLoadFunction : ol.source.Image.defaultImageLoadFunction;
  this.params_ = options.params || {};
  this.image_ = null;
  this.imageSize_ = [0, 0];
  this.renderedRevision_ = 0;
  this.ratio_ = options.ratio !== undefined ? options.ratio : 1.5;
};
ol.inherits(ol.source.ImageArcGISRest, ol.source.Image);
ol.source.ImageArcGISRest.prototype.getParams = function() {
  return this.params_;
};
ol.source.ImageArcGISRest.prototype.getImageInternal = function(extent, resolution, pixelRatio, projection) {
  if (this.url_ === undefined) {
    return null;
  }
  resolution = this.findNearestResolution(resolution);
  pixelRatio = this.hidpi_ ? pixelRatio : 1;
  var image = this.image_;
  if (image && this.renderedRevision_ == this.getRevision() && image.getResolution() == resolution && image.getPixelRatio() == pixelRatio && ol.extent.containsExtent(image.getExtent(), extent)) {
    return image;
  }
  var params = {"F":"image", "FORMAT":"PNG32", "TRANSPARENT":true};
  ol.obj.assign(params, this.params_);
  extent = extent.slice();
  var centerX = (extent[0] + extent[2]) / 2;
  var centerY = (extent[1] + extent[3]) / 2;
  if (this.ratio_ != 1) {
    var halfWidth = this.ratio_ * ol.extent.getWidth(extent) / 2;
    var halfHeight = this.ratio_ * ol.extent.getHeight(extent) / 2;
    extent[0] = centerX - halfWidth;
    extent[1] = centerY - halfHeight;
    extent[2] = centerX + halfWidth;
    extent[3] = centerY + halfHeight;
  }
  var imageResolution = resolution / pixelRatio;
  var width = Math.ceil(ol.extent.getWidth(extent) / imageResolution);
  var height = Math.ceil(ol.extent.getHeight(extent) / imageResolution);
  extent[0] = centerX - imageResolution * width / 2;
  extent[2] = centerX + imageResolution * width / 2;
  extent[1] = centerY - imageResolution * height / 2;
  extent[3] = centerY + imageResolution * height / 2;
  this.imageSize_[0] = width;
  this.imageSize_[1] = height;
  var url = this.getRequestUrl_(extent, this.imageSize_, pixelRatio, projection, params);
  this.image_ = new ol.Image(extent, resolution, pixelRatio, url, this.crossOrigin_, this.imageLoadFunction_);
  this.renderedRevision_ = this.getRevision();
  ol.events.listen(this.image_, ol.events.EventType.CHANGE, this.handleImageChange, this);
  return this.image_;
};
ol.source.ImageArcGISRest.prototype.getImageLoadFunction = function() {
  return this.imageLoadFunction_;
};
ol.source.ImageArcGISRest.prototype.getRequestUrl_ = function(extent, size, pixelRatio, projection, params) {
  var srid = projection.getCode().split(":").pop();
  params["SIZE"] = size[0] + "," + size[1];
  params["BBOX"] = extent.join(",");
  params["BBOXSR"] = srid;
  params["IMAGESR"] = srid;
  params["DPI"] = Math.round(90 * pixelRatio);
  var url = this.url_;
  var modifiedUrl = url.replace(/MapServer\/?$/, "MapServer/export").replace(/ImageServer\/?$/, "ImageServer/exportImage");
  if (modifiedUrl == url) {
    ol.asserts.assert(false, 50);
  }
  return ol.uri.appendParams(modifiedUrl, params);
};
ol.source.ImageArcGISRest.prototype.getUrl = function() {
  return this.url_;
};
ol.source.ImageArcGISRest.prototype.setImageLoadFunction = function(imageLoadFunction) {
  this.image_ = null;
  this.imageLoadFunction_ = imageLoadFunction;
  this.changed();
};
ol.source.ImageArcGISRest.prototype.setUrl = function(url) {
  if (url != this.url_) {
    this.url_ = url;
    this.image_ = null;
    this.changed();
  }
};
ol.source.ImageArcGISRest.prototype.updateParams = function(params) {
  ol.obj.assign(this.params_, params);
  this.image_ = null;
  this.changed();
};
goog.provide("ol.source.ImageCanvas");
goog.require("ol");
goog.require("ol.ImageCanvas");
goog.require("ol.extent");
goog.require("ol.source.Image");
ol.source.ImageCanvas = function(options) {
  ol.source.Image.call(this, {attributions:options.attributions, logo:options.logo, projection:options.projection, resolutions:options.resolutions, state:options.state});
  this.canvasFunction_ = options.canvasFunction;
  this.canvas_ = null;
  this.renderedRevision_ = 0;
  this.ratio_ = options.ratio !== undefined ? options.ratio : 1.5;
};
ol.inherits(ol.source.ImageCanvas, ol.source.Image);
ol.source.ImageCanvas.prototype.getImageInternal = function(extent, resolution, pixelRatio, projection) {
  resolution = this.findNearestResolution(resolution);
  var canvas = this.canvas_;
  if (canvas && this.renderedRevision_ == this.getRevision() && canvas.getResolution() == resolution && canvas.getPixelRatio() == pixelRatio && ol.extent.containsExtent(canvas.getExtent(), extent)) {
    return canvas;
  }
  extent = extent.slice();
  ol.extent.scaleFromCenter(extent, this.ratio_);
  var width = ol.extent.getWidth(extent) / resolution;
  var height = ol.extent.getHeight(extent) / resolution;
  var size = [width * pixelRatio, height * pixelRatio];
  var canvasElement = this.canvasFunction_(extent, resolution, pixelRatio, size, projection);
  if (canvasElement) {
    canvas = new ol.ImageCanvas(extent, resolution, pixelRatio, canvasElement);
  }
  this.canvas_ = canvas;
  this.renderedRevision_ = this.getRevision();
  return canvas;
};
goog.provide("ol.source.ImageMapGuide");
goog.require("ol");
goog.require("ol.Image");
goog.require("ol.events");
goog.require("ol.events.EventType");
goog.require("ol.extent");
goog.require("ol.obj");
goog.require("ol.source.Image");
goog.require("ol.uri");
ol.source.ImageMapGuide = function(options) {
  ol.source.Image.call(this, {projection:options.projection, resolutions:options.resolutions});
  this.crossOrigin_ = options.crossOrigin !== undefined ? options.crossOrigin : null;
  this.displayDpi_ = options.displayDpi !== undefined ? options.displayDpi : 96;
  this.params_ = options.params || {};
  this.url_ = options.url;
  this.imageLoadFunction_ = options.imageLoadFunction !== undefined ? options.imageLoadFunction : ol.source.Image.defaultImageLoadFunction;
  this.hidpi_ = options.hidpi !== undefined ? options.hidpi : true;
  this.metersPerUnit_ = options.metersPerUnit !== undefined ? options.metersPerUnit : 1;
  this.ratio_ = options.ratio !== undefined ? options.ratio : 1;
  this.useOverlay_ = options.useOverlay !== undefined ? options.useOverlay : false;
  this.image_ = null;
  this.renderedRevision_ = 0;
};
ol.inherits(ol.source.ImageMapGuide, ol.source.Image);
ol.source.ImageMapGuide.prototype.getParams = function() {
  return this.params_;
};
ol.source.ImageMapGuide.prototype.getImageInternal = function(extent, resolution, pixelRatio, projection) {
  resolution = this.findNearestResolution(resolution);
  pixelRatio = this.hidpi_ ? pixelRatio : 1;
  var image = this.image_;
  if (image && this.renderedRevision_ == this.getRevision() && image.getResolution() == resolution && image.getPixelRatio() == pixelRatio && ol.extent.containsExtent(image.getExtent(), extent)) {
    return image;
  }
  if (this.ratio_ != 1) {
    extent = extent.slice();
    ol.extent.scaleFromCenter(extent, this.ratio_);
  }
  var width = ol.extent.getWidth(extent) / resolution;
  var height = ol.extent.getHeight(extent) / resolution;
  var size = [width * pixelRatio, height * pixelRatio];
  if (this.url_ !== undefined) {
    var imageUrl = this.getUrl(this.url_, this.params_, extent, size, projection);
    image = new ol.Image(extent, resolution, pixelRatio, imageUrl, this.crossOrigin_, this.imageLoadFunction_);
    ol.events.listen(image, ol.events.EventType.CHANGE, this.handleImageChange, this);
  } else {
    image = null;
  }
  this.image_ = image;
  this.renderedRevision_ = this.getRevision();
  return image;
};
ol.source.ImageMapGuide.prototype.getImageLoadFunction = function() {
  return this.imageLoadFunction_;
};
ol.source.ImageMapGuide.getScale = function(extent, size, metersPerUnit, dpi) {
  var mcsW = ol.extent.getWidth(extent);
  var mcsH = ol.extent.getHeight(extent);
  var devW = size[0];
  var devH = size[1];
  var mpp = 0.0254 / dpi;
  if (devH * mcsW > devW * mcsH) {
    return mcsW * metersPerUnit / (devW * mpp);
  } else {
    return mcsH * metersPerUnit / (devH * mpp);
  }
};
ol.source.ImageMapGuide.prototype.updateParams = function(params) {
  ol.obj.assign(this.params_, params);
  this.changed();
};
ol.source.ImageMapGuide.prototype.getUrl = function(baseUrl, params, extent, size, projection) {
  var scale = ol.source.ImageMapGuide.getScale(extent, size, this.metersPerUnit_, this.displayDpi_);
  var center = ol.extent.getCenter(extent);
  var baseParams = {"OPERATION":this.useOverlay_ ? "GETDYNAMICMAPOVERLAYIMAGE" : "GETMAPIMAGE", "VERSION":"2.0.0", "LOCALE":"en", "CLIENTAGENT":"ol.source.ImageMapGuide source", "CLIP":"1", "SETDISPLAYDPI":this.displayDpi_, "SETDISPLAYWIDTH":Math.round(size[0]), "SETDISPLAYHEIGHT":Math.round(size[1]), "SETVIEWSCALE":scale, "SETVIEWCENTERX":center[0], "SETVIEWCENTERY":center[1]};
  ol.obj.assign(baseParams, params);
  return ol.uri.appendParams(baseUrl, baseParams);
};
ol.source.ImageMapGuide.prototype.setImageLoadFunction = function(imageLoadFunction) {
  this.image_ = null;
  this.imageLoadFunction_ = imageLoadFunction;
  this.changed();
};
goog.provide("ol.source.ImageStatic");
goog.require("ol");
goog.require("ol.Image");
goog.require("ol.ImageState");
goog.require("ol.dom");
goog.require("ol.events");
goog.require("ol.events.EventType");
goog.require("ol.extent");
goog.require("ol.proj");
goog.require("ol.source.Image");
ol.source.ImageStatic = function(options) {
  var imageExtent = options.imageExtent;
  var crossOrigin = options.crossOrigin !== undefined ? options.crossOrigin : null;
  var imageLoadFunction = options.imageLoadFunction !== undefined ? options.imageLoadFunction : ol.source.Image.defaultImageLoadFunction;
  ol.source.Image.call(this, {attributions:options.attributions, logo:options.logo, projection:ol.proj.get(options.projection)});
  this.image_ = new ol.Image(imageExtent, undefined, 1, options.url, crossOrigin, imageLoadFunction);
  this.imageSize_ = options.imageSize ? options.imageSize : null;
  ol.events.listen(this.image_, ol.events.EventType.CHANGE, this.handleImageChange, this);
};
ol.inherits(ol.source.ImageStatic, ol.source.Image);
ol.source.ImageStatic.prototype.getImageInternal = function(extent, resolution, pixelRatio, projection) {
  if (ol.extent.intersects(extent, this.image_.getExtent())) {
    return this.image_;
  }
  return null;
};
ol.source.ImageStatic.prototype.handleImageChange = function(evt) {
  if (this.image_.getState() == ol.ImageState.LOADED) {
    var imageExtent = this.image_.getExtent();
    var image = this.image_.getImage();
    var imageWidth, imageHeight;
    if (this.imageSize_) {
      imageWidth = this.imageSize_[0];
      imageHeight = this.imageSize_[1];
    } else {
      imageWidth = image.width;
      imageHeight = image.height;
    }
    var resolution = ol.extent.getHeight(imageExtent) / imageHeight;
    var targetWidth = Math.ceil(ol.extent.getWidth(imageExtent) / resolution);
    if (targetWidth != imageWidth) {
      var context = ol.dom.createCanvasContext2D(targetWidth, imageHeight);
      var canvas = context.canvas;
      context.drawImage(image, 0, 0, imageWidth, imageHeight, 0, 0, canvas.width, canvas.height);
      this.image_.setImage(canvas);
    }
  }
  ol.source.Image.prototype.handleImageChange.call(this, evt);
};
goog.provide("ol.source.ImageVector");
goog.require("ol");
goog.require("ol.dom");
goog.require("ol.events");
goog.require("ol.events.EventType");
goog.require("ol.ext.rbush");
goog.require("ol.extent");
goog.require("ol.render.canvas.ReplayGroup");
goog.require("ol.renderer.vector");
goog.require("ol.source.ImageCanvas");
goog.require("ol.style.Style");
goog.require("ol.transform");
ol.source.ImageVector = function(options) {
  this.source_ = options.source;
  this.transform_ = ol.transform.create();
  this.canvasContext_ = ol.dom.createCanvasContext2D();
  this.canvasSize_ = [0, 0];
  this.declutterTree_ = ol.ext.rbush(9);
  this.renderBuffer_ = options.renderBuffer == undefined ? 100 : options.renderBuffer;
  this.replayGroup_ = null;
  ol.source.ImageCanvas.call(this, {attributions:options.attributions, canvasFunction:this.canvasFunctionInternal_.bind(this), logo:options.logo, projection:options.projection, ratio:options.ratio, resolutions:options.resolutions, state:this.source_.getState()});
  this.style_ = null;
  this.styleFunction_ = undefined;
  this.setStyle(options.style);
  ol.events.listen(this.source_, ol.events.EventType.CHANGE, this.handleSourceChange_, this);
};
ol.inherits(ol.source.ImageVector, ol.source.ImageCanvas);
ol.source.ImageVector.prototype.canvasFunctionInternal_ = function(extent, resolution, pixelRatio, size, projection) {
  var replayGroup = new ol.render.canvas.ReplayGroup(ol.renderer.vector.getTolerance(resolution, pixelRatio), extent, resolution, pixelRatio, this.source_.getOverlaps(), this.declutterTree_, this.renderBuffer_);
  this.source_.loadFeatures(extent, resolution, projection);
  var loading = false;
  this.source_.forEachFeatureInExtent(extent, function(feature) {
    loading = loading || this.renderFeature_(feature, resolution, pixelRatio, replayGroup);
  }, this);
  replayGroup.finish();
  if (loading) {
    return null;
  }
  if (this.canvasSize_[0] != size[0] || this.canvasSize_[1] != size[1]) {
    this.canvasContext_.canvas.width = size[0];
    this.canvasContext_.canvas.height = size[1];
    this.canvasSize_[0] = size[0];
    this.canvasSize_[1] = size[1];
  } else {
    this.canvasContext_.clearRect(0, 0, size[0], size[1]);
  }
  this.declutterTree_.clear();
  var transform = this.getTransform_(ol.extent.getCenter(extent), resolution, pixelRatio, size);
  replayGroup.replay(this.canvasContext_, transform, 0, {});
  this.replayGroup_ = replayGroup;
  return this.canvasContext_.canvas;
};
ol.source.ImageVector.prototype.forEachFeatureAtCoordinate = function(coordinate, resolution, rotation, hitTolerance, skippedFeatureUids, callback) {
  if (!this.replayGroup_) {
    return undefined;
  } else {
    var features = {};
    var result = this.replayGroup_.forEachFeatureAtCoordinate(coordinate, resolution, 0, hitTolerance, skippedFeatureUids, function(feature) {
      var key = ol.getUid(feature).toString();
      if (!(key in features)) {
        features[key] = true;
        return callback(feature);
      }
    }, null);
    return result;
  }
};
ol.source.ImageVector.prototype.getSource = function() {
  return this.source_;
};
ol.source.ImageVector.prototype.getStyle = function() {
  return this.style_;
};
ol.source.ImageVector.prototype.getStyleFunction = function() {
  return this.styleFunction_;
};
ol.source.ImageVector.prototype.getTransform_ = function(center, resolution, pixelRatio, size) {
  var dx1 = size[0] / 2;
  var dy1 = size[1] / 2;
  var sx = pixelRatio / resolution;
  var sy = -sx;
  var dx2 = -center[0];
  var dy2 = -center[1];
  return ol.transform.compose(this.transform_, dx1, dy1, sx, sy, 0, dx2, dy2);
};
ol.source.ImageVector.prototype.handleImageChange_ = function(event) {
  this.changed();
};
ol.source.ImageVector.prototype.handleSourceChange_ = function() {
  this.setState(this.source_.getState());
};
ol.source.ImageVector.prototype.renderFeature_ = function(feature, resolution, pixelRatio, replayGroup) {
  var styles;
  var styleFunction = feature.getStyleFunction();
  if (styleFunction) {
    styles = styleFunction.call(feature, resolution);
  } else {
    if (this.styleFunction_) {
      styles = this.styleFunction_(feature, resolution);
    }
  }
  if (!styles) {
    return false;
  }
  var i, ii, loading = false;
  if (!Array.isArray(styles)) {
    styles = [styles];
  }
  for (i = 0, ii = styles.length; i < ii; ++i) {
    loading = ol.renderer.vector.renderFeature(replayGroup, feature, styles[i], ol.renderer.vector.getSquaredTolerance(resolution, pixelRatio), this.handleImageChange_, this) || loading;
  }
  return loading;
};
ol.source.ImageVector.prototype.setStyle = function(style) {
  this.style_ = style !== undefined ? style : ol.style.Style.defaultFunction;
  this.styleFunction_ = !style ? undefined : ol.style.Style.createFunction(this.style_);
  this.changed();
};
goog.provide("ol.source.OSM");
goog.require("ol");
goog.require("ol.source.XYZ");
ol.source.OSM = function(opt_options) {
  var options = opt_options || {};
  var attributions;
  if (options.attributions !== undefined) {
    attributions = options.attributions;
  } else {
    attributions = [ol.source.OSM.ATTRIBUTION];
  }
  var crossOrigin = options.crossOrigin !== undefined ? options.crossOrigin : "anonymous";
  var url = options.url !== undefined ? options.url : "https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png";
  ol.source.XYZ.call(this, {attributions:attributions, cacheSize:options.cacheSize, crossOrigin:crossOrigin, opaque:options.opaque !== undefined ? options.opaque : true, maxZoom:options.maxZoom !== undefined ? options.maxZoom : 19, reprojectionErrorThreshold:options.reprojectionErrorThreshold, tileLoadFunction:options.tileLoadFunction, url:url, wrapX:options.wrapX});
};
ol.inherits(ol.source.OSM, ol.source.XYZ);
ol.source.OSM.ATTRIBUTION = "&copy; " + '<a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> ' + "contributors.";
goog.provide("ol.ext.pixelworks.Processor");
ol.ext.pixelworks.Processor = function() {
};
(function() {
  (function(exports) {
    var hasImageData = true;
    try {
      new ImageData(10, 10);
    } catch (_) {
      hasImageData = false;
    }
    var context = document.createElement("canvas").getContext("2d");
    function newImageData$1(data, width, height) {
      if (hasImageData) {
        return new ImageData(data, width, height);
      } else {
        var imageData = context.createImageData(width, height);
        imageData.data.set(data);
        return imageData;
      }
    }
    var newImageData_1 = newImageData$1;
    var util = {newImageData:newImageData_1};
    var newImageData = util.newImageData;
    function createMinion(operation) {
      var workerHasImageData = true;
      try {
        new ImageData(10, 10);
      } catch (_$11) {
        workerHasImageData = false;
      }
      function newWorkerImageData(data, width, height) {
        if (workerHasImageData) {
          return new ImageData(data, width, height);
        } else {
          return {data:data, width:width, height:height};
        }
      }
      return function(data) {
        var buffers = data["buffers"];
        var meta = data["meta"];
        var imageOps = data["imageOps"];
        var width = data["width"];
        var height = data["height"];
        var numBuffers = buffers.length;
        var numBytes = buffers[0].byteLength;
        var output, b;
        if (imageOps) {
          var images = new Array(numBuffers);
          for (b = 0; b < numBuffers; ++b) {
            images[b] = newWorkerImageData(new Uint8ClampedArray(buffers[b]), width, height);
          }
          output = operation(images, meta).data;
        } else {
          output = new Uint8ClampedArray(numBytes);
          var arrays = new Array(numBuffers);
          var pixels = new Array(numBuffers);
          for (b = 0; b < numBuffers; ++b) {
            arrays[b] = new Uint8ClampedArray(buffers[b]);
            pixels[b] = [0, 0, 0, 0];
          }
          for (var i = 0; i < numBytes; i += 4) {
            for (var j = 0; j < numBuffers; ++j) {
              var array = arrays[j];
              pixels[j][0] = array[i];
              pixels[j][1] = array[i + 1];
              pixels[j][2] = array[i + 2];
              pixels[j][3] = array[i + 3];
            }
            var pixel = operation(pixels, meta);
            output[i] = pixel[0];
            output[i + 1] = pixel[1];
            output[i + 2] = pixel[2];
            output[i + 3] = pixel[3];
          }
        }
        return output.buffer;
      };
    }
    function createWorker(config, onMessage) {
      var lib = Object.keys(config.lib || {}).map(function(name) {
        return "var " + name + " = " + config.lib[name].toString() + ";";
      });
      var lines = lib.concat(["var __minion__ = (" + createMinion.toString() + ")(", config.operation.toString(), ");", 'self.addEventListener("message", function(event) {', "  var buffer = __minion__(event.data);", "  self.postMessage({buffer: buffer, meta: event.data.meta}, [buffer]);", "});"]);
      var blob = new Blob(lines, {type:"text/javascript"});
      var source = URL.createObjectURL(blob);
      var worker = new Worker(source);
      worker.addEventListener("message", onMessage);
      return worker;
    }
    function createFauxWorker(config, onMessage) {
      var minion = createMinion(config.operation);
      return {postMessage:function(data) {
        setTimeout(function() {
          onMessage({"data":{"buffer":minion(data), "meta":data["meta"]}});
        }, 0);
      }};
    }
    function Processor(config) {
      this._imageOps = !!config.imageOps;
      var threads;
      if (config.threads === 0) {
        threads = 0;
      } else {
        if (this._imageOps) {
          threads = 1;
        } else {
          threads = config.threads || 1;
        }
      }
      var workers = [];
      if (threads) {
        for (var i = 0; i < threads; ++i) {
          workers[i] = createWorker(config, this._onWorkerMessage.bind(this, i));
        }
      } else {
        workers[0] = createFauxWorker(config, this._onWorkerMessage.bind(this, 0));
      }
      this._workers = workers;
      this._queue = [];
      this._maxQueueLength = config.queue || Infinity;
      this._running = 0;
      this._dataLookup = {};
      this._job = null;
    }
    Processor.prototype.process = function(inputs, meta, callback) {
      this._enqueue({inputs:inputs, meta:meta, callback:callback});
      this._dispatch();
    };
    Processor.prototype.destroy = function() {
      for (var key in this) {
        this[key] = null;
      }
      this._destroyed = true;
    };
    Processor.prototype._enqueue = function(job) {
      this._queue.push(job);
      while (this._queue.length > this._maxQueueLength) {
        this._queue.shift().callback(null, null);
      }
    };
    Processor.prototype._dispatch = function() {
      if (this._running === 0 && this._queue.length > 0) {
        var job = this._job = this._queue.shift();
        var width = job.inputs[0].width;
        var height = job.inputs[0].height;
        var buffers = job.inputs.map(function(input) {
          return input.data.buffer;
        });
        var threads = this._workers.length;
        this._running = threads;
        if (threads === 1) {
          this._workers[0].postMessage({"buffers":buffers, "meta":job.meta, "imageOps":this._imageOps, "width":width, "height":height}, buffers);
        } else {
          var length = job.inputs[0].data.length;
          var segmentLength = 4 * Math.ceil(length / 4 / threads);
          for (var i = 0; i < threads; ++i) {
            var offset = i * segmentLength;
            var slices = [];
            for (var j = 0, jj = buffers.length; j < jj; ++j) {
              slices.push(buffers[i].slice(offset, offset + segmentLength));
            }
            this._workers[i].postMessage({"buffers":slices, "meta":job.meta, "imageOps":this._imageOps, "width":width, "height":height}, slices);
          }
        }
      }
    };
    Processor.prototype._onWorkerMessage = function(index, event) {
      if (this._destroyed) {
        return;
      }
      this._dataLookup[index] = event.data;
      --this._running;
      if (this._running === 0) {
        this._resolveJob();
      }
    };
    Processor.prototype._resolveJob = function() {
      var job = this._job;
      var threads = this._workers.length;
      var data, meta;
      if (threads === 1) {
        data = new Uint8ClampedArray(this._dataLookup[0]["buffer"]);
        meta = this._dataLookup[0]["meta"];
      } else {
        var length = job.inputs[0].data.length;
        data = new Uint8ClampedArray(length);
        meta = new Array(length);
        var segmentLength = 4 * Math.ceil(length / 4 / threads);
        for (var i = 0; i < threads; ++i) {
          var buffer = this._dataLookup[i]["buffer"];
          var offset = i * segmentLength;
          data.set(new Uint8ClampedArray(buffer), offset);
          meta[i] = this._dataLookup[i]["meta"];
        }
      }
      this._job = null;
      this._dataLookup = {};
      job.callback(null, newImageData(data, job.inputs[0].width, job.inputs[0].height), meta);
      this._dispatch();
    };
    var processor = Processor;
    var Processor_1 = processor;
    var lib = {Processor:Processor_1};
    exports["default"] = lib;
    exports.Processor = Processor_1;
  })(this.pixelworks = this.pixelworks || {});
}).call(ol.ext);
goog.provide("ol.source.RasterOperationType");
ol.source.RasterOperationType = {PIXEL:"pixel", IMAGE:"image"};
goog.provide("ol.source.Raster");
goog.require("ol");
goog.require("ol.ImageCanvas");
goog.require("ol.TileQueue");
goog.require("ol.dom");
goog.require("ol.events");
goog.require("ol.events.Event");
goog.require("ol.events.EventType");
goog.require("ol.ext.pixelworks.Processor");
goog.require("ol.extent");
goog.require("ol.layer.Image");
goog.require("ol.layer.Tile");
goog.require("ol.obj");
goog.require("ol.renderer.canvas.ImageLayer");
goog.require("ol.renderer.canvas.TileLayer");
goog.require("ol.source.Image");
goog.require("ol.source.RasterOperationType");
goog.require("ol.source.State");
goog.require("ol.source.Tile");
goog.require("ol.transform");
ol.source.Raster = function(options) {
  this.worker_ = null;
  this.operationType_ = options.operationType !== undefined ? options.operationType : ol.source.RasterOperationType.PIXEL;
  this.threads_ = options.threads !== undefined ? options.threads : 1;
  this.renderers_ = ol.source.Raster.createRenderers_(options.sources);
  for (var r = 0, rr = this.renderers_.length; r < rr; ++r) {
    ol.events.listen(this.renderers_[r], ol.events.EventType.CHANGE, this.changed, this);
  }
  this.tileQueue_ = new ol.TileQueue(function() {
    return 1;
  }, this.changed.bind(this));
  var layerStatesArray = ol.source.Raster.getLayerStatesArray_(this.renderers_);
  var layerStates = {};
  for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
    layerStates[ol.getUid(layerStatesArray[i].layer)] = layerStatesArray[i];
  }
  this.requestedFrameState_;
  this.renderedImageCanvas_ = null;
  this.renderedRevision_;
  this.frameState_ = {animate:false, coordinateToPixelTransform:ol.transform.create(), extent:null, focus:null, index:0, layerStates:layerStates, layerStatesArray:layerStatesArray, logos:{}, pixelRatio:1, pixelToCoordinateTransform:ol.transform.create(), postRenderFunctions:[], size:[0, 0], skippedFeatureUids:{}, tileQueue:this.tileQueue_, time:Date.now(), usedTiles:{}, viewState:{rotation:0}, viewHints:[], wantedTiles:{}};
  ol.source.Image.call(this, {});
  if (options.operation !== undefined) {
    this.setOperation(options.operation, options.lib);
  }
};
ol.inherits(ol.source.Raster, ol.source.Image);
ol.source.Raster.prototype.setOperation = function(operation, opt_lib) {
  this.worker_ = new ol.ext.pixelworks.Processor({operation:operation, imageOps:this.operationType_ === ol.source.RasterOperationType.IMAGE, queue:1, lib:opt_lib, threads:this.threads_});
  this.changed();
};
ol.source.Raster.prototype.updateFrameState_ = function(extent, resolution, projection) {
  var frameState = ol.obj.assign({}, this.frameState_);
  frameState.viewState = ol.obj.assign({}, frameState.viewState);
  var center = ol.extent.getCenter(extent);
  frameState.extent = extent.slice();
  frameState.focus = center;
  frameState.size[0] = Math.round(ol.extent.getWidth(extent) / resolution);
  frameState.size[1] = Math.round(ol.extent.getHeight(extent) / resolution);
  frameState.time = Date.now();
  frameState.animate = false;
  var viewState = frameState.viewState;
  viewState.center = center;
  viewState.projection = projection;
  viewState.resolution = resolution;
  return frameState;
};
ol.source.Raster.prototype.allSourcesReady_ = function() {
  var ready = true;
  var source;
  for (var i = 0, ii = this.renderers_.length; i < ii; ++i) {
    source = this.renderers_[i].getLayer().getSource();
    if (source.getState() !== ol.source.State.READY) {
      ready = false;
      break;
    }
  }
  return ready;
};
ol.source.Raster.prototype.getImage = function(extent, resolution, pixelRatio, projection) {
  if (!this.allSourcesReady_()) {
    return null;
  }
  var frameState = this.updateFrameState_(extent, resolution, projection);
  this.requestedFrameState_ = frameState;
  if (this.renderedImageCanvas_) {
    var renderedResolution = this.renderedImageCanvas_.getResolution();
    var renderedExtent = this.renderedImageCanvas_.getExtent();
    if (resolution !== renderedResolution || !ol.extent.equals(extent, renderedExtent)) {
      this.renderedImageCanvas_ = null;
    }
  }
  if (!this.renderedImageCanvas_ || this.getRevision() !== this.renderedRevision_) {
    this.processSources_();
  }
  frameState.tileQueue.loadMoreTiles(16, 16);
  if (frameState.animate) {
    requestAnimationFrame(this.changed.bind(this));
  }
  return this.renderedImageCanvas_;
};
ol.source.Raster.prototype.processSources_ = function() {
  var frameState = this.requestedFrameState_;
  var len = this.renderers_.length;
  var imageDatas = new Array(len);
  for (var i = 0; i < len; ++i) {
    var imageData = ol.source.Raster.getImageData_(this.renderers_[i], frameState, frameState.layerStatesArray[i]);
    if (imageData) {
      imageDatas[i] = imageData;
    } else {
      return;
    }
  }
  var data = {};
  this.dispatchEvent(new ol.source.Raster.Event(ol.source.Raster.EventType_.BEFOREOPERATIONS, frameState, data));
  this.worker_.process(imageDatas, data, this.onWorkerComplete_.bind(this, frameState));
};
ol.source.Raster.prototype.onWorkerComplete_ = function(frameState, err, output, data) {
  if (err || !output) {
    return;
  }
  var extent = frameState.extent;
  var resolution = frameState.viewState.resolution;
  if (resolution !== this.requestedFrameState_.viewState.resolution || !ol.extent.equals(extent, this.requestedFrameState_.extent)) {
    return;
  }
  var context;
  if (this.renderedImageCanvas_) {
    context = this.renderedImageCanvas_.getImage().getContext("2d");
  } else {
    var width = Math.round(ol.extent.getWidth(extent) / resolution);
    var height = Math.round(ol.extent.getHeight(extent) / resolution);
    context = ol.dom.createCanvasContext2D(width, height);
    this.renderedImageCanvas_ = new ol.ImageCanvas(extent, resolution, 1, context.canvas);
  }
  context.putImageData(output, 0, 0);
  this.changed();
  this.renderedRevision_ = this.getRevision();
  this.dispatchEvent(new ol.source.Raster.Event(ol.source.Raster.EventType_.AFTEROPERATIONS, frameState, data));
};
ol.source.Raster.getImageData_ = function(renderer, frameState, layerState) {
  if (!renderer.prepareFrame(frameState, layerState)) {
    return null;
  }
  var width = frameState.size[0];
  var height = frameState.size[1];
  if (!ol.source.Raster.context_) {
    ol.source.Raster.context_ = ol.dom.createCanvasContext2D(width, height);
  } else {
    var canvas = ol.source.Raster.context_.canvas;
    if (canvas.width !== width || canvas.height !== height) {
      ol.source.Raster.context_ = ol.dom.createCanvasContext2D(width, height);
    } else {
      ol.source.Raster.context_.clearRect(0, 0, width, height);
    }
  }
  renderer.composeFrame(frameState, layerState, ol.source.Raster.context_);
  return ol.source.Raster.context_.getImageData(0, 0, width, height);
};
ol.source.Raster.context_ = null;
ol.source.Raster.getLayerStatesArray_ = function(renderers) {
  return renderers.map(function(renderer) {
    return renderer.getLayer().getLayerState();
  });
};
ol.source.Raster.createRenderers_ = function(sources) {
  var len = sources.length;
  var renderers = new Array(len);
  for (var i = 0; i < len; ++i) {
    renderers[i] = ol.source.Raster.createRenderer_(sources[i]);
  }
  return renderers;
};
ol.source.Raster.createRenderer_ = function(source) {
  var renderer = null;
  if (source instanceof ol.source.Tile) {
    renderer = ol.source.Raster.createTileRenderer_(source);
  } else {
    if (source instanceof ol.source.Image) {
      renderer = ol.source.Raster.createImageRenderer_(source);
    }
  }
  return renderer;
};
ol.source.Raster.createImageRenderer_ = function(source) {
  var layer = new ol.layer.Image({source:source});
  return new ol.renderer.canvas.ImageLayer(layer);
};
ol.source.Raster.createTileRenderer_ = function(source) {
  var layer = new ol.layer.Tile({source:source});
  return new ol.renderer.canvas.TileLayer(layer);
};
ol.source.Raster.Event = function(type, frameState, data) {
  ol.events.Event.call(this, type);
  this.extent = frameState.extent;
  this.resolution = frameState.viewState.resolution / frameState.pixelRatio;
  this.data = data;
};
ol.inherits(ol.source.Raster.Event, ol.events.Event);
ol.source.Raster.prototype.getImageInternal = function() {
  return null;
};
ol.source.Raster.EventType_ = {BEFOREOPERATIONS:"beforeoperations", AFTEROPERATIONS:"afteroperations"};
goog.provide("ol.source.Stamen");
goog.require("ol");
goog.require("ol.source.OSM");
goog.require("ol.source.XYZ");
ol.source.Stamen = function(options) {
  var i = options.layer.indexOf("-");
  var provider = i == -1 ? options.layer : options.layer.slice(0, i);
  var providerConfig = ol.source.Stamen.ProviderConfig[provider];
  var layerConfig = ol.source.Stamen.LayerConfig[options.layer];
  var url = options.url !== undefined ? options.url : "https://stamen-tiles-{a-d}.a.ssl.fastly.net/" + options.layer + "/{z}/{x}/{y}." + layerConfig.extension;
  ol.source.XYZ.call(this, {attributions:ol.source.Stamen.ATTRIBUTIONS, cacheSize:options.cacheSize, crossOrigin:"anonymous", maxZoom:options.maxZoom != undefined ? options.maxZoom : providerConfig.maxZoom, minZoom:options.minZoom != undefined ? options.minZoom : providerConfig.minZoom, opaque:layerConfig.opaque, reprojectionErrorThreshold:options.reprojectionErrorThreshold, tileLoadFunction:options.tileLoadFunction, url:url, wrapX:options.wrapX});
};
ol.inherits(ol.source.Stamen, ol.source.XYZ);
ol.source.Stamen.ATTRIBUTIONS = ['Map tiles by <a href="https://stamen.com/">Stamen Design</a>, ' + 'under <a href="https://creativecommons.org/licenses/by/3.0/">CC BY' + " 3.0</a>.", ol.source.OSM.ATTRIBUTION];
ol.source.Stamen.LayerConfig = {"terrain":{extension:"jpg", opaque:true}, "terrain-background":{extension:"jpg", opaque:true}, "terrain-labels":{extension:"png", opaque:false}, "terrain-lines":{extension:"png", opaque:false}, "toner-background":{extension:"png", opaque:true}, "toner":{extension:"png", opaque:true}, "toner-hybrid":{extension:"png", opaque:false}, "toner-labels":{extension:"png", opaque:false}, "toner-lines":{extension:"png", opaque:false}, "toner-lite":{extension:"png", opaque:true}, 
"watercolor":{extension:"jpg", opaque:true}};
ol.source.Stamen.ProviderConfig = {"terrain":{minZoom:4, maxZoom:18}, "toner":{minZoom:0, maxZoom:20}, "watercolor":{minZoom:1, maxZoom:16}};
goog.provide("ol.source.TileArcGISRest");
goog.require("ol");
goog.require("ol.extent");
goog.require("ol.math");
goog.require("ol.obj");
goog.require("ol.size");
goog.require("ol.source.TileImage");
goog.require("ol.tilecoord");
goog.require("ol.uri");
ol.source.TileArcGISRest = function(opt_options) {
  var options = opt_options || {};
  ol.source.TileImage.call(this, {attributions:options.attributions, cacheSize:options.cacheSize, crossOrigin:options.crossOrigin, logo:options.logo, projection:options.projection, reprojectionErrorThreshold:options.reprojectionErrorThreshold, tileGrid:options.tileGrid, tileLoadFunction:options.tileLoadFunction, url:options.url, urls:options.urls, wrapX:options.wrapX !== undefined ? options.wrapX : true, transition:options.transition});
  this.params_ = options.params || {};
  this.tmpExtent_ = ol.extent.createEmpty();
  this.setKey(this.getKeyForParams_());
};
ol.inherits(ol.source.TileArcGISRest, ol.source.TileImage);
ol.source.TileArcGISRest.prototype.getKeyForParams_ = function() {
  var i = 0;
  var res = [];
  for (var key in this.params_) {
    res[i++] = key + "-" + this.params_[key];
  }
  return res.join("/");
};
ol.source.TileArcGISRest.prototype.getParams = function() {
  return this.params_;
};
ol.source.TileArcGISRest.prototype.getRequestUrl_ = function(tileCoord, tileSize, tileExtent, pixelRatio, projection, params) {
  var urls = this.urls;
  if (!urls) {
    return undefined;
  }
  var srid = projection.getCode().split(":").pop();
  params["SIZE"] = tileSize[0] + "," + tileSize[1];
  params["BBOX"] = tileExtent.join(",");
  params["BBOXSR"] = srid;
  params["IMAGESR"] = srid;
  params["DPI"] = Math.round(params["DPI"] ? params["DPI"] * pixelRatio : 90 * pixelRatio);
  var url;
  if (urls.length == 1) {
    url = urls[0];
  } else {
    var index = ol.math.modulo(ol.tilecoord.hash(tileCoord), urls.length);
    url = urls[index];
  }
  var modifiedUrl = url.replace(/MapServer\/?$/, "MapServer/export").replace(/ImageServer\/?$/, "ImageServer/exportImage");
  return ol.uri.appendParams(modifiedUrl, params);
};
ol.source.TileArcGISRest.prototype.getTilePixelRatio = function(pixelRatio) {
  return pixelRatio;
};
ol.source.TileArcGISRest.prototype.fixedTileUrlFunction = function(tileCoord, pixelRatio, projection) {
  var tileGrid = this.getTileGrid();
  if (!tileGrid) {
    tileGrid = this.getTileGridForProjection(projection);
  }
  if (tileGrid.getResolutions().length <= tileCoord[0]) {
    return undefined;
  }
  var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);
  var tileSize = ol.size.toSize(tileGrid.getTileSize(tileCoord[0]), this.tmpSize);
  if (pixelRatio != 1) {
    tileSize = ol.size.scale(tileSize, pixelRatio, this.tmpSize);
  }
  var baseParams = {"F":"image", "FORMAT":"PNG32", "TRANSPARENT":true};
  ol.obj.assign(baseParams, this.params_);
  return this.getRequestUrl_(tileCoord, tileSize, tileExtent, pixelRatio, projection, baseParams);
};
ol.source.TileArcGISRest.prototype.updateParams = function(params) {
  ol.obj.assign(this.params_, params);
  this.setKey(this.getKeyForParams_());
};
goog.provide("ol.source.TileDebug");
goog.require("ol");
goog.require("ol.Tile");
goog.require("ol.TileState");
goog.require("ol.dom");
goog.require("ol.size");
goog.require("ol.source.Tile");
goog.require("ol.tilecoord");
ol.source.TileDebug = function(options) {
  ol.source.Tile.call(this, {opaque:false, projection:options.projection, tileGrid:options.tileGrid, wrapX:options.wrapX !== undefined ? options.wrapX : true});
};
ol.inherits(ol.source.TileDebug, ol.source.Tile);
ol.source.TileDebug.prototype.getTile = function(z, x, y) {
  var tileCoordKey = ol.tilecoord.getKeyZXY(z, x, y);
  if (this.tileCache.containsKey(tileCoordKey)) {
    return this.tileCache.get(tileCoordKey);
  } else {
    var tileSize = ol.size.toSize(this.tileGrid.getTileSize(z));
    var tileCoord = [z, x, y];
    var textTileCoord = this.getTileCoordForTileUrlFunction(tileCoord);
    var text = !textTileCoord ? "" : this.getTileCoordForTileUrlFunction(textTileCoord).toString();
    var tile = new ol.source.TileDebug.Tile_(tileCoord, tileSize, text);
    this.tileCache.set(tileCoordKey, tile);
    return tile;
  }
};
ol.source.TileDebug.Tile_ = function(tileCoord, tileSize, text) {
  ol.Tile.call(this, tileCoord, ol.TileState.LOADED);
  this.tileSize_ = tileSize;
  this.text_ = text;
  this.canvas_ = null;
};
ol.inherits(ol.source.TileDebug.Tile_, ol.Tile);
ol.source.TileDebug.Tile_.prototype.getImage = function() {
  if (this.canvas_) {
    return this.canvas_;
  } else {
    var tileSize = this.tileSize_;
    var context = ol.dom.createCanvasContext2D(tileSize[0], tileSize[1]);
    context.strokeStyle = "black";
    context.strokeRect(0.5, 0.5, tileSize[0] + 0.5, tileSize[1] + 0.5);
    context.fillStyle = "black";
    context.textAlign = "center";
    context.textBaseline = "middle";
    context.font = "24px sans-serif";
    context.fillText(this.text_, tileSize[0] / 2, tileSize[1] / 2);
    this.canvas_ = context.canvas;
    return context.canvas;
  }
};
ol.source.TileDebug.Tile_.prototype.load = function() {
};
goog.provide("ol.source.TileJSON");
goog.require("ol");
goog.require("ol.TileUrlFunction");
goog.require("ol.asserts");
goog.require("ol.extent");
goog.require("ol.net");
goog.require("ol.proj");
goog.require("ol.source.State");
goog.require("ol.source.TileImage");
goog.require("ol.tilegrid");
ol.source.TileJSON = function(options) {
  this.tileJSON_ = null;
  ol.source.TileImage.call(this, {attributions:options.attributions, cacheSize:options.cacheSize, crossOrigin:options.crossOrigin, projection:ol.proj.get("EPSG:3857"), reprojectionErrorThreshold:options.reprojectionErrorThreshold, state:ol.source.State.LOADING, tileLoadFunction:options.tileLoadFunction, wrapX:options.wrapX !== undefined ? options.wrapX : true, transition:options.transition});
  if (options.url) {
    if (options.jsonp) {
      ol.net.jsonp(options.url, this.handleTileJSONResponse.bind(this), this.handleTileJSONError.bind(this));
    } else {
      var client = new XMLHttpRequest;
      client.addEventListener("load", this.onXHRLoad_.bind(this));
      client.addEventListener("error", this.onXHRError_.bind(this));
      client.open("GET", options.url);
      client.send();
    }
  } else {
    if (options.tileJSON) {
      this.handleTileJSONResponse(options.tileJSON);
    } else {
      ol.asserts.assert(false, 51);
    }
  }
};
ol.inherits(ol.source.TileJSON, ol.source.TileImage);
ol.source.TileJSON.prototype.onXHRLoad_ = function(event) {
  var client = event.target;
  if (!client.status || client.status >= 200 && client.status < 300) {
    var response;
    try {
      response = JSON.parse(client.responseText);
    } catch (err) {
      this.handleTileJSONError();
      return;
    }
    this.handleTileJSONResponse(response);
  } else {
    this.handleTileJSONError();
  }
};
ol.source.TileJSON.prototype.onXHRError_ = function(event) {
  this.handleTileJSONError();
};
ol.source.TileJSON.prototype.getTileJSON = function() {
  return this.tileJSON_;
};
ol.source.TileJSON.prototype.handleTileJSONResponse = function(tileJSON) {
  var epsg4326Projection = ol.proj.get("EPSG:4326");
  var sourceProjection = this.getProjection();
  var extent;
  if (tileJSON.bounds !== undefined) {
    var transform = ol.proj.getTransformFromProjections(epsg4326Projection, sourceProjection);
    extent = ol.extent.applyTransform(tileJSON.bounds, transform);
  }
  var minZoom = tileJSON.minzoom || 0;
  var maxZoom = tileJSON.maxzoom || 22;
  var tileGrid = ol.tilegrid.createXYZ({extent:ol.tilegrid.extentFromProjection(sourceProjection), maxZoom:maxZoom, minZoom:minZoom});
  this.tileGrid = tileGrid;
  this.tileUrlFunction = ol.TileUrlFunction.createFromTemplates(tileJSON.tiles, tileGrid);
  if (tileJSON.attribution !== undefined && !this.getAttributions2()) {
    var attributionExtent = extent !== undefined ? extent : epsg4326Projection.getExtent();
    this.setAttributions(function(frameState) {
      if (ol.extent.intersects(attributionExtent, frameState.extent)) {
        return [tileJSON.attribution];
      }
      return null;
    });
  }
  this.tileJSON_ = tileJSON;
  this.setState(ol.source.State.READY);
};
ol.source.TileJSON.prototype.handleTileJSONError = function() {
  this.setState(ol.source.State.ERROR);
};
goog.provide("ol.source.TileUTFGrid");
goog.require("ol");
goog.require("ol.Tile");
goog.require("ol.TileState");
goog.require("ol.TileUrlFunction");
goog.require("ol.asserts");
goog.require("ol.events");
goog.require("ol.events.EventType");
goog.require("ol.extent");
goog.require("ol.net");
goog.require("ol.proj");
goog.require("ol.source.State");
goog.require("ol.source.Tile");
goog.require("ol.tilecoord");
goog.require("ol.tilegrid");
ol.source.TileUTFGrid = function(options) {
  ol.source.Tile.call(this, {projection:ol.proj.get("EPSG:3857"), state:ol.source.State.LOADING});
  this.preemptive_ = options.preemptive !== undefined ? options.preemptive : true;
  this.tileUrlFunction_ = ol.TileUrlFunction.nullTileUrlFunction;
  this.template_ = undefined;
  this.jsonp_ = options.jsonp || false;
  if (options.url) {
    if (this.jsonp_) {
      ol.net.jsonp(options.url, this.handleTileJSONResponse.bind(this), this.handleTileJSONError.bind(this));
    } else {
      var client = new XMLHttpRequest;
      client.addEventListener("load", this.onXHRLoad_.bind(this));
      client.addEventListener("error", this.onXHRError_.bind(this));
      client.open("GET", options.url);
      client.send();
    }
  } else {
    if (options.tileJSON) {
      this.handleTileJSONResponse(options.tileJSON);
    } else {
      ol.asserts.assert(false, 51);
    }
  }
};
ol.inherits(ol.source.TileUTFGrid, ol.source.Tile);
ol.source.TileUTFGrid.prototype.onXHRLoad_ = function(event) {
  var client = event.target;
  if (!client.status || client.status >= 200 && client.status < 300) {
    var response;
    try {
      response = JSON.parse(client.responseText);
    } catch (err) {
      this.handleTileJSONError();
      return;
    }
    this.handleTileJSONResponse(response);
  } else {
    this.handleTileJSONError();
  }
};
ol.source.TileUTFGrid.prototype.onXHRError_ = function(event) {
  this.handleTileJSONError();
};
ol.source.TileUTFGrid.prototype.getTemplate = function() {
  return this.template_;
};
ol.source.TileUTFGrid.prototype.forDataAtCoordinateAndResolution = function(coordinate, resolution, callback, opt_this, opt_request) {
  if (this.tileGrid) {
    var tileCoord = this.tileGrid.getTileCoordForCoordAndResolution(coordinate, resolution);
    var tile = this.getTile(tileCoord[0], tileCoord[1], tileCoord[2], 1, this.getProjection());
    tile.forDataAtCoordinate(coordinate, callback, opt_this, opt_request);
  } else {
    if (opt_request === true) {
      setTimeout(function() {
        callback.call(opt_this, null);
      }, 0);
    } else {
      callback.call(opt_this, null);
    }
  }
};
ol.source.TileUTFGrid.prototype.handleTileJSONError = function() {
  this.setState(ol.source.State.ERROR);
};
ol.source.TileUTFGrid.prototype.handleTileJSONResponse = function(tileJSON) {
  var epsg4326Projection = ol.proj.get("EPSG:4326");
  var sourceProjection = this.getProjection();
  var extent;
  if (tileJSON.bounds !== undefined) {
    var transform = ol.proj.getTransformFromProjections(epsg4326Projection, sourceProjection);
    extent = ol.extent.applyTransform(tileJSON.bounds, transform);
  }
  var minZoom = tileJSON.minzoom || 0;
  var maxZoom = tileJSON.maxzoom || 22;
  var tileGrid = ol.tilegrid.createXYZ({extent:ol.tilegrid.extentFromProjection(sourceProjection), maxZoom:maxZoom, minZoom:minZoom});
  this.tileGrid = tileGrid;
  this.template_ = tileJSON.template;
  var grids = tileJSON.grids;
  if (!grids) {
    this.setState(ol.source.State.ERROR);
    return;
  }
  this.tileUrlFunction_ = ol.TileUrlFunction.createFromTemplates(grids, tileGrid);
  if (tileJSON.attribution !== undefined) {
    var attributionExtent = extent !== undefined ? extent : epsg4326Projection.getExtent();
    this.setAttributions(function(frameState) {
      if (ol.extent.intersects(attributionExtent, frameState.extent)) {
        return [tileJSON.attribution];
      }
      return null;
    });
  }
  this.setState(ol.source.State.READY);
};
ol.source.TileUTFGrid.prototype.getTile = function(z, x, y, pixelRatio, projection) {
  var tileCoordKey = ol.tilecoord.getKeyZXY(z, x, y);
  if (this.tileCache.containsKey(tileCoordKey)) {
    return this.tileCache.get(tileCoordKey);
  } else {
    var tileCoord = [z, x, y];
    var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
    var tileUrl = this.tileUrlFunction_(urlTileCoord, pixelRatio, projection);
    var tile = new ol.source.TileUTFGrid.Tile_(tileCoord, tileUrl !== undefined ? ol.TileState.IDLE : ol.TileState.EMPTY, tileUrl !== undefined ? tileUrl : "", this.tileGrid.getTileCoordExtent(tileCoord), this.preemptive_, this.jsonp_);
    this.tileCache.set(tileCoordKey, tile);
    return tile;
  }
};
ol.source.TileUTFGrid.prototype.useTile = function(z, x, y) {
  var tileCoordKey = ol.tilecoord.getKeyZXY(z, x, y);
  if (this.tileCache.containsKey(tileCoordKey)) {
    this.tileCache.get(tileCoordKey);
  }
};
ol.source.TileUTFGrid.Tile_ = function(tileCoord, state, src, extent, preemptive, jsonp) {
  ol.Tile.call(this, tileCoord, state);
  this.src_ = src;
  this.extent_ = extent;
  this.preemptive_ = preemptive;
  this.grid_ = null;
  this.keys_ = null;
  this.data_ = null;
  this.jsonp_ = jsonp;
};
ol.inherits(ol.source.TileUTFGrid.Tile_, ol.Tile);
ol.source.TileUTFGrid.Tile_.prototype.getImage = function() {
  return null;
};
ol.source.TileUTFGrid.Tile_.prototype.getData = function(coordinate) {
  if (!this.grid_ || !this.keys_) {
    return null;
  }
  var xRelative = (coordinate[0] - this.extent_[0]) / (this.extent_[2] - this.extent_[0]);
  var yRelative = (coordinate[1] - this.extent_[1]) / (this.extent_[3] - this.extent_[1]);
  var row = this.grid_[Math.floor((1 - yRelative) * this.grid_.length)];
  if (typeof row !== "string") {
    return null;
  }
  var code = row.charCodeAt(Math.floor(xRelative * row.length));
  if (code >= 93) {
    code--;
  }
  if (code >= 35) {
    code--;
  }
  code -= 32;
  var data = null;
  if (code in this.keys_) {
    var id = this.keys_[code];
    if (this.data_ && id in this.data_) {
      data = this.data_[id];
    } else {
      data = id;
    }
  }
  return data;
};
ol.source.TileUTFGrid.Tile_.prototype.forDataAtCoordinate = function(coordinate, callback, opt_this, opt_request) {
  if (this.state == ol.TileState.IDLE && opt_request === true) {
    ol.events.listenOnce(this, ol.events.EventType.CHANGE, function(e) {
      callback.call(opt_this, this.getData(coordinate));
    }, this);
    this.loadInternal_();
  } else {
    if (opt_request === true) {
      setTimeout(function() {
        callback.call(opt_this, this.getData(coordinate));
      }.bind(this), 0);
    } else {
      callback.call(opt_this, this.getData(coordinate));
    }
  }
};
ol.source.TileUTFGrid.Tile_.prototype.getKey = function() {
  return this.src_;
};
ol.source.TileUTFGrid.Tile_.prototype.handleError_ = function() {
  this.state = ol.TileState.ERROR;
  this.changed();
};
ol.source.TileUTFGrid.Tile_.prototype.handleLoad_ = function(json) {
  this.grid_ = json.grid;
  this.keys_ = json.keys;
  this.data_ = json.data;
  this.state = ol.TileState.EMPTY;
  this.changed();
};
ol.source.TileUTFGrid.Tile_.prototype.loadInternal_ = function() {
  if (this.state == ol.TileState.IDLE) {
    this.state = ol.TileState.LOADING;
    if (this.jsonp_) {
      ol.net.jsonp(this.src_, this.handleLoad_.bind(this), this.handleError_.bind(this));
    } else {
      var client = new XMLHttpRequest;
      client.addEventListener("load", this.onXHRLoad_.bind(this));
      client.addEventListener("error", this.onXHRError_.bind(this));
      client.open("GET", this.src_);
      client.send();
    }
  }
};
ol.source.TileUTFGrid.Tile_.prototype.onXHRLoad_ = function(event) {
  var client = event.target;
  if (!client.status || client.status >= 200 && client.status < 300) {
    var response;
    try {
      response = JSON.parse(client.responseText);
    } catch (err) {
      this.handleError_();
      return;
    }
    this.handleLoad_(response);
  } else {
    this.handleError_();
  }
};
ol.source.TileUTFGrid.Tile_.prototype.onXHRError_ = function(event) {
  this.handleError_();
};
ol.source.TileUTFGrid.Tile_.prototype.load = function() {
  if (this.preemptive_) {
    this.loadInternal_();
  }
};
goog.provide("ol.VectorImageTile");
goog.require("ol");
goog.require("ol.Tile");
goog.require("ol.TileState");
goog.require("ol.dom");
goog.require("ol.events");
goog.require("ol.extent");
goog.require("ol.events.EventType");
goog.require("ol.featureloader");
ol.VectorImageTile = function(tileCoord, state, sourceRevision, format, tileLoadFunction, urlTileCoord, tileUrlFunction, sourceTileGrid, tileGrid, sourceTiles, pixelRatio, projection, tileClass, handleTileChange, opt_options) {
  ol.Tile.call(this, tileCoord, state, opt_options);
  this.context_ = {};
  this.loader_;
  this.replayState_ = {};
  this.sourceTiles_ = sourceTiles;
  this.tileKeys = [];
  this.sourceRevision_ = sourceRevision;
  this.wrappedTileCoord = urlTileCoord;
  this.loadListenerKeys_ = [];
  this.sourceTileListenerKeys_ = [];
  if (urlTileCoord) {
    var extent = tileGrid.getTileCoordExtent(urlTileCoord);
    var resolution = tileGrid.getResolution(tileCoord[0]);
    var sourceZ = sourceTileGrid.getZForResolution(resolution);
    sourceTileGrid.forEachTileCoord(extent, sourceZ, function(sourceTileCoord) {
      var sharedExtent = ol.extent.getIntersection(extent, sourceTileGrid.getTileCoordExtent(sourceTileCoord));
      var sourceExtent = sourceTileGrid.getExtent();
      if (sourceExtent) {
        sharedExtent = ol.extent.getIntersection(sharedExtent, sourceExtent);
      }
      if (ol.extent.getWidth(sharedExtent) / resolution >= 0.5 && ol.extent.getHeight(sharedExtent) / resolution >= 0.5) {
        var sourceTileKey = sourceTileCoord.toString();
        var sourceTile = sourceTiles[sourceTileKey];
        if (!sourceTile) {
          var tileUrl = tileUrlFunction(sourceTileCoord, pixelRatio, projection);
          sourceTile = sourceTiles[sourceTileKey] = new tileClass(sourceTileCoord, tileUrl == undefined ? ol.TileState.EMPTY : ol.TileState.IDLE, tileUrl == undefined ? "" : tileUrl, format, tileLoadFunction);
          this.sourceTileListenerKeys_.push(ol.events.listen(sourceTile, ol.events.EventType.CHANGE, handleTileChange));
        }
        sourceTile.consumers++;
        this.tileKeys.push(sourceTileKey);
      }
    }.bind(this));
  }
};
ol.inherits(ol.VectorImageTile, ol.Tile);
ol.VectorImageTile.prototype.disposeInternal = function() {
  for (var i = 0, ii = this.tileKeys.length; i < ii; ++i) {
    var sourceTileKey = this.tileKeys[i];
    var sourceTile = this.getTile(sourceTileKey);
    sourceTile.consumers--;
    if (sourceTile.consumers == 0) {
      delete this.sourceTiles_[sourceTileKey];
      sourceTile.dispose();
    }
  }
  this.tileKeys.length = 0;
  this.sourceTiles_ = null;
  this.loadListenerKeys_.forEach(ol.events.unlistenByKey);
  this.loadListenerKeys_.length = 0;
  if (this.interimTile) {
    this.interimTile.dispose();
  }
  this.state = ol.TileState.ABORT;
  this.changed();
  this.sourceTileListenerKeys_.forEach(ol.events.unlistenByKey);
  this.sourceTileListenerKeys_.length = 0;
  ol.Tile.prototype.disposeInternal.call(this);
};
ol.VectorImageTile.prototype.getContext = function(layer) {
  var key = ol.getUid(layer).toString();
  if (!(key in this.context_)) {
    this.context_[key] = ol.dom.createCanvasContext2D();
  }
  return this.context_[key];
};
ol.VectorImageTile.prototype.getImage = function(layer) {
  return this.getReplayState(layer).renderedTileRevision == -1 ? null : this.getContext(layer).canvas;
};
ol.VectorImageTile.prototype.getReplayState = function(layer) {
  var key = ol.getUid(layer).toString();
  if (!(key in this.replayState_)) {
    this.replayState_[key] = {dirty:false, renderedRenderOrder:null, renderedRevision:-1, renderedTileRevision:-1};
  }
  return this.replayState_[key];
};
ol.VectorImageTile.prototype.getKey = function() {
  return this.tileKeys.join("/") + "-" + this.sourceRevision_;
};
ol.VectorImageTile.prototype.getTile = function(tileKey) {
  return this.sourceTiles_[tileKey];
};
ol.VectorImageTile.prototype.load = function() {
  var leftToLoad = 0;
  var errorSourceTiles = {};
  if (this.state == ol.TileState.IDLE) {
    this.setState(ol.TileState.LOADING);
  }
  if (this.state == ol.TileState.LOADING) {
    this.tileKeys.forEach(function(sourceTileKey) {
      var sourceTile = this.getTile(sourceTileKey);
      if (sourceTile.state == ol.TileState.IDLE) {
        sourceTile.setLoader(this.loader_);
        sourceTile.load();
      }
      if (sourceTile.state == ol.TileState.LOADING) {
        var key = ol.events.listen(sourceTile, ol.events.EventType.CHANGE, function(e) {
          var state = sourceTile.getState();
          if (state == ol.TileState.LOADED || state == ol.TileState.ERROR) {
            var uid = ol.getUid(sourceTile);
            if (state == ol.TileState.ERROR) {
              errorSourceTiles[uid] = true;
            } else {
              --leftToLoad;
              delete errorSourceTiles[uid];
            }
            if (leftToLoad - Object.keys(errorSourceTiles).length == 0) {
              this.finishLoading_();
            }
          }
        }.bind(this));
        this.loadListenerKeys_.push(key);
        ++leftToLoad;
      }
    }.bind(this));
  }
  if (leftToLoad - Object.keys(errorSourceTiles).length == 0) {
    setTimeout(this.finishLoading_.bind(this), 0);
  }
};
ol.VectorImageTile.prototype.finishLoading_ = function() {
  var loaded = this.tileKeys.length;
  var empty = 0;
  for (var i = loaded - 1; i >= 0; --i) {
    var state = this.getTile(this.tileKeys[i]).getState();
    if (state != ol.TileState.LOADED) {
      --loaded;
    }
    if (state == ol.TileState.EMPTY) {
      ++empty;
    }
  }
  if (loaded == this.tileKeys.length) {
    this.loadListenerKeys_.forEach(ol.events.unlistenByKey);
    this.loadListenerKeys_.length = 0;
    this.setState(ol.TileState.LOADED);
  } else {
    this.setState(empty == this.tileKeys.length ? ol.TileState.EMPTY : ol.TileState.ERROR);
  }
};
ol.VectorImageTile.defaultLoadFunction = function(tile, url) {
  var loader = ol.featureloader.loadFeaturesXhr(url, tile.getFormat(), tile.onLoad.bind(tile), tile.onError.bind(tile));
  tile.setLoader(loader);
};
goog.provide("ol.VectorTile");
goog.require("ol");
goog.require("ol.Tile");
goog.require("ol.TileState");
ol.VectorTile = function(tileCoord, state, src, format, tileLoadFunction, opt_options) {
  ol.Tile.call(this, tileCoord, state, opt_options);
  this.consumers = 0;
  this.extent_ = null;
  this.format_ = format;
  this.features_ = null;
  this.loader_;
  this.projection_;
  this.replayGroups_ = {};
  this.tileLoadFunction_ = tileLoadFunction;
  this.url_ = src;
};
ol.inherits(ol.VectorTile, ol.Tile);
ol.VectorTile.prototype.disposeInternal = function() {
  this.features_ = null;
  this.replayGroups_ = {};
  this.state = ol.TileState.ABORT;
  this.changed();
  ol.Tile.prototype.disposeInternal.call(this);
};
ol.VectorTile.prototype.getExtent = function() {
  return this.extent_ || ol.VectorTile.DEFAULT_EXTENT;
};
ol.VectorTile.prototype.getFormat = function() {
  return this.format_;
};
ol.VectorTile.prototype.getFeatures = function() {
  return this.features_;
};
ol.VectorTile.prototype.getKey = function() {
  return this.url_;
};
ol.VectorTile.prototype.getProjection = function() {
  return this.projection_;
};
ol.VectorTile.prototype.getReplayGroup = function(layer, key) {
  return this.replayGroups_[ol.getUid(layer) + "," + key];
};
ol.VectorTile.prototype.load = function() {
  if (this.state == ol.TileState.IDLE) {
    this.setState(ol.TileState.LOADING);
    this.tileLoadFunction_(this, this.url_);
    this.loader_(null, NaN, null);
  }
};
ol.VectorTile.prototype.onLoad = function(features, dataProjection, extent) {
  this.setProjection(dataProjection);
  this.setFeatures(features);
  this.setExtent(extent);
};
ol.VectorTile.prototype.onError = function() {
  this.setState(ol.TileState.ERROR);
};
ol.VectorTile.prototype.setExtent = function(extent) {
  this.extent_ = extent;
};
ol.VectorTile.prototype.setFeatures = function(features) {
  this.features_ = features;
  this.setState(ol.TileState.LOADED);
};
ol.VectorTile.prototype.setProjection = function(projection) {
  this.projection_ = projection;
};
ol.VectorTile.prototype.setReplayGroup = function(layer, key, replayGroup) {
  this.replayGroups_[ol.getUid(layer) + "," + key] = replayGroup;
};
ol.VectorTile.prototype.setLoader = function(loader) {
  this.loader_ = loader;
};
ol.VectorTile.DEFAULT_EXTENT = [0, 0, 4096, 4096];
goog.provide("ol.source.VectorTile");
goog.require("ol");
goog.require("ol.TileState");
goog.require("ol.VectorImageTile");
goog.require("ol.VectorTile");
goog.require("ol.size");
goog.require("ol.source.UrlTile");
goog.require("ol.tilecoord");
goog.require("ol.tilegrid");
ol.source.VectorTile = function(options) {
  var projection = options.projection || "EPSG:3857";
  var extent = options.extent || ol.tilegrid.extentFromProjection(projection);
  var tileGrid = options.tileGrid || ol.tilegrid.createXYZ({extent:extent, maxZoom:options.maxZoom || 22, minZoom:options.minZoom, tileSize:options.tileSize || 512});
  ol.source.UrlTile.call(this, {attributions:options.attributions, cacheSize:options.cacheSize !== undefined ? options.cacheSize : 128, extent:extent, logo:options.logo, opaque:false, projection:projection, state:options.state, tileGrid:tileGrid, tileLoadFunction:options.tileLoadFunction ? options.tileLoadFunction : ol.VectorImageTile.defaultLoadFunction, tileUrlFunction:options.tileUrlFunction, url:options.url, urls:options.urls, wrapX:options.wrapX === undefined ? true : options.wrapX, transition:options.transition});
  this.format_ = options.format ? options.format : null;
  this.sourceTiles_ = {};
  this.overlaps_ = options.overlaps == undefined ? true : options.overlaps;
  this.tileClass = options.tileClass ? options.tileClass : ol.VectorTile;
  this.tileGrids_ = {};
};
ol.inherits(ol.source.VectorTile, ol.source.UrlTile);
ol.source.VectorTile.prototype.getOverlaps = function() {
  return this.overlaps_;
};
ol.source.VectorTile.prototype.clear = function() {
  this.tileCache.clear();
  this.sourceTiles_ = {};
};
ol.source.VectorTile.prototype.getTile = function(z, x, y, pixelRatio, projection) {
  var tileCoordKey = ol.tilecoord.getKeyZXY(z, x, y);
  if (this.tileCache.containsKey(tileCoordKey)) {
    return this.tileCache.get(tileCoordKey);
  } else {
    var tileCoord = [z, x, y];
    var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
    var tile = new ol.VectorImageTile(tileCoord, urlTileCoord !== null ? ol.TileState.IDLE : ol.TileState.EMPTY, this.getRevision(), this.format_, this.tileLoadFunction, urlTileCoord, this.tileUrlFunction, this.tileGrid, this.getTileGridForProjection(projection), this.sourceTiles_, pixelRatio, projection, this.tileClass, this.handleTileChange.bind(this), this.tileOptions);
    this.tileCache.set(tileCoordKey, tile);
    return tile;
  }
};
ol.source.VectorTile.prototype.getTileGridForProjection = function(projection) {
  var code = projection.getCode();
  var tileGrid = this.tileGrids_[code];
  if (!tileGrid) {
    var sourceTileGrid = this.tileGrid;
    tileGrid = this.tileGrids_[code] = ol.tilegrid.createForProjection(projection, undefined, sourceTileGrid ? sourceTileGrid.getTileSize(sourceTileGrid.getMinZoom()) : undefined);
  }
  return tileGrid;
};
ol.source.VectorTile.prototype.getTilePixelRatio = function(pixelRatio) {
  return pixelRatio;
};
ol.source.VectorTile.prototype.getTilePixelSize = function(z, pixelRatio, projection) {
  var tileSize = ol.size.toSize(this.getTileGridForProjection(projection).getTileSize(z));
  return [Math.round(tileSize[0] * pixelRatio), Math.round(tileSize[1] * pixelRatio)];
};
goog.provide("ol.source.WMTSRequestEncoding");
ol.source.WMTSRequestEncoding = {KVP:"KVP", REST:"REST"};
goog.provide("ol.tilegrid.WMTS");
goog.require("ol");
goog.require("ol.array");
goog.require("ol.proj");
goog.require("ol.tilegrid.TileGrid");
ol.tilegrid.WMTS = function(options) {
  this.matrixIds_ = options.matrixIds;
  ol.tilegrid.TileGrid.call(this, {extent:options.extent, origin:options.origin, origins:options.origins, resolutions:options.resolutions, tileSize:options.tileSize, tileSizes:options.tileSizes, sizes:options.sizes});
};
ol.inherits(ol.tilegrid.WMTS, ol.tilegrid.TileGrid);
ol.tilegrid.WMTS.prototype.getMatrixId = function(z) {
  return this.matrixIds_[z];
};
ol.tilegrid.WMTS.prototype.getMatrixIds = function() {
  return this.matrixIds_;
};
ol.tilegrid.WMTS.createFromCapabilitiesMatrixSet = function(matrixSet, opt_extent, opt_matrixLimits) {
  var resolutions = [];
  var matrixIds = [];
  var origins = [];
  var tileSizes = [];
  var sizes = [];
  var matrixLimits = opt_matrixLimits !== undefined ? opt_matrixLimits : [];
  var supportedCRSPropName = "SupportedCRS";
  var matrixIdsPropName = "TileMatrix";
  var identifierPropName = "Identifier";
  var scaleDenominatorPropName = "ScaleDenominator";
  var topLeftCornerPropName = "TopLeftCorner";
  var tileWidthPropName = "TileWidth";
  var tileHeightPropName = "TileHeight";
  var code = matrixSet[supportedCRSPropName];
  var projection = ol.proj.get(code.replace(/urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, "$1:$3")) || ol.proj.get(code);
  var metersPerUnit = projection.getMetersPerUnit();
  var switchOriginXY = projection.getAxisOrientation().substr(0, 2) == "ne";
  matrixSet[matrixIdsPropName].sort(function(a, b) {
    return b[scaleDenominatorPropName] - a[scaleDenominatorPropName];
  });
  matrixSet[matrixIdsPropName].forEach(function(elt, index, array) {
    var matrixAvailable;
    if (matrixLimits.length > 0) {
      matrixAvailable = ol.array.find(matrixLimits, function(elt_ml, index_ml, array_ml) {
        return elt[identifierPropName] == elt_ml[matrixIdsPropName];
      });
    } else {
      matrixAvailable = true;
    }
    if (matrixAvailable) {
      matrixIds.push(elt[identifierPropName]);
      var resolution = elt[scaleDenominatorPropName] * 0.28E-3 / metersPerUnit;
      var tileWidth = elt[tileWidthPropName];
      var tileHeight = elt[tileHeightPropName];
      if (switchOriginXY) {
        origins.push([elt[topLeftCornerPropName][1], elt[topLeftCornerPropName][0]]);
      } else {
        origins.push(elt[topLeftCornerPropName]);
      }
      resolutions.push(resolution);
      tileSizes.push(tileWidth == tileHeight ? tileWidth : [tileWidth, tileHeight]);
      sizes.push([elt["MatrixWidth"], -elt["MatrixHeight"]]);
    }
  });
  return new ol.tilegrid.WMTS({extent:opt_extent, origins:origins, resolutions:resolutions, matrixIds:matrixIds, tileSizes:tileSizes, sizes:sizes});
};
goog.provide("ol.source.WMTS");
goog.require("ol");
goog.require("ol.TileUrlFunction");
goog.require("ol.array");
goog.require("ol.extent");
goog.require("ol.obj");
goog.require("ol.proj");
goog.require("ol.source.TileImage");
goog.require("ol.source.WMTSRequestEncoding");
goog.require("ol.tilegrid.WMTS");
goog.require("ol.uri");
ol.source.WMTS = function(options) {
  this.version_ = options.version !== undefined ? options.version : "1.0.0";
  this.format_ = options.format !== undefined ? options.format : "image/jpeg";
  this.dimensions_ = options.dimensions !== undefined ? options.dimensions : {};
  this.layer_ = options.layer;
  this.matrixSet_ = options.matrixSet;
  this.style_ = options.style;
  var urls = options.urls;
  if (urls === undefined && options.url !== undefined) {
    urls = ol.TileUrlFunction.expandUrl(options.url);
  }
  this.requestEncoding_ = options.requestEncoding !== undefined ? options.requestEncoding : ol.source.WMTSRequestEncoding.KVP;
  var requestEncoding = this.requestEncoding_;
  var tileGrid = options.tileGrid;
  var context = {"layer":this.layer_, "style":this.style_, "tilematrixset":this.matrixSet_};
  if (requestEncoding == ol.source.WMTSRequestEncoding.KVP) {
    ol.obj.assign(context, {"Service":"WMTS", "Request":"GetTile", "Version":this.version_, "Format":this.format_});
  }
  var dimensions = this.dimensions_;
  this.createFromWMTSTemplate_ = function(template) {
    template = requestEncoding == ol.source.WMTSRequestEncoding.KVP ? ol.uri.appendParams(template, context) : template.replace(/\{(\w+?)\}/g, function(m, p) {
      return p.toLowerCase() in context ? context[p.toLowerCase()] : m;
    });
    return function(tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return undefined;
      } else {
        var localContext = {"TileMatrix":tileGrid.getMatrixId(tileCoord[0]), "TileCol":tileCoord[1], "TileRow":-tileCoord[2] - 1};
        ol.obj.assign(localContext, dimensions);
        var url = template;
        if (requestEncoding == ol.source.WMTSRequestEncoding.KVP) {
          url = ol.uri.appendParams(url, localContext);
        } else {
          url = url.replace(/\{(\w+?)\}/g, function(m, p) {
            return localContext[p];
          });
        }
        return url;
      }
    };
  };
  var tileUrlFunction = urls && urls.length > 0 ? ol.TileUrlFunction.createFromTileUrlFunctions(urls.map(this.createFromWMTSTemplate_)) : ol.TileUrlFunction.nullTileUrlFunction;
  ol.source.TileImage.call(this, {attributions:options.attributions, cacheSize:options.cacheSize, crossOrigin:options.crossOrigin, logo:options.logo, projection:options.projection, reprojectionErrorThreshold:options.reprojectionErrorThreshold, tileClass:options.tileClass, tileGrid:tileGrid, tileLoadFunction:options.tileLoadFunction, tilePixelRatio:options.tilePixelRatio, tileUrlFunction:tileUrlFunction, urls:urls, wrapX:options.wrapX !== undefined ? options.wrapX : false, transition:options.transition});
  this.setKey(this.getKeyForDimensions_());
};
ol.inherits(ol.source.WMTS, ol.source.TileImage);
ol.source.WMTS.prototype.setUrls = function(urls) {
  this.urls = urls;
  var key = urls.join("\n");
  this.setTileUrlFunction(this.fixedTileUrlFunction ? this.fixedTileUrlFunction.bind(this) : ol.TileUrlFunction.createFromTileUrlFunctions(urls.map(this.createFromWMTSTemplate_.bind(this))), key);
};
ol.source.WMTS.prototype.getDimensions = function() {
  return this.dimensions_;
};
ol.source.WMTS.prototype.getFormat = function() {
  return this.format_;
};
ol.source.WMTS.prototype.getLayer = function() {
  return this.layer_;
};
ol.source.WMTS.prototype.getMatrixSet = function() {
  return this.matrixSet_;
};
ol.source.WMTS.prototype.getRequestEncoding = function() {
  return this.requestEncoding_;
};
ol.source.WMTS.prototype.getStyle = function() {
  return this.style_;
};
ol.source.WMTS.prototype.getVersion = function() {
  return this.version_;
};
ol.source.WMTS.prototype.getKeyForDimensions_ = function() {
  var i = 0;
  var res = [];
  for (var key in this.dimensions_) {
    res[i++] = key + "-" + this.dimensions_[key];
  }
  return res.join("/");
};
ol.source.WMTS.prototype.updateDimensions = function(dimensions) {
  ol.obj.assign(this.dimensions_, dimensions);
  this.setKey(this.getKeyForDimensions_());
};
ol.source.WMTS.optionsFromCapabilities = function(wmtsCap, config) {
  var layers = wmtsCap["Contents"]["Layer"];
  var l = ol.array.find(layers, function(elt, index, array) {
    return elt["Identifier"] == config["layer"];
  });
  if (l === null) {
    return null;
  }
  var tileMatrixSets = wmtsCap["Contents"]["TileMatrixSet"];
  var idx, matrixSet, matrixLimits;
  if (l["TileMatrixSetLink"].length > 1) {
    if ("projection" in config) {
      idx = ol.array.findIndex(l["TileMatrixSetLink"], function(elt, index, array) {
        var tileMatrixSet = ol.array.find(tileMatrixSets, function(el) {
          return el["Identifier"] == elt["TileMatrixSet"];
        });
        var supportedCRS = tileMatrixSet["SupportedCRS"];
        var proj1 = ol.proj.get(supportedCRS.replace(/urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, "$1:$3")) || ol.proj.get(supportedCRS);
        var proj2 = ol.proj.get(config["projection"]);
        if (proj1 && proj2) {
          return ol.proj.equivalent(proj1, proj2);
        } else {
          return supportedCRS == config["projection"];
        }
      });
    } else {
      idx = ol.array.findIndex(l["TileMatrixSetLink"], function(elt, index, array) {
        return elt["TileMatrixSet"] == config["matrixSet"];
      });
    }
  } else {
    idx = 0;
  }
  if (idx < 0) {
    idx = 0;
  }
  matrixSet = l["TileMatrixSetLink"][idx]["TileMatrixSet"];
  matrixLimits = l["TileMatrixSetLink"][idx]["TileMatrixSetLimits"];
  var format = l["Format"][0];
  if ("format" in config) {
    format = config["format"];
  }
  idx = ol.array.findIndex(l["Style"], function(elt, index, array) {
    if ("style" in config) {
      return elt["Title"] == config["style"];
    } else {
      return elt["isDefault"];
    }
  });
  if (idx < 0) {
    idx = 0;
  }
  var style = l["Style"][idx]["Identifier"];
  var dimensions = {};
  if ("Dimension" in l) {
    l["Dimension"].forEach(function(elt, index, array) {
      var key = elt["Identifier"];
      var value = elt["Default"];
      if (value === undefined) {
        value = elt["Value"][0];
      }
      dimensions[key] = value;
    });
  }
  var matrixSets = wmtsCap["Contents"]["TileMatrixSet"];
  var matrixSetObj = ol.array.find(matrixSets, function(elt, index, array) {
    return elt["Identifier"] == matrixSet;
  });
  var projection;
  var code = matrixSetObj["SupportedCRS"];
  if (code) {
    projection = ol.proj.get(code.replace(/urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, "$1:$3")) || ol.proj.get(code);
  }
  if ("projection" in config) {
    var projConfig = ol.proj.get(config["projection"]);
    if (projConfig) {
      if (!projection || ol.proj.equivalent(projConfig, projection)) {
        projection = projConfig;
      }
    }
  }
  var wgs84BoundingBox = l["WGS84BoundingBox"];
  var extent, wrapX;
  if (wgs84BoundingBox !== undefined) {
    var wgs84ProjectionExtent = ol.proj.get("EPSG:4326").getExtent();
    wrapX = wgs84BoundingBox[0] == wgs84ProjectionExtent[0] && wgs84BoundingBox[2] == wgs84ProjectionExtent[2];
    extent = ol.proj.transformExtent(wgs84BoundingBox, "EPSG:4326", projection);
    var projectionExtent = projection.getExtent();
    if (projectionExtent) {
      if (!ol.extent.containsExtent(projectionExtent, extent)) {
        extent = undefined;
      }
    }
  }
  var tileGrid = ol.tilegrid.WMTS.createFromCapabilitiesMatrixSet(matrixSetObj, extent, matrixLimits);
  var urls = [];
  var requestEncoding = config["requestEncoding"];
  requestEncoding = requestEncoding !== undefined ? requestEncoding : "";
  if ("OperationsMetadata" in wmtsCap && "GetTile" in wmtsCap["OperationsMetadata"]) {
    var gets = wmtsCap["OperationsMetadata"]["GetTile"]["DCP"]["HTTP"]["Get"];
    for (var i = 0, ii = gets.length; i < ii; ++i) {
      if (gets[i]["Constraint"]) {
        var constraint = ol.array.find(gets[i]["Constraint"], function(element) {
          return element["name"] == "GetEncoding";
        });
        var encodings = constraint["AllowedValues"]["Value"];
        if (requestEncoding === "") {
          requestEncoding = encodings[0];
        }
        if (requestEncoding === ol.source.WMTSRequestEncoding.KVP) {
          if (ol.array.includes(encodings, ol.source.WMTSRequestEncoding.KVP)) {
            urls.push(gets[i]["href"]);
          }
        } else {
          break;
        }
      } else {
        if (gets[i]["href"]) {
          requestEncoding = ol.source.WMTSRequestEncoding.KVP;
          urls.push(gets[i]["href"]);
        }
      }
    }
  }
  if (urls.length === 0) {
    requestEncoding = ol.source.WMTSRequestEncoding.REST;
    l["ResourceURL"].forEach(function(element) {
      if (element["resourceType"] === "tile") {
        format = element["format"];
        urls.push(element["template"]);
      }
    });
  }
  return {urls:urls, layer:config["layer"], matrixSet:matrixSet, format:format, projection:projection, requestEncoding:requestEncoding, tileGrid:tileGrid, style:style, dimensions:dimensions, wrapX:wrapX, crossOrigin:config["crossOrigin"]};
};
goog.provide("ol.source.Zoomify");
goog.require("ol");
goog.require("ol.ImageTile");
goog.require("ol.TileState");
goog.require("ol.TileUrlFunction");
goog.require("ol.asserts");
goog.require("ol.dom");
goog.require("ol.extent");
goog.require("ol.size");
goog.require("ol.source.TileImage");
goog.require("ol.tilegrid.TileGrid");
ol.source.Zoomify = function(opt_options) {
  var options = opt_options || {};
  var size = options.size;
  var tierSizeCalculation = options.tierSizeCalculation !== undefined ? options.tierSizeCalculation : ol.source.Zoomify.TierSizeCalculation_.DEFAULT;
  var imageWidth = size[0];
  var imageHeight = size[1];
  var extent = options.extent || [0, -size[1], size[0], 0];
  var tierSizeInTiles = [];
  var tileSize = options.tileSize || ol.DEFAULT_TILE_SIZE;
  var tileSizeForTierSizeCalculation = tileSize;
  switch(tierSizeCalculation) {
    case ol.source.Zoomify.TierSizeCalculation_.DEFAULT:
      while (imageWidth > tileSizeForTierSizeCalculation || imageHeight > tileSizeForTierSizeCalculation) {
        tierSizeInTiles.push([Math.ceil(imageWidth / tileSizeForTierSizeCalculation), Math.ceil(imageHeight / tileSizeForTierSizeCalculation)]);
        tileSizeForTierSizeCalculation += tileSizeForTierSizeCalculation;
      }
      break;
    case ol.source.Zoomify.TierSizeCalculation_.TRUNCATED:
      var width = imageWidth;
      var height = imageHeight;
      while (width > tileSizeForTierSizeCalculation || height > tileSizeForTierSizeCalculation) {
        tierSizeInTiles.push([Math.ceil(width / tileSizeForTierSizeCalculation), Math.ceil(height / tileSizeForTierSizeCalculation)]);
        width >>= 1;
        height >>= 1;
      }
      break;
    default:
      ol.asserts.assert(false, 53);
      break;
  }
  tierSizeInTiles.push([1, 1]);
  tierSizeInTiles.reverse();
  var resolutions = [1];
  var tileCountUpToTier = [0];
  var i, ii;
  for (i = 1, ii = tierSizeInTiles.length; i < ii; i++) {
    resolutions.push(1 << i);
    tileCountUpToTier.push(tierSizeInTiles[i - 1][0] * tierSizeInTiles[i - 1][1] + tileCountUpToTier[i - 1]);
  }
  resolutions.reverse();
  var tileGrid = new ol.tilegrid.TileGrid({tileSize:tileSize, extent:extent, origin:ol.extent.getTopLeft(extent), resolutions:resolutions});
  var url = options.url;
  if (url && url.indexOf("{TileGroup}") == -1 && url.indexOf("{tileIndex}") == -1) {
    url += "{TileGroup}/{z}-{x}-{y}.jpg";
  }
  var urls = ol.TileUrlFunction.expandUrl(url);
  function createFromTemplate(template) {
    return function(tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return undefined;
      } else {
        var tileCoordZ = tileCoord[0];
        var tileCoordX = tileCoord[1];
        var tileCoordY = -tileCoord[2] - 1;
        var tileIndex = tileCoordX + tileCoordY * tierSizeInTiles[tileCoordZ][0];
        var tileSize = tileGrid.getTileSize(tileCoordZ);
        var tileGroup = (tileIndex + tileCountUpToTier[tileCoordZ]) / tileSize | 0;
        var localContext = {"z":tileCoordZ, "x":tileCoordX, "y":tileCoordY, "tileIndex":tileIndex, "TileGroup":"TileGroup" + tileGroup};
        return template.replace(/\{(\w+?)\}/g, function(m, p) {
          return localContext[p];
        });
      }
    };
  }
  var tileUrlFunction = ol.TileUrlFunction.createFromTileUrlFunctions(urls.map(createFromTemplate));
  var ZoomifyTileClass = ol.source.Zoomify.Tile_.bind(null, tileGrid);
  ol.source.TileImage.call(this, {attributions:options.attributions, cacheSize:options.cacheSize, crossOrigin:options.crossOrigin, logo:options.logo, projection:options.projection, reprojectionErrorThreshold:options.reprojectionErrorThreshold, tileClass:ZoomifyTileClass, tileGrid:tileGrid, tileUrlFunction:tileUrlFunction, transition:options.transition});
};
ol.inherits(ol.source.Zoomify, ol.source.TileImage);
ol.source.Zoomify.Tile_ = function(tileGrid, tileCoord, state, src, crossOrigin, tileLoadFunction, opt_options) {
  ol.ImageTile.call(this, tileCoord, state, src, crossOrigin, tileLoadFunction, opt_options);
  this.zoomifyImage_ = null;
  this.tileSize_ = ol.size.toSize(tileGrid.getTileSize(tileCoord[0]));
};
ol.inherits(ol.source.Zoomify.Tile_, ol.ImageTile);
ol.source.Zoomify.Tile_.prototype.getImage = function() {
  if (this.zoomifyImage_) {
    return this.zoomifyImage_;
  }
  var image = ol.ImageTile.prototype.getImage.call(this);
  if (this.state == ol.TileState.LOADED) {
    var tileSize = this.tileSize_;
    if (image.width == tileSize[0] && image.height == tileSize[1]) {
      this.zoomifyImage_ = image;
      return image;
    } else {
      var context = ol.dom.createCanvasContext2D(tileSize[0], tileSize[1]);
      context.drawImage(image, 0, 0);
      this.zoomifyImage_ = context.canvas;
      return context.canvas;
    }
  } else {
    return image;
  }
};
ol.source.Zoomify.TierSizeCalculation_ = {DEFAULT:"default", TRUNCATED:"truncated"};
goog.addDependency("demos/editor/equationeditor.js", ["goog.demos.editor.EquationEditor"], ["goog.ui.equation.EquationEditorDialog"]);
goog.addDependency("demos/editor/helloworld.js", ["goog.demos.editor.HelloWorld"], ["goog.dom", "goog.dom.TagName", "goog.editor.Plugin"]);
goog.addDependency("demos/editor/helloworlddialog.js", ["goog.demos.editor.HelloWorldDialog", "goog.demos.editor.HelloWorldDialog.OkEvent"], ["goog.dom.TagName", "goog.events.Event", "goog.string", "goog.ui.editor.AbstractDialog", "goog.ui.editor.AbstractDialog.Builder", "goog.ui.editor.AbstractDialog.EventType"]);
goog.addDependency("demos/editor/helloworlddialogplugin.js", ["goog.demos.editor.HelloWorldDialogPlugin", "goog.demos.editor.HelloWorldDialogPlugin.Command"], ["goog.demos.editor.HelloWorldDialog", "goog.dom.TagName", "goog.editor.plugins.AbstractDialogPlugin", "goog.editor.range", "goog.functions", "goog.ui.editor.AbstractDialog.EventType"]);
goog.require("ol");
goog.require("ol.AssertionError");
goog.require("ol.Attribution");
goog.require("ol.CanvasMap");
goog.require("ol.Collection");
goog.require("ol.DeviceOrientation");
goog.require("ol.Feature");
goog.require("ol.Geolocation");
goog.require("ol.Graticule");
goog.require("ol.Image");
goog.require("ol.ImageTile");
goog.require("ol.Kinetic");
goog.require("ol.Map");
goog.require("ol.MapBrowserEvent");
goog.require("ol.MapEvent");
goog.require("ol.Object");
goog.require("ol.Observable");
goog.require("ol.Overlay");
goog.require("ol.PluggableMap");
goog.require("ol.Sphere");
goog.require("ol.Tile");
goog.require("ol.VectorTile");
goog.require("ol.View");
goog.require("ol.color");
goog.require("ol.colorlike");
goog.require("ol.control");
goog.require("ol.control.Attribution");
goog.require("ol.control.Control");
goog.require("ol.control.FullScreen");
goog.require("ol.control.MousePosition");
goog.require("ol.control.OverviewMap");
goog.require("ol.control.Rotate");
goog.require("ol.control.ScaleLine");
goog.require("ol.control.Zoom");
goog.require("ol.control.ZoomSlider");
goog.require("ol.control.ZoomToExtent");
goog.require("ol.coordinate");
goog.require("ol.easing");
goog.require("ol.events.Event");
goog.require("ol.events.condition");
goog.require("ol.extent");
goog.require("ol.featureloader");
goog.require("ol.format.EsriJSON");
goog.require("ol.format.Feature");
goog.require("ol.format.GML");
goog.require("ol.format.GML2");
goog.require("ol.format.GML3");
goog.require("ol.format.GMLBase");
goog.require("ol.format.GPX");
goog.require("ol.format.GeoJSON");
goog.require("ol.format.IGC");
goog.require("ol.format.KML");
goog.require("ol.format.MVT");
goog.require("ol.format.OSMXML");
goog.require("ol.format.Polyline");
goog.require("ol.format.TopoJSON");
goog.require("ol.format.WFS");
goog.require("ol.format.WKT");
goog.require("ol.format.WMSCapabilities");
goog.require("ol.format.WMSGetFeatureInfo");
goog.require("ol.format.WMTSCapabilities");
goog.require("ol.format.filter");
goog.require("ol.format.filter.And");
goog.require("ol.format.filter.Bbox");
goog.require("ol.format.filter.Comparison");
goog.require("ol.format.filter.ComparisonBinary");
goog.require("ol.format.filter.Contains");
goog.require("ol.format.filter.During");
goog.require("ol.format.filter.EqualTo");
goog.require("ol.format.filter.Filter");
goog.require("ol.format.filter.GreaterThan");
goog.require("ol.format.filter.GreaterThanOrEqualTo");
goog.require("ol.format.filter.Intersects");
goog.require("ol.format.filter.IsBetween");
goog.require("ol.format.filter.IsLike");
goog.require("ol.format.filter.IsNull");
goog.require("ol.format.filter.LessThan");
goog.require("ol.format.filter.LessThanOrEqualTo");
goog.require("ol.format.filter.Not");
goog.require("ol.format.filter.NotEqualTo");
goog.require("ol.format.filter.Or");
goog.require("ol.format.filter.Spatial");
goog.require("ol.format.filter.Within");
goog.require("ol.geom.Circle");
goog.require("ol.geom.Geometry");
goog.require("ol.geom.GeometryCollection");
goog.require("ol.geom.LineString");
goog.require("ol.geom.LinearRing");
goog.require("ol.geom.MultiLineString");
goog.require("ol.geom.MultiPoint");
goog.require("ol.geom.MultiPolygon");
goog.require("ol.geom.Point");
goog.require("ol.geom.Polygon");
goog.require("ol.geom.SimpleGeometry");
goog.require("ol.has");
goog.require("ol.interaction");
goog.require("ol.interaction.DoubleClickZoom");
goog.require("ol.interaction.DragAndDrop");
goog.require("ol.interaction.DragBox");
goog.require("ol.interaction.DragPan");
goog.require("ol.interaction.DragRotate");
goog.require("ol.interaction.DragRotateAndZoom");
goog.require("ol.interaction.DragZoom");
goog.require("ol.interaction.Draw");
goog.require("ol.interaction.Extent");
goog.require("ol.interaction.Interaction");
goog.require("ol.interaction.KeyboardPan");
goog.require("ol.interaction.KeyboardZoom");
goog.require("ol.interaction.Modify");
goog.require("ol.interaction.MouseWheelZoom");
goog.require("ol.interaction.PinchRotate");
goog.require("ol.interaction.PinchZoom");
goog.require("ol.interaction.Pointer");
goog.require("ol.interaction.Select");
goog.require("ol.interaction.Snap");
goog.require("ol.interaction.Translate");
goog.require("ol.layer.Base");
goog.require("ol.layer.Group");
goog.require("ol.layer.Heatmap");
goog.require("ol.layer.Image");
goog.require("ol.layer.Layer");
goog.require("ol.layer.Tile");
goog.require("ol.layer.Vector");
goog.require("ol.layer.VectorTile");
goog.require("ol.loadingstrategy");
goog.require("ol.proj");
goog.require("ol.proj.Projection");
goog.require("ol.proj.Units");
goog.require("ol.proj.common");
goog.require("ol.render");
goog.require("ol.render.Event");
goog.require("ol.render.Feature");
goog.require("ol.render.VectorContext");
goog.require("ol.render.canvas.Immediate");
goog.require("ol.render.webgl.Immediate");
goog.require("ol.renderer.canvas.ImageLayer");
goog.require("ol.renderer.canvas.Map");
goog.require("ol.renderer.canvas.TileLayer");
goog.require("ol.renderer.canvas.VectorLayer");
goog.require("ol.renderer.canvas.VectorTileLayer");
goog.require("ol.renderer.webgl.ImageLayer");
goog.require("ol.renderer.webgl.Map");
goog.require("ol.renderer.webgl.TileLayer");
goog.require("ol.renderer.webgl.VectorLayer");
goog.require("ol.size");
goog.require("ol.source.BingMaps");
goog.require("ol.source.CartoDB");
goog.require("ol.source.Cluster");
goog.require("ol.source.Image");
goog.require("ol.source.ImageArcGISRest");
goog.require("ol.source.ImageCanvas");
goog.require("ol.source.ImageMapGuide");
goog.require("ol.source.ImageStatic");
goog.require("ol.source.ImageVector");
goog.require("ol.source.ImageWMS");
goog.require("ol.source.OSM");
goog.require("ol.source.Raster");
goog.require("ol.source.Source");
goog.require("ol.source.Stamen");
goog.require("ol.source.Tile");
goog.require("ol.source.TileArcGISRest");
goog.require("ol.source.TileDebug");
goog.require("ol.source.TileImage");
goog.require("ol.source.TileJSON");
goog.require("ol.source.TileUTFGrid");
goog.require("ol.source.TileWMS");
goog.require("ol.source.UrlTile");
goog.require("ol.source.Vector");
goog.require("ol.source.VectorTile");
goog.require("ol.source.WMTS");
goog.require("ol.source.XYZ");
goog.require("ol.source.Zoomify");
goog.require("ol.style");
goog.require("ol.style.AtlasManager");
goog.require("ol.style.Circle");
goog.require("ol.style.Fill");
goog.require("ol.style.Icon");
goog.require("ol.style.IconImageCache");
goog.require("ol.style.Image");
goog.require("ol.style.RegularShape");
goog.require("ol.style.Stroke");
goog.require("ol.style.Style");
goog.require("ol.style.Text");
goog.require("ol.tilegrid");
goog.require("ol.tilegrid.TileGrid");
goog.require("ol.tilegrid.WMTS");
goog.require("ol.webgl.Context");
goog.require("ol.xml");
goog.require("olcs.AbstractSynchronizer");
goog.require("olcs.AutoRenderLoop");
goog.require("olcs.Camera");
goog.require("olcs.FeatureConverter");
goog.require("olcs.GaKmlSynchronizer");
goog.require("olcs.GaRasterSynchronizer");
goog.require("olcs.GaTileset3dSynchronizer");
goog.require("olcs.GaVectorSynchronizer");
goog.require("olcs.OLCesium");
goog.require("olcs.OverlaySynchronizer");
goog.require("olcs.RasterSynchronizer");
goog.require("olcs.SynchronizedOverlay");
goog.require("olcs.VectorSynchronizer");
goog.require("olcs.contrib.LazyLoader");
goog.require("olcs.contrib.Manager");
goog.require("olcs.core");
goog.exportProperty(ol.AssertionError.prototype, "code", ol.AssertionError.prototype.code);
goog.exportSymbol("ol.Attribution", ol.Attribution);
goog.exportProperty(ol.Attribution.prototype, "getHTML", ol.Attribution.prototype.getHTML);
goog.exportSymbol("ol.CanvasMap", ol.CanvasMap);
goog.exportSymbol("ol.Collection", ol.Collection);
goog.exportProperty(ol.Collection.prototype, "clear", ol.Collection.prototype.clear);
goog.exportProperty(ol.Collection.prototype, "extend", ol.Collection.prototype.extend);
goog.exportProperty(ol.Collection.prototype, "forEach", ol.Collection.prototype.forEach);
goog.exportProperty(ol.Collection.prototype, "getArray", ol.Collection.prototype.getArray);
goog.exportProperty(ol.Collection.prototype, "item", ol.Collection.prototype.item);
goog.exportProperty(ol.Collection.prototype, "getLength", ol.Collection.prototype.getLength);
goog.exportProperty(ol.Collection.prototype, "insertAt", ol.Collection.prototype.insertAt);
goog.exportProperty(ol.Collection.prototype, "pop", ol.Collection.prototype.pop);
goog.exportProperty(ol.Collection.prototype, "push", ol.Collection.prototype.push);
goog.exportProperty(ol.Collection.prototype, "remove", ol.Collection.prototype.remove);
goog.exportProperty(ol.Collection.prototype, "removeAt", ol.Collection.prototype.removeAt);
goog.exportProperty(ol.Collection.prototype, "setAt", ol.Collection.prototype.setAt);
goog.exportProperty(ol.Collection.Event.prototype, "element", ol.Collection.Event.prototype.element);
goog.exportSymbol("ol.color.asArray", ol.color.asArray);
goog.exportSymbol("ol.color.asString", ol.color.asString);
goog.exportSymbol("ol.colorlike.asColorLike", ol.colorlike.asColorLike);
goog.exportSymbol("ol.control.defaults", ol.control.defaults);
goog.exportSymbol("ol.coordinate.add", ol.coordinate.add);
goog.exportSymbol("ol.coordinate.createStringXY", ol.coordinate.createStringXY);
goog.exportSymbol("ol.coordinate.format", ol.coordinate.format);
goog.exportSymbol("ol.coordinate.rotate", ol.coordinate.rotate);
goog.exportSymbol("ol.coordinate.toStringHDMS", ol.coordinate.toStringHDMS);
goog.exportSymbol("ol.coordinate.toStringXY", ol.coordinate.toStringXY);
goog.exportSymbol("ol.DeviceOrientation", ol.DeviceOrientation);
goog.exportProperty(ol.DeviceOrientation.prototype, "getAlpha", ol.DeviceOrientation.prototype.getAlpha);
goog.exportProperty(ol.DeviceOrientation.prototype, "getBeta", ol.DeviceOrientation.prototype.getBeta);
goog.exportProperty(ol.DeviceOrientation.prototype, "getGamma", ol.DeviceOrientation.prototype.getGamma);
goog.exportProperty(ol.DeviceOrientation.prototype, "getHeading", ol.DeviceOrientation.prototype.getHeading);
goog.exportProperty(ol.DeviceOrientation.prototype, "getTracking", ol.DeviceOrientation.prototype.getTracking);
goog.exportProperty(ol.DeviceOrientation.prototype, "setTracking", ol.DeviceOrientation.prototype.setTracking);
goog.exportSymbol("ol.easing.easeIn", ol.easing.easeIn);
goog.exportSymbol("ol.easing.easeOut", ol.easing.easeOut);
goog.exportSymbol("ol.easing.inAndOut", ol.easing.inAndOut);
goog.exportSymbol("ol.easing.linear", ol.easing.linear);
goog.exportSymbol("ol.easing.upAndDown", ol.easing.upAndDown);
goog.exportSymbol("ol.extent.boundingExtent", ol.extent.boundingExtent);
goog.exportSymbol("ol.extent.buffer", ol.extent.buffer);
goog.exportSymbol("ol.extent.containsCoordinate", ol.extent.containsCoordinate);
goog.exportSymbol("ol.extent.containsExtent", ol.extent.containsExtent);
goog.exportSymbol("ol.extent.containsXY", ol.extent.containsXY);
goog.exportSymbol("ol.extent.createEmpty", ol.extent.createEmpty);
goog.exportSymbol("ol.extent.equals", ol.extent.equals);
goog.exportSymbol("ol.extent.extend", ol.extent.extend);
goog.exportSymbol("ol.extent.getArea", ol.extent.getArea);
goog.exportSymbol("ol.extent.getBottomLeft", ol.extent.getBottomLeft);
goog.exportSymbol("ol.extent.getBottomRight", ol.extent.getBottomRight);
goog.exportSymbol("ol.extent.getCenter", ol.extent.getCenter);
goog.exportSymbol("ol.extent.getHeight", ol.extent.getHeight);
goog.exportSymbol("ol.extent.getIntersection", ol.extent.getIntersection);
goog.exportSymbol("ol.extent.getSize", ol.extent.getSize);
goog.exportSymbol("ol.extent.getTopLeft", ol.extent.getTopLeft);
goog.exportSymbol("ol.extent.getTopRight", ol.extent.getTopRight);
goog.exportSymbol("ol.extent.getWidth", ol.extent.getWidth);
goog.exportSymbol("ol.extent.intersects", ol.extent.intersects);
goog.exportSymbol("ol.extent.isEmpty", ol.extent.isEmpty);
goog.exportSymbol("ol.extent.applyTransform", ol.extent.applyTransform);
goog.exportSymbol("ol.Feature", ol.Feature);
goog.exportProperty(ol.Feature.prototype, "clone", ol.Feature.prototype.clone);
goog.exportProperty(ol.Feature.prototype, "getGeometry", ol.Feature.prototype.getGeometry);
goog.exportProperty(ol.Feature.prototype, "getId", ol.Feature.prototype.getId);
goog.exportProperty(ol.Feature.prototype, "getGeometryName", ol.Feature.prototype.getGeometryName);
goog.exportProperty(ol.Feature.prototype, "getStyle", ol.Feature.prototype.getStyle);
goog.exportProperty(ol.Feature.prototype, "getStyleFunction", ol.Feature.prototype.getStyleFunction);
goog.exportProperty(ol.Feature.prototype, "setGeometry", ol.Feature.prototype.setGeometry);
goog.exportProperty(ol.Feature.prototype, "setStyle", ol.Feature.prototype.setStyle);
goog.exportProperty(ol.Feature.prototype, "setId", ol.Feature.prototype.setId);
goog.exportProperty(ol.Feature.prototype, "setGeometryName", ol.Feature.prototype.setGeometryName);
goog.exportSymbol("ol.featureloader.xhr", ol.featureloader.xhr);
goog.exportSymbol("ol.Geolocation", ol.Geolocation);
goog.exportProperty(ol.Geolocation.prototype, "getAccuracy", ol.Geolocation.prototype.getAccuracy);
goog.exportProperty(ol.Geolocation.prototype, "getAccuracyGeometry", ol.Geolocation.prototype.getAccuracyGeometry);
goog.exportProperty(ol.Geolocation.prototype, "getAltitude", ol.Geolocation.prototype.getAltitude);
goog.exportProperty(ol.Geolocation.prototype, "getAltitudeAccuracy", ol.Geolocation.prototype.getAltitudeAccuracy);
goog.exportProperty(ol.Geolocation.prototype, "getHeading", ol.Geolocation.prototype.getHeading);
goog.exportProperty(ol.Geolocation.prototype, "getPosition", ol.Geolocation.prototype.getPosition);
goog.exportProperty(ol.Geolocation.prototype, "getProjection", ol.Geolocation.prototype.getProjection);
goog.exportProperty(ol.Geolocation.prototype, "getSpeed", ol.Geolocation.prototype.getSpeed);
goog.exportProperty(ol.Geolocation.prototype, "getTracking", ol.Geolocation.prototype.getTracking);
goog.exportProperty(ol.Geolocation.prototype, "getTrackingOptions", ol.Geolocation.prototype.getTrackingOptions);
goog.exportProperty(ol.Geolocation.prototype, "setProjection", ol.Geolocation.prototype.setProjection);
goog.exportProperty(ol.Geolocation.prototype, "setTracking", ol.Geolocation.prototype.setTracking);
goog.exportProperty(ol.Geolocation.prototype, "setTrackingOptions", ol.Geolocation.prototype.setTrackingOptions);
goog.exportSymbol("ol.Graticule", ol.Graticule);
goog.exportProperty(ol.Graticule.prototype, "getMap", ol.Graticule.prototype.getMap);
goog.exportProperty(ol.Graticule.prototype, "getMeridians", ol.Graticule.prototype.getMeridians);
goog.exportProperty(ol.Graticule.prototype, "getParallels", ol.Graticule.prototype.getParallels);
goog.exportProperty(ol.Graticule.prototype, "setMap", ol.Graticule.prototype.setMap);
goog.exportSymbol("ol.has.DEVICE_PIXEL_RATIO", ol.has.DEVICE_PIXEL_RATIO);
goog.exportSymbol("ol.has.CANVAS", ol.has.CANVAS);
goog.exportSymbol("ol.has.DEVICE_ORIENTATION", ol.has.DEVICE_ORIENTATION);
goog.exportSymbol("ol.has.GEOLOCATION", ol.has.GEOLOCATION);
goog.exportSymbol("ol.has.TOUCH", ol.has.TOUCH);
goog.exportSymbol("ol.has.WEBGL", ol.has.WEBGL);
goog.exportProperty(ol.Image.prototype, "getImage", ol.Image.prototype.getImage);
goog.exportProperty(ol.Image.prototype, "load", ol.Image.prototype.load);
goog.exportProperty(ol.ImageTile.prototype, "getImage", ol.ImageTile.prototype.getImage);
goog.exportProperty(ol.ImageTile.prototype, "load", ol.ImageTile.prototype.load);
goog.exportSymbol("ol.inherits", ol.inherits);
goog.exportSymbol("ol.interaction.defaults", ol.interaction.defaults);
goog.exportSymbol("ol.Kinetic", ol.Kinetic);
goog.exportSymbol("ol.loadingstrategy.all", ol.loadingstrategy.all);
goog.exportSymbol("ol.loadingstrategy.bbox", ol.loadingstrategy.bbox);
goog.exportSymbol("ol.loadingstrategy.tile", ol.loadingstrategy.tile);
goog.exportSymbol("ol.Map", ol.Map);
goog.exportProperty(ol.MapBrowserEvent.prototype, "originalEvent", ol.MapBrowserEvent.prototype.originalEvent);
goog.exportProperty(ol.MapBrowserEvent.prototype, "pixel", ol.MapBrowserEvent.prototype.pixel);
goog.exportProperty(ol.MapBrowserEvent.prototype, "coordinate", ol.MapBrowserEvent.prototype.coordinate);
goog.exportProperty(ol.MapBrowserEvent.prototype, "dragging", ol.MapBrowserEvent.prototype.dragging);
goog.exportProperty(ol.MapBrowserEvent.prototype, "preventDefault", ol.MapBrowserEvent.prototype.preventDefault);
goog.exportProperty(ol.MapBrowserEvent.prototype, "stopPropagation", ol.MapBrowserEvent.prototype.stopPropagation);
goog.exportProperty(ol.MapEvent.prototype, "map", ol.MapEvent.prototype.map);
goog.exportProperty(ol.MapEvent.prototype, "frameState", ol.MapEvent.prototype.frameState);
goog.exportSymbol("ol.Object", ol.Object);
goog.exportProperty(ol.Object.prototype, "get", ol.Object.prototype.get);
goog.exportProperty(ol.Object.prototype, "getKeys", ol.Object.prototype.getKeys);
goog.exportProperty(ol.Object.prototype, "getProperties", ol.Object.prototype.getProperties);
goog.exportProperty(ol.Object.prototype, "set", ol.Object.prototype.set);
goog.exportProperty(ol.Object.prototype, "setProperties", ol.Object.prototype.setProperties);
goog.exportProperty(ol.Object.prototype, "unset", ol.Object.prototype.unset);
goog.exportProperty(ol.Object.Event.prototype, "key", ol.Object.Event.prototype.key);
goog.exportProperty(ol.Object.Event.prototype, "oldValue", ol.Object.Event.prototype.oldValue);
goog.exportSymbol("ol.Observable", ol.Observable);
goog.exportSymbol("ol.Observable.unByKey", ol.Observable.unByKey);
goog.exportProperty(ol.Observable.prototype, "changed", ol.Observable.prototype.changed);
goog.exportProperty(ol.Observable.prototype, "dispatchEvent", ol.Observable.prototype.dispatchEvent);
goog.exportProperty(ol.Observable.prototype, "getRevision", ol.Observable.prototype.getRevision);
goog.exportProperty(ol.Observable.prototype, "on", ol.Observable.prototype.on);
goog.exportProperty(ol.Observable.prototype, "once", ol.Observable.prototype.once);
goog.exportProperty(ol.Observable.prototype, "un", ol.Observable.prototype.un);
goog.exportSymbol("ol.Overlay", ol.Overlay);
goog.exportProperty(ol.Overlay.prototype, "getElement", ol.Overlay.prototype.getElement);
goog.exportProperty(ol.Overlay.prototype, "getId", ol.Overlay.prototype.getId);
goog.exportProperty(ol.Overlay.prototype, "getMap", ol.Overlay.prototype.getMap);
goog.exportProperty(ol.Overlay.prototype, "getOffset", ol.Overlay.prototype.getOffset);
goog.exportProperty(ol.Overlay.prototype, "getPosition", ol.Overlay.prototype.getPosition);
goog.exportProperty(ol.Overlay.prototype, "getPositioning", ol.Overlay.prototype.getPositioning);
goog.exportProperty(ol.Overlay.prototype, "setElement", ol.Overlay.prototype.setElement);
goog.exportProperty(ol.Overlay.prototype, "setMap", ol.Overlay.prototype.setMap);
goog.exportProperty(ol.Overlay.prototype, "setOffset", ol.Overlay.prototype.setOffset);
goog.exportProperty(ol.Overlay.prototype, "setPosition", ol.Overlay.prototype.setPosition);
goog.exportProperty(ol.Overlay.prototype, "setPositioning", ol.Overlay.prototype.setPositioning);
goog.exportSymbol("ol.PluggableMap", ol.PluggableMap);
goog.exportProperty(ol.PluggableMap.prototype, "addControl", ol.PluggableMap.prototype.addControl);
goog.exportProperty(ol.PluggableMap.prototype, "addInteraction", ol.PluggableMap.prototype.addInteraction);
goog.exportProperty(ol.PluggableMap.prototype, "addLayer", ol.PluggableMap.prototype.addLayer);
goog.exportProperty(ol.PluggableMap.prototype, "addOverlay", ol.PluggableMap.prototype.addOverlay);
goog.exportProperty(ol.PluggableMap.prototype, "forEachFeatureAtPixel", ol.PluggableMap.prototype.forEachFeatureAtPixel);
goog.exportProperty(ol.PluggableMap.prototype, "getFeaturesAtPixel", ol.PluggableMap.prototype.getFeaturesAtPixel);
goog.exportProperty(ol.PluggableMap.prototype, "forEachLayerAtPixel", ol.PluggableMap.prototype.forEachLayerAtPixel);
goog.exportProperty(ol.PluggableMap.prototype, "hasFeatureAtPixel", ol.PluggableMap.prototype.hasFeatureAtPixel);
goog.exportProperty(ol.PluggableMap.prototype, "getEventCoordinate", ol.PluggableMap.prototype.getEventCoordinate);
goog.exportProperty(ol.PluggableMap.prototype, "getEventPixel", ol.PluggableMap.prototype.getEventPixel);
goog.exportProperty(ol.PluggableMap.prototype, "getTarget", ol.PluggableMap.prototype.getTarget);
goog.exportProperty(ol.PluggableMap.prototype, "getTargetElement", ol.PluggableMap.prototype.getTargetElement);
goog.exportProperty(ol.PluggableMap.prototype, "getCoordinateFromPixel", ol.PluggableMap.prototype.getCoordinateFromPixel);
goog.exportProperty(ol.PluggableMap.prototype, "getControls", ol.PluggableMap.prototype.getControls);
goog.exportProperty(ol.PluggableMap.prototype, "getOverlays", ol.PluggableMap.prototype.getOverlays);
goog.exportProperty(ol.PluggableMap.prototype, "getOverlayById", ol.PluggableMap.prototype.getOverlayById);
goog.exportProperty(ol.PluggableMap.prototype, "getInteractions", ol.PluggableMap.prototype.getInteractions);
goog.exportProperty(ol.PluggableMap.prototype, "getLayerGroup", ol.PluggableMap.prototype.getLayerGroup);
goog.exportProperty(ol.PluggableMap.prototype, "getLayers", ol.PluggableMap.prototype.getLayers);
goog.exportProperty(ol.PluggableMap.prototype, "getPixelFromCoordinate", ol.PluggableMap.prototype.getPixelFromCoordinate);
goog.exportProperty(ol.PluggableMap.prototype, "getSize", ol.PluggableMap.prototype.getSize);
goog.exportProperty(ol.PluggableMap.prototype, "getView", ol.PluggableMap.prototype.getView);
goog.exportProperty(ol.PluggableMap.prototype, "getViewport", ol.PluggableMap.prototype.getViewport);
goog.exportProperty(ol.PluggableMap.prototype, "renderSync", ol.PluggableMap.prototype.renderSync);
goog.exportProperty(ol.PluggableMap.prototype, "render", ol.PluggableMap.prototype.render);
goog.exportProperty(ol.PluggableMap.prototype, "removeControl", ol.PluggableMap.prototype.removeControl);
goog.exportProperty(ol.PluggableMap.prototype, "removeInteraction", ol.PluggableMap.prototype.removeInteraction);
goog.exportProperty(ol.PluggableMap.prototype, "removeLayer", ol.PluggableMap.prototype.removeLayer);
goog.exportProperty(ol.PluggableMap.prototype, "removeOverlay", ol.PluggableMap.prototype.removeOverlay);
goog.exportProperty(ol.PluggableMap.prototype, "setLayerGroup", ol.PluggableMap.prototype.setLayerGroup);
goog.exportProperty(ol.PluggableMap.prototype, "setSize", ol.PluggableMap.prototype.setSize);
goog.exportProperty(ol.PluggableMap.prototype, "setTarget", ol.PluggableMap.prototype.setTarget);
goog.exportProperty(ol.PluggableMap.prototype, "setView", ol.PluggableMap.prototype.setView);
goog.exportProperty(ol.PluggableMap.prototype, "updateSize", ol.PluggableMap.prototype.updateSize);
goog.exportSymbol("ol.proj.METERS_PER_UNIT", ol.proj.METERS_PER_UNIT);
goog.exportSymbol("ol.proj.setProj4", ol.proj.setProj4);
goog.exportSymbol("ol.proj.getPointResolution", ol.proj.getPointResolution);
goog.exportSymbol("ol.proj.addEquivalentProjections", ol.proj.addEquivalentProjections);
goog.exportSymbol("ol.proj.addProjection", ol.proj.addProjection);
goog.exportSymbol("ol.proj.addCoordinateTransforms", ol.proj.addCoordinateTransforms);
goog.exportSymbol("ol.proj.fromLonLat", ol.proj.fromLonLat);
goog.exportSymbol("ol.proj.toLonLat", ol.proj.toLonLat);
goog.exportSymbol("ol.proj.get", ol.proj.get);
goog.exportSymbol("ol.proj.equivalent", ol.proj.equivalent);
goog.exportSymbol("ol.proj.getTransform", ol.proj.getTransform);
goog.exportSymbol("ol.proj.transform", ol.proj.transform);
goog.exportSymbol("ol.proj.transformExtent", ol.proj.transformExtent);
goog.exportSymbol("ol.render.toContext", ol.render.toContext);
goog.exportSymbol("ol.size.toSize", ol.size.toSize);
goog.exportSymbol("ol.Sphere", ol.Sphere);
goog.exportProperty(ol.Sphere.prototype, "geodesicArea", ol.Sphere.prototype.geodesicArea);
goog.exportProperty(ol.Sphere.prototype, "haversineDistance", ol.Sphere.prototype.haversineDistance);
goog.exportSymbol("ol.Sphere.getLength", ol.Sphere.getLength);
goog.exportSymbol("ol.Sphere.getArea", ol.Sphere.getArea);
goog.exportSymbol("ol.style.iconImageCache", ol.style.iconImageCache);
goog.exportProperty(ol.Tile.prototype, "getTileCoord", ol.Tile.prototype.getTileCoord);
goog.exportProperty(ol.Tile.prototype, "load", ol.Tile.prototype.load);
goog.exportSymbol("ol.tilegrid.createXYZ", ol.tilegrid.createXYZ);
goog.exportProperty(ol.VectorTile.prototype, "getExtent", ol.VectorTile.prototype.getExtent);
goog.exportProperty(ol.VectorTile.prototype, "getFormat", ol.VectorTile.prototype.getFormat);
goog.exportProperty(ol.VectorTile.prototype, "getFeatures", ol.VectorTile.prototype.getFeatures);
goog.exportProperty(ol.VectorTile.prototype, "getProjection", ol.VectorTile.prototype.getProjection);
goog.exportProperty(ol.VectorTile.prototype, "setExtent", ol.VectorTile.prototype.setExtent);
goog.exportProperty(ol.VectorTile.prototype, "setFeatures", ol.VectorTile.prototype.setFeatures);
goog.exportProperty(ol.VectorTile.prototype, "setProjection", ol.VectorTile.prototype.setProjection);
goog.exportProperty(ol.VectorTile.prototype, "setLoader", ol.VectorTile.prototype.setLoader);
goog.exportSymbol("ol.View", ol.View);
goog.exportProperty(ol.View.prototype, "animate", ol.View.prototype.animate);
goog.exportProperty(ol.View.prototype, "getAnimating", ol.View.prototype.getAnimating);
goog.exportProperty(ol.View.prototype, "getInteracting", ol.View.prototype.getInteracting);
goog.exportProperty(ol.View.prototype, "cancelAnimations", ol.View.prototype.cancelAnimations);
goog.exportProperty(ol.View.prototype, "constrainCenter", ol.View.prototype.constrainCenter);
goog.exportProperty(ol.View.prototype, "constrainResolution", ol.View.prototype.constrainResolution);
goog.exportProperty(ol.View.prototype, "constrainRotation", ol.View.prototype.constrainRotation);
goog.exportProperty(ol.View.prototype, "getCenter", ol.View.prototype.getCenter);
goog.exportProperty(ol.View.prototype, "calculateExtent", ol.View.prototype.calculateExtent);
goog.exportProperty(ol.View.prototype, "getMaxResolution", ol.View.prototype.getMaxResolution);
goog.exportProperty(ol.View.prototype, "getMinResolution", ol.View.prototype.getMinResolution);
goog.exportProperty(ol.View.prototype, "getMaxZoom", ol.View.prototype.getMaxZoom);
goog.exportProperty(ol.View.prototype, "setMaxZoom", ol.View.prototype.setMaxZoom);
goog.exportProperty(ol.View.prototype, "getMinZoom", ol.View.prototype.getMinZoom);
goog.exportProperty(ol.View.prototype, "setMinZoom", ol.View.prototype.setMinZoom);
goog.exportProperty(ol.View.prototype, "getProjection", ol.View.prototype.getProjection);
goog.exportProperty(ol.View.prototype, "getResolution", ol.View.prototype.getResolution);
goog.exportProperty(ol.View.prototype, "getResolutions", ol.View.prototype.getResolutions);
goog.exportProperty(ol.View.prototype, "getResolutionForExtent", ol.View.prototype.getResolutionForExtent);
goog.exportProperty(ol.View.prototype, "getRotation", ol.View.prototype.getRotation);
goog.exportProperty(ol.View.prototype, "getZoom", ol.View.prototype.getZoom);
goog.exportProperty(ol.View.prototype, "getZoomForResolution", ol.View.prototype.getZoomForResolution);
goog.exportProperty(ol.View.prototype, "getResolutionForZoom", ol.View.prototype.getResolutionForZoom);
goog.exportProperty(ol.View.prototype, "fit", ol.View.prototype.fit);
goog.exportProperty(ol.View.prototype, "centerOn", ol.View.prototype.centerOn);
goog.exportProperty(ol.View.prototype, "rotate", ol.View.prototype.rotate);
goog.exportProperty(ol.View.prototype, "setCenter", ol.View.prototype.setCenter);
goog.exportProperty(ol.View.prototype, "setResolution", ol.View.prototype.setResolution);
goog.exportProperty(ol.View.prototype, "setRotation", ol.View.prototype.setRotation);
goog.exportProperty(ol.View.prototype, "setZoom", ol.View.prototype.setZoom);
goog.exportSymbol("ol.xml.getAllTextContent", ol.xml.getAllTextContent);
goog.exportSymbol("ol.xml.parse", ol.xml.parse);
goog.exportProperty(ol.webgl.Context.prototype, "getGL", ol.webgl.Context.prototype.getGL);
goog.exportProperty(ol.webgl.Context.prototype, "useProgram", ol.webgl.Context.prototype.useProgram);
goog.exportSymbol("ol.tilegrid.TileGrid", ol.tilegrid.TileGrid);
goog.exportProperty(ol.tilegrid.TileGrid.prototype, "forEachTileCoord", ol.tilegrid.TileGrid.prototype.forEachTileCoord);
goog.exportProperty(ol.tilegrid.TileGrid.prototype, "getMaxZoom", ol.tilegrid.TileGrid.prototype.getMaxZoom);
goog.exportProperty(ol.tilegrid.TileGrid.prototype, "getMinZoom", ol.tilegrid.TileGrid.prototype.getMinZoom);
goog.exportProperty(ol.tilegrid.TileGrid.prototype, "getOrigin", ol.tilegrid.TileGrid.prototype.getOrigin);
goog.exportProperty(ol.tilegrid.TileGrid.prototype, "getResolution", ol.tilegrid.TileGrid.prototype.getResolution);
goog.exportProperty(ol.tilegrid.TileGrid.prototype, "getResolutions", ol.tilegrid.TileGrid.prototype.getResolutions);
goog.exportProperty(ol.tilegrid.TileGrid.prototype, "getTileCoordExtent", ol.tilegrid.TileGrid.prototype.getTileCoordExtent);
goog.exportProperty(ol.tilegrid.TileGrid.prototype, "getTileCoordForCoordAndResolution", ol.tilegrid.TileGrid.prototype.getTileCoordForCoordAndResolution);
goog.exportProperty(ol.tilegrid.TileGrid.prototype, "getTileCoordForCoordAndZ", ol.tilegrid.TileGrid.prototype.getTileCoordForCoordAndZ);
goog.exportProperty(ol.tilegrid.TileGrid.prototype, "getTileSize", ol.tilegrid.TileGrid.prototype.getTileSize);
goog.exportProperty(ol.tilegrid.TileGrid.prototype, "getZForResolution", ol.tilegrid.TileGrid.prototype.getZForResolution);
goog.exportSymbol("ol.tilegrid.WMTS", ol.tilegrid.WMTS);
goog.exportProperty(ol.tilegrid.WMTS.prototype, "getMatrixIds", ol.tilegrid.WMTS.prototype.getMatrixIds);
goog.exportSymbol("ol.tilegrid.WMTS.createFromCapabilitiesMatrixSet", ol.tilegrid.WMTS.createFromCapabilitiesMatrixSet);
goog.exportSymbol("ol.style.AtlasManager", ol.style.AtlasManager);
goog.exportSymbol("ol.style.Circle", ol.style.Circle);
goog.exportProperty(ol.style.Circle.prototype, "clone", ol.style.Circle.prototype.clone);
goog.exportProperty(ol.style.Circle.prototype, "setRadius", ol.style.Circle.prototype.setRadius);
goog.exportSymbol("ol.style.Fill", ol.style.Fill);
goog.exportProperty(ol.style.Fill.prototype, "clone", ol.style.Fill.prototype.clone);
goog.exportProperty(ol.style.Fill.prototype, "getColor", ol.style.Fill.prototype.getColor);
goog.exportProperty(ol.style.Fill.prototype, "setColor", ol.style.Fill.prototype.setColor);
goog.exportSymbol("ol.style.Icon", ol.style.Icon);
goog.exportProperty(ol.style.Icon.prototype, "clone", ol.style.Icon.prototype.clone);
goog.exportProperty(ol.style.Icon.prototype, "getAnchor", ol.style.Icon.prototype.getAnchor);
goog.exportProperty(ol.style.Icon.prototype, "getColor", ol.style.Icon.prototype.getColor);
goog.exportProperty(ol.style.Icon.prototype, "getImage", ol.style.Icon.prototype.getImage);
goog.exportProperty(ol.style.Icon.prototype, "getOrigin", ol.style.Icon.prototype.getOrigin);
goog.exportProperty(ol.style.Icon.prototype, "getSrc", ol.style.Icon.prototype.getSrc);
goog.exportProperty(ol.style.Icon.prototype, "getSize", ol.style.Icon.prototype.getSize);
goog.exportProperty(ol.style.Icon.prototype, "load", ol.style.Icon.prototype.load);
goog.exportProperty(ol.style.IconImageCache.prototype, "setSize", ol.style.IconImageCache.prototype.setSize);
goog.exportSymbol("ol.style.Image", ol.style.Image);
goog.exportProperty(ol.style.Image.prototype, "getOpacity", ol.style.Image.prototype.getOpacity);
goog.exportProperty(ol.style.Image.prototype, "getRotateWithView", ol.style.Image.prototype.getRotateWithView);
goog.exportProperty(ol.style.Image.prototype, "getRotation", ol.style.Image.prototype.getRotation);
goog.exportProperty(ol.style.Image.prototype, "getScale", ol.style.Image.prototype.getScale);
goog.exportProperty(ol.style.Image.prototype, "getSnapToPixel", ol.style.Image.prototype.getSnapToPixel);
goog.exportProperty(ol.style.Image.prototype, "setOpacity", ol.style.Image.prototype.setOpacity);
goog.exportProperty(ol.style.Image.prototype, "setRotation", ol.style.Image.prototype.setRotation);
goog.exportProperty(ol.style.Image.prototype, "setScale", ol.style.Image.prototype.setScale);
goog.exportSymbol("ol.style.RegularShape", ol.style.RegularShape);
goog.exportProperty(ol.style.RegularShape.prototype, "clone", ol.style.RegularShape.prototype.clone);
goog.exportProperty(ol.style.RegularShape.prototype, "getAnchor", ol.style.RegularShape.prototype.getAnchor);
goog.exportProperty(ol.style.RegularShape.prototype, "getAngle", ol.style.RegularShape.prototype.getAngle);
goog.exportProperty(ol.style.RegularShape.prototype, "getFill", ol.style.RegularShape.prototype.getFill);
goog.exportProperty(ol.style.RegularShape.prototype, "getImage", ol.style.RegularShape.prototype.getImage);
goog.exportProperty(ol.style.RegularShape.prototype, "getOrigin", ol.style.RegularShape.prototype.getOrigin);
goog.exportProperty(ol.style.RegularShape.prototype, "getPoints", ol.style.RegularShape.prototype.getPoints);
goog.exportProperty(ol.style.RegularShape.prototype, "getRadius", ol.style.RegularShape.prototype.getRadius);
goog.exportProperty(ol.style.RegularShape.prototype, "getRadius2", ol.style.RegularShape.prototype.getRadius2);
goog.exportProperty(ol.style.RegularShape.prototype, "getSize", ol.style.RegularShape.prototype.getSize);
goog.exportProperty(ol.style.RegularShape.prototype, "getStroke", ol.style.RegularShape.prototype.getStroke);
goog.exportSymbol("ol.style.Stroke", ol.style.Stroke);
goog.exportProperty(ol.style.Stroke.prototype, "clone", ol.style.Stroke.prototype.clone);
goog.exportProperty(ol.style.Stroke.prototype, "getColor", ol.style.Stroke.prototype.getColor);
goog.exportProperty(ol.style.Stroke.prototype, "getLineCap", ol.style.Stroke.prototype.getLineCap);
goog.exportProperty(ol.style.Stroke.prototype, "getLineDash", ol.style.Stroke.prototype.getLineDash);
goog.exportProperty(ol.style.Stroke.prototype, "getLineDashOffset", ol.style.Stroke.prototype.getLineDashOffset);
goog.exportProperty(ol.style.Stroke.prototype, "getLineJoin", ol.style.Stroke.prototype.getLineJoin);
goog.exportProperty(ol.style.Stroke.prototype, "getMiterLimit", ol.style.Stroke.prototype.getMiterLimit);
goog.exportProperty(ol.style.Stroke.prototype, "getWidth", ol.style.Stroke.prototype.getWidth);
goog.exportProperty(ol.style.Stroke.prototype, "setColor", ol.style.Stroke.prototype.setColor);
goog.exportProperty(ol.style.Stroke.prototype, "setLineCap", ol.style.Stroke.prototype.setLineCap);
goog.exportProperty(ol.style.Stroke.prototype, "setLineDash", ol.style.Stroke.prototype.setLineDash);
goog.exportProperty(ol.style.Stroke.prototype, "setLineDashOffset", ol.style.Stroke.prototype.setLineDashOffset);
goog.exportProperty(ol.style.Stroke.prototype, "setLineJoin", ol.style.Stroke.prototype.setLineJoin);
goog.exportProperty(ol.style.Stroke.prototype, "setMiterLimit", ol.style.Stroke.prototype.setMiterLimit);
goog.exportProperty(ol.style.Stroke.prototype, "setWidth", ol.style.Stroke.prototype.setWidth);
goog.exportSymbol("ol.style.Style", ol.style.Style);
goog.exportProperty(ol.style.Style.prototype, "clone", ol.style.Style.prototype.clone);
goog.exportProperty(ol.style.Style.prototype, "getRenderer", ol.style.Style.prototype.getRenderer);
goog.exportProperty(ol.style.Style.prototype, "setRenderer", ol.style.Style.prototype.setRenderer);
goog.exportProperty(ol.style.Style.prototype, "getGeometry", ol.style.Style.prototype.getGeometry);
goog.exportProperty(ol.style.Style.prototype, "getGeometryFunction", ol.style.Style.prototype.getGeometryFunction);
goog.exportProperty(ol.style.Style.prototype, "getFill", ol.style.Style.prototype.getFill);
goog.exportProperty(ol.style.Style.prototype, "setFill", ol.style.Style.prototype.setFill);
goog.exportProperty(ol.style.Style.prototype, "getImage", ol.style.Style.prototype.getImage);
goog.exportProperty(ol.style.Style.prototype, "setImage", ol.style.Style.prototype.setImage);
goog.exportProperty(ol.style.Style.prototype, "getStroke", ol.style.Style.prototype.getStroke);
goog.exportProperty(ol.style.Style.prototype, "setStroke", ol.style.Style.prototype.setStroke);
goog.exportProperty(ol.style.Style.prototype, "getText", ol.style.Style.prototype.getText);
goog.exportProperty(ol.style.Style.prototype, "setText", ol.style.Style.prototype.setText);
goog.exportProperty(ol.style.Style.prototype, "getZIndex", ol.style.Style.prototype.getZIndex);
goog.exportProperty(ol.style.Style.prototype, "setGeometry", ol.style.Style.prototype.setGeometry);
goog.exportProperty(ol.style.Style.prototype, "setZIndex", ol.style.Style.prototype.setZIndex);
goog.exportSymbol("ol.style.Text", ol.style.Text);
goog.exportProperty(ol.style.Text.prototype, "clone", ol.style.Text.prototype.clone);
goog.exportProperty(ol.style.Text.prototype, "getOverflow", ol.style.Text.prototype.getOverflow);
goog.exportProperty(ol.style.Text.prototype, "getFont", ol.style.Text.prototype.getFont);
goog.exportProperty(ol.style.Text.prototype, "getMaxAngle", ol.style.Text.prototype.getMaxAngle);
goog.exportProperty(ol.style.Text.prototype, "getPlacement", ol.style.Text.prototype.getPlacement);
goog.exportProperty(ol.style.Text.prototype, "getOffsetX", ol.style.Text.prototype.getOffsetX);
goog.exportProperty(ol.style.Text.prototype, "getOffsetY", ol.style.Text.prototype.getOffsetY);
goog.exportProperty(ol.style.Text.prototype, "getFill", ol.style.Text.prototype.getFill);
goog.exportProperty(ol.style.Text.prototype, "getRotateWithView", ol.style.Text.prototype.getRotateWithView);
goog.exportProperty(ol.style.Text.prototype, "getRotation", ol.style.Text.prototype.getRotation);
goog.exportProperty(ol.style.Text.prototype, "getScale", ol.style.Text.prototype.getScale);
goog.exportProperty(ol.style.Text.prototype, "getStroke", ol.style.Text.prototype.getStroke);
goog.exportProperty(ol.style.Text.prototype, "getText", ol.style.Text.prototype.getText);
goog.exportProperty(ol.style.Text.prototype, "getTextAlign", ol.style.Text.prototype.getTextAlign);
goog.exportProperty(ol.style.Text.prototype, "getTextBaseline", ol.style.Text.prototype.getTextBaseline);
goog.exportProperty(ol.style.Text.prototype, "getBackgroundFill", ol.style.Text.prototype.getBackgroundFill);
goog.exportProperty(ol.style.Text.prototype, "getBackgroundStroke", ol.style.Text.prototype.getBackgroundStroke);
goog.exportProperty(ol.style.Text.prototype, "getPadding", ol.style.Text.prototype.getPadding);
goog.exportProperty(ol.style.Text.prototype, "setOverflow", ol.style.Text.prototype.setOverflow);
goog.exportProperty(ol.style.Text.prototype, "setFont", ol.style.Text.prototype.setFont);
goog.exportProperty(ol.style.Text.prototype, "setMaxAngle", ol.style.Text.prototype.setMaxAngle);
goog.exportProperty(ol.style.Text.prototype, "setOffsetX", ol.style.Text.prototype.setOffsetX);
goog.exportProperty(ol.style.Text.prototype, "setOffsetY", ol.style.Text.prototype.setOffsetY);
goog.exportProperty(ol.style.Text.prototype, "setPlacement", ol.style.Text.prototype.setPlacement);
goog.exportProperty(ol.style.Text.prototype, "setFill", ol.style.Text.prototype.setFill);
goog.exportProperty(ol.style.Text.prototype, "setRotation", ol.style.Text.prototype.setRotation);
goog.exportProperty(ol.style.Text.prototype, "setScale", ol.style.Text.prototype.setScale);
goog.exportProperty(ol.style.Text.prototype, "setStroke", ol.style.Text.prototype.setStroke);
goog.exportProperty(ol.style.Text.prototype, "setText", ol.style.Text.prototype.setText);
goog.exportProperty(ol.style.Text.prototype, "setTextAlign", ol.style.Text.prototype.setTextAlign);
goog.exportProperty(ol.style.Text.prototype, "setTextBaseline", ol.style.Text.prototype.setTextBaseline);
goog.exportProperty(ol.style.Text.prototype, "setBackgroundFill", ol.style.Text.prototype.setBackgroundFill);
goog.exportProperty(ol.style.Text.prototype, "setBackgroundStroke", ol.style.Text.prototype.setBackgroundStroke);
goog.exportProperty(ol.style.Text.prototype, "setPadding", ol.style.Text.prototype.setPadding);
goog.exportSymbol("ol.source.BingMaps", ol.source.BingMaps);
goog.exportSymbol("ol.source.BingMaps.TOS_ATTRIBUTION", ol.source.BingMaps.TOS_ATTRIBUTION);
goog.exportProperty(ol.source.BingMaps.prototype, "getApiKey", ol.source.BingMaps.prototype.getApiKey);
goog.exportProperty(ol.source.BingMaps.prototype, "getImagerySet", ol.source.BingMaps.prototype.getImagerySet);
goog.exportSymbol("ol.source.CartoDB", ol.source.CartoDB);
goog.exportProperty(ol.source.CartoDB.prototype, "getConfig", ol.source.CartoDB.prototype.getConfig);
goog.exportProperty(ol.source.CartoDB.prototype, "updateConfig", ol.source.CartoDB.prototype.updateConfig);
goog.exportProperty(ol.source.CartoDB.prototype, "setConfig", ol.source.CartoDB.prototype.setConfig);
goog.exportSymbol("ol.source.Cluster", ol.source.Cluster);
goog.exportProperty(ol.source.Cluster.prototype, "getDistance", ol.source.Cluster.prototype.getDistance);
goog.exportProperty(ol.source.Cluster.prototype, "getSource", ol.source.Cluster.prototype.getSource);
goog.exportProperty(ol.source.Cluster.prototype, "setDistance", ol.source.Cluster.prototype.setDistance);
goog.exportSymbol("ol.source.Image", ol.source.Image);
goog.exportProperty(ol.source.Image.Event.prototype, "image", ol.source.Image.Event.prototype.image);
goog.exportSymbol("ol.source.ImageArcGISRest", ol.source.ImageArcGISRest);
goog.exportProperty(ol.source.ImageArcGISRest.prototype, "getParams", ol.source.ImageArcGISRest.prototype.getParams);
goog.exportProperty(ol.source.ImageArcGISRest.prototype, "getImageLoadFunction", ol.source.ImageArcGISRest.prototype.getImageLoadFunction);
goog.exportProperty(ol.source.ImageArcGISRest.prototype, "getUrl", ol.source.ImageArcGISRest.prototype.getUrl);
goog.exportProperty(ol.source.ImageArcGISRest.prototype, "setImageLoadFunction", ol.source.ImageArcGISRest.prototype.setImageLoadFunction);
goog.exportProperty(ol.source.ImageArcGISRest.prototype, "setUrl", ol.source.ImageArcGISRest.prototype.setUrl);
goog.exportProperty(ol.source.ImageArcGISRest.prototype, "updateParams", ol.source.ImageArcGISRest.prototype.updateParams);
goog.exportSymbol("ol.source.ImageCanvas", ol.source.ImageCanvas);
goog.exportSymbol("ol.source.ImageMapGuide", ol.source.ImageMapGuide);
goog.exportProperty(ol.source.ImageMapGuide.prototype, "getParams", ol.source.ImageMapGuide.prototype.getParams);
goog.exportProperty(ol.source.ImageMapGuide.prototype, "getImageLoadFunction", ol.source.ImageMapGuide.prototype.getImageLoadFunction);
goog.exportProperty(ol.source.ImageMapGuide.prototype, "updateParams", ol.source.ImageMapGuide.prototype.updateParams);
goog.exportProperty(ol.source.ImageMapGuide.prototype, "setImageLoadFunction", ol.source.ImageMapGuide.prototype.setImageLoadFunction);
goog.exportSymbol("ol.source.ImageStatic", ol.source.ImageStatic);
goog.exportSymbol("ol.source.ImageVector", ol.source.ImageVector);
goog.exportProperty(ol.source.ImageVector.prototype, "getSource", ol.source.ImageVector.prototype.getSource);
goog.exportProperty(ol.source.ImageVector.prototype, "getStyle", ol.source.ImageVector.prototype.getStyle);
goog.exportProperty(ol.source.ImageVector.prototype, "getStyleFunction", ol.source.ImageVector.prototype.getStyleFunction);
goog.exportProperty(ol.source.ImageVector.prototype, "setStyle", ol.source.ImageVector.prototype.setStyle);
goog.exportSymbol("ol.source.ImageWMS", ol.source.ImageWMS);
goog.exportProperty(ol.source.ImageWMS.prototype, "getGetFeatureInfoUrl", ol.source.ImageWMS.prototype.getGetFeatureInfoUrl);
goog.exportProperty(ol.source.ImageWMS.prototype, "getParams", ol.source.ImageWMS.prototype.getParams);
goog.exportProperty(ol.source.ImageWMS.prototype, "getImageLoadFunction", ol.source.ImageWMS.prototype.getImageLoadFunction);
goog.exportProperty(ol.source.ImageWMS.prototype, "getUrl", ol.source.ImageWMS.prototype.getUrl);
goog.exportProperty(ol.source.ImageWMS.prototype, "setImageLoadFunction", ol.source.ImageWMS.prototype.setImageLoadFunction);
goog.exportProperty(ol.source.ImageWMS.prototype, "setUrl", ol.source.ImageWMS.prototype.setUrl);
goog.exportProperty(ol.source.ImageWMS.prototype, "updateParams", ol.source.ImageWMS.prototype.updateParams);
goog.exportSymbol("ol.source.OSM", ol.source.OSM);
goog.exportSymbol("ol.source.OSM.ATTRIBUTION", ol.source.OSM.ATTRIBUTION);
goog.exportSymbol("ol.source.Raster", ol.source.Raster);
goog.exportProperty(ol.source.Raster.prototype, "setOperation", ol.source.Raster.prototype.setOperation);
goog.exportProperty(ol.source.Raster.Event.prototype, "extent", ol.source.Raster.Event.prototype.extent);
goog.exportProperty(ol.source.Raster.Event.prototype, "resolution", ol.source.Raster.Event.prototype.resolution);
goog.exportProperty(ol.source.Raster.Event.prototype, "data", ol.source.Raster.Event.prototype.data);
goog.exportSymbol("ol.source.Source", ol.source.Source);
goog.exportProperty(ol.source.Source.prototype, "getAttributions", ol.source.Source.prototype.getAttributions);
goog.exportProperty(ol.source.Source.prototype, "getLogo", ol.source.Source.prototype.getLogo);
goog.exportProperty(ol.source.Source.prototype, "getProjection", ol.source.Source.prototype.getProjection);
goog.exportProperty(ol.source.Source.prototype, "getState", ol.source.Source.prototype.getState);
goog.exportProperty(ol.source.Source.prototype, "refresh", ol.source.Source.prototype.refresh);
goog.exportProperty(ol.source.Source.prototype, "setAttributions", ol.source.Source.prototype.setAttributions);
goog.exportSymbol("ol.source.Stamen", ol.source.Stamen);
goog.exportSymbol("ol.source.Tile", ol.source.Tile);
goog.exportProperty(ol.source.Tile.prototype, "getTileGrid", ol.source.Tile.prototype.getTileGrid);
goog.exportProperty(ol.source.Tile.Event.prototype, "tile", ol.source.Tile.Event.prototype.tile);
goog.exportSymbol("ol.source.TileArcGISRest", ol.source.TileArcGISRest);
goog.exportProperty(ol.source.TileArcGISRest.prototype, "getParams", ol.source.TileArcGISRest.prototype.getParams);
goog.exportProperty(ol.source.TileArcGISRest.prototype, "updateParams", ol.source.TileArcGISRest.prototype.updateParams);
goog.exportSymbol("ol.source.TileDebug", ol.source.TileDebug);
goog.exportSymbol("ol.source.TileImage", ol.source.TileImage);
goog.exportProperty(ol.source.TileImage.prototype, "setRenderReprojectionEdges", ol.source.TileImage.prototype.setRenderReprojectionEdges);
goog.exportProperty(ol.source.TileImage.prototype, "setTileGridForProjection", ol.source.TileImage.prototype.setTileGridForProjection);
goog.exportSymbol("ol.source.TileJSON", ol.source.TileJSON);
goog.exportProperty(ol.source.TileJSON.prototype, "getTileJSON", ol.source.TileJSON.prototype.getTileJSON);
goog.exportSymbol("ol.source.TileUTFGrid", ol.source.TileUTFGrid);
goog.exportProperty(ol.source.TileUTFGrid.prototype, "getTemplate", ol.source.TileUTFGrid.prototype.getTemplate);
goog.exportProperty(ol.source.TileUTFGrid.prototype, "forDataAtCoordinateAndResolution", ol.source.TileUTFGrid.prototype.forDataAtCoordinateAndResolution);
goog.exportSymbol("ol.source.TileWMS", ol.source.TileWMS);
goog.exportProperty(ol.source.TileWMS.prototype, "getGetFeatureInfoUrl", ol.source.TileWMS.prototype.getGetFeatureInfoUrl);
goog.exportProperty(ol.source.TileWMS.prototype, "getParams", ol.source.TileWMS.prototype.getParams);
goog.exportProperty(ol.source.TileWMS.prototype, "updateParams", ol.source.TileWMS.prototype.updateParams);
goog.exportProperty(ol.source.UrlTile.prototype, "getTileLoadFunction", ol.source.UrlTile.prototype.getTileLoadFunction);
goog.exportProperty(ol.source.UrlTile.prototype, "getTileUrlFunction", ol.source.UrlTile.prototype.getTileUrlFunction);
goog.exportProperty(ol.source.UrlTile.prototype, "getUrls", ol.source.UrlTile.prototype.getUrls);
goog.exportProperty(ol.source.UrlTile.prototype, "setTileLoadFunction", ol.source.UrlTile.prototype.setTileLoadFunction);
goog.exportProperty(ol.source.UrlTile.prototype, "setTileUrlFunction", ol.source.UrlTile.prototype.setTileUrlFunction);
goog.exportProperty(ol.source.UrlTile.prototype, "setUrl", ol.source.UrlTile.prototype.setUrl);
goog.exportProperty(ol.source.UrlTile.prototype, "setUrls", ol.source.UrlTile.prototype.setUrls);
goog.exportSymbol("ol.source.Vector", ol.source.Vector);
goog.exportProperty(ol.source.Vector.prototype, "addFeature", ol.source.Vector.prototype.addFeature);
goog.exportProperty(ol.source.Vector.prototype, "addFeatures", ol.source.Vector.prototype.addFeatures);
goog.exportProperty(ol.source.Vector.prototype, "clear", ol.source.Vector.prototype.clear);
goog.exportProperty(ol.source.Vector.prototype, "forEachFeature", ol.source.Vector.prototype.forEachFeature);
goog.exportProperty(ol.source.Vector.prototype, "forEachFeatureInExtent", ol.source.Vector.prototype.forEachFeatureInExtent);
goog.exportProperty(ol.source.Vector.prototype, "forEachFeatureIntersectingExtent", ol.source.Vector.prototype.forEachFeatureIntersectingExtent);
goog.exportProperty(ol.source.Vector.prototype, "getFeaturesCollection", ol.source.Vector.prototype.getFeaturesCollection);
goog.exportProperty(ol.source.Vector.prototype, "getFeatures", ol.source.Vector.prototype.getFeatures);
goog.exportProperty(ol.source.Vector.prototype, "getFeaturesAtCoordinate", ol.source.Vector.prototype.getFeaturesAtCoordinate);
goog.exportProperty(ol.source.Vector.prototype, "getFeaturesInExtent", ol.source.Vector.prototype.getFeaturesInExtent);
goog.exportProperty(ol.source.Vector.prototype, "getClosestFeatureToCoordinate", ol.source.Vector.prototype.getClosestFeatureToCoordinate);
goog.exportProperty(ol.source.Vector.prototype, "getExtent", ol.source.Vector.prototype.getExtent);
goog.exportProperty(ol.source.Vector.prototype, "getFeatureById", ol.source.Vector.prototype.getFeatureById);
goog.exportProperty(ol.source.Vector.prototype, "getFormat", ol.source.Vector.prototype.getFormat);
goog.exportProperty(ol.source.Vector.prototype, "getUrl", ol.source.Vector.prototype.getUrl);
goog.exportProperty(ol.source.Vector.prototype, "removeLoadedExtent", ol.source.Vector.prototype.removeLoadedExtent);
goog.exportProperty(ol.source.Vector.prototype, "removeFeature", ol.source.Vector.prototype.removeFeature);
goog.exportProperty(ol.source.Vector.prototype, "setLoader", ol.source.Vector.prototype.setLoader);
goog.exportProperty(ol.source.Vector.Event.prototype, "feature", ol.source.Vector.Event.prototype.feature);
goog.exportSymbol("ol.source.VectorTile", ol.source.VectorTile);
goog.exportProperty(ol.source.VectorTile.prototype, "clear", ol.source.VectorTile.prototype.clear);
goog.exportSymbol("ol.source.WMTS", ol.source.WMTS);
goog.exportProperty(ol.source.WMTS.prototype, "getDimensions", ol.source.WMTS.prototype.getDimensions);
goog.exportProperty(ol.source.WMTS.prototype, "getFormat", ol.source.WMTS.prototype.getFormat);
goog.exportProperty(ol.source.WMTS.prototype, "getLayer", ol.source.WMTS.prototype.getLayer);
goog.exportProperty(ol.source.WMTS.prototype, "getMatrixSet", ol.source.WMTS.prototype.getMatrixSet);
goog.exportProperty(ol.source.WMTS.prototype, "getRequestEncoding", ol.source.WMTS.prototype.getRequestEncoding);
goog.exportProperty(ol.source.WMTS.prototype, "getStyle", ol.source.WMTS.prototype.getStyle);
goog.exportProperty(ol.source.WMTS.prototype, "getVersion", ol.source.WMTS.prototype.getVersion);
goog.exportProperty(ol.source.WMTS.prototype, "updateDimensions", ol.source.WMTS.prototype.updateDimensions);
goog.exportSymbol("ol.source.WMTS.optionsFromCapabilities", ol.source.WMTS.optionsFromCapabilities);
goog.exportSymbol("ol.source.XYZ", ol.source.XYZ);
goog.exportSymbol("ol.source.Zoomify", ol.source.Zoomify);
goog.exportSymbol("ol.renderer.webgl.ImageLayer", ol.renderer.webgl.ImageLayer);
goog.exportSymbol("ol.renderer.webgl.Map", ol.renderer.webgl.Map);
goog.exportSymbol("ol.renderer.webgl.TileLayer", ol.renderer.webgl.TileLayer);
goog.exportSymbol("ol.renderer.webgl.VectorLayer", ol.renderer.webgl.VectorLayer);
goog.exportSymbol("ol.renderer.canvas.ImageLayer", ol.renderer.canvas.ImageLayer);
goog.exportSymbol("ol.renderer.canvas.Map", ol.renderer.canvas.Map);
goog.exportSymbol("ol.renderer.canvas.TileLayer", ol.renderer.canvas.TileLayer);
goog.exportSymbol("ol.renderer.canvas.VectorLayer", ol.renderer.canvas.VectorLayer);
goog.exportSymbol("ol.renderer.canvas.VectorTileLayer", ol.renderer.canvas.VectorTileLayer);
goog.exportProperty(ol.render.Event.prototype, "vectorContext", ol.render.Event.prototype.vectorContext);
goog.exportProperty(ol.render.Event.prototype, "frameState", ol.render.Event.prototype.frameState);
goog.exportProperty(ol.render.Event.prototype, "context", ol.render.Event.prototype.context);
goog.exportProperty(ol.render.Event.prototype, "glContext", ol.render.Event.prototype.glContext);
goog.exportProperty(ol.render.Feature.prototype, "get", ol.render.Feature.prototype.get);
goog.exportProperty(ol.render.Feature.prototype, "getExtent", ol.render.Feature.prototype.getExtent);
goog.exportProperty(ol.render.Feature.prototype, "getId", ol.render.Feature.prototype.getId);
goog.exportProperty(ol.render.Feature.prototype, "getGeometry", ol.render.Feature.prototype.getGeometry);
goog.exportProperty(ol.render.Feature.prototype, "getProperties", ol.render.Feature.prototype.getProperties);
goog.exportProperty(ol.render.Feature.prototype, "getType", ol.render.Feature.prototype.getType);
goog.exportSymbol("ol.render.VectorContext", ol.render.VectorContext);
goog.exportProperty(ol.render.webgl.Immediate.prototype, "setStyle", ol.render.webgl.Immediate.prototype.setStyle);
goog.exportProperty(ol.render.webgl.Immediate.prototype, "drawGeometry", ol.render.webgl.Immediate.prototype.drawGeometry);
goog.exportProperty(ol.render.webgl.Immediate.prototype, "drawFeature", ol.render.webgl.Immediate.prototype.drawFeature);
goog.exportProperty(ol.render.canvas.Immediate.prototype, "drawCircle", ol.render.canvas.Immediate.prototype.drawCircle);
goog.exportProperty(ol.render.canvas.Immediate.prototype, "setStyle", ol.render.canvas.Immediate.prototype.setStyle);
goog.exportProperty(ol.render.canvas.Immediate.prototype, "drawGeometry", ol.render.canvas.Immediate.prototype.drawGeometry);
goog.exportProperty(ol.render.canvas.Immediate.prototype, "drawFeature", ol.render.canvas.Immediate.prototype.drawFeature);
goog.exportSymbol("ol.proj.common.add", ol.proj.common.add);
goog.exportSymbol("ol.proj.Projection", ol.proj.Projection);
goog.exportProperty(ol.proj.Projection.prototype, "getCode", ol.proj.Projection.prototype.getCode);
goog.exportProperty(ol.proj.Projection.prototype, "getExtent", ol.proj.Projection.prototype.getExtent);
goog.exportProperty(ol.proj.Projection.prototype, "getUnits", ol.proj.Projection.prototype.getUnits);
goog.exportProperty(ol.proj.Projection.prototype, "getMetersPerUnit", ol.proj.Projection.prototype.getMetersPerUnit);
goog.exportProperty(ol.proj.Projection.prototype, "getWorldExtent", ol.proj.Projection.prototype.getWorldExtent);
goog.exportProperty(ol.proj.Projection.prototype, "getAxisOrientation", ol.proj.Projection.prototype.getAxisOrientation);
goog.exportProperty(ol.proj.Projection.prototype, "isGlobal", ol.proj.Projection.prototype.isGlobal);
goog.exportProperty(ol.proj.Projection.prototype, "setGlobal", ol.proj.Projection.prototype.setGlobal);
goog.exportProperty(ol.proj.Projection.prototype, "setExtent", ol.proj.Projection.prototype.setExtent);
goog.exportProperty(ol.proj.Projection.prototype, "setWorldExtent", ol.proj.Projection.prototype.setWorldExtent);
goog.exportProperty(ol.proj.Projection.prototype, "setGetPointResolution", ol.proj.Projection.prototype.setGetPointResolution);
goog.exportSymbol("ol.proj.Units.METERS_PER_UNIT", ol.proj.Units.METERS_PER_UNIT);
goog.exportSymbol("ol.layer.Base", ol.layer.Base);
goog.exportProperty(ol.layer.Base.prototype, "getExtent", ol.layer.Base.prototype.getExtent);
goog.exportProperty(ol.layer.Base.prototype, "getMaxResolution", ol.layer.Base.prototype.getMaxResolution);
goog.exportProperty(ol.layer.Base.prototype, "getMinResolution", ol.layer.Base.prototype.getMinResolution);
goog.exportProperty(ol.layer.Base.prototype, "getOpacity", ol.layer.Base.prototype.getOpacity);
goog.exportProperty(ol.layer.Base.prototype, "getVisible", ol.layer.Base.prototype.getVisible);
goog.exportProperty(ol.layer.Base.prototype, "getZIndex", ol.layer.Base.prototype.getZIndex);
goog.exportProperty(ol.layer.Base.prototype, "setExtent", ol.layer.Base.prototype.setExtent);
goog.exportProperty(ol.layer.Base.prototype, "setMaxResolution", ol.layer.Base.prototype.setMaxResolution);
goog.exportProperty(ol.layer.Base.prototype, "setMinResolution", ol.layer.Base.prototype.setMinResolution);
goog.exportProperty(ol.layer.Base.prototype, "setOpacity", ol.layer.Base.prototype.setOpacity);
goog.exportProperty(ol.layer.Base.prototype, "setVisible", ol.layer.Base.prototype.setVisible);
goog.exportProperty(ol.layer.Base.prototype, "setZIndex", ol.layer.Base.prototype.setZIndex);
goog.exportSymbol("ol.layer.Group", ol.layer.Group);
goog.exportProperty(ol.layer.Group.prototype, "getLayers", ol.layer.Group.prototype.getLayers);
goog.exportProperty(ol.layer.Group.prototype, "setLayers", ol.layer.Group.prototype.setLayers);
goog.exportSymbol("ol.layer.Heatmap", ol.layer.Heatmap);
goog.exportProperty(ol.layer.Heatmap.prototype, "getBlur", ol.layer.Heatmap.prototype.getBlur);
goog.exportProperty(ol.layer.Heatmap.prototype, "getGradient", ol.layer.Heatmap.prototype.getGradient);
goog.exportProperty(ol.layer.Heatmap.prototype, "getRadius", ol.layer.Heatmap.prototype.getRadius);
goog.exportProperty(ol.layer.Heatmap.prototype, "setBlur", ol.layer.Heatmap.prototype.setBlur);
goog.exportProperty(ol.layer.Heatmap.prototype, "setGradient", ol.layer.Heatmap.prototype.setGradient);
goog.exportProperty(ol.layer.Heatmap.prototype, "setRadius", ol.layer.Heatmap.prototype.setRadius);
goog.exportSymbol("ol.layer.Image", ol.layer.Image);
goog.exportProperty(ol.layer.Image.prototype, "getSource", ol.layer.Image.prototype.getSource);
goog.exportSymbol("ol.layer.Layer", ol.layer.Layer);
goog.exportProperty(ol.layer.Layer.prototype, "getSource", ol.layer.Layer.prototype.getSource);
goog.exportProperty(ol.layer.Layer.prototype, "setMap", ol.layer.Layer.prototype.setMap);
goog.exportProperty(ol.layer.Layer.prototype, "setSource", ol.layer.Layer.prototype.setSource);
goog.exportSymbol("ol.layer.Tile", ol.layer.Tile);
goog.exportProperty(ol.layer.Tile.prototype, "getPreload", ol.layer.Tile.prototype.getPreload);
goog.exportProperty(ol.layer.Tile.prototype, "getSource", ol.layer.Tile.prototype.getSource);
goog.exportProperty(ol.layer.Tile.prototype, "setPreload", ol.layer.Tile.prototype.setPreload);
goog.exportProperty(ol.layer.Tile.prototype, "getUseInterimTilesOnError", ol.layer.Tile.prototype.getUseInterimTilesOnError);
goog.exportProperty(ol.layer.Tile.prototype, "setUseInterimTilesOnError", ol.layer.Tile.prototype.setUseInterimTilesOnError);
goog.exportSymbol("ol.layer.Vector", ol.layer.Vector);
goog.exportProperty(ol.layer.Vector.prototype, "getSource", ol.layer.Vector.prototype.getSource);
goog.exportProperty(ol.layer.Vector.prototype, "getStyle", ol.layer.Vector.prototype.getStyle);
goog.exportProperty(ol.layer.Vector.prototype, "getStyleFunction", ol.layer.Vector.prototype.getStyleFunction);
goog.exportProperty(ol.layer.Vector.prototype, "setStyle", ol.layer.Vector.prototype.setStyle);
goog.exportSymbol("ol.layer.VectorTile", ol.layer.VectorTile);
goog.exportProperty(ol.layer.VectorTile.prototype, "getPreload", ol.layer.VectorTile.prototype.getPreload);
goog.exportProperty(ol.layer.VectorTile.prototype, "getUseInterimTilesOnError", ol.layer.VectorTile.prototype.getUseInterimTilesOnError);
goog.exportProperty(ol.layer.VectorTile.prototype, "setPreload", ol.layer.VectorTile.prototype.setPreload);
goog.exportProperty(ol.layer.VectorTile.prototype, "setUseInterimTilesOnError", ol.layer.VectorTile.prototype.setUseInterimTilesOnError);
goog.exportProperty(ol.layer.VectorTile.prototype, "getSource", ol.layer.VectorTile.prototype.getSource);
goog.exportSymbol("ol.interaction.DoubleClickZoom", ol.interaction.DoubleClickZoom);
goog.exportSymbol("ol.interaction.DoubleClickZoom.handleEvent", ol.interaction.DoubleClickZoom.handleEvent);
goog.exportSymbol("ol.interaction.DragAndDrop", ol.interaction.DragAndDrop);
goog.exportSymbol("ol.interaction.DragAndDrop.handleEvent", ol.interaction.DragAndDrop.handleEvent);
goog.exportProperty(ol.interaction.DragAndDrop.Event.prototype, "features", ol.interaction.DragAndDrop.Event.prototype.features);
goog.exportProperty(ol.interaction.DragAndDrop.Event.prototype, "file", ol.interaction.DragAndDrop.Event.prototype.file);
goog.exportProperty(ol.interaction.DragAndDrop.Event.prototype, "projection", ol.interaction.DragAndDrop.Event.prototype.projection);
goog.exportSymbol("ol.interaction.DragBox", ol.interaction.DragBox);
goog.exportProperty(ol.interaction.DragBox.prototype, "getGeometry", ol.interaction.DragBox.prototype.getGeometry);
goog.exportProperty(ol.interaction.DragBox.Event.prototype, "coordinate", ol.interaction.DragBox.Event.prototype.coordinate);
goog.exportProperty(ol.interaction.DragBox.Event.prototype, "mapBrowserEvent", ol.interaction.DragBox.Event.prototype.mapBrowserEvent);
goog.exportSymbol("ol.interaction.DragPan", ol.interaction.DragPan);
goog.exportSymbol("ol.interaction.DragRotate", ol.interaction.DragRotate);
goog.exportSymbol("ol.interaction.DragRotateAndZoom", ol.interaction.DragRotateAndZoom);
goog.exportSymbol("ol.interaction.DragZoom", ol.interaction.DragZoom);
goog.exportSymbol("ol.interaction.Draw", ol.interaction.Draw);
goog.exportSymbol("ol.interaction.Draw.handleEvent", ol.interaction.Draw.handleEvent);
goog.exportProperty(ol.interaction.Draw.prototype, "removeLastPoint", ol.interaction.Draw.prototype.removeLastPoint);
goog.exportProperty(ol.interaction.Draw.prototype, "finishDrawing", ol.interaction.Draw.prototype.finishDrawing);
goog.exportProperty(ol.interaction.Draw.prototype, "extend", ol.interaction.Draw.prototype.extend);
goog.exportSymbol("ol.interaction.Draw.createRegularPolygon", ol.interaction.Draw.createRegularPolygon);
goog.exportSymbol("ol.interaction.Draw.createBox", ol.interaction.Draw.createBox);
goog.exportProperty(ol.interaction.Draw.Event.prototype, "feature", ol.interaction.Draw.Event.prototype.feature);
goog.exportSymbol("ol.interaction.Extent", ol.interaction.Extent);
goog.exportProperty(ol.interaction.Extent.prototype, "getExtent", ol.interaction.Extent.prototype.getExtent);
goog.exportProperty(ol.interaction.Extent.prototype, "setExtent", ol.interaction.Extent.prototype.setExtent);
goog.exportProperty(ol.interaction.Extent.Event.prototype, "extent", ol.interaction.Extent.Event.prototype.extent);
goog.exportSymbol("ol.interaction.Interaction", ol.interaction.Interaction);
goog.exportProperty(ol.interaction.Interaction.prototype, "getActive", ol.interaction.Interaction.prototype.getActive);
goog.exportProperty(ol.interaction.Interaction.prototype, "getMap", ol.interaction.Interaction.prototype.getMap);
goog.exportProperty(ol.interaction.Interaction.prototype, "setActive", ol.interaction.Interaction.prototype.setActive);
goog.exportSymbol("ol.interaction.KeyboardPan", ol.interaction.KeyboardPan);
goog.exportSymbol("ol.interaction.KeyboardPan.handleEvent", ol.interaction.KeyboardPan.handleEvent);
goog.exportSymbol("ol.interaction.KeyboardZoom", ol.interaction.KeyboardZoom);
goog.exportSymbol("ol.interaction.KeyboardZoom.handleEvent", ol.interaction.KeyboardZoom.handleEvent);
goog.exportSymbol("ol.interaction.Modify", ol.interaction.Modify);
goog.exportSymbol("ol.interaction.Modify.handleEvent", ol.interaction.Modify.handleEvent);
goog.exportProperty(ol.interaction.Modify.prototype, "removePoint", ol.interaction.Modify.prototype.removePoint);
goog.exportProperty(ol.interaction.Modify.Event.prototype, "features", ol.interaction.Modify.Event.prototype.features);
goog.exportProperty(ol.interaction.Modify.Event.prototype, "mapBrowserEvent", ol.interaction.Modify.Event.prototype.mapBrowserEvent);
goog.exportSymbol("ol.interaction.MouseWheelZoom", ol.interaction.MouseWheelZoom);
goog.exportSymbol("ol.interaction.MouseWheelZoom.handleEvent", ol.interaction.MouseWheelZoom.handleEvent);
goog.exportProperty(ol.interaction.MouseWheelZoom.prototype, "setMouseAnchor", ol.interaction.MouseWheelZoom.prototype.setMouseAnchor);
goog.exportSymbol("ol.interaction.PinchRotate", ol.interaction.PinchRotate);
goog.exportSymbol("ol.interaction.PinchZoom", ol.interaction.PinchZoom);
goog.exportSymbol("ol.interaction.Pointer", ol.interaction.Pointer);
goog.exportSymbol("ol.interaction.Pointer.handleEvent", ol.interaction.Pointer.handleEvent);
goog.exportSymbol("ol.interaction.Select", ol.interaction.Select);
goog.exportProperty(ol.interaction.Select.prototype, "getFeatures", ol.interaction.Select.prototype.getFeatures);
goog.exportProperty(ol.interaction.Select.prototype, "getHitTolerance", ol.interaction.Select.prototype.getHitTolerance);
goog.exportProperty(ol.interaction.Select.prototype, "getLayer", ol.interaction.Select.prototype.getLayer);
goog.exportSymbol("ol.interaction.Select.handleEvent", ol.interaction.Select.handleEvent);
goog.exportProperty(ol.interaction.Select.prototype, "setHitTolerance", ol.interaction.Select.prototype.setHitTolerance);
goog.exportProperty(ol.interaction.Select.prototype, "setMap", ol.interaction.Select.prototype.setMap);
goog.exportProperty(ol.interaction.Select.Event.prototype, "selected", ol.interaction.Select.Event.prototype.selected);
goog.exportProperty(ol.interaction.Select.Event.prototype, "deselected", ol.interaction.Select.Event.prototype.deselected);
goog.exportProperty(ol.interaction.Select.Event.prototype, "mapBrowserEvent", ol.interaction.Select.Event.prototype.mapBrowserEvent);
goog.exportSymbol("ol.interaction.Snap", ol.interaction.Snap);
goog.exportProperty(ol.interaction.Snap.prototype, "addFeature", ol.interaction.Snap.prototype.addFeature);
goog.exportProperty(ol.interaction.Snap.prototype, "removeFeature", ol.interaction.Snap.prototype.removeFeature);
goog.exportSymbol("ol.interaction.Translate", ol.interaction.Translate);
goog.exportProperty(ol.interaction.Translate.prototype, "getHitTolerance", ol.interaction.Translate.prototype.getHitTolerance);
goog.exportProperty(ol.interaction.Translate.prototype, "setHitTolerance", ol.interaction.Translate.prototype.setHitTolerance);
goog.exportProperty(ol.interaction.Translate.Event.prototype, "features", ol.interaction.Translate.Event.prototype.features);
goog.exportProperty(ol.interaction.Translate.Event.prototype, "coordinate", ol.interaction.Translate.Event.prototype.coordinate);
goog.exportSymbol("ol.geom.Circle", ol.geom.Circle);
goog.exportProperty(ol.geom.Circle.prototype, "clone", ol.geom.Circle.prototype.clone);
goog.exportProperty(ol.geom.Circle.prototype, "getCenter", ol.geom.Circle.prototype.getCenter);
goog.exportProperty(ol.geom.Circle.prototype, "getRadius", ol.geom.Circle.prototype.getRadius);
goog.exportProperty(ol.geom.Circle.prototype, "getType", ol.geom.Circle.prototype.getType);
goog.exportProperty(ol.geom.Circle.prototype, "intersectsExtent", ol.geom.Circle.prototype.intersectsExtent);
goog.exportProperty(ol.geom.Circle.prototype, "setCenter", ol.geom.Circle.prototype.setCenter);
goog.exportProperty(ol.geom.Circle.prototype, "setCenterAndRadius", ol.geom.Circle.prototype.setCenterAndRadius);
goog.exportProperty(ol.geom.Circle.prototype, "setRadius", ol.geom.Circle.prototype.setRadius);
goog.exportProperty(ol.geom.Circle.prototype, "transform", ol.geom.Circle.prototype.transform);
goog.exportSymbol("ol.geom.Geometry", ol.geom.Geometry);
goog.exportProperty(ol.geom.Geometry.prototype, "getClosestPoint", ol.geom.Geometry.prototype.getClosestPoint);
goog.exportProperty(ol.geom.Geometry.prototype, "intersectsCoordinate", ol.geom.Geometry.prototype.intersectsCoordinate);
goog.exportProperty(ol.geom.Geometry.prototype, "getExtent", ol.geom.Geometry.prototype.getExtent);
goog.exportProperty(ol.geom.Geometry.prototype, "rotate", ol.geom.Geometry.prototype.rotate);
goog.exportProperty(ol.geom.Geometry.prototype, "scale", ol.geom.Geometry.prototype.scale);
goog.exportProperty(ol.geom.Geometry.prototype, "simplify", ol.geom.Geometry.prototype.simplify);
goog.exportProperty(ol.geom.Geometry.prototype, "transform", ol.geom.Geometry.prototype.transform);
goog.exportSymbol("ol.geom.GeometryCollection", ol.geom.GeometryCollection);
goog.exportProperty(ol.geom.GeometryCollection.prototype, "clone", ol.geom.GeometryCollection.prototype.clone);
goog.exportProperty(ol.geom.GeometryCollection.prototype, "getGeometries", ol.geom.GeometryCollection.prototype.getGeometries);
goog.exportProperty(ol.geom.GeometryCollection.prototype, "getType", ol.geom.GeometryCollection.prototype.getType);
goog.exportProperty(ol.geom.GeometryCollection.prototype, "intersectsExtent", ol.geom.GeometryCollection.prototype.intersectsExtent);
goog.exportProperty(ol.geom.GeometryCollection.prototype, "rotate", ol.geom.GeometryCollection.prototype.rotate);
goog.exportProperty(ol.geom.GeometryCollection.prototype, "scale", ol.geom.GeometryCollection.prototype.scale);
goog.exportProperty(ol.geom.GeometryCollection.prototype, "setGeometries", ol.geom.GeometryCollection.prototype.setGeometries);
goog.exportProperty(ol.geom.GeometryCollection.prototype, "applyTransform", ol.geom.GeometryCollection.prototype.applyTransform);
goog.exportProperty(ol.geom.GeometryCollection.prototype, "translate", ol.geom.GeometryCollection.prototype.translate);
goog.exportSymbol("ol.geom.LinearRing", ol.geom.LinearRing);
goog.exportProperty(ol.geom.LinearRing.prototype, "clone", ol.geom.LinearRing.prototype.clone);
goog.exportProperty(ol.geom.LinearRing.prototype, "getArea", ol.geom.LinearRing.prototype.getArea);
goog.exportProperty(ol.geom.LinearRing.prototype, "getCoordinates", ol.geom.LinearRing.prototype.getCoordinates);
goog.exportProperty(ol.geom.LinearRing.prototype, "getType", ol.geom.LinearRing.prototype.getType);
goog.exportProperty(ol.geom.LinearRing.prototype, "setCoordinates", ol.geom.LinearRing.prototype.setCoordinates);
goog.exportSymbol("ol.geom.LineString", ol.geom.LineString);
goog.exportProperty(ol.geom.LineString.prototype, "appendCoordinate", ol.geom.LineString.prototype.appendCoordinate);
goog.exportProperty(ol.geom.LineString.prototype, "clone", ol.geom.LineString.prototype.clone);
goog.exportProperty(ol.geom.LineString.prototype, "forEachSegment", ol.geom.LineString.prototype.forEachSegment);
goog.exportProperty(ol.geom.LineString.prototype, "getCoordinateAtM", ol.geom.LineString.prototype.getCoordinateAtM);
goog.exportProperty(ol.geom.LineString.prototype, "getCoordinates", ol.geom.LineString.prototype.getCoordinates);
goog.exportProperty(ol.geom.LineString.prototype, "getCoordinateAt", ol.geom.LineString.prototype.getCoordinateAt);
goog.exportProperty(ol.geom.LineString.prototype, "getLength", ol.geom.LineString.prototype.getLength);
goog.exportProperty(ol.geom.LineString.prototype, "getType", ol.geom.LineString.prototype.getType);
goog.exportProperty(ol.geom.LineString.prototype, "intersectsExtent", ol.geom.LineString.prototype.intersectsExtent);
goog.exportProperty(ol.geom.LineString.prototype, "setCoordinates", ol.geom.LineString.prototype.setCoordinates);
goog.exportSymbol("ol.geom.MultiLineString", ol.geom.MultiLineString);
goog.exportProperty(ol.geom.MultiLineString.prototype, "appendLineString", ol.geom.MultiLineString.prototype.appendLineString);
goog.exportProperty(ol.geom.MultiLineString.prototype, "clone", ol.geom.MultiLineString.prototype.clone);
goog.exportProperty(ol.geom.MultiLineString.prototype, "getCoordinateAtM", ol.geom.MultiLineString.prototype.getCoordinateAtM);
goog.exportProperty(ol.geom.MultiLineString.prototype, "getCoordinates", ol.geom.MultiLineString.prototype.getCoordinates);
goog.exportProperty(ol.geom.MultiLineString.prototype, "getLineString", ol.geom.MultiLineString.prototype.getLineString);
goog.exportProperty(ol.geom.MultiLineString.prototype, "getLineStrings", ol.geom.MultiLineString.prototype.getLineStrings);
goog.exportProperty(ol.geom.MultiLineString.prototype, "getType", ol.geom.MultiLineString.prototype.getType);
goog.exportProperty(ol.geom.MultiLineString.prototype, "intersectsExtent", ol.geom.MultiLineString.prototype.intersectsExtent);
goog.exportProperty(ol.geom.MultiLineString.prototype, "setCoordinates", ol.geom.MultiLineString.prototype.setCoordinates);
goog.exportSymbol("ol.geom.MultiPoint", ol.geom.MultiPoint);
goog.exportProperty(ol.geom.MultiPoint.prototype, "appendPoint", ol.geom.MultiPoint.prototype.appendPoint);
goog.exportProperty(ol.geom.MultiPoint.prototype, "clone", ol.geom.MultiPoint.prototype.clone);
goog.exportProperty(ol.geom.MultiPoint.prototype, "getCoordinates", ol.geom.MultiPoint.prototype.getCoordinates);
goog.exportProperty(ol.geom.MultiPoint.prototype, "getPoint", ol.geom.MultiPoint.prototype.getPoint);
goog.exportProperty(ol.geom.MultiPoint.prototype, "getPoints", ol.geom.MultiPoint.prototype.getPoints);
goog.exportProperty(ol.geom.MultiPoint.prototype, "getType", ol.geom.MultiPoint.prototype.getType);
goog.exportProperty(ol.geom.MultiPoint.prototype, "intersectsExtent", ol.geom.MultiPoint.prototype.intersectsExtent);
goog.exportProperty(ol.geom.MultiPoint.prototype, "setCoordinates", ol.geom.MultiPoint.prototype.setCoordinates);
goog.exportSymbol("ol.geom.MultiPolygon", ol.geom.MultiPolygon);
goog.exportProperty(ol.geom.MultiPolygon.prototype, "appendPolygon", ol.geom.MultiPolygon.prototype.appendPolygon);
goog.exportProperty(ol.geom.MultiPolygon.prototype, "clone", ol.geom.MultiPolygon.prototype.clone);
goog.exportProperty(ol.geom.MultiPolygon.prototype, "getArea", ol.geom.MultiPolygon.prototype.getArea);
goog.exportProperty(ol.geom.MultiPolygon.prototype, "getCoordinates", ol.geom.MultiPolygon.prototype.getCoordinates);
goog.exportProperty(ol.geom.MultiPolygon.prototype, "getInteriorPoints", ol.geom.MultiPolygon.prototype.getInteriorPoints);
goog.exportProperty(ol.geom.MultiPolygon.prototype, "getPolygon", ol.geom.MultiPolygon.prototype.getPolygon);
goog.exportProperty(ol.geom.MultiPolygon.prototype, "getPolygons", ol.geom.MultiPolygon.prototype.getPolygons);
goog.exportProperty(ol.geom.MultiPolygon.prototype, "getType", ol.geom.MultiPolygon.prototype.getType);
goog.exportProperty(ol.geom.MultiPolygon.prototype, "intersectsExtent", ol.geom.MultiPolygon.prototype.intersectsExtent);
goog.exportProperty(ol.geom.MultiPolygon.prototype, "setCoordinates", ol.geom.MultiPolygon.prototype.setCoordinates);
goog.exportSymbol("ol.geom.Point", ol.geom.Point);
goog.exportProperty(ol.geom.Point.prototype, "clone", ol.geom.Point.prototype.clone);
goog.exportProperty(ol.geom.Point.prototype, "getCoordinates", ol.geom.Point.prototype.getCoordinates);
goog.exportProperty(ol.geom.Point.prototype, "getType", ol.geom.Point.prototype.getType);
goog.exportProperty(ol.geom.Point.prototype, "intersectsExtent", ol.geom.Point.prototype.intersectsExtent);
goog.exportProperty(ol.geom.Point.prototype, "setCoordinates", ol.geom.Point.prototype.setCoordinates);
goog.exportSymbol("ol.geom.Polygon", ol.geom.Polygon);
goog.exportProperty(ol.geom.Polygon.prototype, "appendLinearRing", ol.geom.Polygon.prototype.appendLinearRing);
goog.exportProperty(ol.geom.Polygon.prototype, "clone", ol.geom.Polygon.prototype.clone);
goog.exportProperty(ol.geom.Polygon.prototype, "getArea", ol.geom.Polygon.prototype.getArea);
goog.exportProperty(ol.geom.Polygon.prototype, "getCoordinates", ol.geom.Polygon.prototype.getCoordinates);
goog.exportProperty(ol.geom.Polygon.prototype, "getInteriorPoint", ol.geom.Polygon.prototype.getInteriorPoint);
goog.exportProperty(ol.geom.Polygon.prototype, "getLinearRingCount", ol.geom.Polygon.prototype.getLinearRingCount);
goog.exportProperty(ol.geom.Polygon.prototype, "getLinearRing", ol.geom.Polygon.prototype.getLinearRing);
goog.exportProperty(ol.geom.Polygon.prototype, "getLinearRings", ol.geom.Polygon.prototype.getLinearRings);
goog.exportProperty(ol.geom.Polygon.prototype, "getType", ol.geom.Polygon.prototype.getType);
goog.exportProperty(ol.geom.Polygon.prototype, "intersectsExtent", ol.geom.Polygon.prototype.intersectsExtent);
goog.exportProperty(ol.geom.Polygon.prototype, "setCoordinates", ol.geom.Polygon.prototype.setCoordinates);
goog.exportSymbol("ol.geom.Polygon.circular", ol.geom.Polygon.circular);
goog.exportSymbol("ol.geom.Polygon.fromExtent", ol.geom.Polygon.fromExtent);
goog.exportSymbol("ol.geom.Polygon.fromCircle", ol.geom.Polygon.fromCircle);
goog.exportSymbol("ol.geom.SimpleGeometry", ol.geom.SimpleGeometry);
goog.exportProperty(ol.geom.SimpleGeometry.prototype, "getFirstCoordinate", ol.geom.SimpleGeometry.prototype.getFirstCoordinate);
goog.exportProperty(ol.geom.SimpleGeometry.prototype, "getLastCoordinate", ol.geom.SimpleGeometry.prototype.getLastCoordinate);
goog.exportProperty(ol.geom.SimpleGeometry.prototype, "getLayout", ol.geom.SimpleGeometry.prototype.getLayout);
goog.exportProperty(ol.geom.SimpleGeometry.prototype, "applyTransform", ol.geom.SimpleGeometry.prototype.applyTransform);
goog.exportProperty(ol.geom.SimpleGeometry.prototype, "rotate", ol.geom.SimpleGeometry.prototype.rotate);
goog.exportProperty(ol.geom.SimpleGeometry.prototype, "scale", ol.geom.SimpleGeometry.prototype.scale);
goog.exportProperty(ol.geom.SimpleGeometry.prototype, "translate", ol.geom.SimpleGeometry.prototype.translate);
goog.exportSymbol("ol.format.EsriJSON", ol.format.EsriJSON);
goog.exportProperty(ol.format.EsriJSON.prototype, "readFeature", ol.format.EsriJSON.prototype.readFeature);
goog.exportProperty(ol.format.EsriJSON.prototype, "readFeatures", ol.format.EsriJSON.prototype.readFeatures);
goog.exportProperty(ol.format.EsriJSON.prototype, "readGeometry", ol.format.EsriJSON.prototype.readGeometry);
goog.exportProperty(ol.format.EsriJSON.prototype, "readProjection", ol.format.EsriJSON.prototype.readProjection);
goog.exportProperty(ol.format.EsriJSON.prototype, "writeGeometry", ol.format.EsriJSON.prototype.writeGeometry);
goog.exportProperty(ol.format.EsriJSON.prototype, "writeGeometryObject", ol.format.EsriJSON.prototype.writeGeometryObject);
goog.exportProperty(ol.format.EsriJSON.prototype, "writeFeature", ol.format.EsriJSON.prototype.writeFeature);
goog.exportProperty(ol.format.EsriJSON.prototype, "writeFeatureObject", ol.format.EsriJSON.prototype.writeFeatureObject);
goog.exportProperty(ol.format.EsriJSON.prototype, "writeFeatures", ol.format.EsriJSON.prototype.writeFeatures);
goog.exportProperty(ol.format.EsriJSON.prototype, "writeFeaturesObject", ol.format.EsriJSON.prototype.writeFeaturesObject);
goog.exportSymbol("ol.format.Feature", ol.format.Feature);
goog.exportSymbol("ol.format.filter.and", ol.format.filter.and);
goog.exportSymbol("ol.format.filter.or", ol.format.filter.or);
goog.exportSymbol("ol.format.filter.not", ol.format.filter.not);
goog.exportSymbol("ol.format.filter.bbox", ol.format.filter.bbox);
goog.exportSymbol("ol.format.filter.contains", ol.format.filter.contains);
goog.exportSymbol("ol.format.filter.intersects", ol.format.filter.intersects);
goog.exportSymbol("ol.format.filter.within", ol.format.filter.within);
goog.exportSymbol("ol.format.filter.equalTo", ol.format.filter.equalTo);
goog.exportSymbol("ol.format.filter.notEqualTo", ol.format.filter.notEqualTo);
goog.exportSymbol("ol.format.filter.lessThan", ol.format.filter.lessThan);
goog.exportSymbol("ol.format.filter.lessThanOrEqualTo", ol.format.filter.lessThanOrEqualTo);
goog.exportSymbol("ol.format.filter.greaterThan", ol.format.filter.greaterThan);
goog.exportSymbol("ol.format.filter.greaterThanOrEqualTo", ol.format.filter.greaterThanOrEqualTo);
goog.exportSymbol("ol.format.filter.isNull", ol.format.filter.isNull);
goog.exportSymbol("ol.format.filter.between", ol.format.filter.between);
goog.exportSymbol("ol.format.filter.like", ol.format.filter.like);
goog.exportSymbol("ol.format.filter.during", ol.format.filter.during);
goog.exportSymbol("ol.format.GeoJSON", ol.format.GeoJSON);
goog.exportProperty(ol.format.GeoJSON.prototype, "readFeature", ol.format.GeoJSON.prototype.readFeature);
goog.exportProperty(ol.format.GeoJSON.prototype, "readFeatures", ol.format.GeoJSON.prototype.readFeatures);
goog.exportProperty(ol.format.GeoJSON.prototype, "readGeometry", ol.format.GeoJSON.prototype.readGeometry);
goog.exportProperty(ol.format.GeoJSON.prototype, "readProjection", ol.format.GeoJSON.prototype.readProjection);
goog.exportProperty(ol.format.GeoJSON.prototype, "writeFeature", ol.format.GeoJSON.prototype.writeFeature);
goog.exportProperty(ol.format.GeoJSON.prototype, "writeFeatureObject", ol.format.GeoJSON.prototype.writeFeatureObject);
goog.exportProperty(ol.format.GeoJSON.prototype, "writeFeatures", ol.format.GeoJSON.prototype.writeFeatures);
goog.exportProperty(ol.format.GeoJSON.prototype, "writeFeaturesObject", ol.format.GeoJSON.prototype.writeFeaturesObject);
goog.exportProperty(ol.format.GeoJSON.prototype, "writeGeometry", ol.format.GeoJSON.prototype.writeGeometry);
goog.exportProperty(ol.format.GeoJSON.prototype, "writeGeometryObject", ol.format.GeoJSON.prototype.writeGeometryObject);
goog.exportSymbol("ol.format.GML", ol.format.GML);
goog.exportProperty(ol.format.GML.prototype, "writeFeatures", ol.format.GML.prototype.writeFeatures);
goog.exportProperty(ol.format.GML.prototype, "writeFeaturesNode", ol.format.GML.prototype.writeFeaturesNode);
goog.exportSymbol("ol.format.GML2", ol.format.GML2);
goog.exportSymbol("ol.format.GML3", ol.format.GML3);
goog.exportProperty(ol.format.GML3.prototype, "writeGeometryNode", ol.format.GML3.prototype.writeGeometryNode);
goog.exportProperty(ol.format.GML3.prototype, "writeFeatures", ol.format.GML3.prototype.writeFeatures);
goog.exportProperty(ol.format.GML3.prototype, "writeFeaturesNode", ol.format.GML3.prototype.writeFeaturesNode);
goog.exportProperty(ol.format.GMLBase.prototype, "readFeatures", ol.format.GMLBase.prototype.readFeatures);
goog.exportSymbol("ol.format.GPX", ol.format.GPX);
goog.exportProperty(ol.format.GPX.prototype, "readFeature", ol.format.GPX.prototype.readFeature);
goog.exportProperty(ol.format.GPX.prototype, "readFeatures", ol.format.GPX.prototype.readFeatures);
goog.exportProperty(ol.format.GPX.prototype, "readProjection", ol.format.GPX.prototype.readProjection);
goog.exportProperty(ol.format.GPX.prototype, "writeFeatures", ol.format.GPX.prototype.writeFeatures);
goog.exportProperty(ol.format.GPX.prototype, "writeFeaturesNode", ol.format.GPX.prototype.writeFeaturesNode);
goog.exportSymbol("ol.format.IGC", ol.format.IGC);
goog.exportProperty(ol.format.IGC.prototype, "readFeature", ol.format.IGC.prototype.readFeature);
goog.exportProperty(ol.format.IGC.prototype, "readFeatures", ol.format.IGC.prototype.readFeatures);
goog.exportProperty(ol.format.IGC.prototype, "readProjection", ol.format.IGC.prototype.readProjection);
goog.exportSymbol("ol.format.KML", ol.format.KML);
goog.exportProperty(ol.format.KML.prototype, "readFeature", ol.format.KML.prototype.readFeature);
goog.exportProperty(ol.format.KML.prototype, "readFeatures", ol.format.KML.prototype.readFeatures);
goog.exportProperty(ol.format.KML.prototype, "readName", ol.format.KML.prototype.readName);
goog.exportProperty(ol.format.KML.prototype, "readNetworkLinks", ol.format.KML.prototype.readNetworkLinks);
goog.exportProperty(ol.format.KML.prototype, "readRegion", ol.format.KML.prototype.readRegion);
goog.exportProperty(ol.format.KML.prototype, "readRegionFromNode", ol.format.KML.prototype.readRegionFromNode);
goog.exportProperty(ol.format.KML.prototype, "readProjection", ol.format.KML.prototype.readProjection);
goog.exportProperty(ol.format.KML.prototype, "writeFeatures", ol.format.KML.prototype.writeFeatures);
goog.exportProperty(ol.format.KML.prototype, "writeFeaturesNode", ol.format.KML.prototype.writeFeaturesNode);
goog.exportSymbol("ol.format.MVT", ol.format.MVT);
goog.exportProperty(ol.format.MVT.prototype, "getLastExtent", ol.format.MVT.prototype.getLastExtent);
goog.exportProperty(ol.format.MVT.prototype, "readFeatures", ol.format.MVT.prototype.readFeatures);
goog.exportProperty(ol.format.MVT.prototype, "readProjection", ol.format.MVT.prototype.readProjection);
goog.exportProperty(ol.format.MVT.prototype, "setLayers", ol.format.MVT.prototype.setLayers);
goog.exportSymbol("ol.format.OSMXML", ol.format.OSMXML);
goog.exportProperty(ol.format.OSMXML.prototype, "readFeatures", ol.format.OSMXML.prototype.readFeatures);
goog.exportProperty(ol.format.OSMXML.prototype, "readProjection", ol.format.OSMXML.prototype.readProjection);
goog.exportSymbol("ol.format.Polyline", ol.format.Polyline);
goog.exportSymbol("ol.format.Polyline.encodeDeltas", ol.format.Polyline.encodeDeltas);
goog.exportSymbol("ol.format.Polyline.decodeDeltas", ol.format.Polyline.decodeDeltas);
goog.exportSymbol("ol.format.Polyline.encodeFloats", ol.format.Polyline.encodeFloats);
goog.exportSymbol("ol.format.Polyline.decodeFloats", ol.format.Polyline.decodeFloats);
goog.exportProperty(ol.format.Polyline.prototype, "readFeature", ol.format.Polyline.prototype.readFeature);
goog.exportProperty(ol.format.Polyline.prototype, "readFeatures", ol.format.Polyline.prototype.readFeatures);
goog.exportProperty(ol.format.Polyline.prototype, "readGeometry", ol.format.Polyline.prototype.readGeometry);
goog.exportProperty(ol.format.Polyline.prototype, "readProjection", ol.format.Polyline.prototype.readProjection);
goog.exportProperty(ol.format.Polyline.prototype, "writeGeometry", ol.format.Polyline.prototype.writeGeometry);
goog.exportSymbol("ol.format.TopoJSON", ol.format.TopoJSON);
goog.exportProperty(ol.format.TopoJSON.prototype, "readFeatures", ol.format.TopoJSON.prototype.readFeatures);
goog.exportProperty(ol.format.TopoJSON.prototype, "readProjection", ol.format.TopoJSON.prototype.readProjection);
goog.exportSymbol("ol.format.WFS", ol.format.WFS);
goog.exportProperty(ol.format.WFS.prototype, "readFeatures", ol.format.WFS.prototype.readFeatures);
goog.exportProperty(ol.format.WFS.prototype, "readTransactionResponse", ol.format.WFS.prototype.readTransactionResponse);
goog.exportProperty(ol.format.WFS.prototype, "readFeatureCollectionMetadata", ol.format.WFS.prototype.readFeatureCollectionMetadata);
goog.exportSymbol("ol.format.WFS.writeFilter", ol.format.WFS.writeFilter);
goog.exportProperty(ol.format.WFS.prototype, "writeGetFeature", ol.format.WFS.prototype.writeGetFeature);
goog.exportProperty(ol.format.WFS.prototype, "writeTransaction", ol.format.WFS.prototype.writeTransaction);
goog.exportProperty(ol.format.WFS.prototype, "readProjection", ol.format.WFS.prototype.readProjection);
goog.exportSymbol("ol.format.WKT", ol.format.WKT);
goog.exportProperty(ol.format.WKT.prototype, "readFeature", ol.format.WKT.prototype.readFeature);
goog.exportProperty(ol.format.WKT.prototype, "readFeatures", ol.format.WKT.prototype.readFeatures);
goog.exportProperty(ol.format.WKT.prototype, "readGeometry", ol.format.WKT.prototype.readGeometry);
goog.exportProperty(ol.format.WKT.prototype, "writeFeature", ol.format.WKT.prototype.writeFeature);
goog.exportProperty(ol.format.WKT.prototype, "writeFeatures", ol.format.WKT.prototype.writeFeatures);
goog.exportProperty(ol.format.WKT.prototype, "writeGeometry", ol.format.WKT.prototype.writeGeometry);
goog.exportSymbol("ol.format.WMSCapabilities", ol.format.WMSCapabilities);
goog.exportProperty(ol.format.WMSCapabilities.prototype, "read", ol.format.WMSCapabilities.prototype.read);
goog.exportSymbol("ol.format.WMSGetFeatureInfo", ol.format.WMSGetFeatureInfo);
goog.exportProperty(ol.format.WMSGetFeatureInfo.prototype, "readFeatures", ol.format.WMSGetFeatureInfo.prototype.readFeatures);
goog.exportSymbol("ol.format.WMTSCapabilities", ol.format.WMTSCapabilities);
goog.exportProperty(ol.format.WMTSCapabilities.prototype, "read", ol.format.WMTSCapabilities.prototype.read);
goog.exportSymbol("ol.format.filter.And", ol.format.filter.And);
goog.exportSymbol("ol.format.filter.Bbox", ol.format.filter.Bbox);
goog.exportSymbol("ol.format.filter.Comparison", ol.format.filter.Comparison);
goog.exportSymbol("ol.format.filter.ComparisonBinary", ol.format.filter.ComparisonBinary);
goog.exportSymbol("ol.format.filter.Contains", ol.format.filter.Contains);
goog.exportSymbol("ol.format.filter.During", ol.format.filter.During);
goog.exportSymbol("ol.format.filter.EqualTo", ol.format.filter.EqualTo);
goog.exportSymbol("ol.format.filter.Filter", ol.format.filter.Filter);
goog.exportSymbol("ol.format.filter.GreaterThan", ol.format.filter.GreaterThan);
goog.exportSymbol("ol.format.filter.GreaterThanOrEqualTo", ol.format.filter.GreaterThanOrEqualTo);
goog.exportSymbol("ol.format.filter.Intersects", ol.format.filter.Intersects);
goog.exportSymbol("ol.format.filter.IsBetween", ol.format.filter.IsBetween);
goog.exportSymbol("ol.format.filter.IsLike", ol.format.filter.IsLike);
goog.exportSymbol("ol.format.filter.IsNull", ol.format.filter.IsNull);
goog.exportSymbol("ol.format.filter.LessThan", ol.format.filter.LessThan);
goog.exportSymbol("ol.format.filter.LessThanOrEqualTo", ol.format.filter.LessThanOrEqualTo);
goog.exportSymbol("ol.format.filter.Not", ol.format.filter.Not);
goog.exportSymbol("ol.format.filter.NotEqualTo", ol.format.filter.NotEqualTo);
goog.exportSymbol("ol.format.filter.Or", ol.format.filter.Or);
goog.exportSymbol("ol.format.filter.Spatial", ol.format.filter.Spatial);
goog.exportSymbol("ol.format.filter.Within", ol.format.filter.Within);
goog.exportSymbol("ol.events.condition.altKeyOnly", ol.events.condition.altKeyOnly);
goog.exportSymbol("ol.events.condition.altShiftKeysOnly", ol.events.condition.altShiftKeysOnly);
goog.exportSymbol("ol.events.condition.always", ol.events.condition.always);
goog.exportSymbol("ol.events.condition.click", ol.events.condition.click);
goog.exportSymbol("ol.events.condition.never", ol.events.condition.never);
goog.exportSymbol("ol.events.condition.pointerMove", ol.events.condition.pointerMove);
goog.exportSymbol("ol.events.condition.singleClick", ol.events.condition.singleClick);
goog.exportSymbol("ol.events.condition.doubleClick", ol.events.condition.doubleClick);
goog.exportSymbol("ol.events.condition.noModifierKeys", ol.events.condition.noModifierKeys);
goog.exportSymbol("ol.events.condition.platformModifierKeyOnly", ol.events.condition.platformModifierKeyOnly);
goog.exportSymbol("ol.events.condition.shiftKeyOnly", ol.events.condition.shiftKeyOnly);
goog.exportSymbol("ol.events.condition.targetNotEditable", ol.events.condition.targetNotEditable);
goog.exportSymbol("ol.events.condition.mouseOnly", ol.events.condition.mouseOnly);
goog.exportSymbol("ol.events.condition.primaryAction", ol.events.condition.primaryAction);
goog.exportProperty(ol.events.Event.prototype, "type", ol.events.Event.prototype.type);
goog.exportProperty(ol.events.Event.prototype, "target", ol.events.Event.prototype.target);
goog.exportProperty(ol.events.Event.prototype, "preventDefault", ol.events.Event.prototype.preventDefault);
goog.exportProperty(ol.events.Event.prototype, "stopPropagation", ol.events.Event.prototype.stopPropagation);
goog.exportSymbol("ol.control.Attribution", ol.control.Attribution);
goog.exportSymbol("ol.control.Attribution.render", ol.control.Attribution.render);
goog.exportProperty(ol.control.Attribution.prototype, "getCollapsible", ol.control.Attribution.prototype.getCollapsible);
goog.exportProperty(ol.control.Attribution.prototype, "setCollapsible", ol.control.Attribution.prototype.setCollapsible);
goog.exportProperty(ol.control.Attribution.prototype, "setCollapsed", ol.control.Attribution.prototype.setCollapsed);
goog.exportProperty(ol.control.Attribution.prototype, "getCollapsed", ol.control.Attribution.prototype.getCollapsed);
goog.exportSymbol("ol.control.Control", ol.control.Control);
goog.exportProperty(ol.control.Control.prototype, "getMap", ol.control.Control.prototype.getMap);
goog.exportProperty(ol.control.Control.prototype, "setMap", ol.control.Control.prototype.setMap);
goog.exportProperty(ol.control.Control.prototype, "setTarget", ol.control.Control.prototype.setTarget);
goog.exportSymbol("ol.control.FullScreen", ol.control.FullScreen);
goog.exportProperty(ol.control.FullScreen.prototype, "setMap", ol.control.FullScreen.prototype.setMap);
goog.exportSymbol("ol.control.MousePosition", ol.control.MousePosition);
goog.exportSymbol("ol.control.MousePosition.render", ol.control.MousePosition.render);
goog.exportProperty(ol.control.MousePosition.prototype, "getCoordinateFormat", ol.control.MousePosition.prototype.getCoordinateFormat);
goog.exportProperty(ol.control.MousePosition.prototype, "getProjection", ol.control.MousePosition.prototype.getProjection);
goog.exportProperty(ol.control.MousePosition.prototype, "setMap", ol.control.MousePosition.prototype.setMap);
goog.exportProperty(ol.control.MousePosition.prototype, "setCoordinateFormat", ol.control.MousePosition.prototype.setCoordinateFormat);
goog.exportProperty(ol.control.MousePosition.prototype, "setProjection", ol.control.MousePosition.prototype.setProjection);
goog.exportSymbol("ol.control.OverviewMap", ol.control.OverviewMap);
goog.exportProperty(ol.control.OverviewMap.prototype, "setMap", ol.control.OverviewMap.prototype.setMap);
goog.exportSymbol("ol.control.OverviewMap.render", ol.control.OverviewMap.render);
goog.exportProperty(ol.control.OverviewMap.prototype, "getCollapsible", ol.control.OverviewMap.prototype.getCollapsible);
goog.exportProperty(ol.control.OverviewMap.prototype, "setCollapsible", ol.control.OverviewMap.prototype.setCollapsible);
goog.exportProperty(ol.control.OverviewMap.prototype, "setCollapsed", ol.control.OverviewMap.prototype.setCollapsed);
goog.exportProperty(ol.control.OverviewMap.prototype, "getCollapsed", ol.control.OverviewMap.prototype.getCollapsed);
goog.exportProperty(ol.control.OverviewMap.prototype, "getOverviewMap", ol.control.OverviewMap.prototype.getOverviewMap);
goog.exportSymbol("ol.control.Rotate", ol.control.Rotate);
goog.exportSymbol("ol.control.Rotate.render", ol.control.Rotate.render);
goog.exportSymbol("ol.control.ScaleLine", ol.control.ScaleLine);
goog.exportProperty(ol.control.ScaleLine.prototype, "getUnits", ol.control.ScaleLine.prototype.getUnits);
goog.exportSymbol("ol.control.ScaleLine.render", ol.control.ScaleLine.render);
goog.exportProperty(ol.control.ScaleLine.prototype, "setUnits", ol.control.ScaleLine.prototype.setUnits);
goog.exportSymbol("ol.control.Zoom", ol.control.Zoom);
goog.exportSymbol("ol.control.ZoomSlider", ol.control.ZoomSlider);
goog.exportSymbol("ol.control.ZoomSlider.render", ol.control.ZoomSlider.render);
goog.exportSymbol("ol.control.ZoomToExtent", ol.control.ZoomToExtent);
goog.exportSymbol("olcs.AbstractSynchronizer", olcs.AbstractSynchronizer);
goog.exportProperty(olcs.AbstractSynchronizer.prototype, "synchronize", olcs.AbstractSynchronizer.prototype.synchronize);
goog.exportProperty(olcs.AutoRenderLoop.prototype, "restartRenderLoop", olcs.AutoRenderLoop.prototype.restartRenderLoop);
goog.exportProperty(olcs.AutoRenderLoop.prototype, "setDebug", olcs.AutoRenderLoop.prototype.setDebug);
goog.exportSymbol("olcs.Camera", olcs.Camera);
goog.exportProperty(olcs.Camera.prototype, "setHeading", olcs.Camera.prototype.setHeading);
goog.exportProperty(olcs.Camera.prototype, "getHeading", olcs.Camera.prototype.getHeading);
goog.exportProperty(olcs.Camera.prototype, "setTilt", olcs.Camera.prototype.setTilt);
goog.exportProperty(olcs.Camera.prototype, "getTilt", olcs.Camera.prototype.getTilt);
goog.exportProperty(olcs.Camera.prototype, "setDistance", olcs.Camera.prototype.setDistance);
goog.exportProperty(olcs.Camera.prototype, "getDistance", olcs.Camera.prototype.getDistance);
goog.exportProperty(olcs.Camera.prototype, "setCenter", olcs.Camera.prototype.setCenter);
goog.exportProperty(olcs.Camera.prototype, "getCenter", olcs.Camera.prototype.getCenter);
goog.exportProperty(olcs.Camera.prototype, "setPosition", olcs.Camera.prototype.setPosition);
goog.exportProperty(olcs.Camera.prototype, "getPosition", olcs.Camera.prototype.getPosition);
goog.exportProperty(olcs.Camera.prototype, "setAltitude", olcs.Camera.prototype.setAltitude);
goog.exportProperty(olcs.Camera.prototype, "getAltitude", olcs.Camera.prototype.getAltitude);
goog.exportProperty(olcs.Camera.prototype, "lookAt", olcs.Camera.prototype.lookAt);
goog.exportProperty(olcs.Camera.prototype, "readFromView", olcs.Camera.prototype.readFromView);
goog.exportProperty(olcs.Camera.prototype, "updateView", olcs.Camera.prototype.updateView);
goog.exportProperty(olcs.Camera.prototype, "calcDistanceForResolution", olcs.Camera.prototype.calcDistanceForResolution);
goog.exportProperty(olcs.Camera.prototype, "calcResolutionForDistance", olcs.Camera.prototype.calcResolutionForDistance);
goog.exportSymbol("olcs.core.computePixelSizeAtCoordinate", olcs.core.computePixelSizeAtCoordinate);
goog.exportSymbol("olcs.core.applyHeightOffsetToGeometry", olcs.core.applyHeightOffsetToGeometry);
goog.exportSymbol("olcs.core.createMatrixAtCoordinates", olcs.core.createMatrixAtCoordinates);
goog.exportSymbol("olcs.core.rotateAroundAxis", olcs.core.rotateAroundAxis);
goog.exportSymbol("olcs.core.setHeadingUsingBottomCenter", olcs.core.setHeadingUsingBottomCenter);
goog.exportSymbol("olcs.core.pickOnTerrainOrEllipsoid", olcs.core.pickOnTerrainOrEllipsoid);
goog.exportSymbol("olcs.core.pickBottomPoint", olcs.core.pickBottomPoint);
goog.exportSymbol("olcs.core.pickCenterPoint", olcs.core.pickCenterPoint);
goog.exportSymbol("olcs.core.computeSignedTiltAngleOnGlobe", olcs.core.computeSignedTiltAngleOnGlobe);
goog.exportSymbol("olcs.core.computeAngleToZenith", olcs.core.computeAngleToZenith);
goog.exportSymbol("olcs.core.lookAt", olcs.core.lookAt);
goog.exportSymbol("olcs.core.extentToRectangle", olcs.core.extentToRectangle);
goog.exportSymbol("olcs.core.tileLayerToImageryLayer", olcs.core.tileLayerToImageryLayer);
goog.exportSymbol("olcs.core.updateCesiumLayerProperties", olcs.core.updateCesiumLayerProperties);
goog.exportSymbol("olcs.core.ol4326CoordinateToCesiumCartesian", olcs.core.ol4326CoordinateToCesiumCartesian);
goog.exportSymbol("olcs.core.ol4326CoordinateArrayToCsCartesians", olcs.core.ol4326CoordinateArrayToCsCartesians);
goog.exportSymbol("olcs.core.olGeometryCloneTo4326", olcs.core.olGeometryCloneTo4326);
goog.exportSymbol("olcs.core.convertColorToCesium", olcs.core.convertColorToCesium);
goog.exportSymbol("olcs.core.convertUrlToCesium", olcs.core.convertUrlToCesium);
goog.exportSymbol("olcs.core.resetToNorthZenith", olcs.core.resetToNorthZenith);
goog.exportSymbol("olcs.core.rotateAroundBottomCenter", olcs.core.rotateAroundBottomCenter);
goog.exportSymbol("olcs.core.normalizeView", olcs.core.normalizeView);
goog.exportSymbol("olcs.FeatureConverter", olcs.FeatureConverter);
goog.exportProperty(olcs.FeatureConverter.prototype, "csAddBillboard", olcs.FeatureConverter.prototype.csAddBillboard);
goog.exportProperty(olcs.FeatureConverter.prototype, "olCircleGeometryToCesium", olcs.FeatureConverter.prototype.olCircleGeometryToCesium);
goog.exportProperty(olcs.FeatureConverter.prototype, "olLineStringGeometryToCesium", olcs.FeatureConverter.prototype.olLineStringGeometryToCesium);
goog.exportProperty(olcs.FeatureConverter.prototype, "olPolygonGeometryToCesium", olcs.FeatureConverter.prototype.olPolygonGeometryToCesium);
goog.exportProperty(olcs.FeatureConverter.prototype, "getHeightReference", olcs.FeatureConverter.prototype.getHeightReference);
goog.exportProperty(olcs.FeatureConverter.prototype, "createBillboardFromImage", olcs.FeatureConverter.prototype.createBillboardFromImage);
goog.exportProperty(olcs.FeatureConverter.prototype, "olPointGeometryToCesium", olcs.FeatureConverter.prototype.olPointGeometryToCesium);
goog.exportProperty(olcs.FeatureConverter.prototype, "olMultiGeometryToCesium", olcs.FeatureConverter.prototype.olMultiGeometryToCesium);
goog.exportProperty(olcs.FeatureConverter.prototype, "olGeometry4326TextPartToCesium", olcs.FeatureConverter.prototype.olGeometry4326TextPartToCesium);
goog.exportProperty(olcs.FeatureConverter.prototype, "olStyleToCesium", olcs.FeatureConverter.prototype.olStyleToCesium);
goog.exportProperty(olcs.FeatureConverter.prototype, "computePlainStyle", olcs.FeatureConverter.prototype.computePlainStyle);
goog.exportProperty(olcs.FeatureConverter.prototype, "olFeatureToCesium", olcs.FeatureConverter.prototype.olFeatureToCesium);
goog.exportProperty(olcs.FeatureConverter.prototype, "olVectorLayerToCesium", olcs.FeatureConverter.prototype.olVectorLayerToCesium);
goog.exportProperty(olcs.FeatureConverter.prototype, "convert", olcs.FeatureConverter.prototype.convert);
goog.exportSymbol("olcs.OLCesium", olcs.OLCesium);
goog.exportProperty(olcs.OLCesium.prototype, "getCamera", olcs.OLCesium.prototype.getCamera);
goog.exportProperty(olcs.OLCesium.prototype, "getOlMap", olcs.OLCesium.prototype.getOlMap);
goog.exportProperty(olcs.OLCesium.prototype, "getOlView", olcs.OLCesium.prototype.getOlView);
goog.exportProperty(olcs.OLCesium.prototype, "getCesiumScene", olcs.OLCesium.prototype.getCesiumScene);
goog.exportProperty(olcs.OLCesium.prototype, "getDataSources", olcs.OLCesium.prototype.getDataSources);
goog.exportProperty(olcs.OLCesium.prototype, "getDataSourceDisplay", olcs.OLCesium.prototype.getDataSourceDisplay);
goog.exportProperty(olcs.OLCesium.prototype, "getEnabled", olcs.OLCesium.prototype.getEnabled);
goog.exportProperty(olcs.OLCesium.prototype, "setEnabled", olcs.OLCesium.prototype.setEnabled);
goog.exportProperty(olcs.OLCesium.prototype, "warmUp", olcs.OLCesium.prototype.warmUp);
goog.exportProperty(olcs.OLCesium.prototype, "setBlockCesiumRendering", olcs.OLCesium.prototype.setBlockCesiumRendering);
goog.exportProperty(olcs.OLCesium.prototype, "enableAutoRenderLoop", olcs.OLCesium.prototype.enableAutoRenderLoop);
goog.exportProperty(olcs.OLCesium.prototype, "getAutoRenderLoop", olcs.OLCesium.prototype.getAutoRenderLoop);
goog.exportProperty(olcs.OLCesium.prototype, "setResolutionScale", olcs.OLCesium.prototype.setResolutionScale);
goog.exportProperty(olcs.OLCesium.prototype, "setTargetFrameRate", olcs.OLCesium.prototype.setTargetFrameRate);
goog.exportSymbol("olcs.OverlaySynchronizer", olcs.OverlaySynchronizer);
goog.exportProperty(olcs.OverlaySynchronizer.prototype, "synchronize", olcs.OverlaySynchronizer.prototype.synchronize);
goog.exportProperty(olcs.OverlaySynchronizer.prototype, "addOverlays", olcs.OverlaySynchronizer.prototype.addOverlays);
goog.exportProperty(olcs.OverlaySynchronizer.prototype, "addOverlay", olcs.OverlaySynchronizer.prototype.addOverlay);
goog.exportProperty(olcs.OverlaySynchronizer.prototype, "removeOverlay", olcs.OverlaySynchronizer.prototype.removeOverlay);
goog.exportSymbol("olcs.RasterSynchronizer", olcs.RasterSynchronizer);
goog.exportSymbol("olcs.SynchronizedOverlay", olcs.SynchronizedOverlay);
goog.exportProperty(olcs.SynchronizedOverlay.prototype, "getScene", olcs.SynchronizedOverlay.prototype.getScene);
goog.exportProperty(olcs.SynchronizedOverlay.prototype, "destroy", olcs.SynchronizedOverlay.prototype.destroy);
goog.exportSymbol("olcs.VectorSynchronizer", olcs.VectorSynchronizer);
goog.exportSymbol("olcs.GaKmlSynchronizer", olcs.GaKmlSynchronizer);
goog.exportSymbol("olcs.GaRasterSynchronizer", olcs.GaRasterSynchronizer);
goog.exportSymbol("olcs.GaTileset3dSynchronizer", olcs.GaTileset3dSynchronizer);
goog.exportSymbol("olcs.GaVectorSynchronizer", olcs.GaVectorSynchronizer);
goog.exportSymbol("olcs.contrib.LazyLoader", olcs.contrib.LazyLoader);
goog.exportProperty(olcs.contrib.LazyLoader.prototype, "load", olcs.contrib.LazyLoader.prototype.load);
goog.exportSymbol("olcs.contrib.Manager", olcs.contrib.Manager);
goog.exportProperty(ol.Object.prototype, "changed", ol.Object.prototype.changed);
goog.exportProperty(ol.Object.prototype, "dispatchEvent", ol.Object.prototype.dispatchEvent);
goog.exportProperty(ol.Object.prototype, "getRevision", ol.Object.prototype.getRevision);
goog.exportProperty(ol.Object.prototype, "on", ol.Object.prototype.on);
goog.exportProperty(ol.Object.prototype, "once", ol.Object.prototype.once);
goog.exportProperty(ol.Object.prototype, "un", ol.Object.prototype.un);
goog.exportProperty(ol.PluggableMap.prototype, "get", ol.PluggableMap.prototype.get);
goog.exportProperty(ol.PluggableMap.prototype, "getKeys", ol.PluggableMap.prototype.getKeys);
goog.exportProperty(ol.PluggableMap.prototype, "getProperties", ol.PluggableMap.prototype.getProperties);
goog.exportProperty(ol.PluggableMap.prototype, "set", ol.PluggableMap.prototype.set);
goog.exportProperty(ol.PluggableMap.prototype, "setProperties", ol.PluggableMap.prototype.setProperties);
goog.exportProperty(ol.PluggableMap.prototype, "unset", ol.PluggableMap.prototype.unset);
goog.exportProperty(ol.PluggableMap.prototype, "changed", ol.PluggableMap.prototype.changed);
goog.exportProperty(ol.PluggableMap.prototype, "dispatchEvent", ol.PluggableMap.prototype.dispatchEvent);
goog.exportProperty(ol.PluggableMap.prototype, "getRevision", ol.PluggableMap.prototype.getRevision);
goog.exportProperty(ol.PluggableMap.prototype, "on", ol.PluggableMap.prototype.on);
goog.exportProperty(ol.PluggableMap.prototype, "once", ol.PluggableMap.prototype.once);
goog.exportProperty(ol.PluggableMap.prototype, "un", ol.PluggableMap.prototype.un);
goog.exportProperty(ol.CanvasMap.prototype, "addControl", ol.CanvasMap.prototype.addControl);
goog.exportProperty(ol.CanvasMap.prototype, "addInteraction", ol.CanvasMap.prototype.addInteraction);
goog.exportProperty(ol.CanvasMap.prototype, "addLayer", ol.CanvasMap.prototype.addLayer);
goog.exportProperty(ol.CanvasMap.prototype, "addOverlay", ol.CanvasMap.prototype.addOverlay);
goog.exportProperty(ol.CanvasMap.prototype, "forEachFeatureAtPixel", ol.CanvasMap.prototype.forEachFeatureAtPixel);
goog.exportProperty(ol.CanvasMap.prototype, "getFeaturesAtPixel", ol.CanvasMap.prototype.getFeaturesAtPixel);
goog.exportProperty(ol.CanvasMap.prototype, "forEachLayerAtPixel", ol.CanvasMap.prototype.forEachLayerAtPixel);
goog.exportProperty(ol.CanvasMap.prototype, "hasFeatureAtPixel", ol.CanvasMap.prototype.hasFeatureAtPixel);
goog.exportProperty(ol.CanvasMap.prototype, "getEventCoordinate", ol.CanvasMap.prototype.getEventCoordinate);
goog.exportProperty(ol.CanvasMap.prototype, "getEventPixel", ol.CanvasMap.prototype.getEventPixel);
goog.exportProperty(ol.CanvasMap.prototype, "getTarget", ol.CanvasMap.prototype.getTarget);
goog.exportProperty(ol.CanvasMap.prototype, "getTargetElement", ol.CanvasMap.prototype.getTargetElement);
goog.exportProperty(ol.CanvasMap.prototype, "getCoordinateFromPixel", ol.CanvasMap.prototype.getCoordinateFromPixel);
goog.exportProperty(ol.CanvasMap.prototype, "getControls", ol.CanvasMap.prototype.getControls);
goog.exportProperty(ol.CanvasMap.prototype, "getOverlays", ol.CanvasMap.prototype.getOverlays);
goog.exportProperty(ol.CanvasMap.prototype, "getOverlayById", ol.CanvasMap.prototype.getOverlayById);
goog.exportProperty(ol.CanvasMap.prototype, "getInteractions", ol.CanvasMap.prototype.getInteractions);
goog.exportProperty(ol.CanvasMap.prototype, "getLayerGroup", ol.CanvasMap.prototype.getLayerGroup);
goog.exportProperty(ol.CanvasMap.prototype, "getLayers", ol.CanvasMap.prototype.getLayers);
goog.exportProperty(ol.CanvasMap.prototype, "getPixelFromCoordinate", ol.CanvasMap.prototype.getPixelFromCoordinate);
goog.exportProperty(ol.CanvasMap.prototype, "getSize", ol.CanvasMap.prototype.getSize);
goog.exportProperty(ol.CanvasMap.prototype, "getView", ol.CanvasMap.prototype.getView);
goog.exportProperty(ol.CanvasMap.prototype, "getViewport", ol.CanvasMap.prototype.getViewport);
goog.exportProperty(ol.CanvasMap.prototype, "renderSync", ol.CanvasMap.prototype.renderSync);
goog.exportProperty(ol.CanvasMap.prototype, "render", ol.CanvasMap.prototype.render);
goog.exportProperty(ol.CanvasMap.prototype, "removeControl", ol.CanvasMap.prototype.removeControl);
goog.exportProperty(ol.CanvasMap.prototype, "removeInteraction", ol.CanvasMap.prototype.removeInteraction);
goog.exportProperty(ol.CanvasMap.prototype, "removeLayer", ol.CanvasMap.prototype.removeLayer);
goog.exportProperty(ol.CanvasMap.prototype, "removeOverlay", ol.CanvasMap.prototype.removeOverlay);
goog.exportProperty(ol.CanvasMap.prototype, "setLayerGroup", ol.CanvasMap.prototype.setLayerGroup);
goog.exportProperty(ol.CanvasMap.prototype, "setSize", ol.CanvasMap.prototype.setSize);
goog.exportProperty(ol.CanvasMap.prototype, "setTarget", ol.CanvasMap.prototype.setTarget);
goog.exportProperty(ol.CanvasMap.prototype, "setView", ol.CanvasMap.prototype.setView);
goog.exportProperty(ol.CanvasMap.prototype, "updateSize", ol.CanvasMap.prototype.updateSize);
goog.exportProperty(ol.CanvasMap.prototype, "get", ol.CanvasMap.prototype.get);
goog.exportProperty(ol.CanvasMap.prototype, "getKeys", ol.CanvasMap.prototype.getKeys);
goog.exportProperty(ol.CanvasMap.prototype, "getProperties", ol.CanvasMap.prototype.getProperties);
goog.exportProperty(ol.CanvasMap.prototype, "set", ol.CanvasMap.prototype.set);
goog.exportProperty(ol.CanvasMap.prototype, "setProperties", ol.CanvasMap.prototype.setProperties);
goog.exportProperty(ol.CanvasMap.prototype, "unset", ol.CanvasMap.prototype.unset);
goog.exportProperty(ol.CanvasMap.prototype, "changed", ol.CanvasMap.prototype.changed);
goog.exportProperty(ol.CanvasMap.prototype, "dispatchEvent", ol.CanvasMap.prototype.dispatchEvent);
goog.exportProperty(ol.CanvasMap.prototype, "getRevision", ol.CanvasMap.prototype.getRevision);
goog.exportProperty(ol.CanvasMap.prototype, "on", ol.CanvasMap.prototype.on);
goog.exportProperty(ol.CanvasMap.prototype, "once", ol.CanvasMap.prototype.once);
goog.exportProperty(ol.CanvasMap.prototype, "un", ol.CanvasMap.prototype.un);
goog.exportProperty(ol.Collection.prototype, "get", ol.Collection.prototype.get);
goog.exportProperty(ol.Collection.prototype, "getKeys", ol.Collection.prototype.getKeys);
goog.exportProperty(ol.Collection.prototype, "getProperties", ol.Collection.prototype.getProperties);
goog.exportProperty(ol.Collection.prototype, "set", ol.Collection.prototype.set);
goog.exportProperty(ol.Collection.prototype, "setProperties", ol.Collection.prototype.setProperties);
goog.exportProperty(ol.Collection.prototype, "unset", ol.Collection.prototype.unset);
goog.exportProperty(ol.Collection.prototype, "changed", ol.Collection.prototype.changed);
goog.exportProperty(ol.Collection.prototype, "dispatchEvent", ol.Collection.prototype.dispatchEvent);
goog.exportProperty(ol.Collection.prototype, "getRevision", ol.Collection.prototype.getRevision);
goog.exportProperty(ol.Collection.prototype, "on", ol.Collection.prototype.on);
goog.exportProperty(ol.Collection.prototype, "once", ol.Collection.prototype.once);
goog.exportProperty(ol.Collection.prototype, "un", ol.Collection.prototype.un);
goog.exportProperty(ol.Collection.Event.prototype, "type", ol.Collection.Event.prototype.type);
goog.exportProperty(ol.Collection.Event.prototype, "target", ol.Collection.Event.prototype.target);
goog.exportProperty(ol.Collection.Event.prototype, "preventDefault", ol.Collection.Event.prototype.preventDefault);
goog.exportProperty(ol.Collection.Event.prototype, "stopPropagation", ol.Collection.Event.prototype.stopPropagation);
goog.exportProperty(ol.DeviceOrientation.prototype, "get", ol.DeviceOrientation.prototype.get);
goog.exportProperty(ol.DeviceOrientation.prototype, "getKeys", ol.DeviceOrientation.prototype.getKeys);
goog.exportProperty(ol.DeviceOrientation.prototype, "getProperties", ol.DeviceOrientation.prototype.getProperties);
goog.exportProperty(ol.DeviceOrientation.prototype, "set", ol.DeviceOrientation.prototype.set);
goog.exportProperty(ol.DeviceOrientation.prototype, "setProperties", ol.DeviceOrientation.prototype.setProperties);
goog.exportProperty(ol.DeviceOrientation.prototype, "unset", ol.DeviceOrientation.prototype.unset);
goog.exportProperty(ol.DeviceOrientation.prototype, "changed", ol.DeviceOrientation.prototype.changed);
goog.exportProperty(ol.DeviceOrientation.prototype, "dispatchEvent", ol.DeviceOrientation.prototype.dispatchEvent);
goog.exportProperty(ol.DeviceOrientation.prototype, "getRevision", ol.DeviceOrientation.prototype.getRevision);
goog.exportProperty(ol.DeviceOrientation.prototype, "on", ol.DeviceOrientation.prototype.on);
goog.exportProperty(ol.DeviceOrientation.prototype, "once", ol.DeviceOrientation.prototype.once);
goog.exportProperty(ol.DeviceOrientation.prototype, "un", ol.DeviceOrientation.prototype.un);
goog.exportProperty(ol.Feature.prototype, "get", ol.Feature.prototype.get);
goog.exportProperty(ol.Feature.prototype, "getKeys", ol.Feature.prototype.getKeys);
goog.exportProperty(ol.Feature.prototype, "getProperties", ol.Feature.prototype.getProperties);
goog.exportProperty(ol.Feature.prototype, "set", ol.Feature.prototype.set);
goog.exportProperty(ol.Feature.prototype, "setProperties", ol.Feature.prototype.setProperties);
goog.exportProperty(ol.Feature.prototype, "unset", ol.Feature.prototype.unset);
goog.exportProperty(ol.Feature.prototype, "changed", ol.Feature.prototype.changed);
goog.exportProperty(ol.Feature.prototype, "dispatchEvent", ol.Feature.prototype.dispatchEvent);
goog.exportProperty(ol.Feature.prototype, "getRevision", ol.Feature.prototype.getRevision);
goog.exportProperty(ol.Feature.prototype, "on", ol.Feature.prototype.on);
goog.exportProperty(ol.Feature.prototype, "once", ol.Feature.prototype.once);
goog.exportProperty(ol.Feature.prototype, "un", ol.Feature.prototype.un);
goog.exportProperty(ol.Geolocation.prototype, "get", ol.Geolocation.prototype.get);
goog.exportProperty(ol.Geolocation.prototype, "getKeys", ol.Geolocation.prototype.getKeys);
goog.exportProperty(ol.Geolocation.prototype, "getProperties", ol.Geolocation.prototype.getProperties);
goog.exportProperty(ol.Geolocation.prototype, "set", ol.Geolocation.prototype.set);
goog.exportProperty(ol.Geolocation.prototype, "setProperties", ol.Geolocation.prototype.setProperties);
goog.exportProperty(ol.Geolocation.prototype, "unset", ol.Geolocation.prototype.unset);
goog.exportProperty(ol.Geolocation.prototype, "changed", ol.Geolocation.prototype.changed);
goog.exportProperty(ol.Geolocation.prototype, "dispatchEvent", ol.Geolocation.prototype.dispatchEvent);
goog.exportProperty(ol.Geolocation.prototype, "getRevision", ol.Geolocation.prototype.getRevision);
goog.exportProperty(ol.Geolocation.prototype, "on", ol.Geolocation.prototype.on);
goog.exportProperty(ol.Geolocation.prototype, "once", ol.Geolocation.prototype.once);
goog.exportProperty(ol.Geolocation.prototype, "un", ol.Geolocation.prototype.un);
goog.exportProperty(ol.ImageTile.prototype, "getTileCoord", ol.ImageTile.prototype.getTileCoord);
goog.exportProperty(ol.ImageTile.prototype, "load", ol.ImageTile.prototype.load);
goog.exportProperty(ol.Map.prototype, "addControl", ol.Map.prototype.addControl);
goog.exportProperty(ol.Map.prototype, "addInteraction", ol.Map.prototype.addInteraction);
goog.exportProperty(ol.Map.prototype, "addLayer", ol.Map.prototype.addLayer);
goog.exportProperty(ol.Map.prototype, "addOverlay", ol.Map.prototype.addOverlay);
goog.exportProperty(ol.Map.prototype, "forEachFeatureAtPixel", ol.Map.prototype.forEachFeatureAtPixel);
goog.exportProperty(ol.Map.prototype, "getFeaturesAtPixel", ol.Map.prototype.getFeaturesAtPixel);
goog.exportProperty(ol.Map.prototype, "forEachLayerAtPixel", ol.Map.prototype.forEachLayerAtPixel);
goog.exportProperty(ol.Map.prototype, "hasFeatureAtPixel", ol.Map.prototype.hasFeatureAtPixel);
goog.exportProperty(ol.Map.prototype, "getEventCoordinate", ol.Map.prototype.getEventCoordinate);
goog.exportProperty(ol.Map.prototype, "getEventPixel", ol.Map.prototype.getEventPixel);
goog.exportProperty(ol.Map.prototype, "getTarget", ol.Map.prototype.getTarget);
goog.exportProperty(ol.Map.prototype, "getTargetElement", ol.Map.prototype.getTargetElement);
goog.exportProperty(ol.Map.prototype, "getCoordinateFromPixel", ol.Map.prototype.getCoordinateFromPixel);
goog.exportProperty(ol.Map.prototype, "getControls", ol.Map.prototype.getControls);
goog.exportProperty(ol.Map.prototype, "getOverlays", ol.Map.prototype.getOverlays);
goog.exportProperty(ol.Map.prototype, "getOverlayById", ol.Map.prototype.getOverlayById);
goog.exportProperty(ol.Map.prototype, "getInteractions", ol.Map.prototype.getInteractions);
goog.exportProperty(ol.Map.prototype, "getLayerGroup", ol.Map.prototype.getLayerGroup);
goog.exportProperty(ol.Map.prototype, "getLayers", ol.Map.prototype.getLayers);
goog.exportProperty(ol.Map.prototype, "getPixelFromCoordinate", ol.Map.prototype.getPixelFromCoordinate);
goog.exportProperty(ol.Map.prototype, "getSize", ol.Map.prototype.getSize);
goog.exportProperty(ol.Map.prototype, "getView", ol.Map.prototype.getView);
goog.exportProperty(ol.Map.prototype, "getViewport", ol.Map.prototype.getViewport);
goog.exportProperty(ol.Map.prototype, "renderSync", ol.Map.prototype.renderSync);
goog.exportProperty(ol.Map.prototype, "render", ol.Map.prototype.render);
goog.exportProperty(ol.Map.prototype, "removeControl", ol.Map.prototype.removeControl);
goog.exportProperty(ol.Map.prototype, "removeInteraction", ol.Map.prototype.removeInteraction);
goog.exportProperty(ol.Map.prototype, "removeLayer", ol.Map.prototype.removeLayer);
goog.exportProperty(ol.Map.prototype, "removeOverlay", ol.Map.prototype.removeOverlay);
goog.exportProperty(ol.Map.prototype, "setLayerGroup", ol.Map.prototype.setLayerGroup);
goog.exportProperty(ol.Map.prototype, "setSize", ol.Map.prototype.setSize);
goog.exportProperty(ol.Map.prototype, "setTarget", ol.Map.prototype.setTarget);
goog.exportProperty(ol.Map.prototype, "setView", ol.Map.prototype.setView);
goog.exportProperty(ol.Map.prototype, "updateSize", ol.Map.prototype.updateSize);
goog.exportProperty(ol.Map.prototype, "get", ol.Map.prototype.get);
goog.exportProperty(ol.Map.prototype, "getKeys", ol.Map.prototype.getKeys);
goog.exportProperty(ol.Map.prototype, "getProperties", ol.Map.prototype.getProperties);
goog.exportProperty(ol.Map.prototype, "set", ol.Map.prototype.set);
goog.exportProperty(ol.Map.prototype, "setProperties", ol.Map.prototype.setProperties);
goog.exportProperty(ol.Map.prototype, "unset", ol.Map.prototype.unset);
goog.exportProperty(ol.Map.prototype, "changed", ol.Map.prototype.changed);
goog.exportProperty(ol.Map.prototype, "dispatchEvent", ol.Map.prototype.dispatchEvent);
goog.exportProperty(ol.Map.prototype, "getRevision", ol.Map.prototype.getRevision);
goog.exportProperty(ol.Map.prototype, "on", ol.Map.prototype.on);
goog.exportProperty(ol.Map.prototype, "once", ol.Map.prototype.once);
goog.exportProperty(ol.Map.prototype, "un", ol.Map.prototype.un);
goog.exportProperty(ol.MapEvent.prototype, "type", ol.MapEvent.prototype.type);
goog.exportProperty(ol.MapEvent.prototype, "target", ol.MapEvent.prototype.target);
goog.exportProperty(ol.MapEvent.prototype, "preventDefault", ol.MapEvent.prototype.preventDefault);
goog.exportProperty(ol.MapEvent.prototype, "stopPropagation", ol.MapEvent.prototype.stopPropagation);
goog.exportProperty(ol.MapBrowserEvent.prototype, "map", ol.MapBrowserEvent.prototype.map);
goog.exportProperty(ol.MapBrowserEvent.prototype, "frameState", ol.MapBrowserEvent.prototype.frameState);
goog.exportProperty(ol.MapBrowserEvent.prototype, "type", ol.MapBrowserEvent.prototype.type);
goog.exportProperty(ol.MapBrowserEvent.prototype, "target", ol.MapBrowserEvent.prototype.target);
goog.exportProperty(ol.MapBrowserEvent.prototype, "preventDefault", ol.MapBrowserEvent.prototype.preventDefault);
goog.exportProperty(ol.MapBrowserEvent.prototype, "stopPropagation", ol.MapBrowserEvent.prototype.stopPropagation);
goog.exportProperty(ol.MapBrowserPointerEvent.prototype, "originalEvent", ol.MapBrowserPointerEvent.prototype.originalEvent);
goog.exportProperty(ol.MapBrowserPointerEvent.prototype, "pixel", ol.MapBrowserPointerEvent.prototype.pixel);
goog.exportProperty(ol.MapBrowserPointerEvent.prototype, "coordinate", ol.MapBrowserPointerEvent.prototype.coordinate);
goog.exportProperty(ol.MapBrowserPointerEvent.prototype, "dragging", ol.MapBrowserPointerEvent.prototype.dragging);
goog.exportProperty(ol.MapBrowserPointerEvent.prototype, "preventDefault", ol.MapBrowserPointerEvent.prototype.preventDefault);
goog.exportProperty(ol.MapBrowserPointerEvent.prototype, "stopPropagation", ol.MapBrowserPointerEvent.prototype.stopPropagation);
goog.exportProperty(ol.MapBrowserPointerEvent.prototype, "map", ol.MapBrowserPointerEvent.prototype.map);
goog.exportProperty(ol.MapBrowserPointerEvent.prototype, "frameState", ol.MapBrowserPointerEvent.prototype.frameState);
goog.exportProperty(ol.MapBrowserPointerEvent.prototype, "type", ol.MapBrowserPointerEvent.prototype.type);
goog.exportProperty(ol.MapBrowserPointerEvent.prototype, "target", ol.MapBrowserPointerEvent.prototype.target);
goog.exportProperty(ol.Object.Event.prototype, "type", ol.Object.Event.prototype.type);
goog.exportProperty(ol.Object.Event.prototype, "target", ol.Object.Event.prototype.target);
goog.exportProperty(ol.Object.Event.prototype, "preventDefault", ol.Object.Event.prototype.preventDefault);
goog.exportProperty(ol.Object.Event.prototype, "stopPropagation", ol.Object.Event.prototype.stopPropagation);
goog.exportProperty(ol.Overlay.prototype, "get", ol.Overlay.prototype.get);
goog.exportProperty(ol.Overlay.prototype, "getKeys", ol.Overlay.prototype.getKeys);
goog.exportProperty(ol.Overlay.prototype, "getProperties", ol.Overlay.prototype.getProperties);
goog.exportProperty(ol.Overlay.prototype, "set", ol.Overlay.prototype.set);
goog.exportProperty(ol.Overlay.prototype, "setProperties", ol.Overlay.prototype.setProperties);
goog.exportProperty(ol.Overlay.prototype, "unset", ol.Overlay.prototype.unset);
goog.exportProperty(ol.Overlay.prototype, "changed", ol.Overlay.prototype.changed);
goog.exportProperty(ol.Overlay.prototype, "dispatchEvent", ol.Overlay.prototype.dispatchEvent);
goog.exportProperty(ol.Overlay.prototype, "getRevision", ol.Overlay.prototype.getRevision);
goog.exportProperty(ol.Overlay.prototype, "on", ol.Overlay.prototype.on);
goog.exportProperty(ol.Overlay.prototype, "once", ol.Overlay.prototype.once);
goog.exportProperty(ol.Overlay.prototype, "un", ol.Overlay.prototype.un);
goog.exportProperty(ol.VectorImageTile.prototype, "getTileCoord", ol.VectorImageTile.prototype.getTileCoord);
goog.exportProperty(ol.VectorImageTile.prototype, "load", ol.VectorImageTile.prototype.load);
goog.exportProperty(ol.VectorTile.prototype, "getTileCoord", ol.VectorTile.prototype.getTileCoord);
goog.exportProperty(ol.VectorTile.prototype, "load", ol.VectorTile.prototype.load);
goog.exportProperty(ol.View.prototype, "get", ol.View.prototype.get);
goog.exportProperty(ol.View.prototype, "getKeys", ol.View.prototype.getKeys);
goog.exportProperty(ol.View.prototype, "getProperties", ol.View.prototype.getProperties);
goog.exportProperty(ol.View.prototype, "set", ol.View.prototype.set);
goog.exportProperty(ol.View.prototype, "setProperties", ol.View.prototype.setProperties);
goog.exportProperty(ol.View.prototype, "unset", ol.View.prototype.unset);
goog.exportProperty(ol.View.prototype, "changed", ol.View.prototype.changed);
goog.exportProperty(ol.View.prototype, "dispatchEvent", ol.View.prototype.dispatchEvent);
goog.exportProperty(ol.View.prototype, "getRevision", ol.View.prototype.getRevision);
goog.exportProperty(ol.View.prototype, "on", ol.View.prototype.on);
goog.exportProperty(ol.View.prototype, "once", ol.View.prototype.once);
goog.exportProperty(ol.View.prototype, "un", ol.View.prototype.un);
goog.exportProperty(ol.tilegrid.WMTS.prototype, "forEachTileCoord", ol.tilegrid.WMTS.prototype.forEachTileCoord);
goog.exportProperty(ol.tilegrid.WMTS.prototype, "getMaxZoom", ol.tilegrid.WMTS.prototype.getMaxZoom);
goog.exportProperty(ol.tilegrid.WMTS.prototype, "getMinZoom", ol.tilegrid.WMTS.prototype.getMinZoom);
goog.exportProperty(ol.tilegrid.WMTS.prototype, "getOrigin", ol.tilegrid.WMTS.prototype.getOrigin);
goog.exportProperty(ol.tilegrid.WMTS.prototype, "getResolution", ol.tilegrid.WMTS.prototype.getResolution);
goog.exportProperty(ol.tilegrid.WMTS.prototype, "getResolutions", ol.tilegrid.WMTS.prototype.getResolutions);
goog.exportProperty(ol.tilegrid.WMTS.prototype, "getTileCoordExtent", ol.tilegrid.WMTS.prototype.getTileCoordExtent);
goog.exportProperty(ol.tilegrid.WMTS.prototype, "getTileCoordForCoordAndResolution", ol.tilegrid.WMTS.prototype.getTileCoordForCoordAndResolution);
goog.exportProperty(ol.tilegrid.WMTS.prototype, "getTileCoordForCoordAndZ", ol.tilegrid.WMTS.prototype.getTileCoordForCoordAndZ);
goog.exportProperty(ol.tilegrid.WMTS.prototype, "getTileSize", ol.tilegrid.WMTS.prototype.getTileSize);
goog.exportProperty(ol.tilegrid.WMTS.prototype, "getZForResolution", ol.tilegrid.WMTS.prototype.getZForResolution);
goog.exportProperty(ol.style.RegularShape.prototype, "getOpacity", ol.style.RegularShape.prototype.getOpacity);
goog.exportProperty(ol.style.RegularShape.prototype, "getRotateWithView", ol.style.RegularShape.prototype.getRotateWithView);
goog.exportProperty(ol.style.RegularShape.prototype, "getRotation", ol.style.RegularShape.prototype.getRotation);
goog.exportProperty(ol.style.RegularShape.prototype, "getScale", ol.style.RegularShape.prototype.getScale);
goog.exportProperty(ol.style.RegularShape.prototype, "getSnapToPixel", ol.style.RegularShape.prototype.getSnapToPixel);
goog.exportProperty(ol.style.RegularShape.prototype, "setOpacity", ol.style.RegularShape.prototype.setOpacity);
goog.exportProperty(ol.style.RegularShape.prototype, "setRotation", ol.style.RegularShape.prototype.setRotation);
goog.exportProperty(ol.style.RegularShape.prototype, "setScale", ol.style.RegularShape.prototype.setScale);
goog.exportProperty(ol.style.Circle.prototype, "clone", ol.style.Circle.prototype.clone);
goog.exportProperty(ol.style.Circle.prototype, "getAngle", ol.style.Circle.prototype.getAngle);
goog.exportProperty(ol.style.Circle.prototype, "getFill", ol.style.Circle.prototype.getFill);
goog.exportProperty(ol.style.Circle.prototype, "getPoints", ol.style.Circle.prototype.getPoints);
goog.exportProperty(ol.style.Circle.prototype, "getRadius", ol.style.Circle.prototype.getRadius);
goog.exportProperty(ol.style.Circle.prototype, "getRadius2", ol.style.Circle.prototype.getRadius2);
goog.exportProperty(ol.style.Circle.prototype, "getStroke", ol.style.Circle.prototype.getStroke);
goog.exportProperty(ol.style.Circle.prototype, "getOpacity", ol.style.Circle.prototype.getOpacity);
goog.exportProperty(ol.style.Circle.prototype, "getRotateWithView", ol.style.Circle.prototype.getRotateWithView);
goog.exportProperty(ol.style.Circle.prototype, "getRotation", ol.style.Circle.prototype.getRotation);
goog.exportProperty(ol.style.Circle.prototype, "getScale", ol.style.Circle.prototype.getScale);
goog.exportProperty(ol.style.Circle.prototype, "getSnapToPixel", ol.style.Circle.prototype.getSnapToPixel);
goog.exportProperty(ol.style.Circle.prototype, "setOpacity", ol.style.Circle.prototype.setOpacity);
goog.exportProperty(ol.style.Circle.prototype, "setRotation", ol.style.Circle.prototype.setRotation);
goog.exportProperty(ol.style.Circle.prototype, "setScale", ol.style.Circle.prototype.setScale);
goog.exportProperty(ol.style.Icon.prototype, "getOpacity", ol.style.Icon.prototype.getOpacity);
goog.exportProperty(ol.style.Icon.prototype, "getRotateWithView", ol.style.Icon.prototype.getRotateWithView);
goog.exportProperty(ol.style.Icon.prototype, "getRotation", ol.style.Icon.prototype.getRotation);
goog.exportProperty(ol.style.Icon.prototype, "getScale", ol.style.Icon.prototype.getScale);
goog.exportProperty(ol.style.Icon.prototype, "getSnapToPixel", ol.style.Icon.prototype.getSnapToPixel);
goog.exportProperty(ol.style.Icon.prototype, "setOpacity", ol.style.Icon.prototype.setOpacity);
goog.exportProperty(ol.style.Icon.prototype, "setRotation", ol.style.Icon.prototype.setRotation);
goog.exportProperty(ol.style.Icon.prototype, "setScale", ol.style.Icon.prototype.setScale);
goog.exportProperty(ol.source.Source.prototype, "get", ol.source.Source.prototype.get);
goog.exportProperty(ol.source.Source.prototype, "getKeys", ol.source.Source.prototype.getKeys);
goog.exportProperty(ol.source.Source.prototype, "getProperties", ol.source.Source.prototype.getProperties);
goog.exportProperty(ol.source.Source.prototype, "set", ol.source.Source.prototype.set);
goog.exportProperty(ol.source.Source.prototype, "setProperties", ol.source.Source.prototype.setProperties);
goog.exportProperty(ol.source.Source.prototype, "unset", ol.source.Source.prototype.unset);
goog.exportProperty(ol.source.Source.prototype, "changed", ol.source.Source.prototype.changed);
goog.exportProperty(ol.source.Source.prototype, "dispatchEvent", ol.source.Source.prototype.dispatchEvent);
goog.exportProperty(ol.source.Source.prototype, "getRevision", ol.source.Source.prototype.getRevision);
goog.exportProperty(ol.source.Source.prototype, "on", ol.source.Source.prototype.on);
goog.exportProperty(ol.source.Source.prototype, "once", ol.source.Source.prototype.once);
goog.exportProperty(ol.source.Source.prototype, "un", ol.source.Source.prototype.un);
goog.exportProperty(ol.source.Tile.prototype, "getAttributions", ol.source.Tile.prototype.getAttributions);
goog.exportProperty(ol.source.Tile.prototype, "getLogo", ol.source.Tile.prototype.getLogo);
goog.exportProperty(ol.source.Tile.prototype, "getProjection", ol.source.Tile.prototype.getProjection);
goog.exportProperty(ol.source.Tile.prototype, "getState", ol.source.Tile.prototype.getState);
goog.exportProperty(ol.source.Tile.prototype, "refresh", ol.source.Tile.prototype.refresh);
goog.exportProperty(ol.source.Tile.prototype, "setAttributions", ol.source.Tile.prototype.setAttributions);
goog.exportProperty(ol.source.Tile.prototype, "get", ol.source.Tile.prototype.get);
goog.exportProperty(ol.source.Tile.prototype, "getKeys", ol.source.Tile.prototype.getKeys);
goog.exportProperty(ol.source.Tile.prototype, "getProperties", ol.source.Tile.prototype.getProperties);
goog.exportProperty(ol.source.Tile.prototype, "set", ol.source.Tile.prototype.set);
goog.exportProperty(ol.source.Tile.prototype, "setProperties", ol.source.Tile.prototype.setProperties);
goog.exportProperty(ol.source.Tile.prototype, "unset", ol.source.Tile.prototype.unset);
goog.exportProperty(ol.source.Tile.prototype, "changed", ol.source.Tile.prototype.changed);
goog.exportProperty(ol.source.Tile.prototype, "dispatchEvent", ol.source.Tile.prototype.dispatchEvent);
goog.exportProperty(ol.source.Tile.prototype, "getRevision", ol.source.Tile.prototype.getRevision);
goog.exportProperty(ol.source.Tile.prototype, "on", ol.source.Tile.prototype.on);
goog.exportProperty(ol.source.Tile.prototype, "once", ol.source.Tile.prototype.once);
goog.exportProperty(ol.source.Tile.prototype, "un", ol.source.Tile.prototype.un);
goog.exportProperty(ol.source.UrlTile.prototype, "getTileGrid", ol.source.UrlTile.prototype.getTileGrid);
goog.exportProperty(ol.source.UrlTile.prototype, "refresh", ol.source.UrlTile.prototype.refresh);
goog.exportProperty(ol.source.UrlTile.prototype, "getAttributions", ol.source.UrlTile.prototype.getAttributions);
goog.exportProperty(ol.source.UrlTile.prototype, "getLogo", ol.source.UrlTile.prototype.getLogo);
goog.exportProperty(ol.source.UrlTile.prototype, "getProjection", ol.source.UrlTile.prototype.getProjection);
goog.exportProperty(ol.source.UrlTile.prototype, "getState", ol.source.UrlTile.prototype.getState);
goog.exportProperty(ol.source.UrlTile.prototype, "setAttributions", ol.source.UrlTile.prototype.setAttributions);
goog.exportProperty(ol.source.UrlTile.prototype, "get", ol.source.UrlTile.prototype.get);
goog.exportProperty(ol.source.UrlTile.prototype, "getKeys", ol.source.UrlTile.prototype.getKeys);
goog.exportProperty(ol.source.UrlTile.prototype, "getProperties", ol.source.UrlTile.prototype.getProperties);
goog.exportProperty(ol.source.UrlTile.prototype, "set", ol.source.UrlTile.prototype.set);
goog.exportProperty(ol.source.UrlTile.prototype, "setProperties", ol.source.UrlTile.prototype.setProperties);
goog.exportProperty(ol.source.UrlTile.prototype, "unset", ol.source.UrlTile.prototype.unset);
goog.exportProperty(ol.source.UrlTile.prototype, "changed", ol.source.UrlTile.prototype.changed);
goog.exportProperty(ol.source.UrlTile.prototype, "dispatchEvent", ol.source.UrlTile.prototype.dispatchEvent);
goog.exportProperty(ol.source.UrlTile.prototype, "getRevision", ol.source.UrlTile.prototype.getRevision);
goog.exportProperty(ol.source.UrlTile.prototype, "on", ol.source.UrlTile.prototype.on);
goog.exportProperty(ol.source.UrlTile.prototype, "once", ol.source.UrlTile.prototype.once);
goog.exportProperty(ol.source.UrlTile.prototype, "un", ol.source.UrlTile.prototype.un);
goog.exportProperty(ol.source.TileImage.prototype, "getTileLoadFunction", ol.source.TileImage.prototype.getTileLoadFunction);
goog.exportProperty(ol.source.TileImage.prototype, "getTileUrlFunction", ol.source.TileImage.prototype.getTileUrlFunction);
goog.exportProperty(ol.source.TileImage.prototype, "getUrls", ol.source.TileImage.prototype.getUrls);
goog.exportProperty(ol.source.TileImage.prototype, "setTileLoadFunction", ol.source.TileImage.prototype.setTileLoadFunction);
goog.exportProperty(ol.source.TileImage.prototype, "setTileUrlFunction", ol.source.TileImage.prototype.setTileUrlFunction);
goog.exportProperty(ol.source.TileImage.prototype, "setUrl", ol.source.TileImage.prototype.setUrl);
goog.exportProperty(ol.source.TileImage.prototype, "setUrls", ol.source.TileImage.prototype.setUrls);
goog.exportProperty(ol.source.TileImage.prototype, "getTileGrid", ol.source.TileImage.prototype.getTileGrid);
goog.exportProperty(ol.source.TileImage.prototype, "refresh", ol.source.TileImage.prototype.refresh);
goog.exportProperty(ol.source.TileImage.prototype, "getAttributions", ol.source.TileImage.prototype.getAttributions);
goog.exportProperty(ol.source.TileImage.prototype, "getLogo", ol.source.TileImage.prototype.getLogo);
goog.exportProperty(ol.source.TileImage.prototype, "getProjection", ol.source.TileImage.prototype.getProjection);
goog.exportProperty(ol.source.TileImage.prototype, "getState", ol.source.TileImage.prototype.getState);
goog.exportProperty(ol.source.TileImage.prototype, "setAttributions", ol.source.TileImage.prototype.setAttributions);
goog.exportProperty(ol.source.TileImage.prototype, "get", ol.source.TileImage.prototype.get);
goog.exportProperty(ol.source.TileImage.prototype, "getKeys", ol.source.TileImage.prototype.getKeys);
goog.exportProperty(ol.source.TileImage.prototype, "getProperties", ol.source.TileImage.prototype.getProperties);
goog.exportProperty(ol.source.TileImage.prototype, "set", ol.source.TileImage.prototype.set);
goog.exportProperty(ol.source.TileImage.prototype, "setProperties", ol.source.TileImage.prototype.setProperties);
goog.exportProperty(ol.source.TileImage.prototype, "unset", ol.source.TileImage.prototype.unset);
goog.exportProperty(ol.source.TileImage.prototype, "changed", ol.source.TileImage.prototype.changed);
goog.exportProperty(ol.source.TileImage.prototype, "dispatchEvent", ol.source.TileImage.prototype.dispatchEvent);
goog.exportProperty(ol.source.TileImage.prototype, "getRevision", ol.source.TileImage.prototype.getRevision);
goog.exportProperty(ol.source.TileImage.prototype, "on", ol.source.TileImage.prototype.on);
goog.exportProperty(ol.source.TileImage.prototype, "once", ol.source.TileImage.prototype.once);
goog.exportProperty(ol.source.TileImage.prototype, "un", ol.source.TileImage.prototype.un);
goog.exportProperty(ol.source.BingMaps.prototype, "setRenderReprojectionEdges", ol.source.BingMaps.prototype.setRenderReprojectionEdges);
goog.exportProperty(ol.source.BingMaps.prototype, "setTileGridForProjection", ol.source.BingMaps.prototype.setTileGridForProjection);
goog.exportProperty(ol.source.BingMaps.prototype, "getTileLoadFunction", ol.source.BingMaps.prototype.getTileLoadFunction);
goog.exportProperty(ol.source.BingMaps.prototype, "getTileUrlFunction", ol.source.BingMaps.prototype.getTileUrlFunction);
goog.exportProperty(ol.source.BingMaps.prototype, "getUrls", ol.source.BingMaps.prototype.getUrls);
goog.exportProperty(ol.source.BingMaps.prototype, "setTileLoadFunction", ol.source.BingMaps.prototype.setTileLoadFunction);
goog.exportProperty(ol.source.BingMaps.prototype, "setTileUrlFunction", ol.source.BingMaps.prototype.setTileUrlFunction);
goog.exportProperty(ol.source.BingMaps.prototype, "setUrl", ol.source.BingMaps.prototype.setUrl);
goog.exportProperty(ol.source.BingMaps.prototype, "setUrls", ol.source.BingMaps.prototype.setUrls);
goog.exportProperty(ol.source.BingMaps.prototype, "getTileGrid", ol.source.BingMaps.prototype.getTileGrid);
goog.exportProperty(ol.source.BingMaps.prototype, "refresh", ol.source.BingMaps.prototype.refresh);
goog.exportProperty(ol.source.BingMaps.prototype, "getAttributions", ol.source.BingMaps.prototype.getAttributions);
goog.exportProperty(ol.source.BingMaps.prototype, "getLogo", ol.source.BingMaps.prototype.getLogo);
goog.exportProperty(ol.source.BingMaps.prototype, "getProjection", ol.source.BingMaps.prototype.getProjection);
goog.exportProperty(ol.source.BingMaps.prototype, "getState", ol.source.BingMaps.prototype.getState);
goog.exportProperty(ol.source.BingMaps.prototype, "setAttributions", ol.source.BingMaps.prototype.setAttributions);
goog.exportProperty(ol.source.BingMaps.prototype, "get", ol.source.BingMaps.prototype.get);
goog.exportProperty(ol.source.BingMaps.prototype, "getKeys", ol.source.BingMaps.prototype.getKeys);
goog.exportProperty(ol.source.BingMaps.prototype, "getProperties", ol.source.BingMaps.prototype.getProperties);
goog.exportProperty(ol.source.BingMaps.prototype, "set", ol.source.BingMaps.prototype.set);
goog.exportProperty(ol.source.BingMaps.prototype, "setProperties", ol.source.BingMaps.prototype.setProperties);
goog.exportProperty(ol.source.BingMaps.prototype, "unset", ol.source.BingMaps.prototype.unset);
goog.exportProperty(ol.source.BingMaps.prototype, "changed", ol.source.BingMaps.prototype.changed);
goog.exportProperty(ol.source.BingMaps.prototype, "dispatchEvent", ol.source.BingMaps.prototype.dispatchEvent);
goog.exportProperty(ol.source.BingMaps.prototype, "getRevision", ol.source.BingMaps.prototype.getRevision);
goog.exportProperty(ol.source.BingMaps.prototype, "on", ol.source.BingMaps.prototype.on);
goog.exportProperty(ol.source.BingMaps.prototype, "once", ol.source.BingMaps.prototype.once);
goog.exportProperty(ol.source.BingMaps.prototype, "un", ol.source.BingMaps.prototype.un);
goog.exportProperty(ol.source.XYZ.prototype, "setRenderReprojectionEdges", ol.source.XYZ.prototype.setRenderReprojectionEdges);
goog.exportProperty(ol.source.XYZ.prototype, "setTileGridForProjection", ol.source.XYZ.prototype.setTileGridForProjection);
goog.exportProperty(ol.source.XYZ.prototype, "getTileLoadFunction", ol.source.XYZ.prototype.getTileLoadFunction);
goog.exportProperty(ol.source.XYZ.prototype, "getTileUrlFunction", ol.source.XYZ.prototype.getTileUrlFunction);
goog.exportProperty(ol.source.XYZ.prototype, "getUrls", ol.source.XYZ.prototype.getUrls);
goog.exportProperty(ol.source.XYZ.prototype, "setTileLoadFunction", ol.source.XYZ.prototype.setTileLoadFunction);
goog.exportProperty(ol.source.XYZ.prototype, "setTileUrlFunction", ol.source.XYZ.prototype.setTileUrlFunction);
goog.exportProperty(ol.source.XYZ.prototype, "setUrl", ol.source.XYZ.prototype.setUrl);
goog.exportProperty(ol.source.XYZ.prototype, "setUrls", ol.source.XYZ.prototype.setUrls);
goog.exportProperty(ol.source.XYZ.prototype, "getTileGrid", ol.source.XYZ.prototype.getTileGrid);
goog.exportProperty(ol.source.XYZ.prototype, "refresh", ol.source.XYZ.prototype.refresh);
goog.exportProperty(ol.source.XYZ.prototype, "getAttributions", ol.source.XYZ.prototype.getAttributions);
goog.exportProperty(ol.source.XYZ.prototype, "getLogo", ol.source.XYZ.prototype.getLogo);
goog.exportProperty(ol.source.XYZ.prototype, "getProjection", ol.source.XYZ.prototype.getProjection);
goog.exportProperty(ol.source.XYZ.prototype, "getState", ol.source.XYZ.prototype.getState);
goog.exportProperty(ol.source.XYZ.prototype, "setAttributions", ol.source.XYZ.prototype.setAttributions);
goog.exportProperty(ol.source.XYZ.prototype, "get", ol.source.XYZ.prototype.get);
goog.exportProperty(ol.source.XYZ.prototype, "getKeys", ol.source.XYZ.prototype.getKeys);
goog.exportProperty(ol.source.XYZ.prototype, "getProperties", ol.source.XYZ.prototype.getProperties);
goog.exportProperty(ol.source.XYZ.prototype, "set", ol.source.XYZ.prototype.set);
goog.exportProperty(ol.source.XYZ.prototype, "setProperties", ol.source.XYZ.prototype.setProperties);
goog.exportProperty(ol.source.XYZ.prototype, "unset", ol.source.XYZ.prototype.unset);
goog.exportProperty(ol.source.XYZ.prototype, "changed", ol.source.XYZ.prototype.changed);
goog.exportProperty(ol.source.XYZ.prototype, "dispatchEvent", ol.source.XYZ.prototype.dispatchEvent);
goog.exportProperty(ol.source.XYZ.prototype, "getRevision", ol.source.XYZ.prototype.getRevision);
goog.exportProperty(ol.source.XYZ.prototype, "on", ol.source.XYZ.prototype.on);
goog.exportProperty(ol.source.XYZ.prototype, "once", ol.source.XYZ.prototype.once);
goog.exportProperty(ol.source.XYZ.prototype, "un", ol.source.XYZ.prototype.un);
goog.exportProperty(ol.source.CartoDB.prototype, "setRenderReprojectionEdges", ol.source.CartoDB.prototype.setRenderReprojectionEdges);
goog.exportProperty(ol.source.CartoDB.prototype, "setTileGridForProjection", ol.source.CartoDB.prototype.setTileGridForProjection);
goog.exportProperty(ol.source.CartoDB.prototype, "getTileLoadFunction", ol.source.CartoDB.prototype.getTileLoadFunction);
goog.exportProperty(ol.source.CartoDB.prototype, "getTileUrlFunction", ol.source.CartoDB.prototype.getTileUrlFunction);
goog.exportProperty(ol.source.CartoDB.prototype, "getUrls", ol.source.CartoDB.prototype.getUrls);
goog.exportProperty(ol.source.CartoDB.prototype, "setTileLoadFunction", ol.source.CartoDB.prototype.setTileLoadFunction);
goog.exportProperty(ol.source.CartoDB.prototype, "setTileUrlFunction", ol.source.CartoDB.prototype.setTileUrlFunction);
goog.exportProperty(ol.source.CartoDB.prototype, "setUrl", ol.source.CartoDB.prototype.setUrl);
goog.exportProperty(ol.source.CartoDB.prototype, "setUrls", ol.source.CartoDB.prototype.setUrls);
goog.exportProperty(ol.source.CartoDB.prototype, "getTileGrid", ol.source.CartoDB.prototype.getTileGrid);
goog.exportProperty(ol.source.CartoDB.prototype, "refresh", ol.source.CartoDB.prototype.refresh);
goog.exportProperty(ol.source.CartoDB.prototype, "getAttributions", ol.source.CartoDB.prototype.getAttributions);
goog.exportProperty(ol.source.CartoDB.prototype, "getLogo", ol.source.CartoDB.prototype.getLogo);
goog.exportProperty(ol.source.CartoDB.prototype, "getProjection", ol.source.CartoDB.prototype.getProjection);
goog.exportProperty(ol.source.CartoDB.prototype, "getState", ol.source.CartoDB.prototype.getState);
goog.exportProperty(ol.source.CartoDB.prototype, "setAttributions", ol.source.CartoDB.prototype.setAttributions);
goog.exportProperty(ol.source.CartoDB.prototype, "get", ol.source.CartoDB.prototype.get);
goog.exportProperty(ol.source.CartoDB.prototype, "getKeys", ol.source.CartoDB.prototype.getKeys);
goog.exportProperty(ol.source.CartoDB.prototype, "getProperties", ol.source.CartoDB.prototype.getProperties);
goog.exportProperty(ol.source.CartoDB.prototype, "set", ol.source.CartoDB.prototype.set);
goog.exportProperty(ol.source.CartoDB.prototype, "setProperties", ol.source.CartoDB.prototype.setProperties);
goog.exportProperty(ol.source.CartoDB.prototype, "unset", ol.source.CartoDB.prototype.unset);
goog.exportProperty(ol.source.CartoDB.prototype, "changed", ol.source.CartoDB.prototype.changed);
goog.exportProperty(ol.source.CartoDB.prototype, "dispatchEvent", ol.source.CartoDB.prototype.dispatchEvent);
goog.exportProperty(ol.source.CartoDB.prototype, "getRevision", ol.source.CartoDB.prototype.getRevision);
goog.exportProperty(ol.source.CartoDB.prototype, "on", ol.source.CartoDB.prototype.on);
goog.exportProperty(ol.source.CartoDB.prototype, "once", ol.source.CartoDB.prototype.once);
goog.exportProperty(ol.source.CartoDB.prototype, "un", ol.source.CartoDB.prototype.un);
goog.exportProperty(ol.source.Vector.prototype, "getAttributions", ol.source.Vector.prototype.getAttributions);
goog.exportProperty(ol.source.Vector.prototype, "getLogo", ol.source.Vector.prototype.getLogo);
goog.exportProperty(ol.source.Vector.prototype, "getProjection", ol.source.Vector.prototype.getProjection);
goog.exportProperty(ol.source.Vector.prototype, "getState", ol.source.Vector.prototype.getState);
goog.exportProperty(ol.source.Vector.prototype, "refresh", ol.source.Vector.prototype.refresh);
goog.exportProperty(ol.source.Vector.prototype, "setAttributions", ol.source.Vector.prototype.setAttributions);
goog.exportProperty(ol.source.Vector.prototype, "get", ol.source.Vector.prototype.get);
goog.exportProperty(ol.source.Vector.prototype, "getKeys", ol.source.Vector.prototype.getKeys);
goog.exportProperty(ol.source.Vector.prototype, "getProperties", ol.source.Vector.prototype.getProperties);
goog.exportProperty(ol.source.Vector.prototype, "set", ol.source.Vector.prototype.set);
goog.exportProperty(ol.source.Vector.prototype, "setProperties", ol.source.Vector.prototype.setProperties);
goog.exportProperty(ol.source.Vector.prototype, "unset", ol.source.Vector.prototype.unset);
goog.exportProperty(ol.source.Vector.prototype, "changed", ol.source.Vector.prototype.changed);
goog.exportProperty(ol.source.Vector.prototype, "dispatchEvent", ol.source.Vector.prototype.dispatchEvent);
goog.exportProperty(ol.source.Vector.prototype, "getRevision", ol.source.Vector.prototype.getRevision);
goog.exportProperty(ol.source.Vector.prototype, "on", ol.source.Vector.prototype.on);
goog.exportProperty(ol.source.Vector.prototype, "once", ol.source.Vector.prototype.once);
goog.exportProperty(ol.source.Vector.prototype, "un", ol.source.Vector.prototype.un);
goog.exportProperty(ol.source.Cluster.prototype, "addFeature", ol.source.Cluster.prototype.addFeature);
goog.exportProperty(ol.source.Cluster.prototype, "addFeatures", ol.source.Cluster.prototype.addFeatures);
goog.exportProperty(ol.source.Cluster.prototype, "clear", ol.source.Cluster.prototype.clear);
goog.exportProperty(ol.source.Cluster.prototype, "forEachFeature", ol.source.Cluster.prototype.forEachFeature);
goog.exportProperty(ol.source.Cluster.prototype, "forEachFeatureInExtent", ol.source.Cluster.prototype.forEachFeatureInExtent);
goog.exportProperty(ol.source.Cluster.prototype, "forEachFeatureIntersectingExtent", ol.source.Cluster.prototype.forEachFeatureIntersectingExtent);
goog.exportProperty(ol.source.Cluster.prototype, "getFeaturesCollection", ol.source.Cluster.prototype.getFeaturesCollection);
goog.exportProperty(ol.source.Cluster.prototype, "getFeatures", ol.source.Cluster.prototype.getFeatures);
goog.exportProperty(ol.source.Cluster.prototype, "getFeaturesAtCoordinate", ol.source.Cluster.prototype.getFeaturesAtCoordinate);
goog.exportProperty(ol.source.Cluster.prototype, "getFeaturesInExtent", ol.source.Cluster.prototype.getFeaturesInExtent);
goog.exportProperty(ol.source.Cluster.prototype, "getClosestFeatureToCoordinate", ol.source.Cluster.prototype.getClosestFeatureToCoordinate);
goog.exportProperty(ol.source.Cluster.prototype, "getExtent", ol.source.Cluster.prototype.getExtent);
goog.exportProperty(ol.source.Cluster.prototype, "getFeatureById", ol.source.Cluster.prototype.getFeatureById);
goog.exportProperty(ol.source.Cluster.prototype, "getFormat", ol.source.Cluster.prototype.getFormat);
goog.exportProperty(ol.source.Cluster.prototype, "getUrl", ol.source.Cluster.prototype.getUrl);
goog.exportProperty(ol.source.Cluster.prototype, "removeLoadedExtent", ol.source.Cluster.prototype.removeLoadedExtent);
goog.exportProperty(ol.source.Cluster.prototype, "removeFeature", ol.source.Cluster.prototype.removeFeature);
goog.exportProperty(ol.source.Cluster.prototype, "setLoader", ol.source.Cluster.prototype.setLoader);
goog.exportProperty(ol.source.Cluster.prototype, "getAttributions", ol.source.Cluster.prototype.getAttributions);
goog.exportProperty(ol.source.Cluster.prototype, "getLogo", ol.source.Cluster.prototype.getLogo);
goog.exportProperty(ol.source.Cluster.prototype, "getProjection", ol.source.Cluster.prototype.getProjection);
goog.exportProperty(ol.source.Cluster.prototype, "getState", ol.source.Cluster.prototype.getState);
goog.exportProperty(ol.source.Cluster.prototype, "refresh", ol.source.Cluster.prototype.refresh);
goog.exportProperty(ol.source.Cluster.prototype, "setAttributions", ol.source.Cluster.prototype.setAttributions);
goog.exportProperty(ol.source.Cluster.prototype, "get", ol.source.Cluster.prototype.get);
goog.exportProperty(ol.source.Cluster.prototype, "getKeys", ol.source.Cluster.prototype.getKeys);
goog.exportProperty(ol.source.Cluster.prototype, "getProperties", ol.source.Cluster.prototype.getProperties);
goog.exportProperty(ol.source.Cluster.prototype, "set", ol.source.Cluster.prototype.set);
goog.exportProperty(ol.source.Cluster.prototype, "setProperties", ol.source.Cluster.prototype.setProperties);
goog.exportProperty(ol.source.Cluster.prototype, "unset", ol.source.Cluster.prototype.unset);
goog.exportProperty(ol.source.Cluster.prototype, "changed", ol.source.Cluster.prototype.changed);
goog.exportProperty(ol.source.Cluster.prototype, "dispatchEvent", ol.source.Cluster.prototype.dispatchEvent);
goog.exportProperty(ol.source.Cluster.prototype, "getRevision", ol.source.Cluster.prototype.getRevision);
goog.exportProperty(ol.source.Cluster.prototype, "on", ol.source.Cluster.prototype.on);
goog.exportProperty(ol.source.Cluster.prototype, "once", ol.source.Cluster.prototype.once);
goog.exportProperty(ol.source.Cluster.prototype, "un", ol.source.Cluster.prototype.un);
goog.exportProperty(ol.source.Image.prototype, "getAttributions", ol.source.Image.prototype.getAttributions);
goog.exportProperty(ol.source.Image.prototype, "getLogo", ol.source.Image.prototype.getLogo);
goog.exportProperty(ol.source.Image.prototype, "getProjection", ol.source.Image.prototype.getProjection);
goog.exportProperty(ol.source.Image.prototype, "getState", ol.source.Image.prototype.getState);
goog.exportProperty(ol.source.Image.prototype, "refresh", ol.source.Image.prototype.refresh);
goog.exportProperty(ol.source.Image.prototype, "setAttributions", ol.source.Image.prototype.setAttributions);
goog.exportProperty(ol.source.Image.prototype, "get", ol.source.Image.prototype.get);
goog.exportProperty(ol.source.Image.prototype, "getKeys", ol.source.Image.prototype.getKeys);
goog.exportProperty(ol.source.Image.prototype, "getProperties", ol.source.Image.prototype.getProperties);
goog.exportProperty(ol.source.Image.prototype, "set", ol.source.Image.prototype.set);
goog.exportProperty(ol.source.Image.prototype, "setProperties", ol.source.Image.prototype.setProperties);
goog.exportProperty(ol.source.Image.prototype, "unset", ol.source.Image.prototype.unset);
goog.exportProperty(ol.source.Image.prototype, "changed", ol.source.Image.prototype.changed);
goog.exportProperty(ol.source.Image.prototype, "dispatchEvent", ol.source.Image.prototype.dispatchEvent);
goog.exportProperty(ol.source.Image.prototype, "getRevision", ol.source.Image.prototype.getRevision);
goog.exportProperty(ol.source.Image.prototype, "on", ol.source.Image.prototype.on);
goog.exportProperty(ol.source.Image.prototype, "once", ol.source.Image.prototype.once);
goog.exportProperty(ol.source.Image.prototype, "un", ol.source.Image.prototype.un);
goog.exportProperty(ol.source.Image.Event.prototype, "type", ol.source.Image.Event.prototype.type);
goog.exportProperty(ol.source.Image.Event.prototype, "target", ol.source.Image.Event.prototype.target);
goog.exportProperty(ol.source.Image.Event.prototype, "preventDefault", ol.source.Image.Event.prototype.preventDefault);
goog.exportProperty(ol.source.Image.Event.prototype, "stopPropagation", ol.source.Image.Event.prototype.stopPropagation);
goog.exportProperty(ol.source.ImageArcGISRest.prototype, "getAttributions", ol.source.ImageArcGISRest.prototype.getAttributions);
goog.exportProperty(ol.source.ImageArcGISRest.prototype, "getLogo", ol.source.ImageArcGISRest.prototype.getLogo);
goog.exportProperty(ol.source.ImageArcGISRest.prototype, "getProjection", ol.source.ImageArcGISRest.prototype.getProjection);
goog.exportProperty(ol.source.ImageArcGISRest.prototype, "getState", ol.source.ImageArcGISRest.prototype.getState);
goog.exportProperty(ol.source.ImageArcGISRest.prototype, "refresh", ol.source.ImageArcGISRest.prototype.refresh);
goog.exportProperty(ol.source.ImageArcGISRest.prototype, "setAttributions", ol.source.ImageArcGISRest.prototype.setAttributions);
goog.exportProperty(ol.source.ImageArcGISRest.prototype, "get", ol.source.ImageArcGISRest.prototype.get);
goog.exportProperty(ol.source.ImageArcGISRest.prototype, "getKeys", ol.source.ImageArcGISRest.prototype.getKeys);
goog.exportProperty(ol.source.ImageArcGISRest.prototype, "getProperties", ol.source.ImageArcGISRest.prototype.getProperties);
goog.exportProperty(ol.source.ImageArcGISRest.prototype, "set", ol.source.ImageArcGISRest.prototype.set);
goog.exportProperty(ol.source.ImageArcGISRest.prototype, "setProperties", ol.source.ImageArcGISRest.prototype.setProperties);
goog.exportProperty(ol.source.ImageArcGISRest.prototype, "unset", ol.source.ImageArcGISRest.prototype.unset);
goog.exportProperty(ol.source.ImageArcGISRest.prototype, "changed", ol.source.ImageArcGISRest.prototype.changed);
goog.exportProperty(ol.source.ImageArcGISRest.prototype, "dispatchEvent", ol.source.ImageArcGISRest.prototype.dispatchEvent);
goog.exportProperty(ol.source.ImageArcGISRest.prototype, "getRevision", ol.source.ImageArcGISRest.prototype.getRevision);
goog.exportProperty(ol.source.ImageArcGISRest.prototype, "on", ol.source.ImageArcGISRest.prototype.on);
goog.exportProperty(ol.source.ImageArcGISRest.prototype, "once", ol.source.ImageArcGISRest.prototype.once);
goog.exportProperty(ol.source.ImageArcGISRest.prototype, "un", ol.source.ImageArcGISRest.prototype.un);
goog.exportProperty(ol.source.ImageCanvas.prototype, "getAttributions", ol.source.ImageCanvas.prototype.getAttributions);
goog.exportProperty(ol.source.ImageCanvas.prototype, "getLogo", ol.source.ImageCanvas.prototype.getLogo);
goog.exportProperty(ol.source.ImageCanvas.prototype, "getProjection", ol.source.ImageCanvas.prototype.getProjection);
goog.exportProperty(ol.source.ImageCanvas.prototype, "getState", ol.source.ImageCanvas.prototype.getState);
goog.exportProperty(ol.source.ImageCanvas.prototype, "refresh", ol.source.ImageCanvas.prototype.refresh);
goog.exportProperty(ol.source.ImageCanvas.prototype, "setAttributions", ol.source.ImageCanvas.prototype.setAttributions);
goog.exportProperty(ol.source.ImageCanvas.prototype, "get", ol.source.ImageCanvas.prototype.get);
goog.exportProperty(ol.source.ImageCanvas.prototype, "getKeys", ol.source.ImageCanvas.prototype.getKeys);
goog.exportProperty(ol.source.ImageCanvas.prototype, "getProperties", ol.source.ImageCanvas.prototype.getProperties);
goog.exportProperty(ol.source.ImageCanvas.prototype, "set", ol.source.ImageCanvas.prototype.set);
goog.exportProperty(ol.source.ImageCanvas.prototype, "setProperties", ol.source.ImageCanvas.prototype.setProperties);
goog.exportProperty(ol.source.ImageCanvas.prototype, "unset", ol.source.ImageCanvas.prototype.unset);
goog.exportProperty(ol.source.ImageCanvas.prototype, "changed", ol.source.ImageCanvas.prototype.changed);
goog.exportProperty(ol.source.ImageCanvas.prototype, "dispatchEvent", ol.source.ImageCanvas.prototype.dispatchEvent);
goog.exportProperty(ol.source.ImageCanvas.prototype, "getRevision", ol.source.ImageCanvas.prototype.getRevision);
goog.exportProperty(ol.source.ImageCanvas.prototype, "on", ol.source.ImageCanvas.prototype.on);
goog.exportProperty(ol.source.ImageCanvas.prototype, "once", ol.source.ImageCanvas.prototype.once);
goog.exportProperty(ol.source.ImageCanvas.prototype, "un", ol.source.ImageCanvas.prototype.un);
goog.exportProperty(ol.source.ImageMapGuide.prototype, "getAttributions", ol.source.ImageMapGuide.prototype.getAttributions);
goog.exportProperty(ol.source.ImageMapGuide.prototype, "getLogo", ol.source.ImageMapGuide.prototype.getLogo);
goog.exportProperty(ol.source.ImageMapGuide.prototype, "getProjection", ol.source.ImageMapGuide.prototype.getProjection);
goog.exportProperty(ol.source.ImageMapGuide.prototype, "getState", ol.source.ImageMapGuide.prototype.getState);
goog.exportProperty(ol.source.ImageMapGuide.prototype, "refresh", ol.source.ImageMapGuide.prototype.refresh);
goog.exportProperty(ol.source.ImageMapGuide.prototype, "setAttributions", ol.source.ImageMapGuide.prototype.setAttributions);
goog.exportProperty(ol.source.ImageMapGuide.prototype, "get", ol.source.ImageMapGuide.prototype.get);
goog.exportProperty(ol.source.ImageMapGuide.prototype, "getKeys", ol.source.ImageMapGuide.prototype.getKeys);
goog.exportProperty(ol.source.ImageMapGuide.prototype, "getProperties", ol.source.ImageMapGuide.prototype.getProperties);
goog.exportProperty(ol.source.ImageMapGuide.prototype, "set", ol.source.ImageMapGuide.prototype.set);
goog.exportProperty(ol.source.ImageMapGuide.prototype, "setProperties", ol.source.ImageMapGuide.prototype.setProperties);
goog.exportProperty(ol.source.ImageMapGuide.prototype, "unset", ol.source.ImageMapGuide.prototype.unset);
goog.exportProperty(ol.source.ImageMapGuide.prototype, "changed", ol.source.ImageMapGuide.prototype.changed);
goog.exportProperty(ol.source.ImageMapGuide.prototype, "dispatchEvent", ol.source.ImageMapGuide.prototype.dispatchEvent);
goog.exportProperty(ol.source.ImageMapGuide.prototype, "getRevision", ol.source.ImageMapGuide.prototype.getRevision);
goog.exportProperty(ol.source.ImageMapGuide.prototype, "on", ol.source.ImageMapGuide.prototype.on);
goog.exportProperty(ol.source.ImageMapGuide.prototype, "once", ol.source.ImageMapGuide.prototype.once);
goog.exportProperty(ol.source.ImageMapGuide.prototype, "un", ol.source.ImageMapGuide.prototype.un);
goog.exportProperty(ol.source.ImageStatic.prototype, "getAttributions", ol.source.ImageStatic.prototype.getAttributions);
goog.exportProperty(ol.source.ImageStatic.prototype, "getLogo", ol.source.ImageStatic.prototype.getLogo);
goog.exportProperty(ol.source.ImageStatic.prototype, "getProjection", ol.source.ImageStatic.prototype.getProjection);
goog.exportProperty(ol.source.ImageStatic.prototype, "getState", ol.source.ImageStatic.prototype.getState);
goog.exportProperty(ol.source.ImageStatic.prototype, "refresh", ol.source.ImageStatic.prototype.refresh);
goog.exportProperty(ol.source.ImageStatic.prototype, "setAttributions", ol.source.ImageStatic.prototype.setAttributions);
goog.exportProperty(ol.source.ImageStatic.prototype, "get", ol.source.ImageStatic.prototype.get);
goog.exportProperty(ol.source.ImageStatic.prototype, "getKeys", ol.source.ImageStatic.prototype.getKeys);
goog.exportProperty(ol.source.ImageStatic.prototype, "getProperties", ol.source.ImageStatic.prototype.getProperties);
goog.exportProperty(ol.source.ImageStatic.prototype, "set", ol.source.ImageStatic.prototype.set);
goog.exportProperty(ol.source.ImageStatic.prototype, "setProperties", ol.source.ImageStatic.prototype.setProperties);
goog.exportProperty(ol.source.ImageStatic.prototype, "unset", ol.source.ImageStatic.prototype.unset);
goog.exportProperty(ol.source.ImageStatic.prototype, "changed", ol.source.ImageStatic.prototype.changed);
goog.exportProperty(ol.source.ImageStatic.prototype, "dispatchEvent", ol.source.ImageStatic.prototype.dispatchEvent);
goog.exportProperty(ol.source.ImageStatic.prototype, "getRevision", ol.source.ImageStatic.prototype.getRevision);
goog.exportProperty(ol.source.ImageStatic.prototype, "on", ol.source.ImageStatic.prototype.on);
goog.exportProperty(ol.source.ImageStatic.prototype, "once", ol.source.ImageStatic.prototype.once);
goog.exportProperty(ol.source.ImageStatic.prototype, "un", ol.source.ImageStatic.prototype.un);
goog.exportProperty(ol.source.ImageVector.prototype, "getAttributions", ol.source.ImageVector.prototype.getAttributions);
goog.exportProperty(ol.source.ImageVector.prototype, "getLogo", ol.source.ImageVector.prototype.getLogo);
goog.exportProperty(ol.source.ImageVector.prototype, "getProjection", ol.source.ImageVector.prototype.getProjection);
goog.exportProperty(ol.source.ImageVector.prototype, "getState", ol.source.ImageVector.prototype.getState);
goog.exportProperty(ol.source.ImageVector.prototype, "refresh", ol.source.ImageVector.prototype.refresh);
goog.exportProperty(ol.source.ImageVector.prototype, "setAttributions", ol.source.ImageVector.prototype.setAttributions);
goog.exportProperty(ol.source.ImageVector.prototype, "get", ol.source.ImageVector.prototype.get);
goog.exportProperty(ol.source.ImageVector.prototype, "getKeys", ol.source.ImageVector.prototype.getKeys);
goog.exportProperty(ol.source.ImageVector.prototype, "getProperties", ol.source.ImageVector.prototype.getProperties);
goog.exportProperty(ol.source.ImageVector.prototype, "set", ol.source.ImageVector.prototype.set);
goog.exportProperty(ol.source.ImageVector.prototype, "setProperties", ol.source.ImageVector.prototype.setProperties);
goog.exportProperty(ol.source.ImageVector.prototype, "unset", ol.source.ImageVector.prototype.unset);
goog.exportProperty(ol.source.ImageVector.prototype, "changed", ol.source.ImageVector.prototype.changed);
goog.exportProperty(ol.source.ImageVector.prototype, "dispatchEvent", ol.source.ImageVector.prototype.dispatchEvent);
goog.exportProperty(ol.source.ImageVector.prototype, "getRevision", ol.source.ImageVector.prototype.getRevision);
goog.exportProperty(ol.source.ImageVector.prototype, "on", ol.source.ImageVector.prototype.on);
goog.exportProperty(ol.source.ImageVector.prototype, "once", ol.source.ImageVector.prototype.once);
goog.exportProperty(ol.source.ImageVector.prototype, "un", ol.source.ImageVector.prototype.un);
goog.exportProperty(ol.source.ImageWMS.prototype, "getAttributions", ol.source.ImageWMS.prototype.getAttributions);
goog.exportProperty(ol.source.ImageWMS.prototype, "getLogo", ol.source.ImageWMS.prototype.getLogo);
goog.exportProperty(ol.source.ImageWMS.prototype, "getProjection", ol.source.ImageWMS.prototype.getProjection);
goog.exportProperty(ol.source.ImageWMS.prototype, "getState", ol.source.ImageWMS.prototype.getState);
goog.exportProperty(ol.source.ImageWMS.prototype, "refresh", ol.source.ImageWMS.prototype.refresh);
goog.exportProperty(ol.source.ImageWMS.prototype, "setAttributions", ol.source.ImageWMS.prototype.setAttributions);
goog.exportProperty(ol.source.ImageWMS.prototype, "get", ol.source.ImageWMS.prototype.get);
goog.exportProperty(ol.source.ImageWMS.prototype, "getKeys", ol.source.ImageWMS.prototype.getKeys);
goog.exportProperty(ol.source.ImageWMS.prototype, "getProperties", ol.source.ImageWMS.prototype.getProperties);
goog.exportProperty(ol.source.ImageWMS.prototype, "set", ol.source.ImageWMS.prototype.set);
goog.exportProperty(ol.source.ImageWMS.prototype, "setProperties", ol.source.ImageWMS.prototype.setProperties);
goog.exportProperty(ol.source.ImageWMS.prototype, "unset", ol.source.ImageWMS.prototype.unset);
goog.exportProperty(ol.source.ImageWMS.prototype, "changed", ol.source.ImageWMS.prototype.changed);
goog.exportProperty(ol.source.ImageWMS.prototype, "dispatchEvent", ol.source.ImageWMS.prototype.dispatchEvent);
goog.exportProperty(ol.source.ImageWMS.prototype, "getRevision", ol.source.ImageWMS.prototype.getRevision);
goog.exportProperty(ol.source.ImageWMS.prototype, "on", ol.source.ImageWMS.prototype.on);
goog.exportProperty(ol.source.ImageWMS.prototype, "once", ol.source.ImageWMS.prototype.once);
goog.exportProperty(ol.source.ImageWMS.prototype, "un", ol.source.ImageWMS.prototype.un);
goog.exportProperty(ol.source.OSM.prototype, "setRenderReprojectionEdges", ol.source.OSM.prototype.setRenderReprojectionEdges);
goog.exportProperty(ol.source.OSM.prototype, "setTileGridForProjection", ol.source.OSM.prototype.setTileGridForProjection);
goog.exportProperty(ol.source.OSM.prototype, "getTileLoadFunction", ol.source.OSM.prototype.getTileLoadFunction);
goog.exportProperty(ol.source.OSM.prototype, "getTileUrlFunction", ol.source.OSM.prototype.getTileUrlFunction);
goog.exportProperty(ol.source.OSM.prototype, "getUrls", ol.source.OSM.prototype.getUrls);
goog.exportProperty(ol.source.OSM.prototype, "setTileLoadFunction", ol.source.OSM.prototype.setTileLoadFunction);
goog.exportProperty(ol.source.OSM.prototype, "setTileUrlFunction", ol.source.OSM.prototype.setTileUrlFunction);
goog.exportProperty(ol.source.OSM.prototype, "setUrl", ol.source.OSM.prototype.setUrl);
goog.exportProperty(ol.source.OSM.prototype, "setUrls", ol.source.OSM.prototype.setUrls);
goog.exportProperty(ol.source.OSM.prototype, "getTileGrid", ol.source.OSM.prototype.getTileGrid);
goog.exportProperty(ol.source.OSM.prototype, "refresh", ol.source.OSM.prototype.refresh);
goog.exportProperty(ol.source.OSM.prototype, "getAttributions", ol.source.OSM.prototype.getAttributions);
goog.exportProperty(ol.source.OSM.prototype, "getLogo", ol.source.OSM.prototype.getLogo);
goog.exportProperty(ol.source.OSM.prototype, "getProjection", ol.source.OSM.prototype.getProjection);
goog.exportProperty(ol.source.OSM.prototype, "getState", ol.source.OSM.prototype.getState);
goog.exportProperty(ol.source.OSM.prototype, "setAttributions", ol.source.OSM.prototype.setAttributions);
goog.exportProperty(ol.source.OSM.prototype, "get", ol.source.OSM.prototype.get);
goog.exportProperty(ol.source.OSM.prototype, "getKeys", ol.source.OSM.prototype.getKeys);
goog.exportProperty(ol.source.OSM.prototype, "getProperties", ol.source.OSM.prototype.getProperties);
goog.exportProperty(ol.source.OSM.prototype, "set", ol.source.OSM.prototype.set);
goog.exportProperty(ol.source.OSM.prototype, "setProperties", ol.source.OSM.prototype.setProperties);
goog.exportProperty(ol.source.OSM.prototype, "unset", ol.source.OSM.prototype.unset);
goog.exportProperty(ol.source.OSM.prototype, "changed", ol.source.OSM.prototype.changed);
goog.exportProperty(ol.source.OSM.prototype, "dispatchEvent", ol.source.OSM.prototype.dispatchEvent);
goog.exportProperty(ol.source.OSM.prototype, "getRevision", ol.source.OSM.prototype.getRevision);
goog.exportProperty(ol.source.OSM.prototype, "on", ol.source.OSM.prototype.on);
goog.exportProperty(ol.source.OSM.prototype, "once", ol.source.OSM.prototype.once);
goog.exportProperty(ol.source.OSM.prototype, "un", ol.source.OSM.prototype.un);
goog.exportProperty(ol.source.Raster.prototype, "getAttributions", ol.source.Raster.prototype.getAttributions);
goog.exportProperty(ol.source.Raster.prototype, "getLogo", ol.source.Raster.prototype.getLogo);
goog.exportProperty(ol.source.Raster.prototype, "getProjection", ol.source.Raster.prototype.getProjection);
goog.exportProperty(ol.source.Raster.prototype, "getState", ol.source.Raster.prototype.getState);
goog.exportProperty(ol.source.Raster.prototype, "refresh", ol.source.Raster.prototype.refresh);
goog.exportProperty(ol.source.Raster.prototype, "setAttributions", ol.source.Raster.prototype.setAttributions);
goog.exportProperty(ol.source.Raster.prototype, "get", ol.source.Raster.prototype.get);
goog.exportProperty(ol.source.Raster.prototype, "getKeys", ol.source.Raster.prototype.getKeys);
goog.exportProperty(ol.source.Raster.prototype, "getProperties", ol.source.Raster.prototype.getProperties);
goog.exportProperty(ol.source.Raster.prototype, "set", ol.source.Raster.prototype.set);
goog.exportProperty(ol.source.Raster.prototype, "setProperties", ol.source.Raster.prototype.setProperties);
goog.exportProperty(ol.source.Raster.prototype, "unset", ol.source.Raster.prototype.unset);
goog.exportProperty(ol.source.Raster.prototype, "changed", ol.source.Raster.prototype.changed);
goog.exportProperty(ol.source.Raster.prototype, "dispatchEvent", ol.source.Raster.prototype.dispatchEvent);
goog.exportProperty(ol.source.Raster.prototype, "getRevision", ol.source.Raster.prototype.getRevision);
goog.exportProperty(ol.source.Raster.prototype, "on", ol.source.Raster.prototype.on);
goog.exportProperty(ol.source.Raster.prototype, "once", ol.source.Raster.prototype.once);
goog.exportProperty(ol.source.Raster.prototype, "un", ol.source.Raster.prototype.un);
goog.exportProperty(ol.source.Raster.Event.prototype, "type", ol.source.Raster.Event.prototype.type);
goog.exportProperty(ol.source.Raster.Event.prototype, "target", ol.source.Raster.Event.prototype.target);
goog.exportProperty(ol.source.Raster.Event.prototype, "preventDefault", ol.source.Raster.Event.prototype.preventDefault);
goog.exportProperty(ol.source.Raster.Event.prototype, "stopPropagation", ol.source.Raster.Event.prototype.stopPropagation);
goog.exportProperty(ol.source.Stamen.prototype, "setRenderReprojectionEdges", ol.source.Stamen.prototype.setRenderReprojectionEdges);
goog.exportProperty(ol.source.Stamen.prototype, "setTileGridForProjection", ol.source.Stamen.prototype.setTileGridForProjection);
goog.exportProperty(ol.source.Stamen.prototype, "getTileLoadFunction", ol.source.Stamen.prototype.getTileLoadFunction);
goog.exportProperty(ol.source.Stamen.prototype, "getTileUrlFunction", ol.source.Stamen.prototype.getTileUrlFunction);
goog.exportProperty(ol.source.Stamen.prototype, "getUrls", ol.source.Stamen.prototype.getUrls);
goog.exportProperty(ol.source.Stamen.prototype, "setTileLoadFunction", ol.source.Stamen.prototype.setTileLoadFunction);
goog.exportProperty(ol.source.Stamen.prototype, "setTileUrlFunction", ol.source.Stamen.prototype.setTileUrlFunction);
goog.exportProperty(ol.source.Stamen.prototype, "setUrl", ol.source.Stamen.prototype.setUrl);
goog.exportProperty(ol.source.Stamen.prototype, "setUrls", ol.source.Stamen.prototype.setUrls);
goog.exportProperty(ol.source.Stamen.prototype, "getTileGrid", ol.source.Stamen.prototype.getTileGrid);
goog.exportProperty(ol.source.Stamen.prototype, "refresh", ol.source.Stamen.prototype.refresh);
goog.exportProperty(ol.source.Stamen.prototype, "getAttributions", ol.source.Stamen.prototype.getAttributions);
goog.exportProperty(ol.source.Stamen.prototype, "getLogo", ol.source.Stamen.prototype.getLogo);
goog.exportProperty(ol.source.Stamen.prototype, "getProjection", ol.source.Stamen.prototype.getProjection);
goog.exportProperty(ol.source.Stamen.prototype, "getState", ol.source.Stamen.prototype.getState);
goog.exportProperty(ol.source.Stamen.prototype, "setAttributions", ol.source.Stamen.prototype.setAttributions);
goog.exportProperty(ol.source.Stamen.prototype, "get", ol.source.Stamen.prototype.get);
goog.exportProperty(ol.source.Stamen.prototype, "getKeys", ol.source.Stamen.prototype.getKeys);
goog.exportProperty(ol.source.Stamen.prototype, "getProperties", ol.source.Stamen.prototype.getProperties);
goog.exportProperty(ol.source.Stamen.prototype, "set", ol.source.Stamen.prototype.set);
goog.exportProperty(ol.source.Stamen.prototype, "setProperties", ol.source.Stamen.prototype.setProperties);
goog.exportProperty(ol.source.Stamen.prototype, "unset", ol.source.Stamen.prototype.unset);
goog.exportProperty(ol.source.Stamen.prototype, "changed", ol.source.Stamen.prototype.changed);
goog.exportProperty(ol.source.Stamen.prototype, "dispatchEvent", ol.source.Stamen.prototype.dispatchEvent);
goog.exportProperty(ol.source.Stamen.prototype, "getRevision", ol.source.Stamen.prototype.getRevision);
goog.exportProperty(ol.source.Stamen.prototype, "on", ol.source.Stamen.prototype.on);
goog.exportProperty(ol.source.Stamen.prototype, "once", ol.source.Stamen.prototype.once);
goog.exportProperty(ol.source.Stamen.prototype, "un", ol.source.Stamen.prototype.un);
goog.exportProperty(ol.source.Tile.Event.prototype, "type", ol.source.Tile.Event.prototype.type);
goog.exportProperty(ol.source.Tile.Event.prototype, "target", ol.source.Tile.Event.prototype.target);
goog.exportProperty(ol.source.Tile.Event.prototype, "preventDefault", ol.source.Tile.Event.prototype.preventDefault);
goog.exportProperty(ol.source.Tile.Event.prototype, "stopPropagation", ol.source.Tile.Event.prototype.stopPropagation);
goog.exportProperty(ol.source.TileArcGISRest.prototype, "setRenderReprojectionEdges", ol.source.TileArcGISRest.prototype.setRenderReprojectionEdges);
goog.exportProperty(ol.source.TileArcGISRest.prototype, "setTileGridForProjection", ol.source.TileArcGISRest.prototype.setTileGridForProjection);
goog.exportProperty(ol.source.TileArcGISRest.prototype, "getTileLoadFunction", ol.source.TileArcGISRest.prototype.getTileLoadFunction);
goog.exportProperty(ol.source.TileArcGISRest.prototype, "getTileUrlFunction", ol.source.TileArcGISRest.prototype.getTileUrlFunction);
goog.exportProperty(ol.source.TileArcGISRest.prototype, "getUrls", ol.source.TileArcGISRest.prototype.getUrls);
goog.exportProperty(ol.source.TileArcGISRest.prototype, "setTileLoadFunction", ol.source.TileArcGISRest.prototype.setTileLoadFunction);
goog.exportProperty(ol.source.TileArcGISRest.prototype, "setTileUrlFunction", ol.source.TileArcGISRest.prototype.setTileUrlFunction);
goog.exportProperty(ol.source.TileArcGISRest.prototype, "setUrl", ol.source.TileArcGISRest.prototype.setUrl);
goog.exportProperty(ol.source.TileArcGISRest.prototype, "setUrls", ol.source.TileArcGISRest.prototype.setUrls);
goog.exportProperty(ol.source.TileArcGISRest.prototype, "getTileGrid", ol.source.TileArcGISRest.prototype.getTileGrid);
goog.exportProperty(ol.source.TileArcGISRest.prototype, "refresh", ol.source.TileArcGISRest.prototype.refresh);
goog.exportProperty(ol.source.TileArcGISRest.prototype, "getAttributions", ol.source.TileArcGISRest.prototype.getAttributions);
goog.exportProperty(ol.source.TileArcGISRest.prototype, "getLogo", ol.source.TileArcGISRest.prototype.getLogo);
goog.exportProperty(ol.source.TileArcGISRest.prototype, "getProjection", ol.source.TileArcGISRest.prototype.getProjection);
goog.exportProperty(ol.source.TileArcGISRest.prototype, "getState", ol.source.TileArcGISRest.prototype.getState);
goog.exportProperty(ol.source.TileArcGISRest.prototype, "setAttributions", ol.source.TileArcGISRest.prototype.setAttributions);
goog.exportProperty(ol.source.TileArcGISRest.prototype, "get", ol.source.TileArcGISRest.prototype.get);
goog.exportProperty(ol.source.TileArcGISRest.prototype, "getKeys", ol.source.TileArcGISRest.prototype.getKeys);
goog.exportProperty(ol.source.TileArcGISRest.prototype, "getProperties", ol.source.TileArcGISRest.prototype.getProperties);
goog.exportProperty(ol.source.TileArcGISRest.prototype, "set", ol.source.TileArcGISRest.prototype.set);
goog.exportProperty(ol.source.TileArcGISRest.prototype, "setProperties", ol.source.TileArcGISRest.prototype.setProperties);
goog.exportProperty(ol.source.TileArcGISRest.prototype, "unset", ol.source.TileArcGISRest.prototype.unset);
goog.exportProperty(ol.source.TileArcGISRest.prototype, "changed", ol.source.TileArcGISRest.prototype.changed);
goog.exportProperty(ol.source.TileArcGISRest.prototype, "dispatchEvent", ol.source.TileArcGISRest.prototype.dispatchEvent);
goog.exportProperty(ol.source.TileArcGISRest.prototype, "getRevision", ol.source.TileArcGISRest.prototype.getRevision);
goog.exportProperty(ol.source.TileArcGISRest.prototype, "on", ol.source.TileArcGISRest.prototype.on);
goog.exportProperty(ol.source.TileArcGISRest.prototype, "once", ol.source.TileArcGISRest.prototype.once);
goog.exportProperty(ol.source.TileArcGISRest.prototype, "un", ol.source.TileArcGISRest.prototype.un);
goog.exportProperty(ol.source.TileDebug.prototype, "getTileGrid", ol.source.TileDebug.prototype.getTileGrid);
goog.exportProperty(ol.source.TileDebug.prototype, "refresh", ol.source.TileDebug.prototype.refresh);
goog.exportProperty(ol.source.TileDebug.prototype, "getAttributions", ol.source.TileDebug.prototype.getAttributions);
goog.exportProperty(ol.source.TileDebug.prototype, "getLogo", ol.source.TileDebug.prototype.getLogo);
goog.exportProperty(ol.source.TileDebug.prototype, "getProjection", ol.source.TileDebug.prototype.getProjection);
goog.exportProperty(ol.source.TileDebug.prototype, "getState", ol.source.TileDebug.prototype.getState);
goog.exportProperty(ol.source.TileDebug.prototype, "setAttributions", ol.source.TileDebug.prototype.setAttributions);
goog.exportProperty(ol.source.TileDebug.prototype, "get", ol.source.TileDebug.prototype.get);
goog.exportProperty(ol.source.TileDebug.prototype, "getKeys", ol.source.TileDebug.prototype.getKeys);
goog.exportProperty(ol.source.TileDebug.prototype, "getProperties", ol.source.TileDebug.prototype.getProperties);
goog.exportProperty(ol.source.TileDebug.prototype, "set", ol.source.TileDebug.prototype.set);
goog.exportProperty(ol.source.TileDebug.prototype, "setProperties", ol.source.TileDebug.prototype.setProperties);
goog.exportProperty(ol.source.TileDebug.prototype, "unset", ol.source.TileDebug.prototype.unset);
goog.exportProperty(ol.source.TileDebug.prototype, "changed", ol.source.TileDebug.prototype.changed);
goog.exportProperty(ol.source.TileDebug.prototype, "dispatchEvent", ol.source.TileDebug.prototype.dispatchEvent);
goog.exportProperty(ol.source.TileDebug.prototype, "getRevision", ol.source.TileDebug.prototype.getRevision);
goog.exportProperty(ol.source.TileDebug.prototype, "on", ol.source.TileDebug.prototype.on);
goog.exportProperty(ol.source.TileDebug.prototype, "once", ol.source.TileDebug.prototype.once);
goog.exportProperty(ol.source.TileDebug.prototype, "un", ol.source.TileDebug.prototype.un);
goog.exportProperty(ol.source.TileJSON.prototype, "setRenderReprojectionEdges", ol.source.TileJSON.prototype.setRenderReprojectionEdges);
goog.exportProperty(ol.source.TileJSON.prototype, "setTileGridForProjection", ol.source.TileJSON.prototype.setTileGridForProjection);
goog.exportProperty(ol.source.TileJSON.prototype, "getTileLoadFunction", ol.source.TileJSON.prototype.getTileLoadFunction);
goog.exportProperty(ol.source.TileJSON.prototype, "getTileUrlFunction", ol.source.TileJSON.prototype.getTileUrlFunction);
goog.exportProperty(ol.source.TileJSON.prototype, "getUrls", ol.source.TileJSON.prototype.getUrls);
goog.exportProperty(ol.source.TileJSON.prototype, "setTileLoadFunction", ol.source.TileJSON.prototype.setTileLoadFunction);
goog.exportProperty(ol.source.TileJSON.prototype, "setTileUrlFunction", ol.source.TileJSON.prototype.setTileUrlFunction);
goog.exportProperty(ol.source.TileJSON.prototype, "setUrl", ol.source.TileJSON.prototype.setUrl);
goog.exportProperty(ol.source.TileJSON.prototype, "setUrls", ol.source.TileJSON.prototype.setUrls);
goog.exportProperty(ol.source.TileJSON.prototype, "getTileGrid", ol.source.TileJSON.prototype.getTileGrid);
goog.exportProperty(ol.source.TileJSON.prototype, "refresh", ol.source.TileJSON.prototype.refresh);
goog.exportProperty(ol.source.TileJSON.prototype, "getAttributions", ol.source.TileJSON.prototype.getAttributions);
goog.exportProperty(ol.source.TileJSON.prototype, "getLogo", ol.source.TileJSON.prototype.getLogo);
goog.exportProperty(ol.source.TileJSON.prototype, "getProjection", ol.source.TileJSON.prototype.getProjection);
goog.exportProperty(ol.source.TileJSON.prototype, "getState", ol.source.TileJSON.prototype.getState);
goog.exportProperty(ol.source.TileJSON.prototype, "setAttributions", ol.source.TileJSON.prototype.setAttributions);
goog.exportProperty(ol.source.TileJSON.prototype, "get", ol.source.TileJSON.prototype.get);
goog.exportProperty(ol.source.TileJSON.prototype, "getKeys", ol.source.TileJSON.prototype.getKeys);
goog.exportProperty(ol.source.TileJSON.prototype, "getProperties", ol.source.TileJSON.prototype.getProperties);
goog.exportProperty(ol.source.TileJSON.prototype, "set", ol.source.TileJSON.prototype.set);
goog.exportProperty(ol.source.TileJSON.prototype, "setProperties", ol.source.TileJSON.prototype.setProperties);
goog.exportProperty(ol.source.TileJSON.prototype, "unset", ol.source.TileJSON.prototype.unset);
goog.exportProperty(ol.source.TileJSON.prototype, "changed", ol.source.TileJSON.prototype.changed);
goog.exportProperty(ol.source.TileJSON.prototype, "dispatchEvent", ol.source.TileJSON.prototype.dispatchEvent);
goog.exportProperty(ol.source.TileJSON.prototype, "getRevision", ol.source.TileJSON.prototype.getRevision);
goog.exportProperty(ol.source.TileJSON.prototype, "on", ol.source.TileJSON.prototype.on);
goog.exportProperty(ol.source.TileJSON.prototype, "once", ol.source.TileJSON.prototype.once);
goog.exportProperty(ol.source.TileJSON.prototype, "un", ol.source.TileJSON.prototype.un);
goog.exportProperty(ol.source.TileUTFGrid.prototype, "getTileGrid", ol.source.TileUTFGrid.prototype.getTileGrid);
goog.exportProperty(ol.source.TileUTFGrid.prototype, "refresh", ol.source.TileUTFGrid.prototype.refresh);
goog.exportProperty(ol.source.TileUTFGrid.prototype, "getAttributions", ol.source.TileUTFGrid.prototype.getAttributions);
goog.exportProperty(ol.source.TileUTFGrid.prototype, "getLogo", ol.source.TileUTFGrid.prototype.getLogo);
goog.exportProperty(ol.source.TileUTFGrid.prototype, "getProjection", ol.source.TileUTFGrid.prototype.getProjection);
goog.exportProperty(ol.source.TileUTFGrid.prototype, "getState", ol.source.TileUTFGrid.prototype.getState);
goog.exportProperty(ol.source.TileUTFGrid.prototype, "setAttributions", ol.source.TileUTFGrid.prototype.setAttributions);
goog.exportProperty(ol.source.TileUTFGrid.prototype, "get", ol.source.TileUTFGrid.prototype.get);
goog.exportProperty(ol.source.TileUTFGrid.prototype, "getKeys", ol.source.TileUTFGrid.prototype.getKeys);
goog.exportProperty(ol.source.TileUTFGrid.prototype, "getProperties", ol.source.TileUTFGrid.prototype.getProperties);
goog.exportProperty(ol.source.TileUTFGrid.prototype, "set", ol.source.TileUTFGrid.prototype.set);
goog.exportProperty(ol.source.TileUTFGrid.prototype, "setProperties", ol.source.TileUTFGrid.prototype.setProperties);
goog.exportProperty(ol.source.TileUTFGrid.prototype, "unset", ol.source.TileUTFGrid.prototype.unset);
goog.exportProperty(ol.source.TileUTFGrid.prototype, "changed", ol.source.TileUTFGrid.prototype.changed);
goog.exportProperty(ol.source.TileUTFGrid.prototype, "dispatchEvent", ol.source.TileUTFGrid.prototype.dispatchEvent);
goog.exportProperty(ol.source.TileUTFGrid.prototype, "getRevision", ol.source.TileUTFGrid.prototype.getRevision);
goog.exportProperty(ol.source.TileUTFGrid.prototype, "on", ol.source.TileUTFGrid.prototype.on);
goog.exportProperty(ol.source.TileUTFGrid.prototype, "once", ol.source.TileUTFGrid.prototype.once);
goog.exportProperty(ol.source.TileUTFGrid.prototype, "un", ol.source.TileUTFGrid.prototype.un);
goog.exportProperty(ol.source.TileWMS.prototype, "setRenderReprojectionEdges", ol.source.TileWMS.prototype.setRenderReprojectionEdges);
goog.exportProperty(ol.source.TileWMS.prototype, "setTileGridForProjection", ol.source.TileWMS.prototype.setTileGridForProjection);
goog.exportProperty(ol.source.TileWMS.prototype, "getTileLoadFunction", ol.source.TileWMS.prototype.getTileLoadFunction);
goog.exportProperty(ol.source.TileWMS.prototype, "getTileUrlFunction", ol.source.TileWMS.prototype.getTileUrlFunction);
goog.exportProperty(ol.source.TileWMS.prototype, "getUrls", ol.source.TileWMS.prototype.getUrls);
goog.exportProperty(ol.source.TileWMS.prototype, "setTileLoadFunction", ol.source.TileWMS.prototype.setTileLoadFunction);
goog.exportProperty(ol.source.TileWMS.prototype, "setTileUrlFunction", ol.source.TileWMS.prototype.setTileUrlFunction);
goog.exportProperty(ol.source.TileWMS.prototype, "setUrl", ol.source.TileWMS.prototype.setUrl);
goog.exportProperty(ol.source.TileWMS.prototype, "setUrls", ol.source.TileWMS.prototype.setUrls);
goog.exportProperty(ol.source.TileWMS.prototype, "getTileGrid", ol.source.TileWMS.prototype.getTileGrid);
goog.exportProperty(ol.source.TileWMS.prototype, "refresh", ol.source.TileWMS.prototype.refresh);
goog.exportProperty(ol.source.TileWMS.prototype, "getAttributions", ol.source.TileWMS.prototype.getAttributions);
goog.exportProperty(ol.source.TileWMS.prototype, "getLogo", ol.source.TileWMS.prototype.getLogo);
goog.exportProperty(ol.source.TileWMS.prototype, "getProjection", ol.source.TileWMS.prototype.getProjection);
goog.exportProperty(ol.source.TileWMS.prototype, "getState", ol.source.TileWMS.prototype.getState);
goog.exportProperty(ol.source.TileWMS.prototype, "setAttributions", ol.source.TileWMS.prototype.setAttributions);
goog.exportProperty(ol.source.TileWMS.prototype, "get", ol.source.TileWMS.prototype.get);
goog.exportProperty(ol.source.TileWMS.prototype, "getKeys", ol.source.TileWMS.prototype.getKeys);
goog.exportProperty(ol.source.TileWMS.prototype, "getProperties", ol.source.TileWMS.prototype.getProperties);
goog.exportProperty(ol.source.TileWMS.prototype, "set", ol.source.TileWMS.prototype.set);
goog.exportProperty(ol.source.TileWMS.prototype, "setProperties", ol.source.TileWMS.prototype.setProperties);
goog.exportProperty(ol.source.TileWMS.prototype, "unset", ol.source.TileWMS.prototype.unset);
goog.exportProperty(ol.source.TileWMS.prototype, "changed", ol.source.TileWMS.prototype.changed);
goog.exportProperty(ol.source.TileWMS.prototype, "dispatchEvent", ol.source.TileWMS.prototype.dispatchEvent);
goog.exportProperty(ol.source.TileWMS.prototype, "getRevision", ol.source.TileWMS.prototype.getRevision);
goog.exportProperty(ol.source.TileWMS.prototype, "on", ol.source.TileWMS.prototype.on);
goog.exportProperty(ol.source.TileWMS.prototype, "once", ol.source.TileWMS.prototype.once);
goog.exportProperty(ol.source.TileWMS.prototype, "un", ol.source.TileWMS.prototype.un);
goog.exportProperty(ol.source.Vector.Event.prototype, "type", ol.source.Vector.Event.prototype.type);
goog.exportProperty(ol.source.Vector.Event.prototype, "target", ol.source.Vector.Event.prototype.target);
goog.exportProperty(ol.source.Vector.Event.prototype, "preventDefault", ol.source.Vector.Event.prototype.preventDefault);
goog.exportProperty(ol.source.Vector.Event.prototype, "stopPropagation", ol.source.Vector.Event.prototype.stopPropagation);
goog.exportProperty(ol.source.VectorTile.prototype, "getTileLoadFunction", ol.source.VectorTile.prototype.getTileLoadFunction);
goog.exportProperty(ol.source.VectorTile.prototype, "getTileUrlFunction", ol.source.VectorTile.prototype.getTileUrlFunction);
goog.exportProperty(ol.source.VectorTile.prototype, "getUrls", ol.source.VectorTile.prototype.getUrls);
goog.exportProperty(ol.source.VectorTile.prototype, "setTileLoadFunction", ol.source.VectorTile.prototype.setTileLoadFunction);
goog.exportProperty(ol.source.VectorTile.prototype, "setTileUrlFunction", ol.source.VectorTile.prototype.setTileUrlFunction);
goog.exportProperty(ol.source.VectorTile.prototype, "setUrl", ol.source.VectorTile.prototype.setUrl);
goog.exportProperty(ol.source.VectorTile.prototype, "setUrls", ol.source.VectorTile.prototype.setUrls);
goog.exportProperty(ol.source.VectorTile.prototype, "getTileGrid", ol.source.VectorTile.prototype.getTileGrid);
goog.exportProperty(ol.source.VectorTile.prototype, "refresh", ol.source.VectorTile.prototype.refresh);
goog.exportProperty(ol.source.VectorTile.prototype, "getAttributions", ol.source.VectorTile.prototype.getAttributions);
goog.exportProperty(ol.source.VectorTile.prototype, "getLogo", ol.source.VectorTile.prototype.getLogo);
goog.exportProperty(ol.source.VectorTile.prototype, "getProjection", ol.source.VectorTile.prototype.getProjection);
goog.exportProperty(ol.source.VectorTile.prototype, "getState", ol.source.VectorTile.prototype.getState);
goog.exportProperty(ol.source.VectorTile.prototype, "setAttributions", ol.source.VectorTile.prototype.setAttributions);
goog.exportProperty(ol.source.VectorTile.prototype, "get", ol.source.VectorTile.prototype.get);
goog.exportProperty(ol.source.VectorTile.prototype, "getKeys", ol.source.VectorTile.prototype.getKeys);
goog.exportProperty(ol.source.VectorTile.prototype, "getProperties", ol.source.VectorTile.prototype.getProperties);
goog.exportProperty(ol.source.VectorTile.prototype, "set", ol.source.VectorTile.prototype.set);
goog.exportProperty(ol.source.VectorTile.prototype, "setProperties", ol.source.VectorTile.prototype.setProperties);
goog.exportProperty(ol.source.VectorTile.prototype, "unset", ol.source.VectorTile.prototype.unset);
goog.exportProperty(ol.source.VectorTile.prototype, "changed", ol.source.VectorTile.prototype.changed);
goog.exportProperty(ol.source.VectorTile.prototype, "dispatchEvent", ol.source.VectorTile.prototype.dispatchEvent);
goog.exportProperty(ol.source.VectorTile.prototype, "getRevision", ol.source.VectorTile.prototype.getRevision);
goog.exportProperty(ol.source.VectorTile.prototype, "on", ol.source.VectorTile.prototype.on);
goog.exportProperty(ol.source.VectorTile.prototype, "once", ol.source.VectorTile.prototype.once);
goog.exportProperty(ol.source.VectorTile.prototype, "un", ol.source.VectorTile.prototype.un);
goog.exportProperty(ol.source.WMTS.prototype, "setRenderReprojectionEdges", ol.source.WMTS.prototype.setRenderReprojectionEdges);
goog.exportProperty(ol.source.WMTS.prototype, "setTileGridForProjection", ol.source.WMTS.prototype.setTileGridForProjection);
goog.exportProperty(ol.source.WMTS.prototype, "getTileLoadFunction", ol.source.WMTS.prototype.getTileLoadFunction);
goog.exportProperty(ol.source.WMTS.prototype, "getTileUrlFunction", ol.source.WMTS.prototype.getTileUrlFunction);
goog.exportProperty(ol.source.WMTS.prototype, "getUrls", ol.source.WMTS.prototype.getUrls);
goog.exportProperty(ol.source.WMTS.prototype, "setTileLoadFunction", ol.source.WMTS.prototype.setTileLoadFunction);
goog.exportProperty(ol.source.WMTS.prototype, "setTileUrlFunction", ol.source.WMTS.prototype.setTileUrlFunction);
goog.exportProperty(ol.source.WMTS.prototype, "setUrl", ol.source.WMTS.prototype.setUrl);
goog.exportProperty(ol.source.WMTS.prototype, "setUrls", ol.source.WMTS.prototype.setUrls);
goog.exportProperty(ol.source.WMTS.prototype, "getTileGrid", ol.source.WMTS.prototype.getTileGrid);
goog.exportProperty(ol.source.WMTS.prototype, "refresh", ol.source.WMTS.prototype.refresh);
goog.exportProperty(ol.source.WMTS.prototype, "getAttributions", ol.source.WMTS.prototype.getAttributions);
goog.exportProperty(ol.source.WMTS.prototype, "getLogo", ol.source.WMTS.prototype.getLogo);
goog.exportProperty(ol.source.WMTS.prototype, "getProjection", ol.source.WMTS.prototype.getProjection);
goog.exportProperty(ol.source.WMTS.prototype, "getState", ol.source.WMTS.prototype.getState);
goog.exportProperty(ol.source.WMTS.prototype, "setAttributions", ol.source.WMTS.prototype.setAttributions);
goog.exportProperty(ol.source.WMTS.prototype, "get", ol.source.WMTS.prototype.get);
goog.exportProperty(ol.source.WMTS.prototype, "getKeys", ol.source.WMTS.prototype.getKeys);
goog.exportProperty(ol.source.WMTS.prototype, "getProperties", ol.source.WMTS.prototype.getProperties);
goog.exportProperty(ol.source.WMTS.prototype, "set", ol.source.WMTS.prototype.set);
goog.exportProperty(ol.source.WMTS.prototype, "setProperties", ol.source.WMTS.prototype.setProperties);
goog.exportProperty(ol.source.WMTS.prototype, "unset", ol.source.WMTS.prototype.unset);
goog.exportProperty(ol.source.WMTS.prototype, "changed", ol.source.WMTS.prototype.changed);
goog.exportProperty(ol.source.WMTS.prototype, "dispatchEvent", ol.source.WMTS.prototype.dispatchEvent);
goog.exportProperty(ol.source.WMTS.prototype, "getRevision", ol.source.WMTS.prototype.getRevision);
goog.exportProperty(ol.source.WMTS.prototype, "on", ol.source.WMTS.prototype.on);
goog.exportProperty(ol.source.WMTS.prototype, "once", ol.source.WMTS.prototype.once);
goog.exportProperty(ol.source.WMTS.prototype, "un", ol.source.WMTS.prototype.un);
goog.exportProperty(ol.source.Zoomify.prototype, "setRenderReprojectionEdges", ol.source.Zoomify.prototype.setRenderReprojectionEdges);
goog.exportProperty(ol.source.Zoomify.prototype, "setTileGridForProjection", ol.source.Zoomify.prototype.setTileGridForProjection);
goog.exportProperty(ol.source.Zoomify.prototype, "getTileLoadFunction", ol.source.Zoomify.prototype.getTileLoadFunction);
goog.exportProperty(ol.source.Zoomify.prototype, "getTileUrlFunction", ol.source.Zoomify.prototype.getTileUrlFunction);
goog.exportProperty(ol.source.Zoomify.prototype, "getUrls", ol.source.Zoomify.prototype.getUrls);
goog.exportProperty(ol.source.Zoomify.prototype, "setTileLoadFunction", ol.source.Zoomify.prototype.setTileLoadFunction);
goog.exportProperty(ol.source.Zoomify.prototype, "setTileUrlFunction", ol.source.Zoomify.prototype.setTileUrlFunction);
goog.exportProperty(ol.source.Zoomify.prototype, "setUrl", ol.source.Zoomify.prototype.setUrl);
goog.exportProperty(ol.source.Zoomify.prototype, "setUrls", ol.source.Zoomify.prototype.setUrls);
goog.exportProperty(ol.source.Zoomify.prototype, "getTileGrid", ol.source.Zoomify.prototype.getTileGrid);
goog.exportProperty(ol.source.Zoomify.prototype, "refresh", ol.source.Zoomify.prototype.refresh);
goog.exportProperty(ol.source.Zoomify.prototype, "getAttributions", ol.source.Zoomify.prototype.getAttributions);
goog.exportProperty(ol.source.Zoomify.prototype, "getLogo", ol.source.Zoomify.prototype.getLogo);
goog.exportProperty(ol.source.Zoomify.prototype, "getProjection", ol.source.Zoomify.prototype.getProjection);
goog.exportProperty(ol.source.Zoomify.prototype, "getState", ol.source.Zoomify.prototype.getState);
goog.exportProperty(ol.source.Zoomify.prototype, "setAttributions", ol.source.Zoomify.prototype.setAttributions);
goog.exportProperty(ol.source.Zoomify.prototype, "get", ol.source.Zoomify.prototype.get);
goog.exportProperty(ol.source.Zoomify.prototype, "getKeys", ol.source.Zoomify.prototype.getKeys);
goog.exportProperty(ol.source.Zoomify.prototype, "getProperties", ol.source.Zoomify.prototype.getProperties);
goog.exportProperty(ol.source.Zoomify.prototype, "set", ol.source.Zoomify.prototype.set);
goog.exportProperty(ol.source.Zoomify.prototype, "setProperties", ol.source.Zoomify.prototype.setProperties);
goog.exportProperty(ol.source.Zoomify.prototype, "unset", ol.source.Zoomify.prototype.unset);
goog.exportProperty(ol.source.Zoomify.prototype, "changed", ol.source.Zoomify.prototype.changed);
goog.exportProperty(ol.source.Zoomify.prototype, "dispatchEvent", ol.source.Zoomify.prototype.dispatchEvent);
goog.exportProperty(ol.source.Zoomify.prototype, "getRevision", ol.source.Zoomify.prototype.getRevision);
goog.exportProperty(ol.source.Zoomify.prototype, "on", ol.source.Zoomify.prototype.on);
goog.exportProperty(ol.source.Zoomify.prototype, "once", ol.source.Zoomify.prototype.once);
goog.exportProperty(ol.source.Zoomify.prototype, "un", ol.source.Zoomify.prototype.un);
goog.exportProperty(ol.reproj.Tile.prototype, "getTileCoord", ol.reproj.Tile.prototype.getTileCoord);
goog.exportProperty(ol.reproj.Tile.prototype, "load", ol.reproj.Tile.prototype.load);
goog.exportProperty(ol.renderer.Layer.prototype, "changed", ol.renderer.Layer.prototype.changed);
goog.exportProperty(ol.renderer.Layer.prototype, "dispatchEvent", ol.renderer.Layer.prototype.dispatchEvent);
goog.exportProperty(ol.renderer.Layer.prototype, "getRevision", ol.renderer.Layer.prototype.getRevision);
goog.exportProperty(ol.renderer.Layer.prototype, "on", ol.renderer.Layer.prototype.on);
goog.exportProperty(ol.renderer.Layer.prototype, "once", ol.renderer.Layer.prototype.once);
goog.exportProperty(ol.renderer.Layer.prototype, "un", ol.renderer.Layer.prototype.un);
goog.exportProperty(ol.renderer.webgl.Layer.prototype, "changed", ol.renderer.webgl.Layer.prototype.changed);
goog.exportProperty(ol.renderer.webgl.Layer.prototype, "dispatchEvent", ol.renderer.webgl.Layer.prototype.dispatchEvent);
goog.exportProperty(ol.renderer.webgl.Layer.prototype, "getRevision", ol.renderer.webgl.Layer.prototype.getRevision);
goog.exportProperty(ol.renderer.webgl.Layer.prototype, "on", ol.renderer.webgl.Layer.prototype.on);
goog.exportProperty(ol.renderer.webgl.Layer.prototype, "once", ol.renderer.webgl.Layer.prototype.once);
goog.exportProperty(ol.renderer.webgl.Layer.prototype, "un", ol.renderer.webgl.Layer.prototype.un);
goog.exportProperty(ol.renderer.webgl.ImageLayer.prototype, "changed", ol.renderer.webgl.ImageLayer.prototype.changed);
goog.exportProperty(ol.renderer.webgl.ImageLayer.prototype, "dispatchEvent", ol.renderer.webgl.ImageLayer.prototype.dispatchEvent);
goog.exportProperty(ol.renderer.webgl.ImageLayer.prototype, "getRevision", ol.renderer.webgl.ImageLayer.prototype.getRevision);
goog.exportProperty(ol.renderer.webgl.ImageLayer.prototype, "on", ol.renderer.webgl.ImageLayer.prototype.on);
goog.exportProperty(ol.renderer.webgl.ImageLayer.prototype, "once", ol.renderer.webgl.ImageLayer.prototype.once);
goog.exportProperty(ol.renderer.webgl.ImageLayer.prototype, "un", ol.renderer.webgl.ImageLayer.prototype.un);
goog.exportProperty(ol.renderer.webgl.TileLayer.prototype, "changed", ol.renderer.webgl.TileLayer.prototype.changed);
goog.exportProperty(ol.renderer.webgl.TileLayer.prototype, "dispatchEvent", ol.renderer.webgl.TileLayer.prototype.dispatchEvent);
goog.exportProperty(ol.renderer.webgl.TileLayer.prototype, "getRevision", ol.renderer.webgl.TileLayer.prototype.getRevision);
goog.exportProperty(ol.renderer.webgl.TileLayer.prototype, "on", ol.renderer.webgl.TileLayer.prototype.on);
goog.exportProperty(ol.renderer.webgl.TileLayer.prototype, "once", ol.renderer.webgl.TileLayer.prototype.once);
goog.exportProperty(ol.renderer.webgl.TileLayer.prototype, "un", ol.renderer.webgl.TileLayer.prototype.un);
goog.exportProperty(ol.renderer.webgl.VectorLayer.prototype, "changed", ol.renderer.webgl.VectorLayer.prototype.changed);
goog.exportProperty(ol.renderer.webgl.VectorLayer.prototype, "dispatchEvent", ol.renderer.webgl.VectorLayer.prototype.dispatchEvent);
goog.exportProperty(ol.renderer.webgl.VectorLayer.prototype, "getRevision", ol.renderer.webgl.VectorLayer.prototype.getRevision);
goog.exportProperty(ol.renderer.webgl.VectorLayer.prototype, "on", ol.renderer.webgl.VectorLayer.prototype.on);
goog.exportProperty(ol.renderer.webgl.VectorLayer.prototype, "once", ol.renderer.webgl.VectorLayer.prototype.once);
goog.exportProperty(ol.renderer.webgl.VectorLayer.prototype, "un", ol.renderer.webgl.VectorLayer.prototype.un);
goog.exportProperty(ol.renderer.canvas.Layer.prototype, "changed", ol.renderer.canvas.Layer.prototype.changed);
goog.exportProperty(ol.renderer.canvas.Layer.prototype, "dispatchEvent", ol.renderer.canvas.Layer.prototype.dispatchEvent);
goog.exportProperty(ol.renderer.canvas.Layer.prototype, "getRevision", ol.renderer.canvas.Layer.prototype.getRevision);
goog.exportProperty(ol.renderer.canvas.Layer.prototype, "on", ol.renderer.canvas.Layer.prototype.on);
goog.exportProperty(ol.renderer.canvas.Layer.prototype, "once", ol.renderer.canvas.Layer.prototype.once);
goog.exportProperty(ol.renderer.canvas.Layer.prototype, "un", ol.renderer.canvas.Layer.prototype.un);
goog.exportProperty(ol.renderer.canvas.IntermediateCanvas.prototype, "changed", ol.renderer.canvas.IntermediateCanvas.prototype.changed);
goog.exportProperty(ol.renderer.canvas.IntermediateCanvas.prototype, "dispatchEvent", ol.renderer.canvas.IntermediateCanvas.prototype.dispatchEvent);
goog.exportProperty(ol.renderer.canvas.IntermediateCanvas.prototype, "getRevision", ol.renderer.canvas.IntermediateCanvas.prototype.getRevision);
goog.exportProperty(ol.renderer.canvas.IntermediateCanvas.prototype, "on", ol.renderer.canvas.IntermediateCanvas.prototype.on);
goog.exportProperty(ol.renderer.canvas.IntermediateCanvas.prototype, "once", ol.renderer.canvas.IntermediateCanvas.prototype.once);
goog.exportProperty(ol.renderer.canvas.IntermediateCanvas.prototype, "un", ol.renderer.canvas.IntermediateCanvas.prototype.un);
goog.exportProperty(ol.renderer.canvas.ImageLayer.prototype, "changed", ol.renderer.canvas.ImageLayer.prototype.changed);
goog.exportProperty(ol.renderer.canvas.ImageLayer.prototype, "dispatchEvent", ol.renderer.canvas.ImageLayer.prototype.dispatchEvent);
goog.exportProperty(ol.renderer.canvas.ImageLayer.prototype, "getRevision", ol.renderer.canvas.ImageLayer.prototype.getRevision);
goog.exportProperty(ol.renderer.canvas.ImageLayer.prototype, "on", ol.renderer.canvas.ImageLayer.prototype.on);
goog.exportProperty(ol.renderer.canvas.ImageLayer.prototype, "once", ol.renderer.canvas.ImageLayer.prototype.once);
goog.exportProperty(ol.renderer.canvas.ImageLayer.prototype, "un", ol.renderer.canvas.ImageLayer.prototype.un);
goog.exportProperty(ol.renderer.canvas.TileLayer.prototype, "changed", ol.renderer.canvas.TileLayer.prototype.changed);
goog.exportProperty(ol.renderer.canvas.TileLayer.prototype, "dispatchEvent", ol.renderer.canvas.TileLayer.prototype.dispatchEvent);
goog.exportProperty(ol.renderer.canvas.TileLayer.prototype, "getRevision", ol.renderer.canvas.TileLayer.prototype.getRevision);
goog.exportProperty(ol.renderer.canvas.TileLayer.prototype, "on", ol.renderer.canvas.TileLayer.prototype.on);
goog.exportProperty(ol.renderer.canvas.TileLayer.prototype, "once", ol.renderer.canvas.TileLayer.prototype.once);
goog.exportProperty(ol.renderer.canvas.TileLayer.prototype, "un", ol.renderer.canvas.TileLayer.prototype.un);
goog.exportProperty(ol.renderer.canvas.VectorLayer.prototype, "changed", ol.renderer.canvas.VectorLayer.prototype.changed);
goog.exportProperty(ol.renderer.canvas.VectorLayer.prototype, "dispatchEvent", ol.renderer.canvas.VectorLayer.prototype.dispatchEvent);
goog.exportProperty(ol.renderer.canvas.VectorLayer.prototype, "getRevision", ol.renderer.canvas.VectorLayer.prototype.getRevision);
goog.exportProperty(ol.renderer.canvas.VectorLayer.prototype, "on", ol.renderer.canvas.VectorLayer.prototype.on);
goog.exportProperty(ol.renderer.canvas.VectorLayer.prototype, "once", ol.renderer.canvas.VectorLayer.prototype.once);
goog.exportProperty(ol.renderer.canvas.VectorLayer.prototype, "un", ol.renderer.canvas.VectorLayer.prototype.un);
goog.exportProperty(ol.renderer.canvas.VectorTileLayer.prototype, "changed", ol.renderer.canvas.VectorTileLayer.prototype.changed);
goog.exportProperty(ol.renderer.canvas.VectorTileLayer.prototype, "dispatchEvent", ol.renderer.canvas.VectorTileLayer.prototype.dispatchEvent);
goog.exportProperty(ol.renderer.canvas.VectorTileLayer.prototype, "getRevision", ol.renderer.canvas.VectorTileLayer.prototype.getRevision);
goog.exportProperty(ol.renderer.canvas.VectorTileLayer.prototype, "on", ol.renderer.canvas.VectorTileLayer.prototype.on);
goog.exportProperty(ol.renderer.canvas.VectorTileLayer.prototype, "once", ol.renderer.canvas.VectorTileLayer.prototype.once);
goog.exportProperty(ol.renderer.canvas.VectorTileLayer.prototype, "un", ol.renderer.canvas.VectorTileLayer.prototype.un);
goog.exportProperty(ol.render.Event.prototype, "type", ol.render.Event.prototype.type);
goog.exportProperty(ol.render.Event.prototype, "target", ol.render.Event.prototype.target);
goog.exportProperty(ol.render.Event.prototype, "preventDefault", ol.render.Event.prototype.preventDefault);
goog.exportProperty(ol.render.Event.prototype, "stopPropagation", ol.render.Event.prototype.stopPropagation);
goog.exportProperty(ol.pointer.PointerEvent.prototype, "type", ol.pointer.PointerEvent.prototype.type);
goog.exportProperty(ol.pointer.PointerEvent.prototype, "target", ol.pointer.PointerEvent.prototype.target);
goog.exportProperty(ol.pointer.PointerEvent.prototype, "preventDefault", ol.pointer.PointerEvent.prototype.preventDefault);
goog.exportProperty(ol.pointer.PointerEvent.prototype, "stopPropagation", ol.pointer.PointerEvent.prototype.stopPropagation);
goog.exportProperty(ol.layer.Base.prototype, "get", ol.layer.Base.prototype.get);
goog.exportProperty(ol.layer.Base.prototype, "getKeys", ol.layer.Base.prototype.getKeys);
goog.exportProperty(ol.layer.Base.prototype, "getProperties", ol.layer.Base.prototype.getProperties);
goog.exportProperty(ol.layer.Base.prototype, "set", ol.layer.Base.prototype.set);
goog.exportProperty(ol.layer.Base.prototype, "setProperties", ol.layer.Base.prototype.setProperties);
goog.exportProperty(ol.layer.Base.prototype, "unset", ol.layer.Base.prototype.unset);
goog.exportProperty(ol.layer.Base.prototype, "changed", ol.layer.Base.prototype.changed);
goog.exportProperty(ol.layer.Base.prototype, "dispatchEvent", ol.layer.Base.prototype.dispatchEvent);
goog.exportProperty(ol.layer.Base.prototype, "getRevision", ol.layer.Base.prototype.getRevision);
goog.exportProperty(ol.layer.Base.prototype, "on", ol.layer.Base.prototype.on);
goog.exportProperty(ol.layer.Base.prototype, "once", ol.layer.Base.prototype.once);
goog.exportProperty(ol.layer.Base.prototype, "un", ol.layer.Base.prototype.un);
goog.exportProperty(ol.layer.Group.prototype, "getExtent", ol.layer.Group.prototype.getExtent);
goog.exportProperty(ol.layer.Group.prototype, "getMaxResolution", ol.layer.Group.prototype.getMaxResolution);
goog.exportProperty(ol.layer.Group.prototype, "getMinResolution", ol.layer.Group.prototype.getMinResolution);
goog.exportProperty(ol.layer.Group.prototype, "getOpacity", ol.layer.Group.prototype.getOpacity);
goog.exportProperty(ol.layer.Group.prototype, "getVisible", ol.layer.Group.prototype.getVisible);
goog.exportProperty(ol.layer.Group.prototype, "getZIndex", ol.layer.Group.prototype.getZIndex);
goog.exportProperty(ol.layer.Group.prototype, "setExtent", ol.layer.Group.prototype.setExtent);
goog.exportProperty(ol.layer.Group.prototype, "setMaxResolution", ol.layer.Group.prototype.setMaxResolution);
goog.exportProperty(ol.layer.Group.prototype, "setMinResolution", ol.layer.Group.prototype.setMinResolution);
goog.exportProperty(ol.layer.Group.prototype, "setOpacity", ol.layer.Group.prototype.setOpacity);
goog.exportProperty(ol.layer.Group.prototype, "setVisible", ol.layer.Group.prototype.setVisible);
goog.exportProperty(ol.layer.Group.prototype, "setZIndex", ol.layer.Group.prototype.setZIndex);
goog.exportProperty(ol.layer.Group.prototype, "get", ol.layer.Group.prototype.get);
goog.exportProperty(ol.layer.Group.prototype, "getKeys", ol.layer.Group.prototype.getKeys);
goog.exportProperty(ol.layer.Group.prototype, "getProperties", ol.layer.Group.prototype.getProperties);
goog.exportProperty(ol.layer.Group.prototype, "set", ol.layer.Group.prototype.set);
goog.exportProperty(ol.layer.Group.prototype, "setProperties", ol.layer.Group.prototype.setProperties);
goog.exportProperty(ol.layer.Group.prototype, "unset", ol.layer.Group.prototype.unset);
goog.exportProperty(ol.layer.Group.prototype, "changed", ol.layer.Group.prototype.changed);
goog.exportProperty(ol.layer.Group.prototype, "dispatchEvent", ol.layer.Group.prototype.dispatchEvent);
goog.exportProperty(ol.layer.Group.prototype, "getRevision", ol.layer.Group.prototype.getRevision);
goog.exportProperty(ol.layer.Group.prototype, "on", ol.layer.Group.prototype.on);
goog.exportProperty(ol.layer.Group.prototype, "once", ol.layer.Group.prototype.once);
goog.exportProperty(ol.layer.Group.prototype, "un", ol.layer.Group.prototype.un);
goog.exportProperty(ol.layer.Layer.prototype, "getExtent", ol.layer.Layer.prototype.getExtent);
goog.exportProperty(ol.layer.Layer.prototype, "getMaxResolution", ol.layer.Layer.prototype.getMaxResolution);
goog.exportProperty(ol.layer.Layer.prototype, "getMinResolution", ol.layer.Layer.prototype.getMinResolution);
goog.exportProperty(ol.layer.Layer.prototype, "getOpacity", ol.layer.Layer.prototype.getOpacity);
goog.exportProperty(ol.layer.Layer.prototype, "getVisible", ol.layer.Layer.prototype.getVisible);
goog.exportProperty(ol.layer.Layer.prototype, "getZIndex", ol.layer.Layer.prototype.getZIndex);
goog.exportProperty(ol.layer.Layer.prototype, "setExtent", ol.layer.Layer.prototype.setExtent);
goog.exportProperty(ol.layer.Layer.prototype, "setMaxResolution", ol.layer.Layer.prototype.setMaxResolution);
goog.exportProperty(ol.layer.Layer.prototype, "setMinResolution", ol.layer.Layer.prototype.setMinResolution);
goog.exportProperty(ol.layer.Layer.prototype, "setOpacity", ol.layer.Layer.prototype.setOpacity);
goog.exportProperty(ol.layer.Layer.prototype, "setVisible", ol.layer.Layer.prototype.setVisible);
goog.exportProperty(ol.layer.Layer.prototype, "setZIndex", ol.layer.Layer.prototype.setZIndex);
goog.exportProperty(ol.layer.Layer.prototype, "get", ol.layer.Layer.prototype.get);
goog.exportProperty(ol.layer.Layer.prototype, "getKeys", ol.layer.Layer.prototype.getKeys);
goog.exportProperty(ol.layer.Layer.prototype, "getProperties", ol.layer.Layer.prototype.getProperties);
goog.exportProperty(ol.layer.Layer.prototype, "set", ol.layer.Layer.prototype.set);
goog.exportProperty(ol.layer.Layer.prototype, "setProperties", ol.layer.Layer.prototype.setProperties);
goog.exportProperty(ol.layer.Layer.prototype, "unset", ol.layer.Layer.prototype.unset);
goog.exportProperty(ol.layer.Layer.prototype, "changed", ol.layer.Layer.prototype.changed);
goog.exportProperty(ol.layer.Layer.prototype, "dispatchEvent", ol.layer.Layer.prototype.dispatchEvent);
goog.exportProperty(ol.layer.Layer.prototype, "getRevision", ol.layer.Layer.prototype.getRevision);
goog.exportProperty(ol.layer.Layer.prototype, "on", ol.layer.Layer.prototype.on);
goog.exportProperty(ol.layer.Layer.prototype, "once", ol.layer.Layer.prototype.once);
goog.exportProperty(ol.layer.Layer.prototype, "un", ol.layer.Layer.prototype.un);
goog.exportProperty(ol.layer.Vector.prototype, "setMap", ol.layer.Vector.prototype.setMap);
goog.exportProperty(ol.layer.Vector.prototype, "setSource", ol.layer.Vector.prototype.setSource);
goog.exportProperty(ol.layer.Vector.prototype, "getExtent", ol.layer.Vector.prototype.getExtent);
goog.exportProperty(ol.layer.Vector.prototype, "getMaxResolution", ol.layer.Vector.prototype.getMaxResolution);
goog.exportProperty(ol.layer.Vector.prototype, "getMinResolution", ol.layer.Vector.prototype.getMinResolution);
goog.exportProperty(ol.layer.Vector.prototype, "getOpacity", ol.layer.Vector.prototype.getOpacity);
goog.exportProperty(ol.layer.Vector.prototype, "getVisible", ol.layer.Vector.prototype.getVisible);
goog.exportProperty(ol.layer.Vector.prototype, "getZIndex", ol.layer.Vector.prototype.getZIndex);
goog.exportProperty(ol.layer.Vector.prototype, "setExtent", ol.layer.Vector.prototype.setExtent);
goog.exportProperty(ol.layer.Vector.prototype, "setMaxResolution", ol.layer.Vector.prototype.setMaxResolution);
goog.exportProperty(ol.layer.Vector.prototype, "setMinResolution", ol.layer.Vector.prototype.setMinResolution);
goog.exportProperty(ol.layer.Vector.prototype, "setOpacity", ol.layer.Vector.prototype.setOpacity);
goog.exportProperty(ol.layer.Vector.prototype, "setVisible", ol.layer.Vector.prototype.setVisible);
goog.exportProperty(ol.layer.Vector.prototype, "setZIndex", ol.layer.Vector.prototype.setZIndex);
goog.exportProperty(ol.layer.Vector.prototype, "get", ol.layer.Vector.prototype.get);
goog.exportProperty(ol.layer.Vector.prototype, "getKeys", ol.layer.Vector.prototype.getKeys);
goog.exportProperty(ol.layer.Vector.prototype, "getProperties", ol.layer.Vector.prototype.getProperties);
goog.exportProperty(ol.layer.Vector.prototype, "set", ol.layer.Vector.prototype.set);
goog.exportProperty(ol.layer.Vector.prototype, "setProperties", ol.layer.Vector.prototype.setProperties);
goog.exportProperty(ol.layer.Vector.prototype, "unset", ol.layer.Vector.prototype.unset);
goog.exportProperty(ol.layer.Vector.prototype, "changed", ol.layer.Vector.prototype.changed);
goog.exportProperty(ol.layer.Vector.prototype, "dispatchEvent", ol.layer.Vector.prototype.dispatchEvent);
goog.exportProperty(ol.layer.Vector.prototype, "getRevision", ol.layer.Vector.prototype.getRevision);
goog.exportProperty(ol.layer.Vector.prototype, "on", ol.layer.Vector.prototype.on);
goog.exportProperty(ol.layer.Vector.prototype, "once", ol.layer.Vector.prototype.once);
goog.exportProperty(ol.layer.Vector.prototype, "un", ol.layer.Vector.prototype.un);
goog.exportProperty(ol.layer.Heatmap.prototype, "getSource", ol.layer.Heatmap.prototype.getSource);
goog.exportProperty(ol.layer.Heatmap.prototype, "getStyle", ol.layer.Heatmap.prototype.getStyle);
goog.exportProperty(ol.layer.Heatmap.prototype, "getStyleFunction", ol.layer.Heatmap.prototype.getStyleFunction);
goog.exportProperty(ol.layer.Heatmap.prototype, "setStyle", ol.layer.Heatmap.prototype.setStyle);
goog.exportProperty(ol.layer.Heatmap.prototype, "setMap", ol.layer.Heatmap.prototype.setMap);
goog.exportProperty(ol.layer.Heatmap.prototype, "setSource", ol.layer.Heatmap.prototype.setSource);
goog.exportProperty(ol.layer.Heatmap.prototype, "getExtent", ol.layer.Heatmap.prototype.getExtent);
goog.exportProperty(ol.layer.Heatmap.prototype, "getMaxResolution", ol.layer.Heatmap.prototype.getMaxResolution);
goog.exportProperty(ol.layer.Heatmap.prototype, "getMinResolution", ol.layer.Heatmap.prototype.getMinResolution);
goog.exportProperty(ol.layer.Heatmap.prototype, "getOpacity", ol.layer.Heatmap.prototype.getOpacity);
goog.exportProperty(ol.layer.Heatmap.prototype, "getVisible", ol.layer.Heatmap.prototype.getVisible);
goog.exportProperty(ol.layer.Heatmap.prototype, "getZIndex", ol.layer.Heatmap.prototype.getZIndex);
goog.exportProperty(ol.layer.Heatmap.prototype, "setExtent", ol.layer.Heatmap.prototype.setExtent);
goog.exportProperty(ol.layer.Heatmap.prototype, "setMaxResolution", ol.layer.Heatmap.prototype.setMaxResolution);
goog.exportProperty(ol.layer.Heatmap.prototype, "setMinResolution", ol.layer.Heatmap.prototype.setMinResolution);
goog.exportProperty(ol.layer.Heatmap.prototype, "setOpacity", ol.layer.Heatmap.prototype.setOpacity);
goog.exportProperty(ol.layer.Heatmap.prototype, "setVisible", ol.layer.Heatmap.prototype.setVisible);
goog.exportProperty(ol.layer.Heatmap.prototype, "setZIndex", ol.layer.Heatmap.prototype.setZIndex);
goog.exportProperty(ol.layer.Heatmap.prototype, "get", ol.layer.Heatmap.prototype.get);
goog.exportProperty(ol.layer.Heatmap.prototype, "getKeys", ol.layer.Heatmap.prototype.getKeys);
goog.exportProperty(ol.layer.Heatmap.prototype, "getProperties", ol.layer.Heatmap.prototype.getProperties);
goog.exportProperty(ol.layer.Heatmap.prototype, "set", ol.layer.Heatmap.prototype.set);
goog.exportProperty(ol.layer.Heatmap.prototype, "setProperties", ol.layer.Heatmap.prototype.setProperties);
goog.exportProperty(ol.layer.Heatmap.prototype, "unset", ol.layer.Heatmap.prototype.unset);
goog.exportProperty(ol.layer.Heatmap.prototype, "changed", ol.layer.Heatmap.prototype.changed);
goog.exportProperty(ol.layer.Heatmap.prototype, "dispatchEvent", ol.layer.Heatmap.prototype.dispatchEvent);
goog.exportProperty(ol.layer.Heatmap.prototype, "getRevision", ol.layer.Heatmap.prototype.getRevision);
goog.exportProperty(ol.layer.Heatmap.prototype, "on", ol.layer.Heatmap.prototype.on);
goog.exportProperty(ol.layer.Heatmap.prototype, "once", ol.layer.Heatmap.prototype.once);
goog.exportProperty(ol.layer.Heatmap.prototype, "un", ol.layer.Heatmap.prototype.un);
goog.exportProperty(ol.layer.Image.prototype, "setMap", ol.layer.Image.prototype.setMap);
goog.exportProperty(ol.layer.Image.prototype, "setSource", ol.layer.Image.prototype.setSource);
goog.exportProperty(ol.layer.Image.prototype, "getExtent", ol.layer.Image.prototype.getExtent);
goog.exportProperty(ol.layer.Image.prototype, "getMaxResolution", ol.layer.Image.prototype.getMaxResolution);
goog.exportProperty(ol.layer.Image.prototype, "getMinResolution", ol.layer.Image.prototype.getMinResolution);
goog.exportProperty(ol.layer.Image.prototype, "getOpacity", ol.layer.Image.prototype.getOpacity);
goog.exportProperty(ol.layer.Image.prototype, "getVisible", ol.layer.Image.prototype.getVisible);
goog.exportProperty(ol.layer.Image.prototype, "getZIndex", ol.layer.Image.prototype.getZIndex);
goog.exportProperty(ol.layer.Image.prototype, "setExtent", ol.layer.Image.prototype.setExtent);
goog.exportProperty(ol.layer.Image.prototype, "setMaxResolution", ol.layer.Image.prototype.setMaxResolution);
goog.exportProperty(ol.layer.Image.prototype, "setMinResolution", ol.layer.Image.prototype.setMinResolution);
goog.exportProperty(ol.layer.Image.prototype, "setOpacity", ol.layer.Image.prototype.setOpacity);
goog.exportProperty(ol.layer.Image.prototype, "setVisible", ol.layer.Image.prototype.setVisible);
goog.exportProperty(ol.layer.Image.prototype, "setZIndex", ol.layer.Image.prototype.setZIndex);
goog.exportProperty(ol.layer.Image.prototype, "get", ol.layer.Image.prototype.get);
goog.exportProperty(ol.layer.Image.prototype, "getKeys", ol.layer.Image.prototype.getKeys);
goog.exportProperty(ol.layer.Image.prototype, "getProperties", ol.layer.Image.prototype.getProperties);
goog.exportProperty(ol.layer.Image.prototype, "set", ol.layer.Image.prototype.set);
goog.exportProperty(ol.layer.Image.prototype, "setProperties", ol.layer.Image.prototype.setProperties);
goog.exportProperty(ol.layer.Image.prototype, "unset", ol.layer.Image.prototype.unset);
goog.exportProperty(ol.layer.Image.prototype, "changed", ol.layer.Image.prototype.changed);
goog.exportProperty(ol.layer.Image.prototype, "dispatchEvent", ol.layer.Image.prototype.dispatchEvent);
goog.exportProperty(ol.layer.Image.prototype, "getRevision", ol.layer.Image.prototype.getRevision);
goog.exportProperty(ol.layer.Image.prototype, "on", ol.layer.Image.prototype.on);
goog.exportProperty(ol.layer.Image.prototype, "once", ol.layer.Image.prototype.once);
goog.exportProperty(ol.layer.Image.prototype, "un", ol.layer.Image.prototype.un);
goog.exportProperty(ol.layer.Tile.prototype, "setMap", ol.layer.Tile.prototype.setMap);
goog.exportProperty(ol.layer.Tile.prototype, "setSource", ol.layer.Tile.prototype.setSource);
goog.exportProperty(ol.layer.Tile.prototype, "getExtent", ol.layer.Tile.prototype.getExtent);
goog.exportProperty(ol.layer.Tile.prototype, "getMaxResolution", ol.layer.Tile.prototype.getMaxResolution);
goog.exportProperty(ol.layer.Tile.prototype, "getMinResolution", ol.layer.Tile.prototype.getMinResolution);
goog.exportProperty(ol.layer.Tile.prototype, "getOpacity", ol.layer.Tile.prototype.getOpacity);
goog.exportProperty(ol.layer.Tile.prototype, "getVisible", ol.layer.Tile.prototype.getVisible);
goog.exportProperty(ol.layer.Tile.prototype, "getZIndex", ol.layer.Tile.prototype.getZIndex);
goog.exportProperty(ol.layer.Tile.prototype, "setExtent", ol.layer.Tile.prototype.setExtent);
goog.exportProperty(ol.layer.Tile.prototype, "setMaxResolution", ol.layer.Tile.prototype.setMaxResolution);
goog.exportProperty(ol.layer.Tile.prototype, "setMinResolution", ol.layer.Tile.prototype.setMinResolution);
goog.exportProperty(ol.layer.Tile.prototype, "setOpacity", ol.layer.Tile.prototype.setOpacity);
goog.exportProperty(ol.layer.Tile.prototype, "setVisible", ol.layer.Tile.prototype.setVisible);
goog.exportProperty(ol.layer.Tile.prototype, "setZIndex", ol.layer.Tile.prototype.setZIndex);
goog.exportProperty(ol.layer.Tile.prototype, "get", ol.layer.Tile.prototype.get);
goog.exportProperty(ol.layer.Tile.prototype, "getKeys", ol.layer.Tile.prototype.getKeys);
goog.exportProperty(ol.layer.Tile.prototype, "getProperties", ol.layer.Tile.prototype.getProperties);
goog.exportProperty(ol.layer.Tile.prototype, "set", ol.layer.Tile.prototype.set);
goog.exportProperty(ol.layer.Tile.prototype, "setProperties", ol.layer.Tile.prototype.setProperties);
goog.exportProperty(ol.layer.Tile.prototype, "unset", ol.layer.Tile.prototype.unset);
goog.exportProperty(ol.layer.Tile.prototype, "changed", ol.layer.Tile.prototype.changed);
goog.exportProperty(ol.layer.Tile.prototype, "dispatchEvent", ol.layer.Tile.prototype.dispatchEvent);
goog.exportProperty(ol.layer.Tile.prototype, "getRevision", ol.layer.Tile.prototype.getRevision);
goog.exportProperty(ol.layer.Tile.prototype, "on", ol.layer.Tile.prototype.on);
goog.exportProperty(ol.layer.Tile.prototype, "once", ol.layer.Tile.prototype.once);
goog.exportProperty(ol.layer.Tile.prototype, "un", ol.layer.Tile.prototype.un);
goog.exportProperty(ol.layer.VectorTile.prototype, "getStyle", ol.layer.VectorTile.prototype.getStyle);
goog.exportProperty(ol.layer.VectorTile.prototype, "getStyleFunction", ol.layer.VectorTile.prototype.getStyleFunction);
goog.exportProperty(ol.layer.VectorTile.prototype, "setStyle", ol.layer.VectorTile.prototype.setStyle);
goog.exportProperty(ol.layer.VectorTile.prototype, "setMap", ol.layer.VectorTile.prototype.setMap);
goog.exportProperty(ol.layer.VectorTile.prototype, "setSource", ol.layer.VectorTile.prototype.setSource);
goog.exportProperty(ol.layer.VectorTile.prototype, "getExtent", ol.layer.VectorTile.prototype.getExtent);
goog.exportProperty(ol.layer.VectorTile.prototype, "getMaxResolution", ol.layer.VectorTile.prototype.getMaxResolution);
goog.exportProperty(ol.layer.VectorTile.prototype, "getMinResolution", ol.layer.VectorTile.prototype.getMinResolution);
goog.exportProperty(ol.layer.VectorTile.prototype, "getOpacity", ol.layer.VectorTile.prototype.getOpacity);
goog.exportProperty(ol.layer.VectorTile.prototype, "getVisible", ol.layer.VectorTile.prototype.getVisible);
goog.exportProperty(ol.layer.VectorTile.prototype, "getZIndex", ol.layer.VectorTile.prototype.getZIndex);
goog.exportProperty(ol.layer.VectorTile.prototype, "setExtent", ol.layer.VectorTile.prototype.setExtent);
goog.exportProperty(ol.layer.VectorTile.prototype, "setMaxResolution", ol.layer.VectorTile.prototype.setMaxResolution);
goog.exportProperty(ol.layer.VectorTile.prototype, "setMinResolution", ol.layer.VectorTile.prototype.setMinResolution);
goog.exportProperty(ol.layer.VectorTile.prototype, "setOpacity", ol.layer.VectorTile.prototype.setOpacity);
goog.exportProperty(ol.layer.VectorTile.prototype, "setVisible", ol.layer.VectorTile.prototype.setVisible);
goog.exportProperty(ol.layer.VectorTile.prototype, "setZIndex", ol.layer.VectorTile.prototype.setZIndex);
goog.exportProperty(ol.layer.VectorTile.prototype, "get", ol.layer.VectorTile.prototype.get);
goog.exportProperty(ol.layer.VectorTile.prototype, "getKeys", ol.layer.VectorTile.prototype.getKeys);
goog.exportProperty(ol.layer.VectorTile.prototype, "getProperties", ol.layer.VectorTile.prototype.getProperties);
goog.exportProperty(ol.layer.VectorTile.prototype, "set", ol.layer.VectorTile.prototype.set);
goog.exportProperty(ol.layer.VectorTile.prototype, "setProperties", ol.layer.VectorTile.prototype.setProperties);
goog.exportProperty(ol.layer.VectorTile.prototype, "unset", ol.layer.VectorTile.prototype.unset);
goog.exportProperty(ol.layer.VectorTile.prototype, "changed", ol.layer.VectorTile.prototype.changed);
goog.exportProperty(ol.layer.VectorTile.prototype, "dispatchEvent", ol.layer.VectorTile.prototype.dispatchEvent);
goog.exportProperty(ol.layer.VectorTile.prototype, "getRevision", ol.layer.VectorTile.prototype.getRevision);
goog.exportProperty(ol.layer.VectorTile.prototype, "on", ol.layer.VectorTile.prototype.on);
goog.exportProperty(ol.layer.VectorTile.prototype, "once", ol.layer.VectorTile.prototype.once);
goog.exportProperty(ol.layer.VectorTile.prototype, "un", ol.layer.VectorTile.prototype.un);
goog.exportProperty(ol.interaction.Interaction.prototype, "get", ol.interaction.Interaction.prototype.get);
goog.exportProperty(ol.interaction.Interaction.prototype, "getKeys", ol.interaction.Interaction.prototype.getKeys);
goog.exportProperty(ol.interaction.Interaction.prototype, "getProperties", ol.interaction.Interaction.prototype.getProperties);
goog.exportProperty(ol.interaction.Interaction.prototype, "set", ol.interaction.Interaction.prototype.set);
goog.exportProperty(ol.interaction.Interaction.prototype, "setProperties", ol.interaction.Interaction.prototype.setProperties);
goog.exportProperty(ol.interaction.Interaction.prototype, "unset", ol.interaction.Interaction.prototype.unset);
goog.exportProperty(ol.interaction.Interaction.prototype, "changed", ol.interaction.Interaction.prototype.changed);
goog.exportProperty(ol.interaction.Interaction.prototype, "dispatchEvent", ol.interaction.Interaction.prototype.dispatchEvent);
goog.exportProperty(ol.interaction.Interaction.prototype, "getRevision", ol.interaction.Interaction.prototype.getRevision);
goog.exportProperty(ol.interaction.Interaction.prototype, "on", ol.interaction.Interaction.prototype.on);
goog.exportProperty(ol.interaction.Interaction.prototype, "once", ol.interaction.Interaction.prototype.once);
goog.exportProperty(ol.interaction.Interaction.prototype, "un", ol.interaction.Interaction.prototype.un);
goog.exportProperty(ol.interaction.DoubleClickZoom.prototype, "getActive", ol.interaction.DoubleClickZoom.prototype.getActive);
goog.exportProperty(ol.interaction.DoubleClickZoom.prototype, "getMap", ol.interaction.DoubleClickZoom.prototype.getMap);
goog.exportProperty(ol.interaction.DoubleClickZoom.prototype, "setActive", ol.interaction.DoubleClickZoom.prototype.setActive);
goog.exportProperty(ol.interaction.DoubleClickZoom.prototype, "get", ol.interaction.DoubleClickZoom.prototype.get);
goog.exportProperty(ol.interaction.DoubleClickZoom.prototype, "getKeys", ol.interaction.DoubleClickZoom.prototype.getKeys);
goog.exportProperty(ol.interaction.DoubleClickZoom.prototype, "getProperties", ol.interaction.DoubleClickZoom.prototype.getProperties);
goog.exportProperty(ol.interaction.DoubleClickZoom.prototype, "set", ol.interaction.DoubleClickZoom.prototype.set);
goog.exportProperty(ol.interaction.DoubleClickZoom.prototype, "setProperties", ol.interaction.DoubleClickZoom.prototype.setProperties);
goog.exportProperty(ol.interaction.DoubleClickZoom.prototype, "unset", ol.interaction.DoubleClickZoom.prototype.unset);
goog.exportProperty(ol.interaction.DoubleClickZoom.prototype, "changed", ol.interaction.DoubleClickZoom.prototype.changed);
goog.exportProperty(ol.interaction.DoubleClickZoom.prototype, "dispatchEvent", ol.interaction.DoubleClickZoom.prototype.dispatchEvent);
goog.exportProperty(ol.interaction.DoubleClickZoom.prototype, "getRevision", ol.interaction.DoubleClickZoom.prototype.getRevision);
goog.exportProperty(ol.interaction.DoubleClickZoom.prototype, "on", ol.interaction.DoubleClickZoom.prototype.on);
goog.exportProperty(ol.interaction.DoubleClickZoom.prototype, "once", ol.interaction.DoubleClickZoom.prototype.once);
goog.exportProperty(ol.interaction.DoubleClickZoom.prototype, "un", ol.interaction.DoubleClickZoom.prototype.un);
goog.exportProperty(ol.interaction.DragAndDrop.prototype, "getActive", ol.interaction.DragAndDrop.prototype.getActive);
goog.exportProperty(ol.interaction.DragAndDrop.prototype, "getMap", ol.interaction.DragAndDrop.prototype.getMap);
goog.exportProperty(ol.interaction.DragAndDrop.prototype, "setActive", ol.interaction.DragAndDrop.prototype.setActive);
goog.exportProperty(ol.interaction.DragAndDrop.prototype, "get", ol.interaction.DragAndDrop.prototype.get);
goog.exportProperty(ol.interaction.DragAndDrop.prototype, "getKeys", ol.interaction.DragAndDrop.prototype.getKeys);
goog.exportProperty(ol.interaction.DragAndDrop.prototype, "getProperties", ol.interaction.DragAndDrop.prototype.getProperties);
goog.exportProperty(ol.interaction.DragAndDrop.prototype, "set", ol.interaction.DragAndDrop.prototype.set);
goog.exportProperty(ol.interaction.DragAndDrop.prototype, "setProperties", ol.interaction.DragAndDrop.prototype.setProperties);
goog.exportProperty(ol.interaction.DragAndDrop.prototype, "unset", ol.interaction.DragAndDrop.prototype.unset);
goog.exportProperty(ol.interaction.DragAndDrop.prototype, "changed", ol.interaction.DragAndDrop.prototype.changed);
goog.exportProperty(ol.interaction.DragAndDrop.prototype, "dispatchEvent", ol.interaction.DragAndDrop.prototype.dispatchEvent);
goog.exportProperty(ol.interaction.DragAndDrop.prototype, "getRevision", ol.interaction.DragAndDrop.prototype.getRevision);
goog.exportProperty(ol.interaction.DragAndDrop.prototype, "on", ol.interaction.DragAndDrop.prototype.on);
goog.exportProperty(ol.interaction.DragAndDrop.prototype, "once", ol.interaction.DragAndDrop.prototype.once);
goog.exportProperty(ol.interaction.DragAndDrop.prototype, "un", ol.interaction.DragAndDrop.prototype.un);
goog.exportProperty(ol.interaction.DragAndDrop.Event.prototype, "type", ol.interaction.DragAndDrop.Event.prototype.type);
goog.exportProperty(ol.interaction.DragAndDrop.Event.prototype, "target", ol.interaction.DragAndDrop.Event.prototype.target);
goog.exportProperty(ol.interaction.DragAndDrop.Event.prototype, "preventDefault", ol.interaction.DragAndDrop.Event.prototype.preventDefault);
goog.exportProperty(ol.interaction.DragAndDrop.Event.prototype, "stopPropagation", ol.interaction.DragAndDrop.Event.prototype.stopPropagation);
goog.exportProperty(ol.interaction.Pointer.prototype, "getActive", ol.interaction.Pointer.prototype.getActive);
goog.exportProperty(ol.interaction.Pointer.prototype, "getMap", ol.interaction.Pointer.prototype.getMap);
goog.exportProperty(ol.interaction.Pointer.prototype, "setActive", ol.interaction.Pointer.prototype.setActive);
goog.exportProperty(ol.interaction.Pointer.prototype, "get", ol.interaction.Pointer.prototype.get);
goog.exportProperty(ol.interaction.Pointer.prototype, "getKeys", ol.interaction.Pointer.prototype.getKeys);
goog.exportProperty(ol.interaction.Pointer.prototype, "getProperties", ol.interaction.Pointer.prototype.getProperties);
goog.exportProperty(ol.interaction.Pointer.prototype, "set", ol.interaction.Pointer.prototype.set);
goog.exportProperty(ol.interaction.Pointer.prototype, "setProperties", ol.interaction.Pointer.prototype.setProperties);
goog.exportProperty(ol.interaction.Pointer.prototype, "unset", ol.interaction.Pointer.prototype.unset);
goog.exportProperty(ol.interaction.Pointer.prototype, "changed", ol.interaction.Pointer.prototype.changed);
goog.exportProperty(ol.interaction.Pointer.prototype, "dispatchEvent", ol.interaction.Pointer.prototype.dispatchEvent);
goog.exportProperty(ol.interaction.Pointer.prototype, "getRevision", ol.interaction.Pointer.prototype.getRevision);
goog.exportProperty(ol.interaction.Pointer.prototype, "on", ol.interaction.Pointer.prototype.on);
goog.exportProperty(ol.interaction.Pointer.prototype, "once", ol.interaction.Pointer.prototype.once);
goog.exportProperty(ol.interaction.Pointer.prototype, "un", ol.interaction.Pointer.prototype.un);
goog.exportProperty(ol.interaction.DragBox.prototype, "getActive", ol.interaction.DragBox.prototype.getActive);
goog.exportProperty(ol.interaction.DragBox.prototype, "getMap", ol.interaction.DragBox.prototype.getMap);
goog.exportProperty(ol.interaction.DragBox.prototype, "setActive", ol.interaction.DragBox.prototype.setActive);
goog.exportProperty(ol.interaction.DragBox.prototype, "get", ol.interaction.DragBox.prototype.get);
goog.exportProperty(ol.interaction.DragBox.prototype, "getKeys", ol.interaction.DragBox.prototype.getKeys);
goog.exportProperty(ol.interaction.DragBox.prototype, "getProperties", ol.interaction.DragBox.prototype.getProperties);
goog.exportProperty(ol.interaction.DragBox.prototype, "set", ol.interaction.DragBox.prototype.set);
goog.exportProperty(ol.interaction.DragBox.prototype, "setProperties", ol.interaction.DragBox.prototype.setProperties);
goog.exportProperty(ol.interaction.DragBox.prototype, "unset", ol.interaction.DragBox.prototype.unset);
goog.exportProperty(ol.interaction.DragBox.prototype, "changed", ol.interaction.DragBox.prototype.changed);
goog.exportProperty(ol.interaction.DragBox.prototype, "dispatchEvent", ol.interaction.DragBox.prototype.dispatchEvent);
goog.exportProperty(ol.interaction.DragBox.prototype, "getRevision", ol.interaction.DragBox.prototype.getRevision);
goog.exportProperty(ol.interaction.DragBox.prototype, "on", ol.interaction.DragBox.prototype.on);
goog.exportProperty(ol.interaction.DragBox.prototype, "once", ol.interaction.DragBox.prototype.once);
goog.exportProperty(ol.interaction.DragBox.prototype, "un", ol.interaction.DragBox.prototype.un);
goog.exportProperty(ol.interaction.DragBox.Event.prototype, "type", ol.interaction.DragBox.Event.prototype.type);
goog.exportProperty(ol.interaction.DragBox.Event.prototype, "target", ol.interaction.DragBox.Event.prototype.target);
goog.exportProperty(ol.interaction.DragBox.Event.prototype, "preventDefault", ol.interaction.DragBox.Event.prototype.preventDefault);
goog.exportProperty(ol.interaction.DragBox.Event.prototype, "stopPropagation", ol.interaction.DragBox.Event.prototype.stopPropagation);
goog.exportProperty(ol.interaction.DragPan.prototype, "getActive", ol.interaction.DragPan.prototype.getActive);
goog.exportProperty(ol.interaction.DragPan.prototype, "getMap", ol.interaction.DragPan.prototype.getMap);
goog.exportProperty(ol.interaction.DragPan.prototype, "setActive", ol.interaction.DragPan.prototype.setActive);
goog.exportProperty(ol.interaction.DragPan.prototype, "get", ol.interaction.DragPan.prototype.get);
goog.exportProperty(ol.interaction.DragPan.prototype, "getKeys", ol.interaction.DragPan.prototype.getKeys);
goog.exportProperty(ol.interaction.DragPan.prototype, "getProperties", ol.interaction.DragPan.prototype.getProperties);
goog.exportProperty(ol.interaction.DragPan.prototype, "set", ol.interaction.DragPan.prototype.set);
goog.exportProperty(ol.interaction.DragPan.prototype, "setProperties", ol.interaction.DragPan.prototype.setProperties);
goog.exportProperty(ol.interaction.DragPan.prototype, "unset", ol.interaction.DragPan.prototype.unset);
goog.exportProperty(ol.interaction.DragPan.prototype, "changed", ol.interaction.DragPan.prototype.changed);
goog.exportProperty(ol.interaction.DragPan.prototype, "dispatchEvent", ol.interaction.DragPan.prototype.dispatchEvent);
goog.exportProperty(ol.interaction.DragPan.prototype, "getRevision", ol.interaction.DragPan.prototype.getRevision);
goog.exportProperty(ol.interaction.DragPan.prototype, "on", ol.interaction.DragPan.prototype.on);
goog.exportProperty(ol.interaction.DragPan.prototype, "once", ol.interaction.DragPan.prototype.once);
goog.exportProperty(ol.interaction.DragPan.prototype, "un", ol.interaction.DragPan.prototype.un);
goog.exportProperty(ol.interaction.DragRotate.prototype, "getActive", ol.interaction.DragRotate.prototype.getActive);
goog.exportProperty(ol.interaction.DragRotate.prototype, "getMap", ol.interaction.DragRotate.prototype.getMap);
goog.exportProperty(ol.interaction.DragRotate.prototype, "setActive", ol.interaction.DragRotate.prototype.setActive);
goog.exportProperty(ol.interaction.DragRotate.prototype, "get", ol.interaction.DragRotate.prototype.get);
goog.exportProperty(ol.interaction.DragRotate.prototype, "getKeys", ol.interaction.DragRotate.prototype.getKeys);
goog.exportProperty(ol.interaction.DragRotate.prototype, "getProperties", ol.interaction.DragRotate.prototype.getProperties);
goog.exportProperty(ol.interaction.DragRotate.prototype, "set", ol.interaction.DragRotate.prototype.set);
goog.exportProperty(ol.interaction.DragRotate.prototype, "setProperties", ol.interaction.DragRotate.prototype.setProperties);
goog.exportProperty(ol.interaction.DragRotate.prototype, "unset", ol.interaction.DragRotate.prototype.unset);
goog.exportProperty(ol.interaction.DragRotate.prototype, "changed", ol.interaction.DragRotate.prototype.changed);
goog.exportProperty(ol.interaction.DragRotate.prototype, "dispatchEvent", ol.interaction.DragRotate.prototype.dispatchEvent);
goog.exportProperty(ol.interaction.DragRotate.prototype, "getRevision", ol.interaction.DragRotate.prototype.getRevision);
goog.exportProperty(ol.interaction.DragRotate.prototype, "on", ol.interaction.DragRotate.prototype.on);
goog.exportProperty(ol.interaction.DragRotate.prototype, "once", ol.interaction.DragRotate.prototype.once);
goog.exportProperty(ol.interaction.DragRotate.prototype, "un", ol.interaction.DragRotate.prototype.un);
goog.exportProperty(ol.interaction.DragRotateAndZoom.prototype, "getActive", ol.interaction.DragRotateAndZoom.prototype.getActive);
goog.exportProperty(ol.interaction.DragRotateAndZoom.prototype, "getMap", ol.interaction.DragRotateAndZoom.prototype.getMap);
goog.exportProperty(ol.interaction.DragRotateAndZoom.prototype, "setActive", ol.interaction.DragRotateAndZoom.prototype.setActive);
goog.exportProperty(ol.interaction.DragRotateAndZoom.prototype, "get", ol.interaction.DragRotateAndZoom.prototype.get);
goog.exportProperty(ol.interaction.DragRotateAndZoom.prototype, "getKeys", ol.interaction.DragRotateAndZoom.prototype.getKeys);
goog.exportProperty(ol.interaction.DragRotateAndZoom.prototype, "getProperties", ol.interaction.DragRotateAndZoom.prototype.getProperties);
goog.exportProperty(ol.interaction.DragRotateAndZoom.prototype, "set", ol.interaction.DragRotateAndZoom.prototype.set);
goog.exportProperty(ol.interaction.DragRotateAndZoom.prototype, "setProperties", ol.interaction.DragRotateAndZoom.prototype.setProperties);
goog.exportProperty(ol.interaction.DragRotateAndZoom.prototype, "unset", ol.interaction.DragRotateAndZoom.prototype.unset);
goog.exportProperty(ol.interaction.DragRotateAndZoom.prototype, "changed", ol.interaction.DragRotateAndZoom.prototype.changed);
goog.exportProperty(ol.interaction.DragRotateAndZoom.prototype, "dispatchEvent", ol.interaction.DragRotateAndZoom.prototype.dispatchEvent);
goog.exportProperty(ol.interaction.DragRotateAndZoom.prototype, "getRevision", ol.interaction.DragRotateAndZoom.prototype.getRevision);
goog.exportProperty(ol.interaction.DragRotateAndZoom.prototype, "on", ol.interaction.DragRotateAndZoom.prototype.on);
goog.exportProperty(ol.interaction.DragRotateAndZoom.prototype, "once", ol.interaction.DragRotateAndZoom.prototype.once);
goog.exportProperty(ol.interaction.DragRotateAndZoom.prototype, "un", ol.interaction.DragRotateAndZoom.prototype.un);
goog.exportProperty(ol.interaction.DragZoom.prototype, "getGeometry", ol.interaction.DragZoom.prototype.getGeometry);
goog.exportProperty(ol.interaction.DragZoom.prototype, "getActive", ol.interaction.DragZoom.prototype.getActive);
goog.exportProperty(ol.interaction.DragZoom.prototype, "getMap", ol.interaction.DragZoom.prototype.getMap);
goog.exportProperty(ol.interaction.DragZoom.prototype, "setActive", ol.interaction.DragZoom.prototype.setActive);
goog.exportProperty(ol.interaction.DragZoom.prototype, "get", ol.interaction.DragZoom.prototype.get);
goog.exportProperty(ol.interaction.DragZoom.prototype, "getKeys", ol.interaction.DragZoom.prototype.getKeys);
goog.exportProperty(ol.interaction.DragZoom.prototype, "getProperties", ol.interaction.DragZoom.prototype.getProperties);
goog.exportProperty(ol.interaction.DragZoom.prototype, "set", ol.interaction.DragZoom.prototype.set);
goog.exportProperty(ol.interaction.DragZoom.prototype, "setProperties", ol.interaction.DragZoom.prototype.setProperties);
goog.exportProperty(ol.interaction.DragZoom.prototype, "unset", ol.interaction.DragZoom.prototype.unset);
goog.exportProperty(ol.interaction.DragZoom.prototype, "changed", ol.interaction.DragZoom.prototype.changed);
goog.exportProperty(ol.interaction.DragZoom.prototype, "dispatchEvent", ol.interaction.DragZoom.prototype.dispatchEvent);
goog.exportProperty(ol.interaction.DragZoom.prototype, "getRevision", ol.interaction.DragZoom.prototype.getRevision);
goog.exportProperty(ol.interaction.DragZoom.prototype, "on", ol.interaction.DragZoom.prototype.on);
goog.exportProperty(ol.interaction.DragZoom.prototype, "once", ol.interaction.DragZoom.prototype.once);
goog.exportProperty(ol.interaction.DragZoom.prototype, "un", ol.interaction.DragZoom.prototype.un);
goog.exportProperty(ol.interaction.Draw.prototype, "getActive", ol.interaction.Draw.prototype.getActive);
goog.exportProperty(ol.interaction.Draw.prototype, "getMap", ol.interaction.Draw.prototype.getMap);
goog.exportProperty(ol.interaction.Draw.prototype, "setActive", ol.interaction.Draw.prototype.setActive);
goog.exportProperty(ol.interaction.Draw.prototype, "get", ol.interaction.Draw.prototype.get);
goog.exportProperty(ol.interaction.Draw.prototype, "getKeys", ol.interaction.Draw.prototype.getKeys);
goog.exportProperty(ol.interaction.Draw.prototype, "getProperties", ol.interaction.Draw.prototype.getProperties);
goog.exportProperty(ol.interaction.Draw.prototype, "set", ol.interaction.Draw.prototype.set);
goog.exportProperty(ol.interaction.Draw.prototype, "setProperties", ol.interaction.Draw.prototype.setProperties);
goog.exportProperty(ol.interaction.Draw.prototype, "unset", ol.interaction.Draw.prototype.unset);
goog.exportProperty(ol.interaction.Draw.prototype, "changed", ol.interaction.Draw.prototype.changed);
goog.exportProperty(ol.interaction.Draw.prototype, "dispatchEvent", ol.interaction.Draw.prototype.dispatchEvent);
goog.exportProperty(ol.interaction.Draw.prototype, "getRevision", ol.interaction.Draw.prototype.getRevision);
goog.exportProperty(ol.interaction.Draw.prototype, "on", ol.interaction.Draw.prototype.on);
goog.exportProperty(ol.interaction.Draw.prototype, "once", ol.interaction.Draw.prototype.once);
goog.exportProperty(ol.interaction.Draw.prototype, "un", ol.interaction.Draw.prototype.un);
goog.exportProperty(ol.interaction.Draw.Event.prototype, "type", ol.interaction.Draw.Event.prototype.type);
goog.exportProperty(ol.interaction.Draw.Event.prototype, "target", ol.interaction.Draw.Event.prototype.target);
goog.exportProperty(ol.interaction.Draw.Event.prototype, "preventDefault", ol.interaction.Draw.Event.prototype.preventDefault);
goog.exportProperty(ol.interaction.Draw.Event.prototype, "stopPropagation", ol.interaction.Draw.Event.prototype.stopPropagation);
goog.exportProperty(ol.interaction.Extent.prototype, "getActive", ol.interaction.Extent.prototype.getActive);
goog.exportProperty(ol.interaction.Extent.prototype, "getMap", ol.interaction.Extent.prototype.getMap);
goog.exportProperty(ol.interaction.Extent.prototype, "setActive", ol.interaction.Extent.prototype.setActive);
goog.exportProperty(ol.interaction.Extent.prototype, "get", ol.interaction.Extent.prototype.get);
goog.exportProperty(ol.interaction.Extent.prototype, "getKeys", ol.interaction.Extent.prototype.getKeys);
goog.exportProperty(ol.interaction.Extent.prototype, "getProperties", ol.interaction.Extent.prototype.getProperties);
goog.exportProperty(ol.interaction.Extent.prototype, "set", ol.interaction.Extent.prototype.set);
goog.exportProperty(ol.interaction.Extent.prototype, "setProperties", ol.interaction.Extent.prototype.setProperties);
goog.exportProperty(ol.interaction.Extent.prototype, "unset", ol.interaction.Extent.prototype.unset);
goog.exportProperty(ol.interaction.Extent.prototype, "changed", ol.interaction.Extent.prototype.changed);
goog.exportProperty(ol.interaction.Extent.prototype, "dispatchEvent", ol.interaction.Extent.prototype.dispatchEvent);
goog.exportProperty(ol.interaction.Extent.prototype, "getRevision", ol.interaction.Extent.prototype.getRevision);
goog.exportProperty(ol.interaction.Extent.prototype, "on", ol.interaction.Extent.prototype.on);
goog.exportProperty(ol.interaction.Extent.prototype, "once", ol.interaction.Extent.prototype.once);
goog.exportProperty(ol.interaction.Extent.prototype, "un", ol.interaction.Extent.prototype.un);
goog.exportProperty(ol.interaction.Extent.Event.prototype, "type", ol.interaction.Extent.Event.prototype.type);
goog.exportProperty(ol.interaction.Extent.Event.prototype, "target", ol.interaction.Extent.Event.prototype.target);
goog.exportProperty(ol.interaction.Extent.Event.prototype, "preventDefault", ol.interaction.Extent.Event.prototype.preventDefault);
goog.exportProperty(ol.interaction.Extent.Event.prototype, "stopPropagation", ol.interaction.Extent.Event.prototype.stopPropagation);
goog.exportProperty(ol.interaction.KeyboardPan.prototype, "getActive", ol.interaction.KeyboardPan.prototype.getActive);
goog.exportProperty(ol.interaction.KeyboardPan.prototype, "getMap", ol.interaction.KeyboardPan.prototype.getMap);
goog.exportProperty(ol.interaction.KeyboardPan.prototype, "setActive", ol.interaction.KeyboardPan.prototype.setActive);
goog.exportProperty(ol.interaction.KeyboardPan.prototype, "get", ol.interaction.KeyboardPan.prototype.get);
goog.exportProperty(ol.interaction.KeyboardPan.prototype, "getKeys", ol.interaction.KeyboardPan.prototype.getKeys);
goog.exportProperty(ol.interaction.KeyboardPan.prototype, "getProperties", ol.interaction.KeyboardPan.prototype.getProperties);
goog.exportProperty(ol.interaction.KeyboardPan.prototype, "set", ol.interaction.KeyboardPan.prototype.set);
goog.exportProperty(ol.interaction.KeyboardPan.prototype, "setProperties", ol.interaction.KeyboardPan.prototype.setProperties);
goog.exportProperty(ol.interaction.KeyboardPan.prototype, "unset", ol.interaction.KeyboardPan.prototype.unset);
goog.exportProperty(ol.interaction.KeyboardPan.prototype, "changed", ol.interaction.KeyboardPan.prototype.changed);
goog.exportProperty(ol.interaction.KeyboardPan.prototype, "dispatchEvent", ol.interaction.KeyboardPan.prototype.dispatchEvent);
goog.exportProperty(ol.interaction.KeyboardPan.prototype, "getRevision", ol.interaction.KeyboardPan.prototype.getRevision);
goog.exportProperty(ol.interaction.KeyboardPan.prototype, "on", ol.interaction.KeyboardPan.prototype.on);
goog.exportProperty(ol.interaction.KeyboardPan.prototype, "once", ol.interaction.KeyboardPan.prototype.once);
goog.exportProperty(ol.interaction.KeyboardPan.prototype, "un", ol.interaction.KeyboardPan.prototype.un);
goog.exportProperty(ol.interaction.KeyboardZoom.prototype, "getActive", ol.interaction.KeyboardZoom.prototype.getActive);
goog.exportProperty(ol.interaction.KeyboardZoom.prototype, "getMap", ol.interaction.KeyboardZoom.prototype.getMap);
goog.exportProperty(ol.interaction.KeyboardZoom.prototype, "setActive", ol.interaction.KeyboardZoom.prototype.setActive);
goog.exportProperty(ol.interaction.KeyboardZoom.prototype, "get", ol.interaction.KeyboardZoom.prototype.get);
goog.exportProperty(ol.interaction.KeyboardZoom.prototype, "getKeys", ol.interaction.KeyboardZoom.prototype.getKeys);
goog.exportProperty(ol.interaction.KeyboardZoom.prototype, "getProperties", ol.interaction.KeyboardZoom.prototype.getProperties);
goog.exportProperty(ol.interaction.KeyboardZoom.prototype, "set", ol.interaction.KeyboardZoom.prototype.set);
goog.exportProperty(ol.interaction.KeyboardZoom.prototype, "setProperties", ol.interaction.KeyboardZoom.prototype.setProperties);
goog.exportProperty(ol.interaction.KeyboardZoom.prototype, "unset", ol.interaction.KeyboardZoom.prototype.unset);
goog.exportProperty(ol.interaction.KeyboardZoom.prototype, "changed", ol.interaction.KeyboardZoom.prototype.changed);
goog.exportProperty(ol.interaction.KeyboardZoom.prototype, "dispatchEvent", ol.interaction.KeyboardZoom.prototype.dispatchEvent);
goog.exportProperty(ol.interaction.KeyboardZoom.prototype, "getRevision", ol.interaction.KeyboardZoom.prototype.getRevision);
goog.exportProperty(ol.interaction.KeyboardZoom.prototype, "on", ol.interaction.KeyboardZoom.prototype.on);
goog.exportProperty(ol.interaction.KeyboardZoom.prototype, "once", ol.interaction.KeyboardZoom.prototype.once);
goog.exportProperty(ol.interaction.KeyboardZoom.prototype, "un", ol.interaction.KeyboardZoom.prototype.un);
goog.exportProperty(ol.interaction.Modify.prototype, "getActive", ol.interaction.Modify.prototype.getActive);
goog.exportProperty(ol.interaction.Modify.prototype, "getMap", ol.interaction.Modify.prototype.getMap);
goog.exportProperty(ol.interaction.Modify.prototype, "setActive", ol.interaction.Modify.prototype.setActive);
goog.exportProperty(ol.interaction.Modify.prototype, "get", ol.interaction.Modify.prototype.get);
goog.exportProperty(ol.interaction.Modify.prototype, "getKeys", ol.interaction.Modify.prototype.getKeys);
goog.exportProperty(ol.interaction.Modify.prototype, "getProperties", ol.interaction.Modify.prototype.getProperties);
goog.exportProperty(ol.interaction.Modify.prototype, "set", ol.interaction.Modify.prototype.set);
goog.exportProperty(ol.interaction.Modify.prototype, "setProperties", ol.interaction.Modify.prototype.setProperties);
goog.exportProperty(ol.interaction.Modify.prototype, "unset", ol.interaction.Modify.prototype.unset);
goog.exportProperty(ol.interaction.Modify.prototype, "changed", ol.interaction.Modify.prototype.changed);
goog.exportProperty(ol.interaction.Modify.prototype, "dispatchEvent", ol.interaction.Modify.prototype.dispatchEvent);
goog.exportProperty(ol.interaction.Modify.prototype, "getRevision", ol.interaction.Modify.prototype.getRevision);
goog.exportProperty(ol.interaction.Modify.prototype, "on", ol.interaction.Modify.prototype.on);
goog.exportProperty(ol.interaction.Modify.prototype, "once", ol.interaction.Modify.prototype.once);
goog.exportProperty(ol.interaction.Modify.prototype, "un", ol.interaction.Modify.prototype.un);
goog.exportProperty(ol.interaction.Modify.Event.prototype, "type", ol.interaction.Modify.Event.prototype.type);
goog.exportProperty(ol.interaction.Modify.Event.prototype, "target", ol.interaction.Modify.Event.prototype.target);
goog.exportProperty(ol.interaction.Modify.Event.prototype, "preventDefault", ol.interaction.Modify.Event.prototype.preventDefault);
goog.exportProperty(ol.interaction.Modify.Event.prototype, "stopPropagation", ol.interaction.Modify.Event.prototype.stopPropagation);
goog.exportProperty(ol.interaction.MouseWheelZoom.prototype, "getActive", ol.interaction.MouseWheelZoom.prototype.getActive);
goog.exportProperty(ol.interaction.MouseWheelZoom.prototype, "getMap", ol.interaction.MouseWheelZoom.prototype.getMap);
goog.exportProperty(ol.interaction.MouseWheelZoom.prototype, "setActive", ol.interaction.MouseWheelZoom.prototype.setActive);
goog.exportProperty(ol.interaction.MouseWheelZoom.prototype, "get", ol.interaction.MouseWheelZoom.prototype.get);
goog.exportProperty(ol.interaction.MouseWheelZoom.prototype, "getKeys", ol.interaction.MouseWheelZoom.prototype.getKeys);
goog.exportProperty(ol.interaction.MouseWheelZoom.prototype, "getProperties", ol.interaction.MouseWheelZoom.prototype.getProperties);
goog.exportProperty(ol.interaction.MouseWheelZoom.prototype, "set", ol.interaction.MouseWheelZoom.prototype.set);
goog.exportProperty(ol.interaction.MouseWheelZoom.prototype, "setProperties", ol.interaction.MouseWheelZoom.prototype.setProperties);
goog.exportProperty(ol.interaction.MouseWheelZoom.prototype, "unset", ol.interaction.MouseWheelZoom.prototype.unset);
goog.exportProperty(ol.interaction.MouseWheelZoom.prototype, "changed", ol.interaction.MouseWheelZoom.prototype.changed);
goog.exportProperty(ol.interaction.MouseWheelZoom.prototype, "dispatchEvent", ol.interaction.MouseWheelZoom.prototype.dispatchEvent);
goog.exportProperty(ol.interaction.MouseWheelZoom.prototype, "getRevision", ol.interaction.MouseWheelZoom.prototype.getRevision);
goog.exportProperty(ol.interaction.MouseWheelZoom.prototype, "on", ol.interaction.MouseWheelZoom.prototype.on);
goog.exportProperty(ol.interaction.MouseWheelZoom.prototype, "once", ol.interaction.MouseWheelZoom.prototype.once);
goog.exportProperty(ol.interaction.MouseWheelZoom.prototype, "un", ol.interaction.MouseWheelZoom.prototype.un);
goog.exportProperty(ol.interaction.PinchRotate.prototype, "getActive", ol.interaction.PinchRotate.prototype.getActive);
goog.exportProperty(ol.interaction.PinchRotate.prototype, "getMap", ol.interaction.PinchRotate.prototype.getMap);
goog.exportProperty(ol.interaction.PinchRotate.prototype, "setActive", ol.interaction.PinchRotate.prototype.setActive);
goog.exportProperty(ol.interaction.PinchRotate.prototype, "get", ol.interaction.PinchRotate.prototype.get);
goog.exportProperty(ol.interaction.PinchRotate.prototype, "getKeys", ol.interaction.PinchRotate.prototype.getKeys);
goog.exportProperty(ol.interaction.PinchRotate.prototype, "getProperties", ol.interaction.PinchRotate.prototype.getProperties);
goog.exportProperty(ol.interaction.PinchRotate.prototype, "set", ol.interaction.PinchRotate.prototype.set);
goog.exportProperty(ol.interaction.PinchRotate.prototype, "setProperties", ol.interaction.PinchRotate.prototype.setProperties);
goog.exportProperty(ol.interaction.PinchRotate.prototype, "unset", ol.interaction.PinchRotate.prototype.unset);
goog.exportProperty(ol.interaction.PinchRotate.prototype, "changed", ol.interaction.PinchRotate.prototype.changed);
goog.exportProperty(ol.interaction.PinchRotate.prototype, "dispatchEvent", ol.interaction.PinchRotate.prototype.dispatchEvent);
goog.exportProperty(ol.interaction.PinchRotate.prototype, "getRevision", ol.interaction.PinchRotate.prototype.getRevision);
goog.exportProperty(ol.interaction.PinchRotate.prototype, "on", ol.interaction.PinchRotate.prototype.on);
goog.exportProperty(ol.interaction.PinchRotate.prototype, "once", ol.interaction.PinchRotate.prototype.once);
goog.exportProperty(ol.interaction.PinchRotate.prototype, "un", ol.interaction.PinchRotate.prototype.un);
goog.exportProperty(ol.interaction.PinchZoom.prototype, "getActive", ol.interaction.PinchZoom.prototype.getActive);
goog.exportProperty(ol.interaction.PinchZoom.prototype, "getMap", ol.interaction.PinchZoom.prototype.getMap);
goog.exportProperty(ol.interaction.PinchZoom.prototype, "setActive", ol.interaction.PinchZoom.prototype.setActive);
goog.exportProperty(ol.interaction.PinchZoom.prototype, "get", ol.interaction.PinchZoom.prototype.get);
goog.exportProperty(ol.interaction.PinchZoom.prototype, "getKeys", ol.interaction.PinchZoom.prototype.getKeys);
goog.exportProperty(ol.interaction.PinchZoom.prototype, "getProperties", ol.interaction.PinchZoom.prototype.getProperties);
goog.exportProperty(ol.interaction.PinchZoom.prototype, "set", ol.interaction.PinchZoom.prototype.set);
goog.exportProperty(ol.interaction.PinchZoom.prototype, "setProperties", ol.interaction.PinchZoom.prototype.setProperties);
goog.exportProperty(ol.interaction.PinchZoom.prototype, "unset", ol.interaction.PinchZoom.prototype.unset);
goog.exportProperty(ol.interaction.PinchZoom.prototype, "changed", ol.interaction.PinchZoom.prototype.changed);
goog.exportProperty(ol.interaction.PinchZoom.prototype, "dispatchEvent", ol.interaction.PinchZoom.prototype.dispatchEvent);
goog.exportProperty(ol.interaction.PinchZoom.prototype, "getRevision", ol.interaction.PinchZoom.prototype.getRevision);
goog.exportProperty(ol.interaction.PinchZoom.prototype, "on", ol.interaction.PinchZoom.prototype.on);
goog.exportProperty(ol.interaction.PinchZoom.prototype, "once", ol.interaction.PinchZoom.prototype.once);
goog.exportProperty(ol.interaction.PinchZoom.prototype, "un", ol.interaction.PinchZoom.prototype.un);
goog.exportProperty(ol.interaction.Select.prototype, "getActive", ol.interaction.Select.prototype.getActive);
goog.exportProperty(ol.interaction.Select.prototype, "getMap", ol.interaction.Select.prototype.getMap);
goog.exportProperty(ol.interaction.Select.prototype, "setActive", ol.interaction.Select.prototype.setActive);
goog.exportProperty(ol.interaction.Select.prototype, "get", ol.interaction.Select.prototype.get);
goog.exportProperty(ol.interaction.Select.prototype, "getKeys", ol.interaction.Select.prototype.getKeys);
goog.exportProperty(ol.interaction.Select.prototype, "getProperties", ol.interaction.Select.prototype.getProperties);
goog.exportProperty(ol.interaction.Select.prototype, "set", ol.interaction.Select.prototype.set);
goog.exportProperty(ol.interaction.Select.prototype, "setProperties", ol.interaction.Select.prototype.setProperties);
goog.exportProperty(ol.interaction.Select.prototype, "unset", ol.interaction.Select.prototype.unset);
goog.exportProperty(ol.interaction.Select.prototype, "changed", ol.interaction.Select.prototype.changed);
goog.exportProperty(ol.interaction.Select.prototype, "dispatchEvent", ol.interaction.Select.prototype.dispatchEvent);
goog.exportProperty(ol.interaction.Select.prototype, "getRevision", ol.interaction.Select.prototype.getRevision);
goog.exportProperty(ol.interaction.Select.prototype, "on", ol.interaction.Select.prototype.on);
goog.exportProperty(ol.interaction.Select.prototype, "once", ol.interaction.Select.prototype.once);
goog.exportProperty(ol.interaction.Select.prototype, "un", ol.interaction.Select.prototype.un);
goog.exportProperty(ol.interaction.Select.Event.prototype, "type", ol.interaction.Select.Event.prototype.type);
goog.exportProperty(ol.interaction.Select.Event.prototype, "target", ol.interaction.Select.Event.prototype.target);
goog.exportProperty(ol.interaction.Select.Event.prototype, "preventDefault", ol.interaction.Select.Event.prototype.preventDefault);
goog.exportProperty(ol.interaction.Select.Event.prototype, "stopPropagation", ol.interaction.Select.Event.prototype.stopPropagation);
goog.exportProperty(ol.interaction.Snap.prototype, "getActive", ol.interaction.Snap.prototype.getActive);
goog.exportProperty(ol.interaction.Snap.prototype, "getMap", ol.interaction.Snap.prototype.getMap);
goog.exportProperty(ol.interaction.Snap.prototype, "setActive", ol.interaction.Snap.prototype.setActive);
goog.exportProperty(ol.interaction.Snap.prototype, "get", ol.interaction.Snap.prototype.get);
goog.exportProperty(ol.interaction.Snap.prototype, "getKeys", ol.interaction.Snap.prototype.getKeys);
goog.exportProperty(ol.interaction.Snap.prototype, "getProperties", ol.interaction.Snap.prototype.getProperties);
goog.exportProperty(ol.interaction.Snap.prototype, "set", ol.interaction.Snap.prototype.set);
goog.exportProperty(ol.interaction.Snap.prototype, "setProperties", ol.interaction.Snap.prototype.setProperties);
goog.exportProperty(ol.interaction.Snap.prototype, "unset", ol.interaction.Snap.prototype.unset);
goog.exportProperty(ol.interaction.Snap.prototype, "changed", ol.interaction.Snap.prototype.changed);
goog.exportProperty(ol.interaction.Snap.prototype, "dispatchEvent", ol.interaction.Snap.prototype.dispatchEvent);
goog.exportProperty(ol.interaction.Snap.prototype, "getRevision", ol.interaction.Snap.prototype.getRevision);
goog.exportProperty(ol.interaction.Snap.prototype, "on", ol.interaction.Snap.prototype.on);
goog.exportProperty(ol.interaction.Snap.prototype, "once", ol.interaction.Snap.prototype.once);
goog.exportProperty(ol.interaction.Snap.prototype, "un", ol.interaction.Snap.prototype.un);
goog.exportProperty(ol.interaction.Translate.prototype, "getActive", ol.interaction.Translate.prototype.getActive);
goog.exportProperty(ol.interaction.Translate.prototype, "getMap", ol.interaction.Translate.prototype.getMap);
goog.exportProperty(ol.interaction.Translate.prototype, "setActive", ol.interaction.Translate.prototype.setActive);
goog.exportProperty(ol.interaction.Translate.prototype, "get", ol.interaction.Translate.prototype.get);
goog.exportProperty(ol.interaction.Translate.prototype, "getKeys", ol.interaction.Translate.prototype.getKeys);
goog.exportProperty(ol.interaction.Translate.prototype, "getProperties", ol.interaction.Translate.prototype.getProperties);
goog.exportProperty(ol.interaction.Translate.prototype, "set", ol.interaction.Translate.prototype.set);
goog.exportProperty(ol.interaction.Translate.prototype, "setProperties", ol.interaction.Translate.prototype.setProperties);
goog.exportProperty(ol.interaction.Translate.prototype, "unset", ol.interaction.Translate.prototype.unset);
goog.exportProperty(ol.interaction.Translate.prototype, "changed", ol.interaction.Translate.prototype.changed);
goog.exportProperty(ol.interaction.Translate.prototype, "dispatchEvent", ol.interaction.Translate.prototype.dispatchEvent);
goog.exportProperty(ol.interaction.Translate.prototype, "getRevision", ol.interaction.Translate.prototype.getRevision);
goog.exportProperty(ol.interaction.Translate.prototype, "on", ol.interaction.Translate.prototype.on);
goog.exportProperty(ol.interaction.Translate.prototype, "once", ol.interaction.Translate.prototype.once);
goog.exportProperty(ol.interaction.Translate.prototype, "un", ol.interaction.Translate.prototype.un);
goog.exportProperty(ol.interaction.Translate.Event.prototype, "type", ol.interaction.Translate.Event.prototype.type);
goog.exportProperty(ol.interaction.Translate.Event.prototype, "target", ol.interaction.Translate.Event.prototype.target);
goog.exportProperty(ol.interaction.Translate.Event.prototype, "preventDefault", ol.interaction.Translate.Event.prototype.preventDefault);
goog.exportProperty(ol.interaction.Translate.Event.prototype, "stopPropagation", ol.interaction.Translate.Event.prototype.stopPropagation);
goog.exportProperty(ol.geom.Geometry.prototype, "get", ol.geom.Geometry.prototype.get);
goog.exportProperty(ol.geom.Geometry.prototype, "getKeys", ol.geom.Geometry.prototype.getKeys);
goog.exportProperty(ol.geom.Geometry.prototype, "getProperties", ol.geom.Geometry.prototype.getProperties);
goog.exportProperty(ol.geom.Geometry.prototype, "set", ol.geom.Geometry.prototype.set);
goog.exportProperty(ol.geom.Geometry.prototype, "setProperties", ol.geom.Geometry.prototype.setProperties);
goog.exportProperty(ol.geom.Geometry.prototype, "unset", ol.geom.Geometry.prototype.unset);
goog.exportProperty(ol.geom.Geometry.prototype, "changed", ol.geom.Geometry.prototype.changed);
goog.exportProperty(ol.geom.Geometry.prototype, "dispatchEvent", ol.geom.Geometry.prototype.dispatchEvent);
goog.exportProperty(ol.geom.Geometry.prototype, "getRevision", ol.geom.Geometry.prototype.getRevision);
goog.exportProperty(ol.geom.Geometry.prototype, "on", ol.geom.Geometry.prototype.on);
goog.exportProperty(ol.geom.Geometry.prototype, "once", ol.geom.Geometry.prototype.once);
goog.exportProperty(ol.geom.Geometry.prototype, "un", ol.geom.Geometry.prototype.un);
goog.exportProperty(ol.geom.SimpleGeometry.prototype, "getClosestPoint", ol.geom.SimpleGeometry.prototype.getClosestPoint);
goog.exportProperty(ol.geom.SimpleGeometry.prototype, "intersectsCoordinate", ol.geom.SimpleGeometry.prototype.intersectsCoordinate);
goog.exportProperty(ol.geom.SimpleGeometry.prototype, "getExtent", ol.geom.SimpleGeometry.prototype.getExtent);
goog.exportProperty(ol.geom.SimpleGeometry.prototype, "rotate", ol.geom.SimpleGeometry.prototype.rotate);
goog.exportProperty(ol.geom.SimpleGeometry.prototype, "scale", ol.geom.SimpleGeometry.prototype.scale);
goog.exportProperty(ol.geom.SimpleGeometry.prototype, "simplify", ol.geom.SimpleGeometry.prototype.simplify);
goog.exportProperty(ol.geom.SimpleGeometry.prototype, "transform", ol.geom.SimpleGeometry.prototype.transform);
goog.exportProperty(ol.geom.SimpleGeometry.prototype, "get", ol.geom.SimpleGeometry.prototype.get);
goog.exportProperty(ol.geom.SimpleGeometry.prototype, "getKeys", ol.geom.SimpleGeometry.prototype.getKeys);
goog.exportProperty(ol.geom.SimpleGeometry.prototype, "getProperties", ol.geom.SimpleGeometry.prototype.getProperties);
goog.exportProperty(ol.geom.SimpleGeometry.prototype, "set", ol.geom.SimpleGeometry.prototype.set);
goog.exportProperty(ol.geom.SimpleGeometry.prototype, "setProperties", ol.geom.SimpleGeometry.prototype.setProperties);
goog.exportProperty(ol.geom.SimpleGeometry.prototype, "unset", ol.geom.SimpleGeometry.prototype.unset);
goog.exportProperty(ol.geom.SimpleGeometry.prototype, "changed", ol.geom.SimpleGeometry.prototype.changed);
goog.exportProperty(ol.geom.SimpleGeometry.prototype, "dispatchEvent", ol.geom.SimpleGeometry.prototype.dispatchEvent);
goog.exportProperty(ol.geom.SimpleGeometry.prototype, "getRevision", ol.geom.SimpleGeometry.prototype.getRevision);
goog.exportProperty(ol.geom.SimpleGeometry.prototype, "on", ol.geom.SimpleGeometry.prototype.on);
goog.exportProperty(ol.geom.SimpleGeometry.prototype, "once", ol.geom.SimpleGeometry.prototype.once);
goog.exportProperty(ol.geom.SimpleGeometry.prototype, "un", ol.geom.SimpleGeometry.prototype.un);
goog.exportProperty(ol.geom.Circle.prototype, "getFirstCoordinate", ol.geom.Circle.prototype.getFirstCoordinate);
goog.exportProperty(ol.geom.Circle.prototype, "getLastCoordinate", ol.geom.Circle.prototype.getLastCoordinate);
goog.exportProperty(ol.geom.Circle.prototype, "getLayout", ol.geom.Circle.prototype.getLayout);
goog.exportProperty(ol.geom.Circle.prototype, "rotate", ol.geom.Circle.prototype.rotate);
goog.exportProperty(ol.geom.Circle.prototype, "scale", ol.geom.Circle.prototype.scale);
goog.exportProperty(ol.geom.Circle.prototype, "getClosestPoint", ol.geom.Circle.prototype.getClosestPoint);
goog.exportProperty(ol.geom.Circle.prototype, "intersectsCoordinate", ol.geom.Circle.prototype.intersectsCoordinate);
goog.exportProperty(ol.geom.Circle.prototype, "getExtent", ol.geom.Circle.prototype.getExtent);
goog.exportProperty(ol.geom.Circle.prototype, "simplify", ol.geom.Circle.prototype.simplify);
goog.exportProperty(ol.geom.Circle.prototype, "get", ol.geom.Circle.prototype.get);
goog.exportProperty(ol.geom.Circle.prototype, "getKeys", ol.geom.Circle.prototype.getKeys);
goog.exportProperty(ol.geom.Circle.prototype, "getProperties", ol.geom.Circle.prototype.getProperties);
goog.exportProperty(ol.geom.Circle.prototype, "set", ol.geom.Circle.prototype.set);
goog.exportProperty(ol.geom.Circle.prototype, "setProperties", ol.geom.Circle.prototype.setProperties);
goog.exportProperty(ol.geom.Circle.prototype, "unset", ol.geom.Circle.prototype.unset);
goog.exportProperty(ol.geom.Circle.prototype, "changed", ol.geom.Circle.prototype.changed);
goog.exportProperty(ol.geom.Circle.prototype, "dispatchEvent", ol.geom.Circle.prototype.dispatchEvent);
goog.exportProperty(ol.geom.Circle.prototype, "getRevision", ol.geom.Circle.prototype.getRevision);
goog.exportProperty(ol.geom.Circle.prototype, "on", ol.geom.Circle.prototype.on);
goog.exportProperty(ol.geom.Circle.prototype, "once", ol.geom.Circle.prototype.once);
goog.exportProperty(ol.geom.Circle.prototype, "un", ol.geom.Circle.prototype.un);
goog.exportProperty(ol.geom.GeometryCollection.prototype, "getClosestPoint", ol.geom.GeometryCollection.prototype.getClosestPoint);
goog.exportProperty(ol.geom.GeometryCollection.prototype, "intersectsCoordinate", ol.geom.GeometryCollection.prototype.intersectsCoordinate);
goog.exportProperty(ol.geom.GeometryCollection.prototype, "getExtent", ol.geom.GeometryCollection.prototype.getExtent);
goog.exportProperty(ol.geom.GeometryCollection.prototype, "rotate", ol.geom.GeometryCollection.prototype.rotate);
goog.exportProperty(ol.geom.GeometryCollection.prototype, "scale", ol.geom.GeometryCollection.prototype.scale);
goog.exportProperty(ol.geom.GeometryCollection.prototype, "simplify", ol.geom.GeometryCollection.prototype.simplify);
goog.exportProperty(ol.geom.GeometryCollection.prototype, "transform", ol.geom.GeometryCollection.prototype.transform);
goog.exportProperty(ol.geom.GeometryCollection.prototype, "get", ol.geom.GeometryCollection.prototype.get);
goog.exportProperty(ol.geom.GeometryCollection.prototype, "getKeys", ol.geom.GeometryCollection.prototype.getKeys);
goog.exportProperty(ol.geom.GeometryCollection.prototype, "getProperties", ol.geom.GeometryCollection.prototype.getProperties);
goog.exportProperty(ol.geom.GeometryCollection.prototype, "set", ol.geom.GeometryCollection.prototype.set);
goog.exportProperty(ol.geom.GeometryCollection.prototype, "setProperties", ol.geom.GeometryCollection.prototype.setProperties);
goog.exportProperty(ol.geom.GeometryCollection.prototype, "unset", ol.geom.GeometryCollection.prototype.unset);
goog.exportProperty(ol.geom.GeometryCollection.prototype, "changed", ol.geom.GeometryCollection.prototype.changed);
goog.exportProperty(ol.geom.GeometryCollection.prototype, "dispatchEvent", ol.geom.GeometryCollection.prototype.dispatchEvent);
goog.exportProperty(ol.geom.GeometryCollection.prototype, "getRevision", ol.geom.GeometryCollection.prototype.getRevision);
goog.exportProperty(ol.geom.GeometryCollection.prototype, "on", ol.geom.GeometryCollection.prototype.on);
goog.exportProperty(ol.geom.GeometryCollection.prototype, "once", ol.geom.GeometryCollection.prototype.once);
goog.exportProperty(ol.geom.GeometryCollection.prototype, "un", ol.geom.GeometryCollection.prototype.un);
goog.exportProperty(ol.geom.LinearRing.prototype, "getFirstCoordinate", ol.geom.LinearRing.prototype.getFirstCoordinate);
goog.exportProperty(ol.geom.LinearRing.prototype, "getLastCoordinate", ol.geom.LinearRing.prototype.getLastCoordinate);
goog.exportProperty(ol.geom.LinearRing.prototype, "getLayout", ol.geom.LinearRing.prototype.getLayout);
goog.exportProperty(ol.geom.LinearRing.prototype, "rotate", ol.geom.LinearRing.prototype.rotate);
goog.exportProperty(ol.geom.LinearRing.prototype, "scale", ol.geom.LinearRing.prototype.scale);
goog.exportProperty(ol.geom.LinearRing.prototype, "getClosestPoint", ol.geom.LinearRing.prototype.getClosestPoint);
goog.exportProperty(ol.geom.LinearRing.prototype, "intersectsCoordinate", ol.geom.LinearRing.prototype.intersectsCoordinate);
goog.exportProperty(ol.geom.LinearRing.prototype, "getExtent", ol.geom.LinearRing.prototype.getExtent);
goog.exportProperty(ol.geom.LinearRing.prototype, "simplify", ol.geom.LinearRing.prototype.simplify);
goog.exportProperty(ol.geom.LinearRing.prototype, "transform", ol.geom.LinearRing.prototype.transform);
goog.exportProperty(ol.geom.LinearRing.prototype, "get", ol.geom.LinearRing.prototype.get);
goog.exportProperty(ol.geom.LinearRing.prototype, "getKeys", ol.geom.LinearRing.prototype.getKeys);
goog.exportProperty(ol.geom.LinearRing.prototype, "getProperties", ol.geom.LinearRing.prototype.getProperties);
goog.exportProperty(ol.geom.LinearRing.prototype, "set", ol.geom.LinearRing.prototype.set);
goog.exportProperty(ol.geom.LinearRing.prototype, "setProperties", ol.geom.LinearRing.prototype.setProperties);
goog.exportProperty(ol.geom.LinearRing.prototype, "unset", ol.geom.LinearRing.prototype.unset);
goog.exportProperty(ol.geom.LinearRing.prototype, "changed", ol.geom.LinearRing.prototype.changed);
goog.exportProperty(ol.geom.LinearRing.prototype, "dispatchEvent", ol.geom.LinearRing.prototype.dispatchEvent);
goog.exportProperty(ol.geom.LinearRing.prototype, "getRevision", ol.geom.LinearRing.prototype.getRevision);
goog.exportProperty(ol.geom.LinearRing.prototype, "on", ol.geom.LinearRing.prototype.on);
goog.exportProperty(ol.geom.LinearRing.prototype, "once", ol.geom.LinearRing.prototype.once);
goog.exportProperty(ol.geom.LinearRing.prototype, "un", ol.geom.LinearRing.prototype.un);
goog.exportProperty(ol.geom.LineString.prototype, "getFirstCoordinate", ol.geom.LineString.prototype.getFirstCoordinate);
goog.exportProperty(ol.geom.LineString.prototype, "getLastCoordinate", ol.geom.LineString.prototype.getLastCoordinate);
goog.exportProperty(ol.geom.LineString.prototype, "getLayout", ol.geom.LineString.prototype.getLayout);
goog.exportProperty(ol.geom.LineString.prototype, "rotate", ol.geom.LineString.prototype.rotate);
goog.exportProperty(ol.geom.LineString.prototype, "scale", ol.geom.LineString.prototype.scale);
goog.exportProperty(ol.geom.LineString.prototype, "getClosestPoint", ol.geom.LineString.prototype.getClosestPoint);
goog.exportProperty(ol.geom.LineString.prototype, "intersectsCoordinate", ol.geom.LineString.prototype.intersectsCoordinate);
goog.exportProperty(ol.geom.LineString.prototype, "getExtent", ol.geom.LineString.prototype.getExtent);
goog.exportProperty(ol.geom.LineString.prototype, "simplify", ol.geom.LineString.prototype.simplify);
goog.exportProperty(ol.geom.LineString.prototype, "transform", ol.geom.LineString.prototype.transform);
goog.exportProperty(ol.geom.LineString.prototype, "get", ol.geom.LineString.prototype.get);
goog.exportProperty(ol.geom.LineString.prototype, "getKeys", ol.geom.LineString.prototype.getKeys);
goog.exportProperty(ol.geom.LineString.prototype, "getProperties", ol.geom.LineString.prototype.getProperties);
goog.exportProperty(ol.geom.LineString.prototype, "set", ol.geom.LineString.prototype.set);
goog.exportProperty(ol.geom.LineString.prototype, "setProperties", ol.geom.LineString.prototype.setProperties);
goog.exportProperty(ol.geom.LineString.prototype, "unset", ol.geom.LineString.prototype.unset);
goog.exportProperty(ol.geom.LineString.prototype, "changed", ol.geom.LineString.prototype.changed);
goog.exportProperty(ol.geom.LineString.prototype, "dispatchEvent", ol.geom.LineString.prototype.dispatchEvent);
goog.exportProperty(ol.geom.LineString.prototype, "getRevision", ol.geom.LineString.prototype.getRevision);
goog.exportProperty(ol.geom.LineString.prototype, "on", ol.geom.LineString.prototype.on);
goog.exportProperty(ol.geom.LineString.prototype, "once", ol.geom.LineString.prototype.once);
goog.exportProperty(ol.geom.LineString.prototype, "un", ol.geom.LineString.prototype.un);
goog.exportProperty(ol.geom.MultiLineString.prototype, "getFirstCoordinate", ol.geom.MultiLineString.prototype.getFirstCoordinate);
goog.exportProperty(ol.geom.MultiLineString.prototype, "getLastCoordinate", ol.geom.MultiLineString.prototype.getLastCoordinate);
goog.exportProperty(ol.geom.MultiLineString.prototype, "getLayout", ol.geom.MultiLineString.prototype.getLayout);
goog.exportProperty(ol.geom.MultiLineString.prototype, "rotate", ol.geom.MultiLineString.prototype.rotate);
goog.exportProperty(ol.geom.MultiLineString.prototype, "scale", ol.geom.MultiLineString.prototype.scale);
goog.exportProperty(ol.geom.MultiLineString.prototype, "getClosestPoint", ol.geom.MultiLineString.prototype.getClosestPoint);
goog.exportProperty(ol.geom.MultiLineString.prototype, "intersectsCoordinate", ol.geom.MultiLineString.prototype.intersectsCoordinate);
goog.exportProperty(ol.geom.MultiLineString.prototype, "getExtent", ol.geom.MultiLineString.prototype.getExtent);
goog.exportProperty(ol.geom.MultiLineString.prototype, "simplify", ol.geom.MultiLineString.prototype.simplify);
goog.exportProperty(ol.geom.MultiLineString.prototype, "transform", ol.geom.MultiLineString.prototype.transform);
goog.exportProperty(ol.geom.MultiLineString.prototype, "get", ol.geom.MultiLineString.prototype.get);
goog.exportProperty(ol.geom.MultiLineString.prototype, "getKeys", ol.geom.MultiLineString.prototype.getKeys);
goog.exportProperty(ol.geom.MultiLineString.prototype, "getProperties", ol.geom.MultiLineString.prototype.getProperties);
goog.exportProperty(ol.geom.MultiLineString.prototype, "set", ol.geom.MultiLineString.prototype.set);
goog.exportProperty(ol.geom.MultiLineString.prototype, "setProperties", ol.geom.MultiLineString.prototype.setProperties);
goog.exportProperty(ol.geom.MultiLineString.prototype, "unset", ol.geom.MultiLineString.prototype.unset);
goog.exportProperty(ol.geom.MultiLineString.prototype, "changed", ol.geom.MultiLineString.prototype.changed);
goog.exportProperty(ol.geom.MultiLineString.prototype, "dispatchEvent", ol.geom.MultiLineString.prototype.dispatchEvent);
goog.exportProperty(ol.geom.MultiLineString.prototype, "getRevision", ol.geom.MultiLineString.prototype.getRevision);
goog.exportProperty(ol.geom.MultiLineString.prototype, "on", ol.geom.MultiLineString.prototype.on);
goog.exportProperty(ol.geom.MultiLineString.prototype, "once", ol.geom.MultiLineString.prototype.once);
goog.exportProperty(ol.geom.MultiLineString.prototype, "un", ol.geom.MultiLineString.prototype.un);
goog.exportProperty(ol.geom.MultiPoint.prototype, "getFirstCoordinate", ol.geom.MultiPoint.prototype.getFirstCoordinate);
goog.exportProperty(ol.geom.MultiPoint.prototype, "getLastCoordinate", ol.geom.MultiPoint.prototype.getLastCoordinate);
goog.exportProperty(ol.geom.MultiPoint.prototype, "getLayout", ol.geom.MultiPoint.prototype.getLayout);
goog.exportProperty(ol.geom.MultiPoint.prototype, "rotate", ol.geom.MultiPoint.prototype.rotate);
goog.exportProperty(ol.geom.MultiPoint.prototype, "scale", ol.geom.MultiPoint.prototype.scale);
goog.exportProperty(ol.geom.MultiPoint.prototype, "getClosestPoint", ol.geom.MultiPoint.prototype.getClosestPoint);
goog.exportProperty(ol.geom.MultiPoint.prototype, "intersectsCoordinate", ol.geom.MultiPoint.prototype.intersectsCoordinate);
goog.exportProperty(ol.geom.MultiPoint.prototype, "getExtent", ol.geom.MultiPoint.prototype.getExtent);
goog.exportProperty(ol.geom.MultiPoint.prototype, "simplify", ol.geom.MultiPoint.prototype.simplify);
goog.exportProperty(ol.geom.MultiPoint.prototype, "transform", ol.geom.MultiPoint.prototype.transform);
goog.exportProperty(ol.geom.MultiPoint.prototype, "get", ol.geom.MultiPoint.prototype.get);
goog.exportProperty(ol.geom.MultiPoint.prototype, "getKeys", ol.geom.MultiPoint.prototype.getKeys);
goog.exportProperty(ol.geom.MultiPoint.prototype, "getProperties", ol.geom.MultiPoint.prototype.getProperties);
goog.exportProperty(ol.geom.MultiPoint.prototype, "set", ol.geom.MultiPoint.prototype.set);
goog.exportProperty(ol.geom.MultiPoint.prototype, "setProperties", ol.geom.MultiPoint.prototype.setProperties);
goog.exportProperty(ol.geom.MultiPoint.prototype, "unset", ol.geom.MultiPoint.prototype.unset);
goog.exportProperty(ol.geom.MultiPoint.prototype, "changed", ol.geom.MultiPoint.prototype.changed);
goog.exportProperty(ol.geom.MultiPoint.prototype, "dispatchEvent", ol.geom.MultiPoint.prototype.dispatchEvent);
goog.exportProperty(ol.geom.MultiPoint.prototype, "getRevision", ol.geom.MultiPoint.prototype.getRevision);
goog.exportProperty(ol.geom.MultiPoint.prototype, "on", ol.geom.MultiPoint.prototype.on);
goog.exportProperty(ol.geom.MultiPoint.prototype, "once", ol.geom.MultiPoint.prototype.once);
goog.exportProperty(ol.geom.MultiPoint.prototype, "un", ol.geom.MultiPoint.prototype.un);
goog.exportProperty(ol.geom.MultiPolygon.prototype, "getFirstCoordinate", ol.geom.MultiPolygon.prototype.getFirstCoordinate);
goog.exportProperty(ol.geom.MultiPolygon.prototype, "getLastCoordinate", ol.geom.MultiPolygon.prototype.getLastCoordinate);
goog.exportProperty(ol.geom.MultiPolygon.prototype, "getLayout", ol.geom.MultiPolygon.prototype.getLayout);
goog.exportProperty(ol.geom.MultiPolygon.prototype, "rotate", ol.geom.MultiPolygon.prototype.rotate);
goog.exportProperty(ol.geom.MultiPolygon.prototype, "scale", ol.geom.MultiPolygon.prototype.scale);
goog.exportProperty(ol.geom.MultiPolygon.prototype, "getClosestPoint", ol.geom.MultiPolygon.prototype.getClosestPoint);
goog.exportProperty(ol.geom.MultiPolygon.prototype, "intersectsCoordinate", ol.geom.MultiPolygon.prototype.intersectsCoordinate);
goog.exportProperty(ol.geom.MultiPolygon.prototype, "getExtent", ol.geom.MultiPolygon.prototype.getExtent);
goog.exportProperty(ol.geom.MultiPolygon.prototype, "simplify", ol.geom.MultiPolygon.prototype.simplify);
goog.exportProperty(ol.geom.MultiPolygon.prototype, "transform", ol.geom.MultiPolygon.prototype.transform);
goog.exportProperty(ol.geom.MultiPolygon.prototype, "get", ol.geom.MultiPolygon.prototype.get);
goog.exportProperty(ol.geom.MultiPolygon.prototype, "getKeys", ol.geom.MultiPolygon.prototype.getKeys);
goog.exportProperty(ol.geom.MultiPolygon.prototype, "getProperties", ol.geom.MultiPolygon.prototype.getProperties);
goog.exportProperty(ol.geom.MultiPolygon.prototype, "set", ol.geom.MultiPolygon.prototype.set);
goog.exportProperty(ol.geom.MultiPolygon.prototype, "setProperties", ol.geom.MultiPolygon.prototype.setProperties);
goog.exportProperty(ol.geom.MultiPolygon.prototype, "unset", ol.geom.MultiPolygon.prototype.unset);
goog.exportProperty(ol.geom.MultiPolygon.prototype, "changed", ol.geom.MultiPolygon.prototype.changed);
goog.exportProperty(ol.geom.MultiPolygon.prototype, "dispatchEvent", ol.geom.MultiPolygon.prototype.dispatchEvent);
goog.exportProperty(ol.geom.MultiPolygon.prototype, "getRevision", ol.geom.MultiPolygon.prototype.getRevision);
goog.exportProperty(ol.geom.MultiPolygon.prototype, "on", ol.geom.MultiPolygon.prototype.on);
goog.exportProperty(ol.geom.MultiPolygon.prototype, "once", ol.geom.MultiPolygon.prototype.once);
goog.exportProperty(ol.geom.MultiPolygon.prototype, "un", ol.geom.MultiPolygon.prototype.un);
goog.exportProperty(ol.geom.Point.prototype, "getFirstCoordinate", ol.geom.Point.prototype.getFirstCoordinate);
goog.exportProperty(ol.geom.Point.prototype, "getLastCoordinate", ol.geom.Point.prototype.getLastCoordinate);
goog.exportProperty(ol.geom.Point.prototype, "getLayout", ol.geom.Point.prototype.getLayout);
goog.exportProperty(ol.geom.Point.prototype, "rotate", ol.geom.Point.prototype.rotate);
goog.exportProperty(ol.geom.Point.prototype, "scale", ol.geom.Point.prototype.scale);
goog.exportProperty(ol.geom.Point.prototype, "getClosestPoint", ol.geom.Point.prototype.getClosestPoint);
goog.exportProperty(ol.geom.Point.prototype, "intersectsCoordinate", ol.geom.Point.prototype.intersectsCoordinate);
goog.exportProperty(ol.geom.Point.prototype, "getExtent", ol.geom.Point.prototype.getExtent);
goog.exportProperty(ol.geom.Point.prototype, "simplify", ol.geom.Point.prototype.simplify);
goog.exportProperty(ol.geom.Point.prototype, "transform", ol.geom.Point.prototype.transform);
goog.exportProperty(ol.geom.Point.prototype, "get", ol.geom.Point.prototype.get);
goog.exportProperty(ol.geom.Point.prototype, "getKeys", ol.geom.Point.prototype.getKeys);
goog.exportProperty(ol.geom.Point.prototype, "getProperties", ol.geom.Point.prototype.getProperties);
goog.exportProperty(ol.geom.Point.prototype, "set", ol.geom.Point.prototype.set);
goog.exportProperty(ol.geom.Point.prototype, "setProperties", ol.geom.Point.prototype.setProperties);
goog.exportProperty(ol.geom.Point.prototype, "unset", ol.geom.Point.prototype.unset);
goog.exportProperty(ol.geom.Point.prototype, "changed", ol.geom.Point.prototype.changed);
goog.exportProperty(ol.geom.Point.prototype, "dispatchEvent", ol.geom.Point.prototype.dispatchEvent);
goog.exportProperty(ol.geom.Point.prototype, "getRevision", ol.geom.Point.prototype.getRevision);
goog.exportProperty(ol.geom.Point.prototype, "on", ol.geom.Point.prototype.on);
goog.exportProperty(ol.geom.Point.prototype, "once", ol.geom.Point.prototype.once);
goog.exportProperty(ol.geom.Point.prototype, "un", ol.geom.Point.prototype.un);
goog.exportProperty(ol.geom.Polygon.prototype, "getFirstCoordinate", ol.geom.Polygon.prototype.getFirstCoordinate);
goog.exportProperty(ol.geom.Polygon.prototype, "getLastCoordinate", ol.geom.Polygon.prototype.getLastCoordinate);
goog.exportProperty(ol.geom.Polygon.prototype, "getLayout", ol.geom.Polygon.prototype.getLayout);
goog.exportProperty(ol.geom.Polygon.prototype, "rotate", ol.geom.Polygon.prototype.rotate);
goog.exportProperty(ol.geom.Polygon.prototype, "scale", ol.geom.Polygon.prototype.scale);
goog.exportProperty(ol.geom.Polygon.prototype, "getClosestPoint", ol.geom.Polygon.prototype.getClosestPoint);
goog.exportProperty(ol.geom.Polygon.prototype, "intersectsCoordinate", ol.geom.Polygon.prototype.intersectsCoordinate);
goog.exportProperty(ol.geom.Polygon.prototype, "getExtent", ol.geom.Polygon.prototype.getExtent);
goog.exportProperty(ol.geom.Polygon.prototype, "simplify", ol.geom.Polygon.prototype.simplify);
goog.exportProperty(ol.geom.Polygon.prototype, "transform", ol.geom.Polygon.prototype.transform);
goog.exportProperty(ol.geom.Polygon.prototype, "get", ol.geom.Polygon.prototype.get);
goog.exportProperty(ol.geom.Polygon.prototype, "getKeys", ol.geom.Polygon.prototype.getKeys);
goog.exportProperty(ol.geom.Polygon.prototype, "getProperties", ol.geom.Polygon.prototype.getProperties);
goog.exportProperty(ol.geom.Polygon.prototype, "set", ol.geom.Polygon.prototype.set);
goog.exportProperty(ol.geom.Polygon.prototype, "setProperties", ol.geom.Polygon.prototype.setProperties);
goog.exportProperty(ol.geom.Polygon.prototype, "unset", ol.geom.Polygon.prototype.unset);
goog.exportProperty(ol.geom.Polygon.prototype, "changed", ol.geom.Polygon.prototype.changed);
goog.exportProperty(ol.geom.Polygon.prototype, "dispatchEvent", ol.geom.Polygon.prototype.dispatchEvent);
goog.exportProperty(ol.geom.Polygon.prototype, "getRevision", ol.geom.Polygon.prototype.getRevision);
goog.exportProperty(ol.geom.Polygon.prototype, "on", ol.geom.Polygon.prototype.on);
goog.exportProperty(ol.geom.Polygon.prototype, "once", ol.geom.Polygon.prototype.once);
goog.exportProperty(ol.geom.Polygon.prototype, "un", ol.geom.Polygon.prototype.un);
goog.exportProperty(ol.format.GML.prototype, "readFeatures", ol.format.GML.prototype.readFeatures);
goog.exportProperty(ol.format.GML2.prototype, "readFeatures", ol.format.GML2.prototype.readFeatures);
goog.exportProperty(ol.format.GML3.prototype, "readFeatures", ol.format.GML3.prototype.readFeatures);
goog.exportProperty(ol.control.Control.prototype, "get", ol.control.Control.prototype.get);
goog.exportProperty(ol.control.Control.prototype, "getKeys", ol.control.Control.prototype.getKeys);
goog.exportProperty(ol.control.Control.prototype, "getProperties", ol.control.Control.prototype.getProperties);
goog.exportProperty(ol.control.Control.prototype, "set", ol.control.Control.prototype.set);
goog.exportProperty(ol.control.Control.prototype, "setProperties", ol.control.Control.prototype.setProperties);
goog.exportProperty(ol.control.Control.prototype, "unset", ol.control.Control.prototype.unset);
goog.exportProperty(ol.control.Control.prototype, "changed", ol.control.Control.prototype.changed);
goog.exportProperty(ol.control.Control.prototype, "dispatchEvent", ol.control.Control.prototype.dispatchEvent);
goog.exportProperty(ol.control.Control.prototype, "getRevision", ol.control.Control.prototype.getRevision);
goog.exportProperty(ol.control.Control.prototype, "on", ol.control.Control.prototype.on);
goog.exportProperty(ol.control.Control.prototype, "once", ol.control.Control.prototype.once);
goog.exportProperty(ol.control.Control.prototype, "un", ol.control.Control.prototype.un);
goog.exportProperty(ol.control.Attribution.prototype, "getMap", ol.control.Attribution.prototype.getMap);
goog.exportProperty(ol.control.Attribution.prototype, "setMap", ol.control.Attribution.prototype.setMap);
goog.exportProperty(ol.control.Attribution.prototype, "setTarget", ol.control.Attribution.prototype.setTarget);
goog.exportProperty(ol.control.Attribution.prototype, "get", ol.control.Attribution.prototype.get);
goog.exportProperty(ol.control.Attribution.prototype, "getKeys", ol.control.Attribution.prototype.getKeys);
goog.exportProperty(ol.control.Attribution.prototype, "getProperties", ol.control.Attribution.prototype.getProperties);
goog.exportProperty(ol.control.Attribution.prototype, "set", ol.control.Attribution.prototype.set);
goog.exportProperty(ol.control.Attribution.prototype, "setProperties", ol.control.Attribution.prototype.setProperties);
goog.exportProperty(ol.control.Attribution.prototype, "unset", ol.control.Attribution.prototype.unset);
goog.exportProperty(ol.control.Attribution.prototype, "changed", ol.control.Attribution.prototype.changed);
goog.exportProperty(ol.control.Attribution.prototype, "dispatchEvent", ol.control.Attribution.prototype.dispatchEvent);
goog.exportProperty(ol.control.Attribution.prototype, "getRevision", ol.control.Attribution.prototype.getRevision);
goog.exportProperty(ol.control.Attribution.prototype, "on", ol.control.Attribution.prototype.on);
goog.exportProperty(ol.control.Attribution.prototype, "once", ol.control.Attribution.prototype.once);
goog.exportProperty(ol.control.Attribution.prototype, "un", ol.control.Attribution.prototype.un);
goog.exportProperty(ol.control.FullScreen.prototype, "getMap", ol.control.FullScreen.prototype.getMap);
goog.exportProperty(ol.control.FullScreen.prototype, "setMap", ol.control.FullScreen.prototype.setMap);
goog.exportProperty(ol.control.FullScreen.prototype, "setTarget", ol.control.FullScreen.prototype.setTarget);
goog.exportProperty(ol.control.FullScreen.prototype, "get", ol.control.FullScreen.prototype.get);
goog.exportProperty(ol.control.FullScreen.prototype, "getKeys", ol.control.FullScreen.prototype.getKeys);
goog.exportProperty(ol.control.FullScreen.prototype, "getProperties", ol.control.FullScreen.prototype.getProperties);
goog.exportProperty(ol.control.FullScreen.prototype, "set", ol.control.FullScreen.prototype.set);
goog.exportProperty(ol.control.FullScreen.prototype, "setProperties", ol.control.FullScreen.prototype.setProperties);
goog.exportProperty(ol.control.FullScreen.prototype, "unset", ol.control.FullScreen.prototype.unset);
goog.exportProperty(ol.control.FullScreen.prototype, "changed", ol.control.FullScreen.prototype.changed);
goog.exportProperty(ol.control.FullScreen.prototype, "dispatchEvent", ol.control.FullScreen.prototype.dispatchEvent);
goog.exportProperty(ol.control.FullScreen.prototype, "getRevision", ol.control.FullScreen.prototype.getRevision);
goog.exportProperty(ol.control.FullScreen.prototype, "on", ol.control.FullScreen.prototype.on);
goog.exportProperty(ol.control.FullScreen.prototype, "once", ol.control.FullScreen.prototype.once);
goog.exportProperty(ol.control.FullScreen.prototype, "un", ol.control.FullScreen.prototype.un);
goog.exportProperty(ol.control.MousePosition.prototype, "getMap", ol.control.MousePosition.prototype.getMap);
goog.exportProperty(ol.control.MousePosition.prototype, "setMap", ol.control.MousePosition.prototype.setMap);
goog.exportProperty(ol.control.MousePosition.prototype, "setTarget", ol.control.MousePosition.prototype.setTarget);
goog.exportProperty(ol.control.MousePosition.prototype, "get", ol.control.MousePosition.prototype.get);
goog.exportProperty(ol.control.MousePosition.prototype, "getKeys", ol.control.MousePosition.prototype.getKeys);
goog.exportProperty(ol.control.MousePosition.prototype, "getProperties", ol.control.MousePosition.prototype.getProperties);
goog.exportProperty(ol.control.MousePosition.prototype, "set", ol.control.MousePosition.prototype.set);
goog.exportProperty(ol.control.MousePosition.prototype, "setProperties", ol.control.MousePosition.prototype.setProperties);
goog.exportProperty(ol.control.MousePosition.prototype, "unset", ol.control.MousePosition.prototype.unset);
goog.exportProperty(ol.control.MousePosition.prototype, "changed", ol.control.MousePosition.prototype.changed);
goog.exportProperty(ol.control.MousePosition.prototype, "dispatchEvent", ol.control.MousePosition.prototype.dispatchEvent);
goog.exportProperty(ol.control.MousePosition.prototype, "getRevision", ol.control.MousePosition.prototype.getRevision);
goog.exportProperty(ol.control.MousePosition.prototype, "on", ol.control.MousePosition.prototype.on);
goog.exportProperty(ol.control.MousePosition.prototype, "once", ol.control.MousePosition.prototype.once);
goog.exportProperty(ol.control.MousePosition.prototype, "un", ol.control.MousePosition.prototype.un);
goog.exportProperty(ol.control.OverviewMap.prototype, "getMap", ol.control.OverviewMap.prototype.getMap);
goog.exportProperty(ol.control.OverviewMap.prototype, "setMap", ol.control.OverviewMap.prototype.setMap);
goog.exportProperty(ol.control.OverviewMap.prototype, "setTarget", ol.control.OverviewMap.prototype.setTarget);
goog.exportProperty(ol.control.OverviewMap.prototype, "get", ol.control.OverviewMap.prototype.get);
goog.exportProperty(ol.control.OverviewMap.prototype, "getKeys", ol.control.OverviewMap.prototype.getKeys);
goog.exportProperty(ol.control.OverviewMap.prototype, "getProperties", ol.control.OverviewMap.prototype.getProperties);
goog.exportProperty(ol.control.OverviewMap.prototype, "set", ol.control.OverviewMap.prototype.set);
goog.exportProperty(ol.control.OverviewMap.prototype, "setProperties", ol.control.OverviewMap.prototype.setProperties);
goog.exportProperty(ol.control.OverviewMap.prototype, "unset", ol.control.OverviewMap.prototype.unset);
goog.exportProperty(ol.control.OverviewMap.prototype, "changed", ol.control.OverviewMap.prototype.changed);
goog.exportProperty(ol.control.OverviewMap.prototype, "dispatchEvent", ol.control.OverviewMap.prototype.dispatchEvent);
goog.exportProperty(ol.control.OverviewMap.prototype, "getRevision", ol.control.OverviewMap.prototype.getRevision);
goog.exportProperty(ol.control.OverviewMap.prototype, "on", ol.control.OverviewMap.prototype.on);
goog.exportProperty(ol.control.OverviewMap.prototype, "once", ol.control.OverviewMap.prototype.once);
goog.exportProperty(ol.control.OverviewMap.prototype, "un", ol.control.OverviewMap.prototype.un);
goog.exportProperty(ol.control.Rotate.prototype, "getMap", ol.control.Rotate.prototype.getMap);
goog.exportProperty(ol.control.Rotate.prototype, "setMap", ol.control.Rotate.prototype.setMap);
goog.exportProperty(ol.control.Rotate.prototype, "setTarget", ol.control.Rotate.prototype.setTarget);
goog.exportProperty(ol.control.Rotate.prototype, "get", ol.control.Rotate.prototype.get);
goog.exportProperty(ol.control.Rotate.prototype, "getKeys", ol.control.Rotate.prototype.getKeys);
goog.exportProperty(ol.control.Rotate.prototype, "getProperties", ol.control.Rotate.prototype.getProperties);
goog.exportProperty(ol.control.Rotate.prototype, "set", ol.control.Rotate.prototype.set);
goog.exportProperty(ol.control.Rotate.prototype, "setProperties", ol.control.Rotate.prototype.setProperties);
goog.exportProperty(ol.control.Rotate.prototype, "unset", ol.control.Rotate.prototype.unset);
goog.exportProperty(ol.control.Rotate.prototype, "changed", ol.control.Rotate.prototype.changed);
goog.exportProperty(ol.control.Rotate.prototype, "dispatchEvent", ol.control.Rotate.prototype.dispatchEvent);
goog.exportProperty(ol.control.Rotate.prototype, "getRevision", ol.control.Rotate.prototype.getRevision);
goog.exportProperty(ol.control.Rotate.prototype, "on", ol.control.Rotate.prototype.on);
goog.exportProperty(ol.control.Rotate.prototype, "once", ol.control.Rotate.prototype.once);
goog.exportProperty(ol.control.Rotate.prototype, "un", ol.control.Rotate.prototype.un);
goog.exportProperty(ol.control.ScaleLine.prototype, "getMap", ol.control.ScaleLine.prototype.getMap);
goog.exportProperty(ol.control.ScaleLine.prototype, "setMap", ol.control.ScaleLine.prototype.setMap);
goog.exportProperty(ol.control.ScaleLine.prototype, "setTarget", ol.control.ScaleLine.prototype.setTarget);
goog.exportProperty(ol.control.ScaleLine.prototype, "get", ol.control.ScaleLine.prototype.get);
goog.exportProperty(ol.control.ScaleLine.prototype, "getKeys", ol.control.ScaleLine.prototype.getKeys);
goog.exportProperty(ol.control.ScaleLine.prototype, "getProperties", ol.control.ScaleLine.prototype.getProperties);
goog.exportProperty(ol.control.ScaleLine.prototype, "set", ol.control.ScaleLine.prototype.set);
goog.exportProperty(ol.control.ScaleLine.prototype, "setProperties", ol.control.ScaleLine.prototype.setProperties);
goog.exportProperty(ol.control.ScaleLine.prototype, "unset", ol.control.ScaleLine.prototype.unset);
goog.exportProperty(ol.control.ScaleLine.prototype, "changed", ol.control.ScaleLine.prototype.changed);
goog.exportProperty(ol.control.ScaleLine.prototype, "dispatchEvent", ol.control.ScaleLine.prototype.dispatchEvent);
goog.exportProperty(ol.control.ScaleLine.prototype, "getRevision", ol.control.ScaleLine.prototype.getRevision);
goog.exportProperty(ol.control.ScaleLine.prototype, "on", ol.control.ScaleLine.prototype.on);
goog.exportProperty(ol.control.ScaleLine.prototype, "once", ol.control.ScaleLine.prototype.once);
goog.exportProperty(ol.control.ScaleLine.prototype, "un", ol.control.ScaleLine.prototype.un);
goog.exportProperty(ol.control.Zoom.prototype, "getMap", ol.control.Zoom.prototype.getMap);
goog.exportProperty(ol.control.Zoom.prototype, "setMap", ol.control.Zoom.prototype.setMap);
goog.exportProperty(ol.control.Zoom.prototype, "setTarget", ol.control.Zoom.prototype.setTarget);
goog.exportProperty(ol.control.Zoom.prototype, "get", ol.control.Zoom.prototype.get);
goog.exportProperty(ol.control.Zoom.prototype, "getKeys", ol.control.Zoom.prototype.getKeys);
goog.exportProperty(ol.control.Zoom.prototype, "getProperties", ol.control.Zoom.prototype.getProperties);
goog.exportProperty(ol.control.Zoom.prototype, "set", ol.control.Zoom.prototype.set);
goog.exportProperty(ol.control.Zoom.prototype, "setProperties", ol.control.Zoom.prototype.setProperties);
goog.exportProperty(ol.control.Zoom.prototype, "unset", ol.control.Zoom.prototype.unset);
goog.exportProperty(ol.control.Zoom.prototype, "changed", ol.control.Zoom.prototype.changed);
goog.exportProperty(ol.control.Zoom.prototype, "dispatchEvent", ol.control.Zoom.prototype.dispatchEvent);
goog.exportProperty(ol.control.Zoom.prototype, "getRevision", ol.control.Zoom.prototype.getRevision);
goog.exportProperty(ol.control.Zoom.prototype, "on", ol.control.Zoom.prototype.on);
goog.exportProperty(ol.control.Zoom.prototype, "once", ol.control.Zoom.prototype.once);
goog.exportProperty(ol.control.Zoom.prototype, "un", ol.control.Zoom.prototype.un);
goog.exportProperty(ol.control.ZoomSlider.prototype, "getMap", ol.control.ZoomSlider.prototype.getMap);
goog.exportProperty(ol.control.ZoomSlider.prototype, "setMap", ol.control.ZoomSlider.prototype.setMap);
goog.exportProperty(ol.control.ZoomSlider.prototype, "setTarget", ol.control.ZoomSlider.prototype.setTarget);
goog.exportProperty(ol.control.ZoomSlider.prototype, "get", ol.control.ZoomSlider.prototype.get);
goog.exportProperty(ol.control.ZoomSlider.prototype, "getKeys", ol.control.ZoomSlider.prototype.getKeys);
goog.exportProperty(ol.control.ZoomSlider.prototype, "getProperties", ol.control.ZoomSlider.prototype.getProperties);
goog.exportProperty(ol.control.ZoomSlider.prototype, "set", ol.control.ZoomSlider.prototype.set);
goog.exportProperty(ol.control.ZoomSlider.prototype, "setProperties", ol.control.ZoomSlider.prototype.setProperties);
goog.exportProperty(ol.control.ZoomSlider.prototype, "unset", ol.control.ZoomSlider.prototype.unset);
goog.exportProperty(ol.control.ZoomSlider.prototype, "changed", ol.control.ZoomSlider.prototype.changed);
goog.exportProperty(ol.control.ZoomSlider.prototype, "dispatchEvent", ol.control.ZoomSlider.prototype.dispatchEvent);
goog.exportProperty(ol.control.ZoomSlider.prototype, "getRevision", ol.control.ZoomSlider.prototype.getRevision);
goog.exportProperty(ol.control.ZoomSlider.prototype, "on", ol.control.ZoomSlider.prototype.on);
goog.exportProperty(ol.control.ZoomSlider.prototype, "once", ol.control.ZoomSlider.prototype.once);
goog.exportProperty(ol.control.ZoomSlider.prototype, "un", ol.control.ZoomSlider.prototype.un);
goog.exportProperty(ol.control.ZoomToExtent.prototype, "getMap", ol.control.ZoomToExtent.prototype.getMap);
goog.exportProperty(ol.control.ZoomToExtent.prototype, "setMap", ol.control.ZoomToExtent.prototype.setMap);
goog.exportProperty(ol.control.ZoomToExtent.prototype, "setTarget", ol.control.ZoomToExtent.prototype.setTarget);
goog.exportProperty(ol.control.ZoomToExtent.prototype, "get", ol.control.ZoomToExtent.prototype.get);
goog.exportProperty(ol.control.ZoomToExtent.prototype, "getKeys", ol.control.ZoomToExtent.prototype.getKeys);
goog.exportProperty(ol.control.ZoomToExtent.prototype, "getProperties", ol.control.ZoomToExtent.prototype.getProperties);
goog.exportProperty(ol.control.ZoomToExtent.prototype, "set", ol.control.ZoomToExtent.prototype.set);
goog.exportProperty(ol.control.ZoomToExtent.prototype, "setProperties", ol.control.ZoomToExtent.prototype.setProperties);
goog.exportProperty(ol.control.ZoomToExtent.prototype, "unset", ol.control.ZoomToExtent.prototype.unset);
goog.exportProperty(ol.control.ZoomToExtent.prototype, "changed", ol.control.ZoomToExtent.prototype.changed);
goog.exportProperty(ol.control.ZoomToExtent.prototype, "dispatchEvent", ol.control.ZoomToExtent.prototype.dispatchEvent);
goog.exportProperty(ol.control.ZoomToExtent.prototype, "getRevision", ol.control.ZoomToExtent.prototype.getRevision);
goog.exportProperty(ol.control.ZoomToExtent.prototype, "on", ol.control.ZoomToExtent.prototype.on);
goog.exportProperty(ol.control.ZoomToExtent.prototype, "once", ol.control.ZoomToExtent.prototype.once);
goog.exportProperty(ol.control.ZoomToExtent.prototype, "un", ol.control.ZoomToExtent.prototype.un);
goog.exportProperty(olcs.SynchronizedOverlay.prototype, "getElement", olcs.SynchronizedOverlay.prototype.getElement);
goog.exportProperty(olcs.SynchronizedOverlay.prototype, "getId", olcs.SynchronizedOverlay.prototype.getId);
goog.exportProperty(olcs.SynchronizedOverlay.prototype, "getMap", olcs.SynchronizedOverlay.prototype.getMap);
goog.exportProperty(olcs.SynchronizedOverlay.prototype, "getOffset", olcs.SynchronizedOverlay.prototype.getOffset);
goog.exportProperty(olcs.SynchronizedOverlay.prototype, "getPosition", olcs.SynchronizedOverlay.prototype.getPosition);
goog.exportProperty(olcs.SynchronizedOverlay.prototype, "getPositioning", olcs.SynchronizedOverlay.prototype.getPositioning);
goog.exportProperty(olcs.SynchronizedOverlay.prototype, "setElement", olcs.SynchronizedOverlay.prototype.setElement);
goog.exportProperty(olcs.SynchronizedOverlay.prototype, "setMap", olcs.SynchronizedOverlay.prototype.setMap);
goog.exportProperty(olcs.SynchronizedOverlay.prototype, "setOffset", olcs.SynchronizedOverlay.prototype.setOffset);
goog.exportProperty(olcs.SynchronizedOverlay.prototype, "setPosition", olcs.SynchronizedOverlay.prototype.setPosition);
goog.exportProperty(olcs.SynchronizedOverlay.prototype, "setPositioning", olcs.SynchronizedOverlay.prototype.setPositioning);
goog.exportProperty(olcs.SynchronizedOverlay.prototype, "get", olcs.SynchronizedOverlay.prototype.get);
goog.exportProperty(olcs.SynchronizedOverlay.prototype, "getKeys", olcs.SynchronizedOverlay.prototype.getKeys);
goog.exportProperty(olcs.SynchronizedOverlay.prototype, "getProperties", olcs.SynchronizedOverlay.prototype.getProperties);
goog.exportProperty(olcs.SynchronizedOverlay.prototype, "set", olcs.SynchronizedOverlay.prototype.set);
goog.exportProperty(olcs.SynchronizedOverlay.prototype, "setProperties", olcs.SynchronizedOverlay.prototype.setProperties);
goog.exportProperty(olcs.SynchronizedOverlay.prototype, "unset", olcs.SynchronizedOverlay.prototype.unset);
goog.exportProperty(olcs.SynchronizedOverlay.prototype, "changed", olcs.SynchronizedOverlay.prototype.changed);
goog.exportProperty(olcs.SynchronizedOverlay.prototype, "dispatchEvent", olcs.SynchronizedOverlay.prototype.dispatchEvent);
goog.exportProperty(olcs.SynchronizedOverlay.prototype, "getRevision", olcs.SynchronizedOverlay.prototype.getRevision);
goog.exportProperty(olcs.SynchronizedOverlay.prototype, "on", olcs.SynchronizedOverlay.prototype.on);
goog.exportProperty(olcs.SynchronizedOverlay.prototype, "once", olcs.SynchronizedOverlay.prototype.once);
goog.exportProperty(olcs.SynchronizedOverlay.prototype, "un", olcs.SynchronizedOverlay.prototype.un);
goog.exportProperty(olcs.GaKmlSynchronizer.prototype, "synchronize", olcs.GaKmlSynchronizer.prototype.synchronize);
goog.exportProperty(olcs.GaTileset3dSynchronizer.prototype, "synchronize", olcs.GaTileset3dSynchronizer.prototype.synchronize);
ol.AtlasBlock;
ol.AtlasInfo;
ol.AtlasManagerInfo;
ol.AttributionLike;
ol.Attribution2;
ol.CanvasFillState;
ol.CanvasFunctionType;
ol.CanvasFillStrokeState;
ol.CanvasStrokeState;
ol.CanvasTextState;
ol.CenterConstraintType;
ol.CircleRenderOptions;
ol.Color;
ol.ColorLike;
ol.Constraints;
ol.Coordinate;
ol.CoordinateFormatType;
ol.DeclutterGroup;
ol.DragBoxEndConditionType;
ol.DrawGeometryFunctionType;
ol.EventsConditionType;
ol.EventsKey;
ol.EventsListenerFunctionType;
ol.EventTargetLike;
ol.Extent;
ol.FeatureLoader;
ol.FeatureStyleFunction;
ol.FeatureUrlFunction;
ol.GraticuleLabelDataType;
ol.ImageCanvasLoader;
ol.ImageLoadFunctionType;
ol.KMLVec2_;
ol.KMLGxTrackObject_;
ol.LayerState;
ol.LayoutOptions;
ol.LinkedListItem;
ol.LoadingStrategy;
ol.LRUCacheEntry;
ol.MapOptionsInternal;
ol.Transform;
ol.ModifySegmentDataType;
ol.Pixel;
ol.PostRenderFunction;
ol.PreRenderFunction;
ol.ProjectionLike;
ol.RasterOperation;
ol.RegularShapeRenderOptions;
ol.RenderOrderFunction;
ol.ReprojImageFunctionType;
ol.ReprojTileFunctionType;
ol.ReprojTriangle;
ol.ResolutionConstraintType;
ol.RotationConstraintType;
ol.SelectFilterFunction;
ol.Size;
ol.SnapResultType;
ol.SnapSegmentDataType;
ol.SourceImageOptions;
ol.SourceRasterRenderedState;
ol.SourceSourceOptions;
ol.SourceTileOptions;
ol.SourceUrlTileOptions;
ol.StyleFunction;
ol.StyleGeometryFunction;
ol.StyleRenderFunction;
ol.StyleImageOptions;
ol.TileCoord;
ol.TileLoadFunctionType;
ol.TilePriorityFunction;
ol.TileReplayState;
ol.TileUrlFunctionType;
ol.TransformFunction;
ol.ViewAnimation;
ol.WebglBufferCacheEntry;
ol.WebglGlyphAtlas;
ol.WebglPolygonSegment;
ol.WebglPolygonVertex;
ol.WebglTextureCacheEntry;
ol.WFSFeatureCollectionMetadata;
ol.WFSTransactionResponse;
ol.WKTToken;
ol.XmlNodeStackItem;
ol.XmlParser;
ol.XmlSerializer;
ol.RBushEntry;

